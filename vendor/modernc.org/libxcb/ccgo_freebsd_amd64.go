// Code generated for freebsd/amd64 by 'generator --prefix-enumerator=_ --prefix-external=x_ --prefix-field=F --prefix-macro=m_ --prefix-static-internal=_ --prefix-static-none=_ --prefix-tagged-enum=_ --prefix-tagged-struct=T --prefix-tagged-union=T --prefix-typename=T --prefix-undefined=_ -extended-errors -ignore-unsupported-alignment -I /home/jnml/src/modernc.org/builder/.exclude/modernc.org/libXau/include/freebsd/amd64 -I /home/jnml/src/modernc.org/builder/.exclude/modernc.org/libXdmcp/include/freebsd/amd64 -lXau -lXdmcp -o libxcb.go --package-name libxcb src/.libs/libxcb.a', DO NOT EDIT.

//go:build freebsd && amd64

package libxcb

import (
	"reflect"
	"unsafe"

	"modernc.org/libXau"
	"modernc.org/libXdmcp"
	"modernc.org/libc"
)

var _ reflect.Type
var _ unsafe.Pointer

const m_AF_APPLETALK = 16
const m_AF_ARP = 35
const m_AF_ATM = 30
const m_AF_BLUETOOTH = 36
const m_AF_CCITT = 10
const m_AF_CHAOS = 5
const m_AF_CNT = 21
const m_AF_COIP = 20
const m_AF_DATAKIT = 9
const m_AF_DECnet = 12
const m_AF_DIVERT = 44
const m_AF_DLI = 13
const m_AF_E164 = "AF_ISDN"
const m_AF_ECMA = 8
const m_AF_HYLINK = 15
const m_AF_HYPERV = 43
const m_AF_IEEE80211 = 37
const m_AF_IMPLINK = 3
const m_AF_INET = 2
const m_AF_INET6 = 28
const m_AF_INET6_SDP = 42
const m_AF_INET_SDP = 40
const m_AF_IPX = 23
const m_AF_ISDN = 26
const m_AF_ISO = 7
const m_AF_LAT = 14
const m_AF_LINK = 18
const m_AF_LOCAL = "AF_UNIX"
const m_AF_MAX = 44
const m_AF_NATM = 29
const m_AF_NETBIOS = 6
const m_AF_NETGRAPH = 32
const m_AF_NETLINK = 38
const m_AF_OSI = "AF_ISO"
const m_AF_PUP = 4
const m_AF_ROUTE = 17
const m_AF_SCLUSTER = 34
const m_AF_SIP = 24
const m_AF_SLOW = 33
const m_AF_SNA = 11
const m_AF_UNIX = 1
const m_AF_UNSPEC = 0
const m_AF_VENDOR00 = 39
const m_AF_VENDOR01 = 41
const m_AF_VENDOR03 = 45
const m_AF_VENDOR04 = 47
const m_AF_VENDOR05 = 49
const m_AF_VENDOR06 = 51
const m_AF_VENDOR07 = 53
const m_AF_VENDOR08 = 55
const m_AF_VENDOR09 = 57
const m_AF_VENDOR10 = 59
const m_AF_VENDOR11 = 61
const m_AF_VENDOR12 = 63
const m_AF_VENDOR13 = 65
const m_AF_VENDOR14 = 67
const m_AF_VENDOR15 = 69
const m_AF_VENDOR16 = 71
const m_AF_VENDOR17 = 73
const m_AF_VENDOR18 = 75
const m_AF_VENDOR19 = 77
const m_AF_VENDOR20 = 79
const m_AF_VENDOR21 = 81
const m_AF_VENDOR22 = 83
const m_AF_VENDOR23 = 85
const m_AF_VENDOR24 = 87
const m_AF_VENDOR25 = 89
const m_AF_VENDOR26 = 91
const m_AF_VENDOR27 = 93
const m_AF_VENDOR28 = 95
const m_AF_VENDOR29 = 97
const m_AF_VENDOR30 = 99
const m_AF_VENDOR31 = 101
const m_AF_VENDOR32 = 103
const m_AF_VENDOR33 = 105
const m_AF_VENDOR34 = 107
const m_AF_VENDOR35 = 109
const m_AF_VENDOR36 = 111
const m_AF_VENDOR37 = 113
const m_AF_VENDOR38 = 115
const m_AF_VENDOR39 = 117
const m_AF_VENDOR40 = 119
const m_AF_VENDOR41 = 121
const m_AF_VENDOR42 = 123
const m_AF_VENDOR43 = 125
const m_AF_VENDOR44 = 127
const m_AF_VENDOR45 = 129
const m_AF_VENDOR46 = 131
const m_AF_VENDOR47 = 133
const m_AT_EACCESS = 0x0100
const m_AT_EMPTY_PATH = 0x4000
const m_AT_REMOVEDIR = 0x0800
const m_AT_RESOLVE_BENEATH = 0x2000
const m_AT_SYMLINK_FOLLOW = 0x0400
const m_AT_SYMLINK_NOFOLLOW = 0x0200
const m_BC_BASE_MAX = 99
const m_BC_DIM_MAX = 2048
const m_BC_SCALE_MAX = 99
const m_BC_STRING_MAX = 1000
const m_BIG_ENDIAN = "_BIG_ENDIAN"
const m_BUFSIZ = 1024
const m_BYTE_ORDER = "_BYTE_ORDER"
const m_CHARCLASS_NAME_MAX = 14
const m_CHAR_BIT = "__CHAR_BIT"
const m_CHAR_MAX = "SCHAR_MAX"
const m_CHAR_MIN = "SCHAR_MIN"
const m_CHILD_MAX = 40
const m_CLK_TCK = 128
const m_CLOCKS_PER_SEC = 128
const m_CLOCK_BOOTTIME = "CLOCK_UPTIME"
const m_CLOCK_MONOTONIC = 4
const m_CLOCK_MONOTONIC_COARSE = "CLOCK_MONOTONIC_FAST"
const m_CLOCK_MONOTONIC_FAST = 12
const m_CLOCK_MONOTONIC_PRECISE = 11
const m_CLOCK_PROCESS_CPUTIME_ID = 15
const m_CLOCK_PROF = 2
const m_CLOCK_REALTIME = 0
const m_CLOCK_REALTIME_COARSE = "CLOCK_REALTIME_FAST"
const m_CLOCK_REALTIME_FAST = 10
const m_CLOCK_REALTIME_PRECISE = 9
const m_CLOCK_SECOND = 13
const m_CLOCK_THREAD_CPUTIME_ID = 14
const m_CLOCK_UPTIME = 5
const m_CLOCK_UPTIME_FAST = 8
const m_CLOCK_UPTIME_PRECISE = 7
const m_CLOCK_VIRTUAL = 1
const m_CMGROUP_MAX = 16
const m_COLL_WEIGHTS_MAX = 10
const m_CPUSET_DEFAULT = 0
const m_CPU_LEVEL_CPUSET = 2
const m_CPU_LEVEL_ROOT = 1
const m_CPU_LEVEL_WHICH = 3
const m_CPU_MAXSIZE = 1024
const m_CPU_SETSIZE = "CPU_MAXSIZE"
const m_CPU_WHICH_CPUSET = 3
const m_CPU_WHICH_DOMAIN = 6
const m_CPU_WHICH_INTRHANDLER = 7
const m_CPU_WHICH_IRQ = 4
const m_CPU_WHICH_ITHREAD = 8
const m_CPU_WHICH_JAIL = 5
const m_CPU_WHICH_PID = 2
const m_CPU_WHICH_TID = 1
const m_CPU_WHICH_TIDPID = 9
const m_E2BIG = 7
const m_EACCES = 13
const m_EADDRINUSE = 48
const m_EADDRNOTAVAIL = 49
const m_EAFNOSUPPORT = 47
const m_EAGAIN = 35
const m_EALREADY = 37
const m_EAUTH = 80
const m_EBADF = 9
const m_EBADMSG = 89
const m_EBADRPC = 72
const m_EBUSY = 16
const m_ECANCELED = 85
const m_ECAPMODE = 94
const m_ECHILD = 10
const m_ECONNABORTED = 53
const m_ECONNREFUSED = 61
const m_ECONNRESET = 54
const m_EDEADLK = 11
const m_EDESTADDRREQ = 39
const m_EDOM = 33
const m_EDOOFUS = 88
const m_EDQUOT = 69
const m_EEXIST = 17
const m_EFAULT = 14
const m_EFBIG = 27
const m_EFTYPE = 79
const m_EHOSTDOWN = 64
const m_EHOSTUNREACH = 65
const m_EIDRM = 82
const m_EILSEQ = 86
const m_EINPROGRESS = 36
const m_EINTEGRITY = 97
const m_EINTR = 4
const m_EINVAL = 22
const m_EIO = 5
const m_EISCONN = 56
const m_EISDIR = 21
const m_ELAST = 97
const m_ELOOP = 62
const m_EMFILE = 24
const m_EMLINK = 31
const m_EMSGSIZE = 40
const m_EMULTIHOP = 90
const m_ENAMETOOLONG = 63
const m_ENEEDAUTH = 81
const m_ENETDOWN = 50
const m_ENETRESET = 52
const m_ENETUNREACH = 51
const m_ENFILE = 23
const m_ENOATTR = 87
const m_ENOBUFS = 55
const m_ENODEV = 19
const m_ENOENT = 2
const m_ENOEXEC = 8
const m_ENOLCK = 77
const m_ENOLINK = 91
const m_ENOMEM = 12
const m_ENOMSG = 83
const m_ENOPROTOOPT = 42
const m_ENOSPC = 28
const m_ENOSYS = 78
const m_ENOTBLK = 15
const m_ENOTCAPABLE = 93
const m_ENOTCONN = 57
const m_ENOTDIR = 20
const m_ENOTEMPTY = 66
const m_ENOTRECOVERABLE = 95
const m_ENOTSOCK = 38
const m_ENOTSUP = "EOPNOTSUPP"
const m_ENOTTY = 25
const m_ENXIO = 6
const m_EOPNOTSUPP = 45
const m_EOVERFLOW = 84
const m_EOWNERDEAD = 96
const m_EPERM = 1
const m_EPFNOSUPPORT = 46
const m_EPIPE = 32
const m_EPROCLIM = 67
const m_EPROCUNAVAIL = 76
const m_EPROGMISMATCH = 75
const m_EPROGUNAVAIL = 74
const m_EPROTO = 92
const m_EPROTONOSUPPORT = 43
const m_EPROTOTYPE = 41
const m_ERANGE = 34
const m_EREMOTE = 71
const m_EROFS = 30
const m_ERPCMISMATCH = 73
const m_ESHUTDOWN = 58
const m_ESOCKTNOSUPPORT = 44
const m_ESPIPE = 29
const m_ESRCH = 3
const m_ESTALE = 70
const m_ETIMEDOUT = 60
const m_ETOOMANYREFS = 59
const m_ETXTBSY = 26
const m_EUSERS = 68
const m_EWOULDBLOCK = "EAGAIN"
const m_EXDEV = 18
const m_EXIT_FAILURE = 1
const m_EXIT_SUCCESS = 0
const m_EXPR_NEST_MAX = 32
const m_FAPPEND = "O_APPEND"
const m_FASYNC = "O_ASYNC"
const m_FDSYNC = "O_DSYNC"
const m_FD_CLOEXEC = 1
const m_FD_SETSIZE = 1024
const m_FFSYNC = "O_FSYNC"
const m_FILENAME_MAX = 1024
const m_FNDELAY = "O_NONBLOCK"
const m_FNONBLOCK = "O_NONBLOCK"
const m_FOPEN_MAX = 20
const m_FRDAHEAD = "O_CREAT"
const m_FREAD = 0x0001
const m_FWRITE = 0x0002
const m_F_ADD_SEALS = 19
const m_F_CANCEL = 5
const m_F_DUP2FD = 10
const m_F_DUP2FD_CLOEXEC = 18
const m_F_DUPFD = 0
const m_F_DUPFD_CLOEXEC = 17
const m_F_GETFD = 1
const m_F_GETFL = 3
const m_F_GETLK = 11
const m_F_GETOWN = 5
const m_F_GET_SEALS = 20
const m_F_ISUNIONSTACK = 21
const m_F_KINFO = 22
const m_F_LOCK = 1
const m_F_OGETLK = 7
const m_F_OK = 0
const m_F_OSETLK = 8
const m_F_OSETLKW = 9
const m_F_RDAHEAD = 16
const m_F_RDLCK = 1
const m_F_READAHEAD = 15
const m_F_SEAL_GROW = 0x0004
const m_F_SEAL_SEAL = 0x0001
const m_F_SEAL_SHRINK = 0x0002
const m_F_SEAL_WRITE = 0x0008
const m_F_SETFD = 2
const m_F_SETFL = 4
const m_F_SETLK = 12
const m_F_SETLKW = 13
const m_F_SETLK_REMOTE = 14
const m_F_SETOWN = 6
const m_F_TEST = 3
const m_F_TLOCK = 2
const m_F_ULOCK = 0
const m_F_UNLCK = 2
const m_F_UNLCKSYS = 4
const m_F_WRLCK = 3
const m_GID_MAX = "UINT_MAX"
const m_HASXDMAUTH = 1
const m_HAVE_CONFIG_H = 1
const m_HAVE_DLFCN_H = 1
const m_HAVE_GETADDRINFO = 1
const m_HAVE_INTTYPES_H = 1
const m_HAVE_SENDMSG = 1
const m_HAVE_SOCKADDR_SUN_LEN = 1
const m_HAVE_STDINT_H = 1
const m_HAVE_STDIO_H = 1
const m_HAVE_STDLIB_H = 1
const m_HAVE_STRINGS_H = 1
const m_HAVE_STRING_H = 1
const m_HAVE_SYS_STAT_H = 1
const m_HAVE_SYS_TYPES_H = 1
const m_HAVE_UNISTD_H = 1
const m_HAVE_WCHAR_H = 1
const m_ICMP6_FILTER = 18
const m_ICMPV6CTL_ND6_ONLINKNSRFC4861 = 47
const m_INET6_ADDRSTRLEN = 46
const m_INET_ADDRSTRLEN = 16
const m_INT16_MAX = 0x7fff
const m_INT32_MAX = 0x7fffffff
const m_INT64_MAX = 0x7fffffffffffffff
const m_INT8_MAX = 0x7f
const m_INTMAX_MAX = "INT64_MAX"
const m_INTMAX_MIN = "INT64_MIN"
const m_INTPTR_MAX = "INT64_MAX"
const m_INTPTR_MIN = "INT64_MIN"
const m_INT_FAST16_MAX = "INT32_MAX"
const m_INT_FAST16_MIN = "INT32_MIN"
const m_INT_FAST32_MAX = "INT32_MAX"
const m_INT_FAST32_MIN = "INT32_MIN"
const m_INT_FAST64_MAX = "INT64_MAX"
const m_INT_FAST64_MIN = "INT64_MIN"
const m_INT_FAST8_MAX = "INT32_MAX"
const m_INT_FAST8_MIN = "INT32_MIN"
const m_INT_LEAST16_MAX = "INT16_MAX"
const m_INT_LEAST16_MIN = "INT16_MIN"
const m_INT_LEAST32_MAX = "INT32_MAX"
const m_INT_LEAST32_MIN = "INT32_MIN"
const m_INT_LEAST64_MAX = "INT64_MAX"
const m_INT_LEAST64_MIN = "INT64_MIN"
const m_INT_LEAST8_MAX = "INT8_MAX"
const m_INT_LEAST8_MIN = "INT8_MIN"
const m_INT_MAX = "__INT_MAX"
const m_INT_MIN = "__INT_MIN"
const m_IN_CLASSA_HOST = 0x00ffffff
const m_IN_CLASSA_MAX = 128
const m_IN_CLASSA_NET = 0xff000000
const m_IN_CLASSA_NSHIFT = 24
const m_IN_CLASSB_HOST = 0x0000ffff
const m_IN_CLASSB_MAX = 65536
const m_IN_CLASSB_NET = 0xffff0000
const m_IN_CLASSB_NSHIFT = 16
const m_IN_CLASSC_HOST = 0x000000ff
const m_IN_CLASSC_NET = 0xffffff00
const m_IN_CLASSC_NSHIFT = 8
const m_IN_CLASSD_HOST = 0x0fffffff
const m_IN_CLASSD_NET = 0xf0000000
const m_IN_CLASSD_NSHIFT = 28
const m_IN_LOOPBACKNET = 127
const m_IN_NETMASK_DEFAULT = 0xffffff00
const m_IOV_MAX = 1024
const m_IPCTL_ACCEPTSOURCEROUTE = 13
const m_IPCTL_DEFTTL = 3
const m_IPCTL_DIRECTEDBROADCAST = 9
const m_IPCTL_FASTFORWARDING = 14
const m_IPCTL_FORWARDING = 1
const m_IPCTL_GIF_TTL = 16
const m_IPCTL_INTRDQDROPS = 18
const m_IPCTL_INTRDQMAXLEN = 17
const m_IPCTL_INTRQDROPS = 11
const m_IPCTL_INTRQMAXLEN = 10
const m_IPCTL_SENDREDIRECTS = 2
const m_IPCTL_SOURCEROUTE = 8
const m_IPCTL_STATS = 12
const m_IPPORT_EPHEMERALFIRST = 10000
const m_IPPORT_EPHEMERALLAST = 65535
const m_IPPORT_HIFIRSTAUTO = 49152
const m_IPPORT_HILASTAUTO = 65535
const m_IPPORT_MAX = 65535
const m_IPPORT_RESERVED = 1024
const m_IPPORT_RESERVEDSTART = 600
const m_IPPROTO_3PC = 34
const m_IPPROTO_ADFS = 68
const m_IPPROTO_AH = 51
const m_IPPROTO_AHIP = 61
const m_IPPROTO_APES = 99
const m_IPPROTO_ARGUS = 13
const m_IPPROTO_AX25 = 93
const m_IPPROTO_BHA = 49
const m_IPPROTO_BLT = 30
const m_IPPROTO_BRSATMON = 76
const m_IPPROTO_CARP = 112
const m_IPPROTO_CFTP = 62
const m_IPPROTO_CHAOS = 16
const m_IPPROTO_CMTP = 38
const m_IPPROTO_CPHB = 73
const m_IPPROTO_CPNX = 72
const m_IPPROTO_DCCP = 33
const m_IPPROTO_DDP = 37
const m_IPPROTO_DGP = 86
const m_IPPROTO_DIVERT = 258
const m_IPPROTO_DONE = 257
const m_IPPROTO_DSTOPTS = 60
const m_IPPROTO_EGP = 8
const m_IPPROTO_EMCON = 14
const m_IPPROTO_ENCAP = 98
const m_IPPROTO_EON = 80
const m_IPPROTO_ESP = 50
const m_IPPROTO_ETHERIP = 97
const m_IPPROTO_FRAGMENT = 44
const m_IPPROTO_GGP = 3
const m_IPPROTO_GMTP = 100
const m_IPPROTO_GRE = 47
const m_IPPROTO_HELLO = 63
const m_IPPROTO_HIP = 139
const m_IPPROTO_HMP = 20
const m_IPPROTO_HOPOPTS = 0
const m_IPPROTO_ICMP = 1
const m_IPPROTO_ICMPV6 = 58
const m_IPPROTO_IDP = 22
const m_IPPROTO_IDPR = 35
const m_IPPROTO_IDRP = 45
const m_IPPROTO_IGMP = 2
const m_IPPROTO_IGP = 85
const m_IPPROTO_IGRP = 88
const m_IPPROTO_IL = 40
const m_IPPROTO_INLSP = 52
const m_IPPROTO_INP = 32
const m_IPPROTO_IP = 0
const m_IPPROTO_IPCOMP = 108
const m_IPPROTO_IPCV = 71
const m_IPPROTO_IPEIP = 94
const m_IPPROTO_IPIP = "IPPROTO_IPV4"
const m_IPPROTO_IPPC = 67
const m_IPPROTO_IPV4 = 4
const m_IPPROTO_IPV6 = 41
const m_IPPROTO_IRTP = 28
const m_IPPROTO_KRYPTOLAN = 65
const m_IPPROTO_LARP = 91
const m_IPPROTO_LEAF1 = 25
const m_IPPROTO_LEAF2 = 26
const m_IPPROTO_MAX = 256
const m_IPPROTO_MEAS = 19
const m_IPPROTO_MH = 135
const m_IPPROTO_MHRP = 48
const m_IPPROTO_MICP = 95
const m_IPPROTO_MOBILE = 55
const m_IPPROTO_MPLS = 137
const m_IPPROTO_MTP = 92
const m_IPPROTO_MUX = 18
const m_IPPROTO_ND = 77
const m_IPPROTO_NHRP = 54
const m_IPPROTO_NONE = 59
const m_IPPROTO_NSP = 31
const m_IPPROTO_NVPII = 11
const m_IPPROTO_OLD_DIVERT = 254
const m_IPPROTO_OSPFIGP = 89
const m_IPPROTO_PFSYNC = 240
const m_IPPROTO_PGM = 113
const m_IPPROTO_PIGP = 9
const m_IPPROTO_PIM = 103
const m_IPPROTO_PRM = 21
const m_IPPROTO_PUP = 12
const m_IPPROTO_PVP = 75
const m_IPPROTO_RAW = 255
const m_IPPROTO_RCCMON = 10
const m_IPPROTO_RDP = 27
const m_IPPROTO_RESERVED_253 = 253
const m_IPPROTO_RESERVED_254 = 254
const m_IPPROTO_ROUTING = 43
const m_IPPROTO_RSVP = 46
const m_IPPROTO_RVD = 66
const m_IPPROTO_SATEXPAK = 64
const m_IPPROTO_SATMON = 69
const m_IPPROTO_SCCSP = 96
const m_IPPROTO_SCTP = 132
const m_IPPROTO_SDRP = 42
const m_IPPROTO_SEND = 259
const m_IPPROTO_SHIM6 = 140
const m_IPPROTO_SKIP = 57
const m_IPPROTO_SPACER = 32767
const m_IPPROTO_SRPC = 90
const m_IPPROTO_ST = 7
const m_IPPROTO_SVMTP = 82
const m_IPPROTO_SWIPE = 53
const m_IPPROTO_TCF = 87
const m_IPPROTO_TCP = 6
const m_IPPROTO_TLSP = 56
const m_IPPROTO_TP = 29
const m_IPPROTO_TPXX = 39
const m_IPPROTO_TRUNK1 = 23
const m_IPPROTO_TRUNK2 = 24
const m_IPPROTO_TTP = 84
const m_IPPROTO_UDP = 17
const m_IPPROTO_UDPLITE = 136
const m_IPPROTO_VINES = 83
const m_IPPROTO_VISA = 70
const m_IPPROTO_VMTP = 81
const m_IPPROTO_WBEXPAK = 79
const m_IPPROTO_WBMON = 78
const m_IPPROTO_WSN = 74
const m_IPPROTO_XNET = 15
const m_IPPROTO_XTP = 36
const m_IPV6CTL_ACCEPT_RTADV = 12
const m_IPV6CTL_ADDRCTLPOLICY = 38
const m_IPV6CTL_AUTO_FLOWLABEL = 17
const m_IPV6CTL_AUTO_LINKLOCAL = 35
const m_IPV6CTL_DAD_COUNT = 16
const m_IPV6CTL_DEFHLIM = 3
const m_IPV6CTL_DEFMCASTHLIM = 18
const m_IPV6CTL_FORWARDING = 1
const m_IPV6CTL_FORWSRCRT = 5
const m_IPV6CTL_GIF_HLIM = 19
const m_IPV6CTL_HDRNESTLIMIT = 15
const m_IPV6CTL_INTRDQMAXLEN = 52
const m_IPV6CTL_INTRQMAXLEN = 51
const m_IPV6CTL_KAME_VERSION = 20
const m_IPV6CTL_LOG_INTERVAL = 14
const m_IPV6CTL_MAXFRAGBUCKETSIZE = 54
const m_IPV6CTL_MAXFRAGPACKETS = 9
const m_IPV6CTL_MAXFRAGS = 41
const m_IPV6CTL_MAXFRAGSPERPACKET = 53
const m_IPV6CTL_MAXID = 55
const m_IPV6CTL_MCAST_PMTU = 44
const m_IPV6CTL_MRTPROTO = 8
const m_IPV6CTL_MRTSTATS = 7
const m_IPV6CTL_NORBIT_RAIF = 49
const m_IPV6CTL_NO_RADR = 48
const m_IPV6CTL_PREFER_TEMPADDR = 37
const m_IPV6CTL_RFC6204W3 = 50
const m_IPV6CTL_RIP6STATS = 36
const m_IPV6CTL_RR_PRUNE = 22
const m_IPV6CTL_SENDREDIRECTS = 2
const m_IPV6CTL_SOURCECHECK = 10
const m_IPV6CTL_SOURCECHECK_LOGINT = 11
const m_IPV6CTL_STATS = 6
const m_IPV6CTL_STEALTH = 45
const m_IPV6CTL_TEMPPLTIME = 33
const m_IPV6CTL_TEMPVLTIME = 34
const m_IPV6CTL_USETEMPADDR = 32
const m_IPV6CTL_USE_DEFAULTZONE = 39
const m_IPV6CTL_USE_DEPRECATED = 21
const m_IPV6CTL_V6ONLY = 24
const m_IPV6PORT_ANONMAX = 65535
const m_IPV6PORT_ANONMIN = 49152
const m_IPV6PORT_RESERVED = 1024
const m_IPV6PORT_RESERVEDMIN = 600
const m_IPV6_AUTOFLOWLABEL = 59
const m_IPV6_BINDANY = 64
const m_IPV6_BINDV6ONLY = "IPV6_V6ONLY"
const m_IPV6_CHECKSUM = 26
const m_IPV6_DEFAULT_MULTICAST_HOPS = 1
const m_IPV6_DEFAULT_MULTICAST_LOOP = 1
const m_IPV6_DONTFRAG = 62
const m_IPV6_DSTOPTS = 50
const m_IPV6_FLOWID = 67
const m_IPV6_FLOWTYPE = 68
const m_IPV6_FW_ADD = 30
const m_IPV6_FW_DEL = 31
const m_IPV6_FW_FLUSH = 32
const m_IPV6_FW_GET = 34
const m_IPV6_FW_ZERO = 33
const m_IPV6_HOPLIMIT = 47
const m_IPV6_HOPOPTS = 49
const m_IPV6_IPSEC_POLICY = 28
const m_IPV6_JOIN_GROUP = 12
const m_IPV6_LEAVE_GROUP = 13
const m_IPV6_MAX_GROUP_SRC_FILTER = 512
const m_IPV6_MAX_MEMBERSHIPS = 4095
const m_IPV6_MAX_SOCK_SRC_FILTER = 128
const m_IPV6_MSFILTER = 74
const m_IPV6_MULTICAST_HOPS = 10
const m_IPV6_MULTICAST_IF = 9
const m_IPV6_MULTICAST_LOOP = 11
const m_IPV6_NEXTHOP = 48
const m_IPV6_ORIGDSTADDR = 72
const m_IPV6_PATHMTU = 44
const m_IPV6_PKTINFO = 46
const m_IPV6_PORTRANGE = 14
const m_IPV6_PORTRANGE_DEFAULT = 0
const m_IPV6_PORTRANGE_HIGH = 1
const m_IPV6_PORTRANGE_LOW = 2
const m_IPV6_PREFER_TEMPADDR = 63
const m_IPV6_RECVDSTOPTS = 40
const m_IPV6_RECVFLOWID = 70
const m_IPV6_RECVHOPLIMIT = 37
const m_IPV6_RECVHOPOPTS = 39
const m_IPV6_RECVORIGDSTADDR = "IPV6_ORIGDSTADDR"
const m_IPV6_RECVPATHMTU = 43
const m_IPV6_RECVPKTINFO = 36
const m_IPV6_RECVRSSBUCKETID = 71
const m_IPV6_RECVRTHDR = 38
const m_IPV6_RECVTCLASS = 57
const m_IPV6_RSSBUCKETID = 69
const m_IPV6_RTHDR = 51
const m_IPV6_RTHDRDSTOPTS = 35
const m_IPV6_RTHDR_LOOSE = 0
const m_IPV6_RTHDR_STRICT = 1
const m_IPV6_RTHDR_TYPE_0 = 0
const m_IPV6_SOCKOPT_RESERVED1 = 3
const m_IPV6_TCLASS = 61
const m_IPV6_UNICAST_HOPS = 4
const m_IPV6_USE_MIN_MTU = 42
const m_IPV6_V6ONLY = 27
const m_IPV6_VLAN_PCP = 75
const m_IP_ADD_MEMBERSHIP = 12
const m_IP_ADD_SOURCE_MEMBERSHIP = 70
const m_IP_BINDANY = 24
const m_IP_BLOCK_SOURCE = 72
const m_IP_DEFAULT_MULTICAST_LOOP = 1
const m_IP_DEFAULT_MULTICAST_TTL = 1
const m_IP_DONTFRAG = 67
const m_IP_DROP_MEMBERSHIP = 13
const m_IP_DROP_SOURCE_MEMBERSHIP = 71
const m_IP_DUMMYNET3 = 49
const m_IP_DUMMYNET_CONFIGURE = 60
const m_IP_DUMMYNET_DEL = 61
const m_IP_DUMMYNET_FLUSH = 62
const m_IP_DUMMYNET_GET = 64
const m_IP_FLOWID = 90
const m_IP_FLOWTYPE = 91
const m_IP_FW3 = 48
const m_IP_FW_ADD = 50
const m_IP_FW_DEL = 51
const m_IP_FW_FLUSH = 52
const m_IP_FW_GET = 54
const m_IP_FW_NAT_CFG = 56
const m_IP_FW_NAT_DEL = 57
const m_IP_FW_NAT_GET_CONFIG = 58
const m_IP_FW_NAT_GET_LOG = 59
const m_IP_FW_RESETLOG = 55
const m_IP_FW_TABLE_ADD = 40
const m_IP_FW_TABLE_DEL = 41
const m_IP_FW_TABLE_FLUSH = 42
const m_IP_FW_TABLE_GETSIZE = 43
const m_IP_FW_TABLE_LIST = 44
const m_IP_FW_ZERO = 53
const m_IP_HDRINCL = 2
const m_IP_IPSEC_POLICY = 21
const m_IP_MAX_GROUP_SRC_FILTER = 512
const m_IP_MAX_MEMBERSHIPS = 4095
const m_IP_MAX_SOCK_MUTE_FILTER = 128
const m_IP_MAX_SOCK_SRC_FILTER = 128
const m_IP_MINTTL = 66
const m_IP_MSFILTER = 74
const m_IP_MULTICAST_IF = 9
const m_IP_MULTICAST_LOOP = 11
const m_IP_MULTICAST_TTL = 10
const m_IP_MULTICAST_VIF = 14
const m_IP_ONESBCAST = 23
const m_IP_OPTIONS = 1
const m_IP_ORIGDSTADDR = 27
const m_IP_PORTRANGE = 19
const m_IP_PORTRANGE_DEFAULT = 0
const m_IP_PORTRANGE_HIGH = 1
const m_IP_PORTRANGE_LOW = 2
const m_IP_RECVDSTADDR = 7
const m_IP_RECVFLOWID = 93
const m_IP_RECVIF = 20
const m_IP_RECVOPTS = 5
const m_IP_RECVORIGDSTADDR = "IP_ORIGDSTADDR"
const m_IP_RECVRETOPTS = 6
const m_IP_RECVRSSBUCKETID = 94
const m_IP_RECVTOS = 68
const m_IP_RECVTTL = 65
const m_IP_RETOPTS = 8
const m_IP_RSSBUCKETID = 92
const m_IP_RSVP_OFF = 16
const m_IP_RSVP_ON = 15
const m_IP_RSVP_VIF_OFF = 18
const m_IP_RSVP_VIF_ON = 17
const m_IP_SENDSRCADDR = "IP_RECVDSTADDR"
const m_IP_TOS = 3
const m_IP_TTL = 4
const m_IP_UNBLOCK_SOURCE = 73
const m_IP_VLAN_PCP = 75
const m_KCMP_FILE = 100
const m_KCMP_FILEOBJ = 101
const m_KCMP_FILES = 102
const m_KCMP_SIGHAND = 103
const m_KCMP_VM = 104
const m_LINE_MAX = 2048
const m_LITTLE_ENDIAN = "_LITTLE_ENDIAN"
const m_LLONG_MAX = "__LLONG_MAX"
const m_LLONG_MIN = "__LLONG_MIN"
const m_LOCK_EX = 0x02
const m_LOCK_NB = 0x04
const m_LOCK_SH = 0x01
const m_LOCK_UN = 0x08
const m_LONG_BIT = "__LONG_BIT"
const m_LONG_MAX = "__LONG_MAX"
const m_LONG_MIN = "__LONG_MIN"
const m_LT_OBJDIR = ".libs/"
const m_L_INCR = "SEEK_CUR"
const m_L_SET = "SEEK_SET"
const m_L_XTND = "SEEK_END"
const m_L_ctermid = 1024
const m_L_cuserid = 17
const m_L_tmpnam = 1024
const m_MAX_CANON = 255
const m_MAX_INPUT = 255
const m_MB_LEN_MAX = 6
const m_MCAST_BLOCK_SOURCE = 84
const m_MCAST_EXCLUDE = 2
const m_MCAST_INCLUDE = 1
const m_MCAST_JOIN_GROUP = 80
const m_MCAST_JOIN_SOURCE_GROUP = 82
const m_MCAST_LEAVE_GROUP = 81
const m_MCAST_LEAVE_SOURCE_GROUP = 83
const m_MCAST_UNBLOCK_SOURCE = 85
const m_MCAST_UNDEFINED = 0
const m_MQ_PRIO_MAX = 64
const m_MSG_CMSG_CLOEXEC = 0x00040000
const m_MSG_COMPAT = 0x00008000
const m_MSG_CTRUNC = 0x00000020
const m_MSG_DONTROUTE = 0x00000004
const m_MSG_DONTWAIT = 0x00000080
const m_MSG_EOF = 0x00000100
const m_MSG_EOR = 0x00000008
const m_MSG_NBIO = 0x00004000
const m_MSG_NOSIGNAL = 0x00020000
const m_MSG_NOTIFICATION = 0x00002000
const m_MSG_OOB = 0x00000001
const m_MSG_PEEK = 0x00000002
const m_MSG_TRUNC = 0x00000010
const m_MSG_WAITALL = 0x00000040
const m_MSG_WAITFORONE = 0x00080000
const m_M_AUTHIPDGM = "M_PROTO7"
const m_M_AUTHIPHDR = "M_PROTO4"
const m_M_DECRYPTED = "M_PROTO5"
const m_M_FASTFWD_OURS = "M_PROTO1"
const m_M_FRAGMENTED = "M_PROTO9"
const m_M_IP6_NEXTHOP = "M_PROTO2"
const m_M_IP_NEXTHOP = "M_PROTO2"
const m_M_LOOP = "M_PROTO6"
const m_M_RTALERT_MLD = "M_PROTO8"
const m_M_SKIP_FIREWALL = "M_PROTO3"
const m_NAME_MAX = 255
const m_NDEBUG = 1
const m_NET_RT_DUMP = 1
const m_NET_RT_FLAGS = 2
const m_NET_RT_IFLIST = 3
const m_NET_RT_IFLISTL = 5
const m_NET_RT_IFMALIST = 4
const m_NET_RT_NHGRP = 7
const m_NET_RT_NHOP = 6
const m_NFDBITS = "_NFDBITS"
const m_NGROUPS_MAX = 1023
const m_NL_ARGMAX = 4096
const m_NL_LANGMAX = 31
const m_NL_MSGMAX = 32767
const m_NL_NMAX = 1
const m_NL_SETMAX = 255
const m_NL_TEXTMAX = 2048
const m_OFF_MAX = "__OFF_MAX"
const m_OFF_MIN = "__OFF_MIN"
const m_OPEN_MAX = 64
const m_O_ACCMODE = 0x0003
const m_O_APPEND = 0x0008
const m_O_ASYNC = 0x0040
const m_O_CLOEXEC = 0x00100000
const m_O_CREAT = 0x0200
const m_O_DIRECT = 0x00010000
const m_O_DIRECTORY = 0x00020000
const m_O_DSYNC = 0x01000000
const m_O_EMPTY_PATH = 0x02000000
const m_O_EXCL = 0x0800
const m_O_EXEC = 0x00040000
const m_O_EXLOCK = 0x0020
const m_O_FSYNC = 0x0080
const m_O_NDELAY = "O_NONBLOCK"
const m_O_NOCTTY = 0x8000
const m_O_NOFOLLOW = 0x0100
const m_O_NONBLOCK = 4
const m_O_PATH = 0x00400000
const m_O_RDONLY = 0x0000
const m_O_RDWR = 0x0002
const m_O_RESOLVE_BENEATH = 0x00800000
const m_O_SEARCH = "O_EXEC"
const m_O_SHLOCK = 0x0010
const m_O_SYNC = 0x0080
const m_O_TRUNC = 0x0400
const m_O_TTY_INIT = 0x00080000
const m_O_VERIFY = 0x00200000
const m_O_WRONLY = 0x0001
const m_PACKAGE = "libxcb"
const m_PACKAGE_BUGREPORT = "https://gitlab.freedesktop.org/xorg/lib/libxcb/-/issues"
const m_PACKAGE_NAME = "libxcb"
const m_PACKAGE_STRING = "libxcb 1.17.0"
const m_PACKAGE_TARNAME = "libxcb"
const m_PACKAGE_URL = ""
const m_PACKAGE_VERSION = "1.17.0"
const m_PACKAGE_VERSION_MAJOR = 1
const m_PACKAGE_VERSION_MINOR = 17
const m_PACKAGE_VERSION_PATCHLEVEL = 0
const m_PASS_MAX = 128
const m_PATH_MAX = 1024
const m_PDP_ENDIAN = "_PDP_ENDIAN"
const m_PF_APPLETALK = "AF_APPLETALK"
const m_PF_ARP = "AF_ARP"
const m_PF_ATM = "AF_ATM"
const m_PF_BLUETOOTH = "AF_BLUETOOTH"
const m_PF_CCITT = "AF_CCITT"
const m_PF_CHAOS = "AF_CHAOS"
const m_PF_CNT = "AF_CNT"
const m_PF_COIP = "AF_COIP"
const m_PF_DATAKIT = "AF_DATAKIT"
const m_PF_DECnet = "AF_DECnet"
const m_PF_DIVERT = "AF_DIVERT"
const m_PF_DLI = "AF_DLI"
const m_PF_ECMA = "AF_ECMA"
const m_PF_HYLINK = "AF_HYLINK"
const m_PF_IEEE80211 = "AF_IEEE80211"
const m_PF_IMPLINK = "AF_IMPLINK"
const m_PF_INET = "AF_INET"
const m_PF_INET6 = "AF_INET6"
const m_PF_INET6_SDP = "AF_INET6_SDP"
const m_PF_INET_SDP = "AF_INET_SDP"
const m_PF_IPX = "AF_IPX"
const m_PF_ISDN = "AF_ISDN"
const m_PF_ISO = "AF_ISO"
const m_PF_KEY = "pseudo_AF_KEY"
const m_PF_LAT = "AF_LAT"
const m_PF_LINK = "AF_LINK"
const m_PF_LOCAL = "AF_LOCAL"
const m_PF_MAX = "AF_MAX"
const m_PF_NATM = "AF_NATM"
const m_PF_NETBIOS = "AF_NETBIOS"
const m_PF_NETGRAPH = "AF_NETGRAPH"
const m_PF_NETLINK = "AF_NETLINK"
const m_PF_OSI = "AF_ISO"
const m_PF_PIP = "pseudo_AF_PIP"
const m_PF_PUP = "AF_PUP"
const m_PF_ROUTE = "AF_ROUTE"
const m_PF_RTIP = "pseudo_AF_RTIP"
const m_PF_SCLUSTER = "AF_SCLUSTER"
const m_PF_SIP = "AF_SIP"
const m_PF_SLOW = "AF_SLOW"
const m_PF_SNA = "AF_SNA"
const m_PF_UNIX = "PF_LOCAL"
const m_PF_UNSPEC = "AF_UNSPEC"
const m_PF_XTP = "pseudo_AF_XTP"
const m_PIPE_BUF = 512
const m_POLLERR = 0x0008
const m_POLLHUP = 0x0010
const m_POLLIN = 1
const m_POLLINIGNEOF = 0x2000
const m_POLLNVAL = 0x0020
const m_POLLOUT = 4
const m_POLLPRI = 0x0002
const m_POLLRDBAND = 0x0080
const m_POLLRDHUP = 0x4000
const m_POLLRDNORM = 0x0040
const m_POLLWRBAND = 0x0100
const m_POLLWRNORM = "POLLOUT"
const m_POSIX_FADV_DONTNEED = 4
const m_POSIX_FADV_NOREUSE = 5
const m_POSIX_FADV_NORMAL = 0
const m_POSIX_FADV_RANDOM = 1
const m_POSIX_FADV_SEQUENTIAL = 2
const m_POSIX_FADV_WILLNEED = 3
const m_PRU_FLUSH_RD = "SHUT_RD"
const m_PRU_FLUSH_RDWR = "SHUT_RDWR"
const m_PRU_FLUSH_WR = "SHUT_WR"
const m_PTHREAD_CANCEL_ASYNCHRONOUS = 2
const m_PTHREAD_CANCEL_DEFERRED = 0
const m_PTHREAD_CANCEL_DISABLE = 1
const m_PTHREAD_CANCEL_ENABLE = 0
const m_PTHREAD_COND_INITIALIZER = "NULL"
const m_PTHREAD_CREATE_DETACHED = "PTHREAD_DETACHED"
const m_PTHREAD_CREATE_JOINABLE = 0
const m_PTHREAD_DESTRUCTOR_ITERATIONS = 4
const m_PTHREAD_DETACHED = 0x1
const m_PTHREAD_DONE_INIT = 1
const m_PTHREAD_EXPLICIT_SCHED = 0
const m_PTHREAD_INHERIT_SCHED = 0x4
const m_PTHREAD_KEYS_MAX = 256
const m_PTHREAD_MUTEX_DEFAULT = "PTHREAD_MUTEX_ERRORCHECK"
const m_PTHREAD_MUTEX_INITIALIZER = "NULL"
const m_PTHREAD_MUTEX_ROBUST = 1
const m_PTHREAD_MUTEX_STALLED = 0
const m_PTHREAD_NEEDS_INIT = 0
const m_PTHREAD_NOFLOAT = 0x8
const m_PTHREAD_PRIO_INHERIT = 1
const m_PTHREAD_PRIO_NONE = 0
const m_PTHREAD_PRIO_PROTECT = 2
const m_PTHREAD_PROCESS_PRIVATE = 0
const m_PTHREAD_PROCESS_SHARED = 1
const m_PTHREAD_RWLOCK_INITIALIZER = "NULL"
const m_PTHREAD_SCOPE_PROCESS = 0
const m_PTHREAD_SCOPE_SYSTEM = 0x2
const m_PTHREAD_STACK_MIN = "__MINSIGSTKSZ"
const m_PTHREAD_THREADS_MAX = "__ULONG_MAX"
const m_PTRDIFF_MAX = "INT64_MAX"
const m_PTRDIFF_MIN = "INT64_MIN"
const m_P_tmpdir = "/tmp/"
const m_QUAD_MAX = "__QUAD_MAX"
const m_QUAD_MIN = "__QUAD_MIN"
const m_RAND_MAX = 0x7fffffff
const m_RE_DUP_MAX = 255
const m_RFTSIGMASK = 0xFF
const m_RFTSIGSHIFT = 20
const m_R_OK = 0x04
const m_SCHAR_MAX = "__SCHAR_MAX"
const m_SCHAR_MIN = "__SCHAR_MIN"
const m_SCHED_FIFO = 1
const m_SCHED_OTHER = 2
const m_SCHED_RR = 3
const m_SCM_BINTIME = 0x04
const m_SCM_CREDS = 0x03
const m_SCM_CREDS2 = 0x08
const m_SCM_MONOTONIC = 0x06
const m_SCM_REALTIME = 0x05
const m_SCM_RIGHTS = 1
const m_SCM_TIMESTAMP = 0x02
const m_SCM_TIME_INFO = 0x07
const m_SEEK_CUR = 1
const m_SEEK_DATA = 3
const m_SEEK_END = 2
const m_SEEK_HOLE = 4
const m_SEEK_SET = 0
const m_SF_MNOWAIT = 0x00000002
const m_SF_NOCACHE = 0x00000010
const m_SF_NODISKIO = 0x00000001
const m_SF_SYNC = 0x00000004
const m_SF_USER_READAHEAD = 0x00000008
const m_SHRT_MAX = "__SHRT_MAX"
const m_SHRT_MIN = "__SHRT_MIN"
const m_SHUT_RD = 0
const m_SHUT_RDWR = 2
const m_SHUT_WR = 1
const m_SIG_ATOMIC_MAX = "INT64_MAX"
const m_SIG_ATOMIC_MIN = "INT64_MIN"
const m_SIZE_MAX = "UINT64_MAX"
const m_SIZE_T_MAX = "__SIZE_T_MAX"
const m_SOCK_CLOEXEC = 0x10000000
const m_SOCK_DGRAM = 2
const m_SOCK_MAXADDRLEN = 255
const m_SOCK_NONBLOCK = 0x20000000
const m_SOCK_RAW = 3
const m_SOCK_RDM = 4
const m_SOCK_SEQPACKET = 5
const m_SOCK_STREAM = 1
const m_SOL_SOCKET = 65535
const m_SOMAXCONN = 128
const m_SO_ACCEPTCONN = 0x00000002
const m_SO_ACCEPTFILTER = 0x00001000
const m_SO_BINTIME = 0x00002000
const m_SO_BROADCAST = 0x00000020
const m_SO_DEBUG = 0x00000001
const m_SO_DOMAIN = 0x1019
const m_SO_DONTROUTE = 0x00000010
const m_SO_ERROR = 0x1007
const m_SO_KEEPALIVE = 0x00000008
const m_SO_LABEL = 0x1009
const m_SO_LINGER = 0x00000080
const m_SO_LISTENINCQLEN = 0x1013
const m_SO_LISTENQLEN = 0x1012
const m_SO_LISTENQLIMIT = 0x1011
const m_SO_MAX_PACING_RATE = 0x1018
const m_SO_NOSIGPIPE = 0x00000800
const m_SO_NO_DDP = 0x00008000
const m_SO_NO_OFFLOAD = 0x00004000
const m_SO_OOBINLINE = 0x00000100
const m_SO_PEERLABEL = 0x1010
const m_SO_PROTOCOL = 0x1016
const m_SO_PROTOTYPE = "SO_PROTOCOL"
const m_SO_RCVBUF = 0x1002
const m_SO_RCVLOWAT = 0x1004
const m_SO_RCVTIMEO = 0x1006
const m_SO_RERROR = 0x00020000
const m_SO_REUSEADDR = 0x00000004
const m_SO_REUSEPORT = 0x00000200
const m_SO_REUSEPORT_LB = 0x00010000
const m_SO_SETFIB = 0x1014
const m_SO_SNDBUF = 0x1001
const m_SO_SNDLOWAT = 0x1003
const m_SO_SNDTIMEO = 0x1005
const m_SO_SPLICE = 0x1023
const m_SO_TIMESTAMP = 0x00000400
const m_SO_TS_BINTIME = 1
const m_SO_TS_CLOCK = 0x1017
const m_SO_TS_CLOCK_MAX = "SO_TS_MONOTONIC"
const m_SO_TS_DEFAULT = "SO_TS_REALTIME_MICRO"
const m_SO_TS_MONOTONIC = 3
const m_SO_TS_REALTIME = 2
const m_SO_TS_REALTIME_MICRO = 0
const m_SO_TYPE = 0x1008
const m_SO_USELOOPBACK = 0x00000040
const m_SO_USER_COOKIE = 0x1015
const m_SO_VENDOR = 0x80000000
const m_SPACECTL_DEALLOC = 1
const m_SPACECTL_F_SUPPORTED = 0
const m_SSIZE_MAX = "__SSIZE_MAX"
const m_STDC_HEADERS = 1
const m_STDERR_FILENO = 2
const m_STDIN_FILENO = 0
const m_STDOUT_FILENO = 1
const m_ST_INFO_HW = 0x0001
const m_ST_INFO_HW_HPREC = 0x0002
const m_SWAPOFF_FORCE = 0x00000001
const m_TIMER_ABSTIME = 0x1
const m_TIMER_RELTIME = 0x0
const m_TIME_MONOTONIC = 2
const m_TIME_UTC = 1
const m_TMP_MAX = 308915776
const m_UCHAR_MAX = "__UCHAR_MAX"
const m_UID_MAX = "UINT_MAX"
const m_UINT16_MAX = 0xffff
const m_UINT32_MAX = 0xffffffff
const m_UINT64_MAX = 0xffffffffffffffff
const m_UINT8_MAX = 0xff
const m_UINTMAX_MAX = "UINT64_MAX"
const m_UINTPTR_MAX = "UINT64_MAX"
const m_UINT_FAST16_MAX = "UINT32_MAX"
const m_UINT_FAST32_MAX = "UINT32_MAX"
const m_UINT_FAST64_MAX = "UINT64_MAX"
const m_UINT_FAST8_MAX = "UINT32_MAX"
const m_UINT_LEAST16_MAX = "UINT16_MAX"
const m_UINT_LEAST32_MAX = "UINT32_MAX"
const m_UINT_LEAST64_MAX = "UINT64_MAX"
const m_UINT_LEAST8_MAX = "UINT8_MAX"
const m_UINT_MAX = "__UINT_MAX"
const m_ULLONG_MAX = "__ULLONG_MAX"
const m_ULONG_MAX = "__ULONG_MAX"
const m_UQUAD_MAX = "__UQUAD_MAX"
const m_USE_POLL = 1
const m_USHRT_MAX = "__USHRT_MAX"
const m_VERSION = "1.17.0"
const m_WCHAR_MAX = "__WCHAR_MAX"
const m_WCHAR_MIN = "__WCHAR_MIN"
const m_WINT_MAX = "INT32_MAX"
const m_WINT_MIN = "INT32_MIN"
const m_WORD_BIT = "__WORD_BIT"
const m_W_OK = 0x02
const m_XCB_ACCESS = 10
const m_XCB_ALLOC = 11
const m_XCB_ALLOC_COLOR = 84
const m_XCB_ALLOC_COLOR_CELLS = 86
const m_XCB_ALLOC_COLOR_PLANES = 87
const m_XCB_ALLOC_NAMED_COLOR = 85
const m_XCB_ALLOW_EVENTS = 35
const m_XCB_ATOM = 5
const m_XCB_BELL = 104
const m_XCB_BIGREQUESTS_MAJOR_VERSION = 0
const m_XCB_BIGREQUESTS_MINOR_VERSION = 0
const m_XCB_BIG_REQUESTS_ENABLE = 0
const m_XCB_BUTTON_PRESS = 4
const m_XCB_BUTTON_RELEASE = 5
const m_XCB_CHANGE_ACTIVE_POINTER_GRAB = 30
const m_XCB_CHANGE_GC = 56
const m_XCB_CHANGE_HOSTS = 109
const m_XCB_CHANGE_KEYBOARD_CONTROL = 102
const m_XCB_CHANGE_KEYBOARD_MAPPING = 100
const m_XCB_CHANGE_POINTER_CONTROL = 105
const m_XCB_CHANGE_PROPERTY = 18
const m_XCB_CHANGE_SAVE_SET = 6
const m_XCB_CHANGE_WINDOW_ATTRIBUTES = 2
const m_XCB_CIRCULATE_NOTIFY = 26
const m_XCB_CIRCULATE_REQUEST = 27
const m_XCB_CIRCULATE_WINDOW = 13
const m_XCB_CLEAR_AREA = 61
const m_XCB_CLIENT_MESSAGE = 33
const m_XCB_CLOSE_FONT = 46
const m_XCB_COLORMAP = 12
const m_XCB_COLORMAP_NOTIFY = 32
const m_XCB_CONFIGURE_NOTIFY = 22
const m_XCB_CONFIGURE_REQUEST = 23
const m_XCB_CONFIGURE_WINDOW = 12
const m_XCB_CONN_CLOSED_EXT_NOTSUPPORTED = 2
const m_XCB_CONN_CLOSED_FDPASSING_FAILED = 7
const m_XCB_CONN_CLOSED_INVALID_SCREEN = 6
const m_XCB_CONN_CLOSED_MEM_INSUFFICIENT = 3
const m_XCB_CONN_CLOSED_PARSE_ERR = 5
const m_XCB_CONN_CLOSED_REQ_LEN_EXCEED = 4
const m_XCB_CONN_ERROR = 1
const m_XCB_CONVERT_SELECTION = 24
const m_XCB_COPY_AREA = 62
const m_XCB_COPY_COLORMAP_AND_FREE = 80
const m_XCB_COPY_FROM_PARENT = 0
const m_XCB_COPY_GC = 57
const m_XCB_COPY_PLANE = 63
const m_XCB_CREATE_COLORMAP = 78
const m_XCB_CREATE_CURSOR = 93
const m_XCB_CREATE_GC = 55
const m_XCB_CREATE_GLYPH_CURSOR = 94
const m_XCB_CREATE_NOTIFY = 16
const m_XCB_CREATE_PIXMAP = 53
const m_XCB_CREATE_WINDOW = 1
const m_XCB_CURRENT_TIME = 0
const m_XCB_CURSOR = 6
const m_XCB_DELETE_PROPERTY = 19
const m_XCB_DESTROY_NOTIFY = 17
const m_XCB_DESTROY_SUBWINDOWS = 5
const m_XCB_DESTROY_WINDOW = 4
const m_XCB_DRAWABLE = 9
const m_XCB_ENTER_NOTIFY = 7
const m_XCB_EXPOSE = 12
const m_XCB_FILL_POLY = 69
const m_XCB_FOCUS_IN = 9
const m_XCB_FOCUS_OUT = 10
const m_XCB_FONT = 7
const m_XCB_FORCE_SCREEN_SAVER = 115
const m_XCB_FREE_COLORMAP = 79
const m_XCB_FREE_COLORS = 88
const m_XCB_FREE_CURSOR = 95
const m_XCB_FREE_GC = 60
const m_XCB_FREE_PIXMAP = 54
const m_XCB_GET_ATOM_NAME = 17
const m_XCB_GET_FONT_PATH = 52
const m_XCB_GET_GEOMETRY = 14
const m_XCB_GET_IMAGE = 73
const m_XCB_GET_INPUT_FOCUS = 43
const m_XCB_GET_KEYBOARD_CONTROL = 103
const m_XCB_GET_KEYBOARD_MAPPING = 101
const m_XCB_GET_MODIFIER_MAPPING = 119
const m_XCB_GET_MOTION_EVENTS = 39
const m_XCB_GET_POINTER_CONTROL = 106
const m_XCB_GET_POINTER_MAPPING = 117
const m_XCB_GET_PROPERTY = 20
const m_XCB_GET_SCREEN_SAVER = 108
const m_XCB_GET_SELECTION_OWNER = 23
const m_XCB_GET_WINDOW_ATTRIBUTES = 3
const m_XCB_GE_GENERIC = 35
const m_XCB_GRAB_BUTTON = 28
const m_XCB_GRAB_KEY = 33
const m_XCB_GRAB_KEYBOARD = 31
const m_XCB_GRAB_POINTER = 26
const m_XCB_GRAB_SERVER = 36
const m_XCB_GRAPHICS_EXPOSURE = 13
const m_XCB_GRAVITY_NOTIFY = 24
const m_XCB_G_CONTEXT = 13
const m_XCB_ID_CHOICE = 14
const m_XCB_IMAGE_TEXT_16 = 77
const m_XCB_IMAGE_TEXT_8 = 76
const m_XCB_IMPLEMENTATION = 17
const m_XCB_INSTALL_COLORMAP = 81
const m_XCB_INTERN_ATOM = 16
const m_XCB_KEYMAP_NOTIFY = 11
const m_XCB_KEY_PRESS = 2
const m_XCB_KEY_RELEASE = 3
const m_XCB_KILL_CLIENT = 113
const m_XCB_LEAVE_NOTIFY = 8
const m_XCB_LENGTH = 16
const m_XCB_LIST_EXTENSIONS = 99
const m_XCB_LIST_FONTS = 49
const m_XCB_LIST_FONTS_WITH_INFO = 50
const m_XCB_LIST_HOSTS = 110
const m_XCB_LIST_INSTALLED_COLORMAPS = 83
const m_XCB_LIST_PROPERTIES = 21
const m_XCB_LOOKUP_COLOR = 92
const m_XCB_MAPPING_NOTIFY = 34
const m_XCB_MAP_NOTIFY = 19
const m_XCB_MAP_REQUEST = 20
const m_XCB_MAP_SUBWINDOWS = 9
const m_XCB_MAP_WINDOW = 8
const m_XCB_MATCH = 8
const m_XCB_MAX_PASS_FD = 16
const m_XCB_MOTION_NOTIFY = 6
const m_XCB_NAME = 15
const m_XCB_NONE = 0
const m_XCB_NO_EXPOSURE = 14
const m_XCB_NO_OPERATION = 127
const m_XCB_NO_SYMBOL = 0
const m_XCB_OPEN_FONT = 45
const m_XCB_PIXMAP = 4
const m_XCB_POLY_ARC = 68
const m_XCB_POLY_FILL_ARC = 71
const m_XCB_POLY_FILL_RECTANGLE = 70
const m_XCB_POLY_LINE = 65
const m_XCB_POLY_POINT = 64
const m_XCB_POLY_RECTANGLE = 67
const m_XCB_POLY_SEGMENT = 66
const m_XCB_POLY_TEXT_16 = 75
const m_XCB_POLY_TEXT_8 = 74
const m_XCB_PROPERTY_NOTIFY = 28
const m_XCB_PUT_IMAGE = 72
const m_XCB_QUERY_BEST_SIZE = 97
const m_XCB_QUERY_COLORS = 91
const m_XCB_QUERY_EXTENSION = 98
const m_XCB_QUERY_FONT = 47
const m_XCB_QUERY_KEYMAP = 44
const m_XCB_QUERY_POINTER = 38
const m_XCB_QUERY_TEXT_EXTENTS = 48
const m_XCB_QUERY_TREE = 15
const m_XCB_QUEUE_BUFFER_SIZE = 16384
const m_XCB_RECOLOR_CURSOR = 96
const m_XCB_REPARENT_NOTIFY = 21
const m_XCB_REPARENT_WINDOW = 7
const m_XCB_REQUEST = 1
const m_XCB_RESIZE_REQUEST = 25
const m_XCB_ROTATE_PROPERTIES = 114
const m_XCB_SELECTION_CLEAR = 29
const m_XCB_SELECTION_NOTIFY = 31
const m_XCB_SELECTION_REQUEST = 30
const m_XCB_SEND_EVENT = 25
const m_XCB_SET_ACCESS_CONTROL = 111
const m_XCB_SET_CLIP_RECTANGLES = 59
const m_XCB_SET_CLOSE_DOWN_MODE = 112
const m_XCB_SET_DASHES = 58
const m_XCB_SET_FONT_PATH = 51
const m_XCB_SET_INPUT_FOCUS = 42
const m_XCB_SET_MODIFIER_MAPPING = 118
const m_XCB_SET_POINTER_MAPPING = 116
const m_XCB_SET_SCREEN_SAVER = 107
const m_XCB_SET_SELECTION_OWNER = 22
const m_XCB_STORE_COLORS = 89
const m_XCB_STORE_NAMED_COLOR = 90
const m_XCB_TRANSLATE_COORDINATES = 40
const m_XCB_UNGRAB_BUTTON = 29
const m_XCB_UNGRAB_KEY = 34
const m_XCB_UNGRAB_KEYBOARD = 32
const m_XCB_UNGRAB_POINTER = 27
const m_XCB_UNGRAB_SERVER = 37
const m_XCB_UNINSTALL_COLORMAP = 82
const m_XCB_UNMAP_NOTIFY = 18
const m_XCB_UNMAP_SUBWINDOWS = 11
const m_XCB_UNMAP_WINDOW = 10
const m_XCB_VALUE = 2
const m_XCB_VISIBILITY_NOTIFY = 15
const m_XCB_WARP_POINTER = 41
const m_XCB_WINDOW = 3
const m_X_OK = 0x01
const m_X_PROTOCOL = 11
const m_X_PROTOCOL_REVISION = 0
const m_X_TCP_PORT = 6000
const m__ALL_SOURCE = 1
const m__BYTE_ORDER = "__BYTE_ORDER__"
const m__CS_PATH = 1
const m__CS_POSIX_V6_ILP32_OFF32_CFLAGS = 2
const m__CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 3
const m__CS_POSIX_V6_ILP32_OFF32_LIBS = 4
const m__CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 5
const m__CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 6
const m__CS_POSIX_V6_ILP32_OFFBIG_LIBS = 7
const m__CS_POSIX_V6_LP64_OFF64_CFLAGS = 8
const m__CS_POSIX_V6_LP64_OFF64_LDFLAGS = 9
const m__CS_POSIX_V6_LP64_OFF64_LIBS = 10
const m__CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 11
const m__CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 12
const m__CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 13
const m__CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = 14
const m__DARWIN_C_SOURCE = 1
const m__GNU_SOURCE = 1
const m__HPUX_ALT_XOPEN_SOCKET_API = 1
const m__IOFBF = 0
const m__IOLBF = 1
const m__IONBF = 2
const m__LP64 = 1
const m__NCPUBITS = "_BITSET_BITS"
const m__NETBSD_SOURCE = 1
const m__OPENBSD_SOURCE = 1
const m__PC_ACL_EXTENDED = 59
const m__PC_ACL_NFS4 = 64
const m__PC_ACL_PATH_MAX = 60
const m__PC_ALLOC_SIZE_MIN = 10
const m__PC_ASYNC_IO = 53
const m__PC_CAP_PRESENT = 61
const m__PC_CHOWN_RESTRICTED = 7
const m__PC_DEALLOC_PRESENT = 65
const m__PC_FILESIZEBITS = 12
const m__PC_INF_PRESENT = 62
const m__PC_LINK_MAX = 1
const m__PC_MAC_PRESENT = 63
const m__PC_MAX_CANON = 2
const m__PC_MAX_INPUT = 3
const m__PC_MIN_HOLE_SIZE = 21
const m__PC_NAME_MAX = 4
const m__PC_NO_TRUNC = 8
const m__PC_PATH_MAX = 5
const m__PC_PIPE_BUF = 6
const m__PC_PRIO_IO = 54
const m__PC_REC_INCR_XFER_SIZE = 14
const m__PC_REC_MAX_XFER_SIZE = 15
const m__PC_REC_MIN_XFER_SIZE = 16
const m__PC_REC_XFER_ALIGN = 17
const m__PC_SYMLINK_MAX = 18
const m__PC_SYNC_IO = 55
const m__PC_VDISABLE = 9
const m__PDP_ENDIAN = "__ORDER_PDP_ENDIAN__"
const m__POSIX2_BC_BASE_MAX = 99
const m__POSIX2_BC_DIM_MAX = 2048
const m__POSIX2_BC_SCALE_MAX = 99
const m__POSIX2_BC_STRING_MAX = 1000
const m__POSIX2_CHARCLASS_NAME_MAX = 14
const m__POSIX2_CHAR_TERM = 1
const m__POSIX2_COLL_WEIGHTS_MAX = 2
const m__POSIX2_C_BIND = 200112
const m__POSIX2_EQUIV_CLASS_MAX = 2
const m__POSIX2_EXPR_NEST_MAX = 32
const m__POSIX2_FORT_RUN = 200112
const m__POSIX2_LINE_MAX = 2048
const m__POSIX2_RE_DUP_MAX = 255
const m__POSIX2_UPE = 200112
const m__POSIX2_VERSION = 199212
const m__POSIX_ADVISORY_INFO = 200112
const m__POSIX_AIO_LISTIO_MAX = 2
const m__POSIX_AIO_MAX = 1
const m__POSIX_ARG_MAX = 4096
const m__POSIX_ASYNCHRONOUS_IO = 200112
const m__POSIX_BARRIERS = 200112
const m__POSIX_CHILD_MAX = 25
const m__POSIX_CHOWN_RESTRICTED = 1
const m__POSIX_CLOCKRES_MIN = 20000000
const m__POSIX_CPUTIME = 200112
const m__POSIX_DELAYTIMER_MAX = 32
const m__POSIX_FSYNC = 200112
const m__POSIX_HOST_NAME_MAX = 255
const m__POSIX_IPV6 = 0
const m__POSIX_JOB_CONTROL = 1
const m__POSIX_LINK_MAX = 8
const m__POSIX_LOGIN_NAME_MAX = 9
const m__POSIX_MAPPED_FILES = 200112
const m__POSIX_MAX_CANON = 255
const m__POSIX_MAX_INPUT = 255
const m__POSIX_MEMLOCK_RANGE = 200112
const m__POSIX_MEMORY_PROTECTION = 200112
const m__POSIX_MESSAGE_PASSING = 200112
const m__POSIX_MONOTONIC_CLOCK = 200112
const m__POSIX_MQ_OPEN_MAX = 8
const m__POSIX_MQ_PRIO_MAX = 32
const m__POSIX_NAME_MAX = 14
const m__POSIX_NGROUPS_MAX = 8
const m__POSIX_NO_TRUNC = 1
const m__POSIX_OPEN_MAX = 20
const m__POSIX_PATH_MAX = 256
const m__POSIX_PIPE_BUF = 512
const m__POSIX_PRIORITY_SCHEDULING = 0
const m__POSIX_PTHREAD_SEMANTICS = 1
const m__POSIX_RAW_SOCKETS = 200112
const m__POSIX_READER_WRITER_LOCKS = 200112
const m__POSIX_REALTIME_SIGNALS = 200112
const m__POSIX_REGEXP = 1
const m__POSIX_RE_DUP_MAX = "_POSIX2_RE_DUP_MAX"
const m__POSIX_RTSIG_MAX = 8
const m__POSIX_SEMAPHORES = 200112
const m__POSIX_SEM_NSEMS_MAX = 256
const m__POSIX_SEM_VALUE_MAX = 32767
const m__POSIX_SHARED_MEMORY_OBJECTS = 200112
const m__POSIX_SHELL = 1
const m__POSIX_SIGQUEUE_MAX = 32
const m__POSIX_SPAWN = 200112
const m__POSIX_SPIN_LOCKS = 200112
const m__POSIX_SSIZE_MAX = 32767
const m__POSIX_SS_REPL_MAX = 4
const m__POSIX_STREAM_MAX = 8
const m__POSIX_SYMLINK_MAX = 255
const m__POSIX_SYMLOOP_MAX = 8
const m__POSIX_THREADS = 200112
const m__POSIX_THREAD_ATTR_STACKADDR = 200112
const m__POSIX_THREAD_ATTR_STACKSIZE = 200112
const m__POSIX_THREAD_CPUTIME = 200112
const m__POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4
const m__POSIX_THREAD_KEYS_MAX = 128
const m__POSIX_THREAD_PRIORITY_SCHEDULING = 200112
const m__POSIX_THREAD_PRIO_INHERIT = 200112
const m__POSIX_THREAD_PRIO_PROTECT = 200112
const m__POSIX_THREAD_PROCESS_SHARED = 200112
const m__POSIX_THREAD_THREADS_MAX = 64
const m__POSIX_TIMEOUTS = 200112
const m__POSIX_TIMERS = 200112
const m__POSIX_TIMER_MAX = 32
const m__POSIX_TRACE_EVENT_NAME_MAX = 30
const m__POSIX_TRACE_NAME_MAX = 8
const m__POSIX_TRACE_SYS_MAX = 8
const m__POSIX_TRACE_USER_EVENT_MAX = 32
const m__POSIX_TTY_NAME_MAX = 9
const m__POSIX_TZNAME_MAX = 6
const m__POSIX_VDISABLE = 0xff
const m__POSIX_VERSION = 200112
const m__QUAD_HIGHWORD = 1
const m__QUAD_LOWWORD = 0
const m__SC_2_CHAR_TERM = 20
const m__SC_2_C_BIND = 18
const m__SC_2_C_DEV = 19
const m__SC_2_FORT_DEV = 21
const m__SC_2_FORT_RUN = 22
const m__SC_2_LOCALEDEF = 23
const m__SC_2_PBS = 59
const m__SC_2_PBS_ACCOUNTING = 60
const m__SC_2_PBS_CHECKPOINT = 61
const m__SC_2_PBS_LOCATE = 62
const m__SC_2_PBS_MESSAGE = 63
const m__SC_2_PBS_TRACK = 64
const m__SC_2_SW_DEV = 24
const m__SC_2_UPE = 25
const m__SC_2_VERSION = 17
const m__SC_ADVISORY_INFO = 65
const m__SC_AIO_LISTIO_MAX = 42
const m__SC_AIO_MAX = 43
const m__SC_AIO_PRIO_DELTA_MAX = 44
const m__SC_ARG_MAX = 1
const m__SC_ASYNCHRONOUS_IO = 28
const m__SC_ATEXIT_MAX = 107
const m__SC_BARRIERS = 66
const m__SC_BC_BASE_MAX = 9
const m__SC_BC_DIM_MAX = 10
const m__SC_BC_SCALE_MAX = 11
const m__SC_BC_STRING_MAX = 12
const m__SC_CHILD_MAX = 2
const m__SC_CLK_TCK = 3
const m__SC_CLOCK_SELECTION = 67
const m__SC_COLL_WEIGHTS_MAX = 13
const m__SC_CPUSET_SIZE = 122
const m__SC_CPUTIME = 68
const m__SC_DELAYTIMER_MAX = 45
const m__SC_EXPR_NEST_MAX = 14
const m__SC_FILE_LOCKING = 69
const m__SC_FSYNC = 38
const m__SC_GETGR_R_SIZE_MAX = 70
const m__SC_GETPW_R_SIZE_MAX = 71
const m__SC_HOST_NAME_MAX = 72
const m__SC_IOV_MAX = 56
const m__SC_IPV6 = 118
const m__SC_JOB_CONTROL = 6
const m__SC_LINE_MAX = 15
const m__SC_LOGIN_NAME_MAX = 73
const m__SC_MAPPED_FILES = 29
const m__SC_MEMLOCK = 30
const m__SC_MEMLOCK_RANGE = 31
const m__SC_MEMORY_PROTECTION = 32
const m__SC_MESSAGE_PASSING = 33
const m__SC_MONOTONIC_CLOCK = 74
const m__SC_MQ_OPEN_MAX = 46
const m__SC_MQ_PRIO_MAX = 75
const m__SC_NGROUPS_MAX = 4
const m__SC_NPROCESSORS_CONF = 57
const m__SC_NPROCESSORS_ONLN = 58
const m__SC_OPEN_MAX = 5
const m__SC_PAGESIZE = 47
const m__SC_PAGE_SIZE = "_SC_PAGESIZE"
const m__SC_PHYS_PAGES = 121
const m__SC_PRIORITIZED_IO = 34
const m__SC_PRIORITY_SCHEDULING = 35
const m__SC_RAW_SOCKETS = 119
const m__SC_READER_WRITER_LOCKS = 76
const m__SC_REALTIME_SIGNALS = 36
const m__SC_REGEXP = 77
const m__SC_RE_DUP_MAX = 16
const m__SC_RTSIG_MAX = 48
const m__SC_SAVED_IDS = 7
const m__SC_SEMAPHORES = 37
const m__SC_SEM_NSEMS_MAX = 49
const m__SC_SEM_VALUE_MAX = 50
const m__SC_SHARED_MEMORY_OBJECTS = 39
const m__SC_SHELL = 78
const m__SC_SIGQUEUE_MAX = 51
const m__SC_SPAWN = 79
const m__SC_SPIN_LOCKS = 80
const m__SC_SPORADIC_SERVER = 81
const m__SC_STREAM_MAX = 26
const m__SC_SYMLOOP_MAX = 120
const m__SC_SYNCHRONIZED_IO = 40
const m__SC_THREADS = 96
const m__SC_THREAD_ATTR_STACKADDR = 82
const m__SC_THREAD_ATTR_STACKSIZE = 83
const m__SC_THREAD_CPUTIME = 84
const m__SC_THREAD_DESTRUCTOR_ITERATIONS = 85
const m__SC_THREAD_KEYS_MAX = 86
const m__SC_THREAD_PRIORITY_SCHEDULING = 89
const m__SC_THREAD_PRIO_INHERIT = 87
const m__SC_THREAD_PRIO_PROTECT = 88
const m__SC_THREAD_PROCESS_SHARED = 90
const m__SC_THREAD_SAFE_FUNCTIONS = 91
const m__SC_THREAD_SPORADIC_SERVER = 92
const m__SC_THREAD_STACK_MIN = 93
const m__SC_THREAD_THREADS_MAX = 94
const m__SC_TIMEOUTS = 95
const m__SC_TIMERS = 41
const m__SC_TIMER_MAX = 52
const m__SC_TRACE = 97
const m__SC_TRACE_EVENT_FILTER = 98
const m__SC_TRACE_INHERIT = 99
const m__SC_TRACE_LOG = 100
const m__SC_TTY_NAME_MAX = 101
const m__SC_TYPED_MEMORY_OBJECTS = 102
const m__SC_TZNAME_MAX = 27
const m__SC_V6_ILP32_OFF32 = 103
const m__SC_V6_ILP32_OFFBIG = 104
const m__SC_V6_LP64_OFF64 = 105
const m__SC_V6_LPBIG_OFFBIG = 106
const m__SC_VERSION = 8
const m__SC_XOPEN_CRYPT = 108
const m__SC_XOPEN_ENH_I18N = 109
const m__SC_XOPEN_LEGACY = 110
const m__SC_XOPEN_REALTIME = 111
const m__SC_XOPEN_REALTIME_THREADS = 112
const m__SC_XOPEN_SHM = 113
const m__SC_XOPEN_STREAMS = 114
const m__SC_XOPEN_UNIX = 115
const m__SC_XOPEN_VERSION = 116
const m__SC_XOPEN_XCU_VERSION = 117
const m__SIG_MAXSIG = 128
const m__SIG_WORDS = 4
const m__SS_MAXSIZE = 128
const m__TANDEM_SOURCE = 1
const m__V6_ILP32_OFFBIG = 0
const m__V6_LP64_OFF64 = 0
const m__XOPEN_IOV_MAX = 16
const m__XOPEN_NAME_MAX = 255
const m__XOPEN_PATH_MAX = 1024
const m__XOPEN_SHM = 1
const m___ATOMIC_ACQUIRE = 2
const m___ATOMIC_ACQ_REL = 4
const m___ATOMIC_CONSUME = 1
const m___ATOMIC_RELAXED = 0
const m___ATOMIC_RELEASE = 3
const m___ATOMIC_SEQ_CST = 5
const m___BIGGEST_ALIGNMENT__ = 16
const m___BITINT_MAXWIDTH__ = 8388608
const m___BOOL_WIDTH__ = 8
const m___BSD_VISIBLE = 1
const m___BYTE_ORDER__ = "__ORDER_LITTLE_ENDIAN__"
const m___CCGO__ = 1
const m___CC_SUPPORTS_DYNAMIC_ARRAY_INIT = 1
const m___CC_SUPPORTS_INLINE = 1
const m___CC_SUPPORTS_VARADIC_XXX = 1
const m___CC_SUPPORTS_WARNING = 1
const m___CC_SUPPORTS___FUNC__ = 1
const m___CC_SUPPORTS___INLINE = 1
const m___CC_SUPPORTS___INLINE__ = 1
const m___CHAR_BIT = 8
const m___CHAR_BIT__ = 8
const m___CLANG_ATOMIC_BOOL_LOCK_FREE = 2
const m___CLANG_ATOMIC_CHAR16_T_LOCK_FREE = 2
const m___CLANG_ATOMIC_CHAR32_T_LOCK_FREE = 2
const m___CLANG_ATOMIC_CHAR_LOCK_FREE = 2
const m___CLANG_ATOMIC_INT_LOCK_FREE = 2
const m___CLANG_ATOMIC_LLONG_LOCK_FREE = 2
const m___CLANG_ATOMIC_LONG_LOCK_FREE = 2
const m___CLANG_ATOMIC_POINTER_LOCK_FREE = 2
const m___CLANG_ATOMIC_SHORT_LOCK_FREE = 2
const m___CLANG_ATOMIC_WCHAR_T_LOCK_FREE = 2
const m___CONSTANT_CFSTRINGS__ = 1
const m___DBL_DECIMAL_DIG__ = 17
const m___DBL_DENORM_MIN__ = 4.9406564584124654e-324
const m___DBL_DIG__ = 15
const m___DBL_EPSILON__ = 2.2204460492503131e-16
const m___DBL_HAS_DENORM__ = 1
const m___DBL_HAS_INFINITY__ = 1
const m___DBL_HAS_QUIET_NAN__ = 1
const m___DBL_MANT_DIG__ = 53
const m___DBL_MAX_10_EXP__ = 308
const m___DBL_MAX_EXP__ = 1024
const m___DBL_MAX__ = 1.7976931348623157e+308
const m___DBL_MIN__ = 2.2250738585072014e-308
const m___DECIMAL_DIG__ = "__LDBL_DECIMAL_DIG__"
const m___ELF__ = 1
const m___EXT1_VISIBLE = 1
const m___EXTENSIONS__ = 1
const m___FINITE_MATH_ONLY__ = 0
const m___FLOAT128__ = 1
const m___FLT16_DECIMAL_DIG__ = 5
const m___FLT16_DENORM_MIN__ = 5.9604644775390625e-8
const m___FLT16_DIG__ = 3
const m___FLT16_EPSILON__ = 9.765625e-4
const m___FLT16_HAS_DENORM__ = 1
const m___FLT16_HAS_INFINITY__ = 1
const m___FLT16_HAS_QUIET_NAN__ = 1
const m___FLT16_MANT_DIG__ = 11
const m___FLT16_MAX_10_EXP__ = 4
const m___FLT16_MAX_EXP__ = 16
const m___FLT16_MAX__ = 6.5504e+4
const m___FLT16_MIN__ = 6.103515625e-5
const m___FLT_DECIMAL_DIG__ = 9
const m___FLT_DENORM_MIN__ = 1.40129846e-45
const m___FLT_DIG__ = 6
const m___FLT_EPSILON__ = 1.19209290e-7
const m___FLT_HAS_DENORM__ = 1
const m___FLT_HAS_INFINITY__ = 1
const m___FLT_HAS_QUIET_NAN__ = 1
const m___FLT_MANT_DIG__ = 24
const m___FLT_MAX_10_EXP__ = 38
const m___FLT_MAX_EXP__ = 128
const m___FLT_MAX__ = 3.40282347e+38
const m___FLT_MIN__ = 1.17549435e-38
const m___FLT_RADIX__ = 2
const m___FPCLASS_NEGINF = 0x0004
const m___FPCLASS_NEGNORMAL = 0x0008
const m___FPCLASS_NEGSUBNORMAL = 0x0010
const m___FPCLASS_NEGZERO = 0x0020
const m___FPCLASS_POSINF = 0x0200
const m___FPCLASS_POSNORMAL = 0x0100
const m___FPCLASS_POSSUBNORMAL = 0x0080
const m___FPCLASS_POSZERO = 0x0040
const m___FPCLASS_QNAN = 0x0002
const m___FPCLASS_SNAN = 0x0001
const m___FUNCTION__ = "__func__"
const m___FXSR__ = 1
const m___FreeBSD__ = 14
const m___FreeBSD_cc_version = 1400006
const m___GCC_ASM_FLAG_OUTPUTS__ = 1
const m___GCC_ATOMIC_BOOL_LOCK_FREE = 2
const m___GCC_ATOMIC_CHAR16_T_LOCK_FREE = 2
const m___GCC_ATOMIC_CHAR32_T_LOCK_FREE = 2
const m___GCC_ATOMIC_CHAR_LOCK_FREE = 2
const m___GCC_ATOMIC_INT_LOCK_FREE = 2
const m___GCC_ATOMIC_LLONG_LOCK_FREE = 2
const m___GCC_ATOMIC_LONG_LOCK_FREE = 2
const m___GCC_ATOMIC_POINTER_LOCK_FREE = 2
const m___GCC_ATOMIC_SHORT_LOCK_FREE = 2
const m___GCC_ATOMIC_TEST_AND_SET_TRUEVAL = 1
const m___GCC_ATOMIC_WCHAR_T_LOCK_FREE = 2
const m___GCC_HAVE_DWARF2_CFI_ASM = 1
const m___GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = 1
const m___GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = 1
const m___GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = 1
const m___GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = 1
const m___GNUCLIKE_ASM = 3
const m___GNUCLIKE_BUILTIN_CONSTANT_P = 1
const m___GNUCLIKE_BUILTIN_MEMCPY = 1
const m___GNUCLIKE_BUILTIN_NEXT_ARG = 1
const m___GNUCLIKE_BUILTIN_STDARG = 1
const m___GNUCLIKE_BUILTIN_VAALIST = 1
const m___GNUCLIKE_BUILTIN_VARARGS = 1
const m___GNUCLIKE_CTOR_SECTION_HANDLING = 1
const m___GNUCLIKE___SECTION = 1
const m___GNUCLIKE___TYPEOF = 1
const m___GNUC_MINOR__ = 2
const m___GNUC_PATCHLEVEL__ = 1
const m___GNUC_STDC_INLINE__ = 1
const m___GNUC_VA_LIST_COMPATIBILITY = 1
const m___GNUC__ = 4
const m___GXX_ABI_VERSION = 1002
const m___INT16_FMTd__ = "hd"
const m___INT16_FMTi__ = "hi"
const m___INT16_MAX__ = 32767
const m___INT16_TYPE__ = "short"
const m___INT32_FMTd__ = "d"
const m___INT32_FMTi__ = "i"
const m___INT32_MAX__ = 2147483647
const m___INT32_TYPE__ = "int"
const m___INT64_C_SUFFIX__ = "L"
const m___INT64_FMTd__ = "ld"
const m___INT64_FMTi__ = "li"
const m___INT64_MAX__ = 9223372036854775807
const m___INT8_FMTd__ = "hhd"
const m___INT8_FMTi__ = "hhi"
const m___INT8_MAX__ = 127
const m___INTMAX_C_SUFFIX__ = "L"
const m___INTMAX_FMTd__ = "ld"
const m___INTMAX_FMTi__ = "li"
const m___INTMAX_MAX__ = 9223372036854775807
const m___INTMAX_WIDTH__ = 64
const m___INTPTR_FMTd__ = "ld"
const m___INTPTR_FMTi__ = "li"
const m___INTPTR_MAX__ = 9223372036854775807
const m___INTPTR_WIDTH__ = 64
const m___INT_FAST16_FMTd__ = "hd"
const m___INT_FAST16_FMTi__ = "hi"
const m___INT_FAST16_MAX__ = 32767
const m___INT_FAST16_TYPE__ = "short"
const m___INT_FAST16_WIDTH__ = 16
const m___INT_FAST32_FMTd__ = "d"
const m___INT_FAST32_FMTi__ = "i"
const m___INT_FAST32_MAX__ = 2147483647
const m___INT_FAST32_TYPE__ = "int"
const m___INT_FAST32_WIDTH__ = 32
const m___INT_FAST64_FMTd__ = "ld"
const m___INT_FAST64_FMTi__ = "li"
const m___INT_FAST64_MAX__ = 9223372036854775807
const m___INT_FAST64_WIDTH__ = 64
const m___INT_FAST8_FMTd__ = "hhd"
const m___INT_FAST8_FMTi__ = "hhi"
const m___INT_FAST8_MAX__ = 127
const m___INT_FAST8_WIDTH__ = 8
const m___INT_LEAST16_FMTd__ = "hd"
const m___INT_LEAST16_FMTi__ = "hi"
const m___INT_LEAST16_MAX__ = 32767
const m___INT_LEAST16_TYPE__ = "short"
const m___INT_LEAST16_WIDTH__ = 16
const m___INT_LEAST32_FMTd__ = "d"
const m___INT_LEAST32_FMTi__ = "i"
const m___INT_LEAST32_MAX__ = 2147483647
const m___INT_LEAST32_TYPE__ = "int"
const m___INT_LEAST32_WIDTH__ = 32
const m___INT_LEAST64_FMTd__ = "ld"
const m___INT_LEAST64_FMTi__ = "li"
const m___INT_LEAST64_MAX__ = 9223372036854775807
const m___INT_LEAST64_WIDTH__ = 64
const m___INT_LEAST8_FMTd__ = "hhd"
const m___INT_LEAST8_FMTi__ = "hhi"
const m___INT_LEAST8_MAX__ = 127
const m___INT_LEAST8_WIDTH__ = 8
const m___INT_MAX = 0x7fffffff
const m___INT_MAX__ = 2147483647
const m___INT_WIDTH__ = 32
const m___IPV6_ADDR_SCOPE_GLOBAL = 0x0e
const m___IPV6_ADDR_SCOPE_INTFACELOCAL = 0x01
const m___IPV6_ADDR_SCOPE_LINKLOCAL = 0x02
const m___IPV6_ADDR_SCOPE_NODELOCAL = 0x01
const m___IPV6_ADDR_SCOPE_ORGLOCAL = 0x08
const m___IPV6_ADDR_SCOPE_SITELOCAL = 0x05
const m___ISO_C_VISIBLE = 2011
const m___KAME_VERSION = "FreeBSD"
const m___KPRINTF_ATTRIBUTE__ = 1
const m___LDBL_DECIMAL_DIG__ = 17
const m___LDBL_DENORM_MIN__ = 4.9406564584124654e-324
const m___LDBL_DIG__ = 15
const m___LDBL_EPSILON__ = 2.2204460492503131e-16
const m___LDBL_HAS_DENORM__ = 1
const m___LDBL_HAS_INFINITY__ = 1
const m___LDBL_HAS_QUIET_NAN__ = 1
const m___LDBL_MANT_DIG__ = 53
const m___LDBL_MAX_10_EXP__ = 308
const m___LDBL_MAX_EXP__ = 1024
const m___LDBL_MAX__ = 1.7976931348623157e+308
const m___LDBL_MIN__ = 2.2250738585072014e-308
const m___LITTLE_ENDIAN__ = 1
const m___LLONG_MAX = 0x7fffffffffffffff
const m___LLONG_WIDTH__ = 64
const m___LONG_BIT = 64
const m___LONG_LONG_MAX__ = 9223372036854775807
const m___LONG_MAX = 0x7fffffffffffffff
const m___LONG_MAX__ = 9223372036854775807
const m___LONG_WIDTH__ = 64
const m___LP64__ = 1
const m___MEMORY_SCOPE_DEVICE = 1
const m___MEMORY_SCOPE_SINGLE = 4
const m___MEMORY_SCOPE_SYSTEM = 0
const m___MEMORY_SCOPE_WRKGRP = 2
const m___MEMORY_SCOPE_WVFRNT = 3
const m___MMX__ = 1
const m___NO_INLINE__ = 1
const m___NO_MATH_ERRNO__ = 1
const m___NO_MATH_INLINES = 1
const m___OBJC_BOOL_IS_BOOL = 0
const m___OFF_MAX = "__LONG_MAX"
const m___OFF_MIN = "__LONG_MIN"
const m___OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = 3
const m___OPENCL_MEMORY_SCOPE_DEVICE = 2
const m___OPENCL_MEMORY_SCOPE_SUB_GROUP = 4
const m___OPENCL_MEMORY_SCOPE_WORK_GROUP = 1
const m___OPENCL_MEMORY_SCOPE_WORK_ITEM = 0
const m___ORDER_BIG_ENDIAN__ = 4321
const m___ORDER_LITTLE_ENDIAN__ = 1234
const m___ORDER_PDP_ENDIAN__ = 3412
const m___POINTER_WIDTH__ = 64
const m___POSIX_VISIBLE = 200809
const m___PRAGMA_REDEFINE_EXTNAME = 1
const m___PRETTY_FUNCTION__ = "__func__"
const m___PTRDIFF_FMTd__ = "ld"
const m___PTRDIFF_FMTi__ = "li"
const m___PTRDIFF_MAX__ = 9223372036854775807
const m___PTRDIFF_WIDTH__ = 64
const m___QUAD_MAX = "__LONG_MAX"
const m___QUAD_MIN = "__LONG_MIN"
const m___S2OAP = 0x0001
const m___SALC = 0x4000
const m___SAPP = 0x0100
const m___SCHAR_MAX = 0x7f
const m___SCHAR_MAX__ = 127
const m___SEG_FS = 1
const m___SEG_GS = 1
const m___SEOF = 0x0020
const m___SERR = 0x0040
const m___SHRT_MAX = 0x7fff
const m___SHRT_MAX__ = 32767
const m___SHRT_WIDTH__ = 16
const m___SIGN = 0x8000
const m___SIG_ATOMIC_MAX__ = 2147483647
const m___SIG_ATOMIC_WIDTH__ = 32
const m___SIZEOF_DOUBLE__ = 8
const m___SIZEOF_FLOAT128__ = 16
const m___SIZEOF_FLOAT__ = 4
const m___SIZEOF_INT128__ = 16
const m___SIZEOF_INT__ = 4
const m___SIZEOF_LONG_DOUBLE__ = 8
const m___SIZEOF_LONG_LONG__ = 8
const m___SIZEOF_LONG__ = 8
const m___SIZEOF_POINTER__ = 8
const m___SIZEOF_PTRDIFF_T__ = 8
const m___SIZEOF_SHORT__ = 2
const m___SIZEOF_SIZE_T__ = 8
const m___SIZEOF_WCHAR_T__ = 4
const m___SIZEOF_WINT_T__ = 4
const m___SIZE_FMTX__ = "lX"
const m___SIZE_FMTo__ = "lo"
const m___SIZE_FMTu__ = "lu"
const m___SIZE_FMTx__ = "lx"
const m___SIZE_MAX__ = 18446744073709551615
const m___SIZE_T_MAX = "__ULONG_MAX"
const m___SIZE_WIDTH__ = 64
const m___SLBF = 0x0001
const m___SMBF = 0x0080
const m___SMOD = 0x2000
const m___SNBF = 0x0002
const m___SNPT = 0x0800
const m___SOFF = 0x1000
const m___SOPT = 0x0400
const m___SRD = 0x0004
const m___SRW = 0x0010
const m___SSE2_MATH__ = 1
const m___SSE2__ = 1
const m___SSE_MATH__ = 1
const m___SSE__ = 1
const m___SSIZE_MAX = "__LONG_MAX"
const m___SSTR = 0x0200
const m___STDC_HOSTED__ = 1
const m___STDC_MB_MIGHT_NEQ_WC__ = 1
const m___STDC_UTF_16__ = 1
const m___STDC_UTF_32__ = 1
const m___STDC_VERSION__ = 201710
const m___STDC_WANT_IEC_60559_ATTRIBS_EXT__ = 1
const m___STDC_WANT_IEC_60559_BFP_EXT__ = 1
const m___STDC_WANT_IEC_60559_DFP_EXT__ = 1
const m___STDC_WANT_IEC_60559_FUNCS_EXT__ = 1
const m___STDC_WANT_IEC_60559_TYPES_EXT__ = 1
const m___STDC_WANT_LIB_EXT2__ = 1
const m___STDC_WANT_MATH_SPEC_FUNCS__ = 1
const m___STDC__ = 1
const m___SWR = 0x0008
const m___UCHAR_MAX = 0xff
const m___UINT16_FMTX__ = "hX"
const m___UINT16_FMTo__ = "ho"
const m___UINT16_FMTu__ = "hu"
const m___UINT16_FMTx__ = "hx"
const m___UINT16_MAX__ = 65535
const m___UINT32_C_SUFFIX__ = "U"
const m___UINT32_FMTX__ = "X"
const m___UINT32_FMTo__ = "o"
const m___UINT32_FMTu__ = "u"
const m___UINT32_FMTx__ = "x"
const m___UINT32_MAX__ = 4294967295
const m___UINT64_C_SUFFIX__ = "UL"
const m___UINT64_FMTX__ = "lX"
const m___UINT64_FMTo__ = "lo"
const m___UINT64_FMTu__ = "lu"
const m___UINT64_FMTx__ = "lx"
const m___UINT64_MAX__ = 18446744073709551615
const m___UINT8_FMTX__ = "hhX"
const m___UINT8_FMTo__ = "hho"
const m___UINT8_FMTu__ = "hhu"
const m___UINT8_FMTx__ = "hhx"
const m___UINT8_MAX__ = 255
const m___UINTMAX_C_SUFFIX__ = "UL"
const m___UINTMAX_FMTX__ = "lX"
const m___UINTMAX_FMTo__ = "lo"
const m___UINTMAX_FMTu__ = "lu"
const m___UINTMAX_FMTx__ = "lx"
const m___UINTMAX_MAX__ = 18446744073709551615
const m___UINTMAX_WIDTH__ = 64
const m___UINTPTR_FMTX__ = "lX"
const m___UINTPTR_FMTo__ = "lo"
const m___UINTPTR_FMTu__ = "lu"
const m___UINTPTR_FMTx__ = "lx"
const m___UINTPTR_MAX__ = 18446744073709551615
const m___UINTPTR_WIDTH__ = 64
const m___UINT_FAST16_FMTX__ = "hX"
const m___UINT_FAST16_FMTo__ = "ho"
const m___UINT_FAST16_FMTu__ = "hu"
const m___UINT_FAST16_FMTx__ = "hx"
const m___UINT_FAST16_MAX__ = 65535
const m___UINT_FAST32_FMTX__ = "X"
const m___UINT_FAST32_FMTo__ = "o"
const m___UINT_FAST32_FMTu__ = "u"
const m___UINT_FAST32_FMTx__ = "x"
const m___UINT_FAST32_MAX__ = 4294967295
const m___UINT_FAST64_FMTX__ = "lX"
const m___UINT_FAST64_FMTo__ = "lo"
const m___UINT_FAST64_FMTu__ = "lu"
const m___UINT_FAST64_FMTx__ = "lx"
const m___UINT_FAST64_MAX__ = 18446744073709551615
const m___UINT_FAST8_FMTX__ = "hhX"
const m___UINT_FAST8_FMTo__ = "hho"
const m___UINT_FAST8_FMTu__ = "hhu"
const m___UINT_FAST8_FMTx__ = "hhx"
const m___UINT_FAST8_MAX__ = 255
const m___UINT_LEAST16_FMTX__ = "hX"
const m___UINT_LEAST16_FMTo__ = "ho"
const m___UINT_LEAST16_FMTu__ = "hu"
const m___UINT_LEAST16_FMTx__ = "hx"
const m___UINT_LEAST16_MAX__ = 65535
const m___UINT_LEAST32_FMTX__ = "X"
const m___UINT_LEAST32_FMTo__ = "o"
const m___UINT_LEAST32_FMTu__ = "u"
const m___UINT_LEAST32_FMTx__ = "x"
const m___UINT_LEAST32_MAX__ = 4294967295
const m___UINT_LEAST64_FMTX__ = "lX"
const m___UINT_LEAST64_FMTo__ = "lo"
const m___UINT_LEAST64_FMTu__ = "lu"
const m___UINT_LEAST64_FMTx__ = "lx"
const m___UINT_LEAST64_MAX__ = 18446744073709551615
const m___UINT_LEAST8_FMTX__ = "hhX"
const m___UINT_LEAST8_FMTo__ = "hho"
const m___UINT_LEAST8_FMTu__ = "hhu"
const m___UINT_LEAST8_FMTx__ = "hhx"
const m___UINT_LEAST8_MAX__ = 255
const m___UINT_MAX = 0xffffffff
const m___ULLONG_MAX = "0xffffffffffffffffU"
const m___ULONG_MAX = 0xffffffffffffffff
const m___UQUAD_MAX = "__ULONG_MAX"
const m___USHRT_MAX = 0xffff
const m___VERSION__ = "FreeBSD Clang 18.1.6 (https://github.com/llvm/llvm-project.git llvmorg-18.1.6-0-g1118c2e05e67)"
const m___WCHAR_MAX = "__INT_MAX"
const m___WCHAR_MAX__ = 2147483647
const m___WCHAR_MIN = "__INT_MIN"
const m___WCHAR_TYPE__ = "int"
const m___WCHAR_WIDTH__ = 32
const m___WINT_MAX__ = 2147483647
const m___WINT_TYPE__ = "int"
const m___WINT_WIDTH__ = 32
const m___WORDSIZE = 64
const m___WORD_BIT = 32
const m___XSI_VISIBLE = 700
const m___amd64 = 1
const m___amd64__ = 1
const m___clang__ = 1
const m___clang_literal_encoding__ = "UTF-8"
const m___clang_major__ = 18
const m___clang_minor__ = 1
const m___clang_patchlevel__ = 6
const m___clang_version__ = "18.1.6 (https://github.com/llvm/llvm-project.git llvmorg-18.1.6-0-g1118c2e05e67)"
const m___clang_wide_literal_encoding__ = "UTF-32"
const m___code_model_small__ = 1
const m___const = "const"
const m___has_extension = "__has_feature"
const m___k8 = 1
const m___k8__ = 1
const m___llvm__ = 1
const m___restrict = "restrict"
const m___restrict_arr = "restrict"
const m___signed = "signed"
const m___tune_k8__ = 1
const m___unix = 1
const m___unix__ = 1
const m___volatile = "volatile"
const m___writeonly = "__unused"
const m___x86_64 = 1
const m___x86_64__ = 1
const m_fds_bits = "__fds_bits"
const m_pseudo_AF_HDRCMPLT = 31
const m_pseudo_AF_KEY = 27
const m_pseudo_AF_PIP = 25
const m_pseudo_AF_RTIP = 22
const m_pseudo_AF_XTP = 19
const m_pthread_attr_default = "NULL"
const m_pthread_condattr_default = "NULL"
const m_pthread_mutexattr_default = "NULL"
const m_static_assert = "_Static_assert"
const m_stderr = "__stderrp"
const m_stdin = "__stdinp"
const m_stdout = "__stdoutp"
const m_unix = 1

type t__builtin_va_list = uintptr

type t__predefined_size_t = uint64

type t__predefined_wchar_t = int32

type t__predefined_ptrdiff_t = int64

type t__int8_t = int8

type t__uint8_t = uint8

type t__int16_t = int16

type t__uint16_t = uint16

type t__int32_t = int32

type t__uint32_t = uint32

type t__int64_t = int64

type t__uint64_t = uint64

type t__int_least8_t = int8

type t__int_least16_t = int16

type t__int_least32_t = int32

type t__int_least64_t = int64

type t__intmax_t = int64

type t__uint_least8_t = uint8

type t__uint_least16_t = uint16

type t__uint_least32_t = uint32

type t__uint_least64_t = uint64

type t__uintmax_t = uint64

type t__intptr_t = int64

type t__intfptr_t = int64

type t__uintptr_t = uint64

type t__uintfptr_t = uint64

type t__vm_offset_t = uint64

type t__vm_size_t = uint64

type t__size_t = uint64

type t__ssize_t = int64

type t__ptrdiff_t = int64

type t__clock_t = int32

type t__critical_t = int64

type t__double_t = float64

type t__float_t = float32

type t__int_fast8_t = int32

type t__int_fast16_t = int32

type t__int_fast32_t = int32

type t__int_fast64_t = int64

type t__register_t = int64

type t__segsz_t = int64

type t__time_t = int64

type t__uint_fast8_t = uint32

type t__uint_fast16_t = uint32

type t__uint_fast32_t = uint32

type t__uint_fast64_t = uint64

type t__u_register_t = uint64

type t__vm_paddr_t = uint64

type T___wchar_t = int32

type t__blksize_t = int32

type t__blkcnt_t = int64

type t__clockid_t = int32

type t__fflags_t = uint32

type t__fsblkcnt_t = uint64

type t__fsfilcnt_t = uint64

type t__gid_t = uint32

type t__id_t = int64

type t__ino_t = uint64

type t__key_t = int64

type t__lwpid_t = int32

type t__mode_t = uint16

type t__accmode_t = int32

type t__nl_item = int32

type t__nlink_t = uint64

type t__off_t = int64

type t__off64_t = int64

type t__pid_t = int32

type t__sbintime_t = int64

type t__rlim_t = int64

type t__sa_family_t = uint8

type t__socklen_t = uint32

type t__suseconds_t = int64

type t__timer_t = uintptr

type t__mqd_t = uintptr

type t__uid_t = uint32

type t__useconds_t = uint32

type t__cpuwhich_t = int32

type t__cpulevel_t = int32

type t__cpusetid_t = int32

type t__daddr_t = int64

type t__ct_rune_t = int32

type t__rune_t = int32

type t__wint_t = int32

type t__char16_t = uint16

type t__char32_t = uint32

type t__max_align_t = struct {
	F__max_align1 int64
	F__max_align2 float64
}

type t__dev_t = uint64

type t__fixpt_t = uint32

type t__mbstate_t = struct {
	F_mbstateL  [0]t__int64_t
	F__mbstate8 [128]int8
}

type t__rman_res_t = uint64

type t__va_list = uintptr

type t__gnuc_va_list = uintptr

type Tsize_t = uint64

type Tlocale_t = uintptr

type Tmode_t = uint16

type Tssize_t = int64

type Trsize_t = uint64

type Terrno_t = int32

type Tfpos_t = int64

type Toff_t = int64

type Toff64_t = int64

type Tva_list = uintptr

type t__sbuf = struct {
	F_base uintptr
	F_size int32
}

type t__sFILE = struct {
	F_p           uintptr
	F_r           int32
	F_w           int32
	F_flags       int16
	F_file        int16
	F_bf          t__sbuf
	F_lbfsize     int32
	F_cookie      uintptr
	F_close       uintptr
	F_read        uintptr
	F_seek        uintptr
	F_write       uintptr
	F_ub          t__sbuf
	F_up          uintptr
	F_ur          int32
	F_ubuf        [3]uint8
	F_nbuf        [1]uint8
	F_lb          t__sbuf
	F_blksize     int32
	F_offset      Tfpos_t
	F_fl_mutex    uintptr
	F_fl_owner    uintptr
	F_fl_count    int32
	F_orientation int32
	F_mbstate     t__mbstate_t
	F_flags2      int32
}

type TFILE = struct {
	F_p           uintptr
	F_r           int32
	F_w           int32
	F_flags       int16
	F_file        int16
	F_bf          t__sbuf
	F_lbfsize     int32
	F_cookie      uintptr
	F_close       uintptr
	F_read        uintptr
	F_seek        uintptr
	F_write       uintptr
	F_ub          t__sbuf
	F_up          uintptr
	F_ur          int32
	F_ubuf        [3]uint8
	F_nbuf        [1]uint8
	F_lb          t__sbuf
	F_blksize     int32
	F_offset      Tfpos_t
	F_fl_mutex    uintptr
	F_fl_owner    uintptr
	F_fl_count    int32
	F_orientation int32
	F_mbstate     t__mbstate_t
	F_flags2      int32
}

type Tcookie_io_functions_t = struct {
	Fread   uintptr
	Fwrite  uintptr
	Fseek   uintptr
	Fclose1 uintptr
}

type Trune_t = int32

type Twchar_t = int32

type Tdiv_t = struct {
	Fquot int32
	Frem  int32
}

type Tldiv_t = struct {
	Fquot int64
	Frem  int64
}

type Tlldiv_t = struct {
	Fquot int64
	Frem  int64
}

type Tconstraint_handler_t = uintptr

type Tpid_t = int32

type Tflock = struct {
	Fl_start  Toff_t
	Fl_len    Toff_t
	Fl_pid    Tpid_t
	Fl_type   int16
	Fl_whence int16
	Fl_sysid  int32
}

type t__oflock = struct {
	Fl_start  Toff_t
	Fl_len    Toff_t
	Fl_pid    Tpid_t
	Fl_type   int16
	Fl_whence int16
}

type Tspacectl_range = struct {
	Fr_offset Toff_t
	Fr_len    Toff_t
}

type Tpthread_once = struct {
	Fstate int32
	Fmutex Tpthread_mutex_t
}

type Tpthread_t = uintptr

type Tpthread_attr_t = uintptr

type Tpthread_mutex_t = uintptr

type Tpthread_mutexattr_t = uintptr

type Tpthread_cond_t = uintptr

type Tpthread_condattr_t = uintptr

type Tpthread_key_t = int32

type Tpthread_once_t = struct {
	Fstate int32
	Fmutex Tpthread_mutex_t
}

type Tpthread_rwlock_t = uintptr

type Tpthread_rwlockattr_t = uintptr

type Tpthread_barrier_t = uintptr

type Tpthread_barrierattr_t = uintptr

type Tpthread_spinlock_t = uintptr

type Tpthread_addr_t = uintptr

type Tpthread_startroutine_t = uintptr

type Tu_char = uint8

type Tu_short = uint16

type Tu_int = uint32

type Tu_long = uint64

type Tushort = uint16

type Tuint = uint32

type Tint8_t = int8

type Tint16_t = int16

type Tint32_t = int32

type Tint64_t = int64

type Tuint8_t = uint8

type Tuint16_t = uint16

type Tuint32_t = uint32

type Tuint64_t = uint64

type Tintptr_t = int64

type Tuintptr_t = uint64

type Tintmax_t = int64

type Tuintmax_t = uint64

type Tu_int8_t = uint8

type Tu_int16_t = uint16

type Tu_int32_t = uint32

type Tu_int64_t = uint64

type Tu_quad_t = uint64

type Tquad_t = int64

type Tqaddr_t = uintptr

type Tcaddr_t = uintptr

type Tc_caddr_t = uintptr

type Tblksize_t = int32

type Tcpuwhich_t = int32

type Tcpulevel_t = int32

type Tcpusetid_t = int32

type Tblkcnt_t = int64

type Tclock_t = int32

type Tclockid_t = int32

type Tcritical_t = int64

type Tdaddr_t = int64

type Tdev_t = uint64

type Tfflags_t = uint32

type Tfixpt_t = uint32

type Tfsblkcnt_t = uint64

type Tfsfilcnt_t = uint64

type Tgid_t = uint32

type Tin_addr_t = uint32

type Tin_port_t = uint16

type Tid_t = int64

type Tino_t = uint64

type Tkey_t = int64

type Tlwpid_t = int32

type Taccmode_t = int32

type Tnlink_t = uint64

type Tregister_t = int64

type Trlim_t = int64

type Tsbintime_t = int64

type Tsegsz_t = int64

type Tsuseconds_t = int64

type Ttime_t = int64

type Ttimer_t = uintptr

type Tmqd_t = uintptr

type Tu_register_t = uint64

type Tuid_t = uint32

type Tuseconds_t = uint32

type Tcap_ioctl_t = uint64

type Tkpaddr_t = uint64

type Tkvaddr_t = uint64

type Tksize_t = uint64

type Tkssize_t = int64

type Tvm_offset_t = uint64

type Tvm_ooffset_t = uint64

type Tvm_paddr_t = uint64

type Tvm_pindex_t = uint64

type Tvm_size_t = uint64

type Trman_res_t = uint64

type Tsyscallarg_t = int64

type t__sigset_t = struct {
	F__bits [4]t__uint32_t
}

type t__sigset = t__sigset_t

type Ttimeval = struct {
	Ftv_sec  Ttime_t
	Ftv_usec Tsuseconds_t
}

type Ttimespec = struct {
	Ftv_sec  Ttime_t
	Ftv_nsec int64
}

type Titimerspec = struct {
	Fit_interval Ttimespec
	Fit_value    Ttimespec
}

type t__fd_mask = uint64

type Tfd_mask = uint64

type Tsigset_t = struct {
	F__bits [4]t__uint32_t
}

type Tfd_set = struct {
	F__fds_bits [16]t__fd_mask
}

type Tint_least8_t = int8

type Tint_least16_t = int16

type Tint_least32_t = int32

type Tint_least64_t = int64

type Tuint_least8_t = uint8

type Tuint_least16_t = uint16

type Tuint_least32_t = uint32

type Tuint_least64_t = uint64

type Tint_fast8_t = int32

type Tint_fast16_t = int32

type Tint_fast32_t = int32

type Tint_fast64_t = int64

type Tuint_fast8_t = uint32

type Tuint_fast16_t = uint32

type Tuint_fast32_t = uint32

type Tuint_fast64_t = uint64

type Tiovec = struct {
	Fiov_base uintptr
	Fiov_len  Tsize_t
}

type _uio_rw = int32

const _UIO_READ = 0
const _UIO_WRITE = 1

type _uio_seg = int32

const _UIO_USERSPACE = 0
const _UIO_SYSSPACE = 1
const _UIO_NOCOPY = 2

type Tsigval = struct {
	Fsival_ptr   [0]uintptr
	Fsigval_int  [0]int32
	Fsigval_ptr  [0]uintptr
	Fsival_int   int32
	F__ccgo_pad4 [4]byte
}

type Tsched_param = struct {
	Fsched_priority int32
}

type T_cpuset = struct {
	F__bits [16]int64
}

type Tcpuset_t = struct {
	F__bits [16]int64
}

type Tcpu_set_t = struct {
	F__bits [16]int64
}

type Ttm = struct {
	Ftm_sec    int32
	Ftm_min    int32
	Ftm_hour   int32
	Ftm_mday   int32
	Ftm_mon    int32
	Ftm_year   int32
	Ftm_wday   int32
	Ftm_yday   int32
	Ftm_isdst  int32
	Ftm_gmtoff int64
	Ftm_zone   uintptr
}

type _pthread_mutextype = int32

const _PTHREAD_MUTEX_ERRORCHECK = 1
const _PTHREAD_MUTEX_RECURSIVE = 2
const _PTHREAD_MUTEX_NORMAL = 3
const _PTHREAD_MUTEX_ADAPTIVE_NP = 4
const _PTHREAD_MUTEX_TYPE_MAX = 5

type T_pthread_cleanup_info = struct {
	Fpthread_cleanup_pad [8]t__uintptr_t
}

type Txcb_connection_t = struct {
	Fhas_error int32
	Fsetup     uintptr
	Ffd        int32
	Fiolock    Tpthread_mutex_t
	Fin        T_xcb_in
	Fout       T_xcb_out
	Fext       T_xcb_ext
	Fxid       T_xcb_xid
}

type Txcb_generic_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_generic_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
}

type Txcb_generic_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Fpad           [7]Tuint32_t
	Ffull_sequence Tuint32_t
}

type Txcb_raw_generic_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Fpad           [7]Tuint32_t
}

type Txcb_ge_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fevent_type    Tuint16_t
	Fpad1          Tuint16_t
	Fpad           [5]Tuint32_t
	Ffull_sequence Tuint32_t
}

type Txcb_generic_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fresource_id   Tuint32_t
	Fminor_code    Tuint16_t
	Fmajor_code    Tuint8_t
	Fpad0          Tuint8_t
	Fpad           [5]Tuint32_t
	Ffull_sequence Tuint32_t
}

type Txcb_void_cookie_t = struct {
	Fsequence uint32
}

type Txcb_char2b_t = struct {
	Fbyte1 Tuint8_t
	Fbyte2 Tuint8_t
}

type Txcb_char2b_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_window_t = uint32

type Txcb_window_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_pixmap_t = uint32

type Txcb_pixmap_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_cursor_t = uint32

type Txcb_cursor_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_font_t = uint32

type Txcb_font_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_gcontext_t = uint32

type Txcb_gcontext_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_colormap_t = uint32

type Txcb_colormap_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_atom_t = uint32

type Txcb_atom_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_drawable_t = uint32

type Txcb_drawable_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_fontable_t = uint32

type Txcb_fontable_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_bool32_t = uint32

type Txcb_bool32_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_visualid_t = uint32

type Txcb_visualid_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_timestamp_t = uint32

type Txcb_timestamp_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_keysym_t = uint32

type Txcb_keysym_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_keycode_t = uint8

type Txcb_keycode_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_keycode32_t = uint32

type Txcb_keycode32_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_button_t = uint8

type Txcb_button_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_point_t = struct {
	Fx Tint16_t
	Fy Tint16_t
}

type Txcb_point_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_rectangle_t = struct {
	Fx      Tint16_t
	Fy      Tint16_t
	Fwidth  Tuint16_t
	Fheight Tuint16_t
}

type Txcb_rectangle_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_arc_t = struct {
	Fx      Tint16_t
	Fy      Tint16_t
	Fwidth  Tuint16_t
	Fheight Tuint16_t
	Fangle1 Tint16_t
	Fangle2 Tint16_t
}

type Txcb_arc_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_format_t = struct {
	Fdepth          Tuint8_t
	Fbits_per_pixel Tuint8_t
	Fscanline_pad   Tuint8_t
	Fpad0           [5]Tuint8_t
}

type Txcb_format_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_visual_class_t = int32

type _xcb_visual_class_t = int32

const _XCB_VISUAL_CLASS_STATIC_GRAY = 0
const _XCB_VISUAL_CLASS_GRAY_SCALE = 1
const _XCB_VISUAL_CLASS_STATIC_COLOR = 2
const _XCB_VISUAL_CLASS_PSEUDO_COLOR = 3
const _XCB_VISUAL_CLASS_TRUE_COLOR = 4
const _XCB_VISUAL_CLASS_DIRECT_COLOR = 5

type Txcb_visualtype_t = struct {
	Fvisual_id          Txcb_visualid_t
	F_class             Tuint8_t
	Fbits_per_rgb_value Tuint8_t
	Fcolormap_entries   Tuint16_t
	Fred_mask           Tuint32_t
	Fgreen_mask         Tuint32_t
	Fblue_mask          Tuint32_t
	Fpad0               [4]Tuint8_t
}

type Txcb_visualtype_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_depth_t = struct {
	Fdepth       Tuint8_t
	Fpad0        Tuint8_t
	Fvisuals_len Tuint16_t
	Fpad1        [4]Tuint8_t
}

type Txcb_depth_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_event_mask_t = int32

type _xcb_event_mask_t = int32

const _XCB_EVENT_MASK_NO_EVENT = 0
const _XCB_EVENT_MASK_KEY_PRESS = 1
const _XCB_EVENT_MASK_KEY_RELEASE = 2
const _XCB_EVENT_MASK_BUTTON_PRESS = 4
const _XCB_EVENT_MASK_BUTTON_RELEASE = 8
const _XCB_EVENT_MASK_ENTER_WINDOW = 16
const _XCB_EVENT_MASK_LEAVE_WINDOW = 32
const _XCB_EVENT_MASK_POINTER_MOTION = 64
const _XCB_EVENT_MASK_POINTER_MOTION_HINT = 128
const _XCB_EVENT_MASK_BUTTON_1_MOTION = 256
const _XCB_EVENT_MASK_BUTTON_2_MOTION = 512
const _XCB_EVENT_MASK_BUTTON_3_MOTION = 1024
const _XCB_EVENT_MASK_BUTTON_4_MOTION = 2048
const _XCB_EVENT_MASK_BUTTON_5_MOTION = 4096
const _XCB_EVENT_MASK_BUTTON_MOTION = 8192
const _XCB_EVENT_MASK_KEYMAP_STATE = 16384
const _XCB_EVENT_MASK_EXPOSURE = 32768
const _XCB_EVENT_MASK_VISIBILITY_CHANGE = 65536
const _XCB_EVENT_MASK_STRUCTURE_NOTIFY = 131072
const _XCB_EVENT_MASK_RESIZE_REDIRECT = 262144
const _XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY = 524288
const _XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT = 1048576
const _XCB_EVENT_MASK_FOCUS_CHANGE = 2097152
const _XCB_EVENT_MASK_PROPERTY_CHANGE = 4194304
const _XCB_EVENT_MASK_COLOR_MAP_CHANGE = 8388608
const _XCB_EVENT_MASK_OWNER_GRAB_BUTTON = 16777216

type Txcb_backing_store_t = int32

type _xcb_backing_store_t = int32

const _XCB_BACKING_STORE_NOT_USEFUL = 0
const _XCB_BACKING_STORE_WHEN_MAPPED = 1
const _XCB_BACKING_STORE_ALWAYS = 2

type Txcb_screen_t = struct {
	Froot                  Txcb_window_t
	Fdefault_colormap      Txcb_colormap_t
	Fwhite_pixel           Tuint32_t
	Fblack_pixel           Tuint32_t
	Fcurrent_input_masks   Tuint32_t
	Fwidth_in_pixels       Tuint16_t
	Fheight_in_pixels      Tuint16_t
	Fwidth_in_millimeters  Tuint16_t
	Fheight_in_millimeters Tuint16_t
	Fmin_installed_maps    Tuint16_t
	Fmax_installed_maps    Tuint16_t
	Froot_visual           Txcb_visualid_t
	Fbacking_stores        Tuint8_t
	Fsave_unders           Tuint8_t
	Froot_depth            Tuint8_t
	Fallowed_depths_len    Tuint8_t
}

type Txcb_screen_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_setup_request_t = struct {
	Fbyte_order                      Tuint8_t
	Fpad0                            Tuint8_t
	Fprotocol_major_version          Tuint16_t
	Fprotocol_minor_version          Tuint16_t
	Fauthorization_protocol_name_len Tuint16_t
	Fauthorization_protocol_data_len Tuint16_t
	Fpad1                            [2]Tuint8_t
}

type Txcb_setup_request_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_setup_failed_t = struct {
	Fstatus                 Tuint8_t
	Freason_len             Tuint8_t
	Fprotocol_major_version Tuint16_t
	Fprotocol_minor_version Tuint16_t
	Flength                 Tuint16_t
}

type Txcb_setup_failed_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_setup_authenticate_t = struct {
	Fstatus Tuint8_t
	Fpad0   [5]Tuint8_t
	Flength Tuint16_t
}

type Txcb_setup_authenticate_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_image_order_t = int32

type _xcb_image_order_t = int32

const _XCB_IMAGE_ORDER_LSB_FIRST = 0
const _XCB_IMAGE_ORDER_MSB_FIRST = 1

type Txcb_setup_t = struct {
	Fstatus                      Tuint8_t
	Fpad0                        Tuint8_t
	Fprotocol_major_version      Tuint16_t
	Fprotocol_minor_version      Tuint16_t
	Flength                      Tuint16_t
	Frelease_number              Tuint32_t
	Fresource_id_base            Tuint32_t
	Fresource_id_mask            Tuint32_t
	Fmotion_buffer_size          Tuint32_t
	Fvendor_len                  Tuint16_t
	Fmaximum_request_length      Tuint16_t
	Froots_len                   Tuint8_t
	Fpixmap_formats_len          Tuint8_t
	Fimage_byte_order            Tuint8_t
	Fbitmap_format_bit_order     Tuint8_t
	Fbitmap_format_scanline_unit Tuint8_t
	Fbitmap_format_scanline_pad  Tuint8_t
	Fmin_keycode                 Txcb_keycode_t
	Fmax_keycode                 Txcb_keycode_t
	Fpad1                        [4]Tuint8_t
}

type Txcb_setup_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_mod_mask_t = int32

type _xcb_mod_mask_t = int32

const _XCB_MOD_MASK_SHIFT = 1
const _XCB_MOD_MASK_LOCK = 2
const _XCB_MOD_MASK_CONTROL = 4
const _XCB_MOD_MASK_1 = 8
const _XCB_MOD_MASK_2 = 16
const _XCB_MOD_MASK_3 = 32
const _XCB_MOD_MASK_4 = 64
const _XCB_MOD_MASK_5 = 128
const _XCB_MOD_MASK_ANY = 32768

type Txcb_key_but_mask_t = int32

type _xcb_key_but_mask_t = int32

const _XCB_KEY_BUT_MASK_SHIFT = 1
const _XCB_KEY_BUT_MASK_LOCK = 2
const _XCB_KEY_BUT_MASK_CONTROL = 4
const _XCB_KEY_BUT_MASK_MOD_1 = 8
const _XCB_KEY_BUT_MASK_MOD_2 = 16
const _XCB_KEY_BUT_MASK_MOD_3 = 32
const _XCB_KEY_BUT_MASK_MOD_4 = 64
const _XCB_KEY_BUT_MASK_MOD_5 = 128
const _XCB_KEY_BUT_MASK_BUTTON_1 = 256
const _XCB_KEY_BUT_MASK_BUTTON_2 = 512
const _XCB_KEY_BUT_MASK_BUTTON_3 = 1024
const _XCB_KEY_BUT_MASK_BUTTON_4 = 2048
const _XCB_KEY_BUT_MASK_BUTTON_5 = 4096

type Txcb_window_enum_t = int32

type _xcb_window_enum_t = int32

const _XCB_WINDOW_NONE = 0

type Txcb_key_press_event_t = struct {
	Fresponse_type Tuint8_t
	Fdetail        Txcb_keycode_t
	Fsequence      Tuint16_t
	Ftime          Txcb_timestamp_t
	Froot          Txcb_window_t
	Fevent         Txcb_window_t
	Fchild         Txcb_window_t
	Froot_x        Tint16_t
	Froot_y        Tint16_t
	Fevent_x       Tint16_t
	Fevent_y       Tint16_t
	Fstate         Tuint16_t
	Fsame_screen   Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_key_release_event_t = struct {
	Fresponse_type Tuint8_t
	Fdetail        Txcb_keycode_t
	Fsequence      Tuint16_t
	Ftime          Txcb_timestamp_t
	Froot          Txcb_window_t
	Fevent         Txcb_window_t
	Fchild         Txcb_window_t
	Froot_x        Tint16_t
	Froot_y        Tint16_t
	Fevent_x       Tint16_t
	Fevent_y       Tint16_t
	Fstate         Tuint16_t
	Fsame_screen   Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_key_press_event_t1 = Txcb_key_release_event_t

type Txcb_button_mask_t = int32

type _xcb_button_mask_t = int32

const _XCB_BUTTON_MASK_1 = 256
const _XCB_BUTTON_MASK_2 = 512
const _XCB_BUTTON_MASK_3 = 1024
const _XCB_BUTTON_MASK_4 = 2048
const _XCB_BUTTON_MASK_5 = 4096
const _XCB_BUTTON_MASK_ANY = 32768

type Txcb_button_press_event_t = struct {
	Fresponse_type Tuint8_t
	Fdetail        Txcb_button_t
	Fsequence      Tuint16_t
	Ftime          Txcb_timestamp_t
	Froot          Txcb_window_t
	Fevent         Txcb_window_t
	Fchild         Txcb_window_t
	Froot_x        Tint16_t
	Froot_y        Tint16_t
	Fevent_x       Tint16_t
	Fevent_y       Tint16_t
	Fstate         Tuint16_t
	Fsame_screen   Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_button_release_event_t = struct {
	Fresponse_type Tuint8_t
	Fdetail        Txcb_button_t
	Fsequence      Tuint16_t
	Ftime          Txcb_timestamp_t
	Froot          Txcb_window_t
	Fevent         Txcb_window_t
	Fchild         Txcb_window_t
	Froot_x        Tint16_t
	Froot_y        Tint16_t
	Fevent_x       Tint16_t
	Fevent_y       Tint16_t
	Fstate         Tuint16_t
	Fsame_screen   Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_button_press_event_t1 = Txcb_button_release_event_t

type Txcb_motion_t = int32

type _xcb_motion_t = int32

const _XCB_MOTION_NORMAL = 0
const _XCB_MOTION_HINT = 1

type Txcb_motion_notify_event_t = struct {
	Fresponse_type Tuint8_t
	Fdetail        Tuint8_t
	Fsequence      Tuint16_t
	Ftime          Txcb_timestamp_t
	Froot          Txcb_window_t
	Fevent         Txcb_window_t
	Fchild         Txcb_window_t
	Froot_x        Tint16_t
	Froot_y        Tint16_t
	Fevent_x       Tint16_t
	Fevent_y       Tint16_t
	Fstate         Tuint16_t
	Fsame_screen   Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_notify_detail_t = int32

type _xcb_notify_detail_t = int32

const _XCB_NOTIFY_DETAIL_ANCESTOR = 0
const _XCB_NOTIFY_DETAIL_VIRTUAL = 1
const _XCB_NOTIFY_DETAIL_INFERIOR = 2
const _XCB_NOTIFY_DETAIL_NONLINEAR = 3
const _XCB_NOTIFY_DETAIL_NONLINEAR_VIRTUAL = 4
const _XCB_NOTIFY_DETAIL_POINTER = 5
const _XCB_NOTIFY_DETAIL_POINTER_ROOT = 6
const _XCB_NOTIFY_DETAIL_NONE = 7

type Txcb_notify_mode_t = int32

type _xcb_notify_mode_t = int32

const _XCB_NOTIFY_MODE_NORMAL = 0
const _XCB_NOTIFY_MODE_GRAB = 1
const _XCB_NOTIFY_MODE_UNGRAB = 2
const _XCB_NOTIFY_MODE_WHILE_GRABBED = 3

type Txcb_enter_notify_event_t = struct {
	Fresponse_type     Tuint8_t
	Fdetail            Tuint8_t
	Fsequence          Tuint16_t
	Ftime              Txcb_timestamp_t
	Froot              Txcb_window_t
	Fevent             Txcb_window_t
	Fchild             Txcb_window_t
	Froot_x            Tint16_t
	Froot_y            Tint16_t
	Fevent_x           Tint16_t
	Fevent_y           Tint16_t
	Fstate             Tuint16_t
	Fmode              Tuint8_t
	Fsame_screen_focus Tuint8_t
}

type Txcb_leave_notify_event_t = struct {
	Fresponse_type     Tuint8_t
	Fdetail            Tuint8_t
	Fsequence          Tuint16_t
	Ftime              Txcb_timestamp_t
	Froot              Txcb_window_t
	Fevent             Txcb_window_t
	Fchild             Txcb_window_t
	Froot_x            Tint16_t
	Froot_y            Tint16_t
	Fevent_x           Tint16_t
	Fevent_y           Tint16_t
	Fstate             Tuint16_t
	Fmode              Tuint8_t
	Fsame_screen_focus Tuint8_t
}

type Txcb_enter_notify_event_t1 = Txcb_leave_notify_event_t

type Txcb_focus_in_event_t = struct {
	Fresponse_type Tuint8_t
	Fdetail        Tuint8_t
	Fsequence      Tuint16_t
	Fevent         Txcb_window_t
	Fmode          Tuint8_t
	Fpad0          [3]Tuint8_t
}

type Txcb_focus_out_event_t = struct {
	Fresponse_type Tuint8_t
	Fdetail        Tuint8_t
	Fsequence      Tuint16_t
	Fevent         Txcb_window_t
	Fmode          Tuint8_t
	Fpad0          [3]Tuint8_t
}

type Txcb_focus_in_event_t1 = Txcb_focus_out_event_t

type Txcb_keymap_notify_event_t = struct {
	Fresponse_type Tuint8_t
	Fkeys          [31]Tuint8_t
}

type Txcb_expose_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Fwindow        Txcb_window_t
	Fx             Tuint16_t
	Fy             Tuint16_t
	Fwidth         Tuint16_t
	Fheight        Tuint16_t
	Fcount         Tuint16_t
	Fpad1          [2]Tuint8_t
}

type Txcb_graphics_exposure_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Fdrawable      Txcb_drawable_t
	Fx             Tuint16_t
	Fy             Tuint16_t
	Fwidth         Tuint16_t
	Fheight        Tuint16_t
	Fminor_opcode  Tuint16_t
	Fcount         Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad1          [3]Tuint8_t
}

type Txcb_no_exposure_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Fdrawable      Txcb_drawable_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad1          Tuint8_t
}

type Txcb_visibility_t = int32

type _xcb_visibility_t = int32

const _XCB_VISIBILITY_UNOBSCURED = 0
const _XCB_VISIBILITY_PARTIALLY_OBSCURED = 1
const _XCB_VISIBILITY_FULLY_OBSCURED = 2

type Txcb_visibility_notify_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Fwindow        Txcb_window_t
	Fstate         Tuint8_t
	Fpad1          [3]Tuint8_t
}

type Txcb_create_notify_event_t = struct {
	Fresponse_type     Tuint8_t
	Fpad0              Tuint8_t
	Fsequence          Tuint16_t
	Fparent            Txcb_window_t
	Fwindow            Txcb_window_t
	Fx                 Tint16_t
	Fy                 Tint16_t
	Fwidth             Tuint16_t
	Fheight            Tuint16_t
	Fborder_width      Tuint16_t
	Foverride_redirect Tuint8_t
	Fpad1              Tuint8_t
}

type Txcb_destroy_notify_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Fevent         Txcb_window_t
	Fwindow        Txcb_window_t
}

type Txcb_unmap_notify_event_t = struct {
	Fresponse_type  Tuint8_t
	Fpad0           Tuint8_t
	Fsequence       Tuint16_t
	Fevent          Txcb_window_t
	Fwindow         Txcb_window_t
	Ffrom_configure Tuint8_t
	Fpad1           [3]Tuint8_t
}

type Txcb_map_notify_event_t = struct {
	Fresponse_type     Tuint8_t
	Fpad0              Tuint8_t
	Fsequence          Tuint16_t
	Fevent             Txcb_window_t
	Fwindow            Txcb_window_t
	Foverride_redirect Tuint8_t
	Fpad1              [3]Tuint8_t
}

type Txcb_map_request_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Fparent        Txcb_window_t
	Fwindow        Txcb_window_t
}

type Txcb_reparent_notify_event_t = struct {
	Fresponse_type     Tuint8_t
	Fpad0              Tuint8_t
	Fsequence          Tuint16_t
	Fevent             Txcb_window_t
	Fwindow            Txcb_window_t
	Fparent            Txcb_window_t
	Fx                 Tint16_t
	Fy                 Tint16_t
	Foverride_redirect Tuint8_t
	Fpad1              [3]Tuint8_t
}

type Txcb_configure_notify_event_t = struct {
	Fresponse_type     Tuint8_t
	Fpad0              Tuint8_t
	Fsequence          Tuint16_t
	Fevent             Txcb_window_t
	Fwindow            Txcb_window_t
	Fabove_sibling     Txcb_window_t
	Fx                 Tint16_t
	Fy                 Tint16_t
	Fwidth             Tuint16_t
	Fheight            Tuint16_t
	Fborder_width      Tuint16_t
	Foverride_redirect Tuint8_t
	Fpad1              Tuint8_t
}

type Txcb_configure_request_event_t = struct {
	Fresponse_type Tuint8_t
	Fstack_mode    Tuint8_t
	Fsequence      Tuint16_t
	Fparent        Txcb_window_t
	Fwindow        Txcb_window_t
	Fsibling       Txcb_window_t
	Fx             Tint16_t
	Fy             Tint16_t
	Fwidth         Tuint16_t
	Fheight        Tuint16_t
	Fborder_width  Tuint16_t
	Fvalue_mask    Tuint16_t
}

type Txcb_gravity_notify_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Fevent         Txcb_window_t
	Fwindow        Txcb_window_t
	Fx             Tint16_t
	Fy             Tint16_t
}

type Txcb_resize_request_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Fwindow        Txcb_window_t
	Fwidth         Tuint16_t
	Fheight        Tuint16_t
}

type Txcb_place_t = int32

type _xcb_place_t = int32

const _XCB_PLACE_ON_TOP = 0
const _XCB_PLACE_ON_BOTTOM = 1

type Txcb_circulate_notify_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Fevent         Txcb_window_t
	Fwindow        Txcb_window_t
	Fpad1          [4]Tuint8_t
	Fplace         Tuint8_t
	Fpad2          [3]Tuint8_t
}

type Txcb_circulate_request_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Fevent         Txcb_window_t
	Fwindow        Txcb_window_t
	Fpad1          [4]Tuint8_t
	Fplace         Tuint8_t
	Fpad2          [3]Tuint8_t
}

type Txcb_circulate_notify_event_t1 = Txcb_circulate_request_event_t

type Txcb_property_t = int32

type _xcb_property_t = int32

const _XCB_PROPERTY_NEW_VALUE = 0
const _XCB_PROPERTY_DELETE = 1

type Txcb_property_notify_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Fwindow        Txcb_window_t
	Fatom          Txcb_atom_t
	Ftime          Txcb_timestamp_t
	Fstate         Tuint8_t
	Fpad1          [3]Tuint8_t
}

type Txcb_selection_clear_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Ftime          Txcb_timestamp_t
	Fowner         Txcb_window_t
	Fselection     Txcb_atom_t
}

type Txcb_time_t = int32

type _xcb_time_t = int32

const _XCB_TIME_CURRENT_TIME = 0

type Txcb_atom_enum_t = int32

type _xcb_atom_enum_t = int32

const _XCB_ATOM_NONE = 0
const _XCB_ATOM_ANY = 0
const _XCB_ATOM_PRIMARY = 1
const _XCB_ATOM_SECONDARY = 2
const _XCB_ATOM_ARC = 3
const _XCB_ATOM_ATOM = 4
const _XCB_ATOM_BITMAP = 5
const _XCB_ATOM_CARDINAL = 6
const _XCB_ATOM_COLORMAP = 7
const _XCB_ATOM_CURSOR = 8
const _XCB_ATOM_CUT_BUFFER0 = 9
const _XCB_ATOM_CUT_BUFFER1 = 10
const _XCB_ATOM_CUT_BUFFER2 = 11
const _XCB_ATOM_CUT_BUFFER3 = 12
const _XCB_ATOM_CUT_BUFFER4 = 13
const _XCB_ATOM_CUT_BUFFER5 = 14
const _XCB_ATOM_CUT_BUFFER6 = 15
const _XCB_ATOM_CUT_BUFFER7 = 16
const _XCB_ATOM_DRAWABLE = 17
const _XCB_ATOM_FONT = 18
const _XCB_ATOM_INTEGER = 19
const _XCB_ATOM_PIXMAP = 20
const _XCB_ATOM_POINT = 21
const _XCB_ATOM_RECTANGLE = 22
const _XCB_ATOM_RESOURCE_MANAGER = 23
const _XCB_ATOM_RGB_COLOR_MAP = 24
const _XCB_ATOM_RGB_BEST_MAP = 25
const _XCB_ATOM_RGB_BLUE_MAP = 26
const _XCB_ATOM_RGB_DEFAULT_MAP = 27
const _XCB_ATOM_RGB_GRAY_MAP = 28
const _XCB_ATOM_RGB_GREEN_MAP = 29
const _XCB_ATOM_RGB_RED_MAP = 30
const _XCB_ATOM_STRING = 31
const _XCB_ATOM_VISUALID = 32
const _XCB_ATOM_WINDOW = 33
const _XCB_ATOM_WM_COMMAND = 34
const _XCB_ATOM_WM_HINTS = 35
const _XCB_ATOM_WM_CLIENT_MACHINE = 36
const _XCB_ATOM_WM_ICON_NAME = 37
const _XCB_ATOM_WM_ICON_SIZE = 38
const _XCB_ATOM_WM_NAME = 39
const _XCB_ATOM_WM_NORMAL_HINTS = 40
const _XCB_ATOM_WM_SIZE_HINTS = 41
const _XCB_ATOM_WM_ZOOM_HINTS = 42
const _XCB_ATOM_MIN_SPACE = 43
const _XCB_ATOM_NORM_SPACE = 44
const _XCB_ATOM_MAX_SPACE = 45
const _XCB_ATOM_END_SPACE = 46
const _XCB_ATOM_SUPERSCRIPT_X = 47
const _XCB_ATOM_SUPERSCRIPT_Y = 48
const _XCB_ATOM_SUBSCRIPT_X = 49
const _XCB_ATOM_SUBSCRIPT_Y = 50
const _XCB_ATOM_UNDERLINE_POSITION = 51
const _XCB_ATOM_UNDERLINE_THICKNESS = 52
const _XCB_ATOM_STRIKEOUT_ASCENT = 53
const _XCB_ATOM_STRIKEOUT_DESCENT = 54
const _XCB_ATOM_ITALIC_ANGLE = 55
const _XCB_ATOM_X_HEIGHT = 56
const _XCB_ATOM_QUAD_WIDTH = 57
const _XCB_ATOM_WEIGHT = 58
const _XCB_ATOM_POINT_SIZE = 59
const _XCB_ATOM_RESOLUTION = 60
const _XCB_ATOM_COPYRIGHT = 61
const _XCB_ATOM_NOTICE = 62
const _XCB_ATOM_FONT_NAME = 63
const _XCB_ATOM_FAMILY_NAME = 64
const _XCB_ATOM_FULL_NAME = 65
const _XCB_ATOM_CAP_HEIGHT = 66
const _XCB_ATOM_WM_CLASS = 67
const _XCB_ATOM_WM_TRANSIENT_FOR = 68

type Txcb_selection_request_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Ftime          Txcb_timestamp_t
	Fowner         Txcb_window_t
	Frequestor     Txcb_window_t
	Fselection     Txcb_atom_t
	Ftarget        Txcb_atom_t
	Fproperty      Txcb_atom_t
}

type Txcb_selection_notify_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Ftime          Txcb_timestamp_t
	Frequestor     Txcb_window_t
	Fselection     Txcb_atom_t
	Ftarget        Txcb_atom_t
	Fproperty      Txcb_atom_t
}

type Txcb_colormap_state_t = int32

type _xcb_colormap_state_t = int32

const _XCB_COLORMAP_STATE_UNINSTALLED = 0
const _XCB_COLORMAP_STATE_INSTALLED = 1

type Txcb_colormap_enum_t = int32

type _xcb_colormap_enum_t = int32

const _XCB_COLORMAP_NONE = 0

type Txcb_colormap_notify_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Fwindow        Txcb_window_t
	Fcolormap      Txcb_colormap_t
	F_new          Tuint8_t
	Fstate         Tuint8_t
	Fpad1          [2]Tuint8_t
}

type Txcb_client_message_data_t = struct {
	Fdata16 [0][10]Tuint16_t
	Fdata32 [0][5]Tuint32_t
	Fdata8  [20]Tuint8_t
}

type Txcb_client_message_data_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_client_message_event_t = struct {
	Fresponse_type Tuint8_t
	Fformat        Tuint8_t
	Fsequence      Tuint16_t
	Fwindow        Txcb_window_t
	Ftype1         Txcb_atom_t
	Fdata          Txcb_client_message_data_t
}

type Txcb_mapping_t = int32

type _xcb_mapping_t = int32

const _XCB_MAPPING_MODIFIER = 0
const _XCB_MAPPING_KEYBOARD = 1
const _XCB_MAPPING_POINTER = 2

type Txcb_mapping_notify_event_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Frequest       Tuint8_t
	Ffirst_keycode Txcb_keycode_t
	Fcount         Tuint8_t
	Fpad1          Tuint8_t
}

type Txcb_ge_generic_event_t = struct {
	Fresponse_type Tuint8_t
	Fextension     Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fevent_type    Tuint16_t
	Fpad0          [22]Tuint8_t
	Ffull_sequence Tuint32_t
}

type Txcb_request_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_value_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_window_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_value_error_t1 = Txcb_window_error_t

type Txcb_pixmap_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_atom_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_cursor_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_font_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_match_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_request_error_t1 = Txcb_match_error_t

type Txcb_drawable_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_access_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_alloc_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_colormap_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_g_context_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_id_choice_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_name_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_length_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_implementation_error_t = struct {
	Fresponse_type Tuint8_t
	Ferror_code    Tuint8_t
	Fsequence      Tuint16_t
	Fbad_value     Tuint32_t
	Fminor_opcode  Tuint16_t
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
}

type Txcb_window_class_t = int32

type _xcb_window_class_t = int32

const _XCB_WINDOW_CLASS_COPY_FROM_PARENT = 0
const _XCB_WINDOW_CLASS_INPUT_OUTPUT = 1
const _XCB_WINDOW_CLASS_INPUT_ONLY = 2

type Txcb_cw_t = int32

type _xcb_cw_t = int32

const _XCB_CW_BACK_PIXMAP = 1
const _XCB_CW_BACK_PIXEL = 2
const _XCB_CW_BORDER_PIXMAP = 4
const _XCB_CW_BORDER_PIXEL = 8
const _XCB_CW_BIT_GRAVITY = 16
const _XCB_CW_WIN_GRAVITY = 32
const _XCB_CW_BACKING_STORE = 64
const _XCB_CW_BACKING_PLANES = 128
const _XCB_CW_BACKING_PIXEL = 256
const _XCB_CW_OVERRIDE_REDIRECT = 512
const _XCB_CW_SAVE_UNDER = 1024
const _XCB_CW_EVENT_MASK = 2048
const _XCB_CW_DONT_PROPAGATE = 4096
const _XCB_CW_COLORMAP = 8192
const _XCB_CW_CURSOR = 16384

type Txcb_back_pixmap_t = int32

type _xcb_back_pixmap_t = int32

const _XCB_BACK_PIXMAP_NONE = 0
const _XCB_BACK_PIXMAP_PARENT_RELATIVE = 1

type Txcb_gravity_t = int32

type _xcb_gravity_t = int32

const _XCB_GRAVITY_BIT_FORGET = 0
const _XCB_GRAVITY_WIN_UNMAP = 0
const _XCB_GRAVITY_NORTH_WEST = 1
const _XCB_GRAVITY_NORTH = 2
const _XCB_GRAVITY_NORTH_EAST = 3
const _XCB_GRAVITY_WEST = 4
const _XCB_GRAVITY_CENTER = 5
const _XCB_GRAVITY_EAST = 6
const _XCB_GRAVITY_SOUTH_WEST = 7
const _XCB_GRAVITY_SOUTH = 8
const _XCB_GRAVITY_SOUTH_EAST = 9
const _XCB_GRAVITY_STATIC = 10

type Txcb_create_window_value_list_t = struct {
	Fbackground_pixmap     Txcb_pixmap_t
	Fbackground_pixel      Tuint32_t
	Fborder_pixmap         Txcb_pixmap_t
	Fborder_pixel          Tuint32_t
	Fbit_gravity           Tuint32_t
	Fwin_gravity           Tuint32_t
	Fbacking_store         Tuint32_t
	Fbacking_planes        Tuint32_t
	Fbacking_pixel         Tuint32_t
	Foverride_redirect     Txcb_bool32_t
	Fsave_under            Txcb_bool32_t
	Fevent_mask            Tuint32_t
	Fdo_not_propogate_mask Tuint32_t
	Fcolormap              Txcb_colormap_t
	Fcursor                Txcb_cursor_t
}

type Txcb_create_window_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fdepth        Tuint8_t
	Flength       Tuint16_t
	Fwid          Txcb_window_t
	Fparent       Txcb_window_t
	Fx            Tint16_t
	Fy            Tint16_t
	Fwidth        Tuint16_t
	Fheight       Tuint16_t
	Fborder_width Tuint16_t
	F_class       Tuint16_t
	Fvisual       Txcb_visualid_t
	Fvalue_mask   Tuint32_t
}

type Txcb_change_window_attributes_value_list_t = struct {
	Fbackground_pixmap     Txcb_pixmap_t
	Fbackground_pixel      Tuint32_t
	Fborder_pixmap         Txcb_pixmap_t
	Fborder_pixel          Tuint32_t
	Fbit_gravity           Tuint32_t
	Fwin_gravity           Tuint32_t
	Fbacking_store         Tuint32_t
	Fbacking_planes        Tuint32_t
	Fbacking_pixel         Tuint32_t
	Foverride_redirect     Txcb_bool32_t
	Fsave_under            Txcb_bool32_t
	Fevent_mask            Tuint32_t
	Fdo_not_propogate_mask Tuint32_t
	Fcolormap              Txcb_colormap_t
	Fcursor                Txcb_cursor_t
}

type Txcb_change_window_attributes_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
	Fvalue_mask   Tuint32_t
}

type Txcb_map_state_t = int32

type _xcb_map_state_t = int32

const _XCB_MAP_STATE_UNMAPPED = 0
const _XCB_MAP_STATE_UNVIEWABLE = 1
const _XCB_MAP_STATE_VIEWABLE = 2

type Txcb_get_window_attributes_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_window_attributes_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
}

type Txcb_get_window_attributes_reply_t = struct {
	Fresponse_type         Tuint8_t
	Fbacking_store         Tuint8_t
	Fsequence              Tuint16_t
	Flength                Tuint32_t
	Fvisual                Txcb_visualid_t
	F_class                Tuint16_t
	Fbit_gravity           Tuint8_t
	Fwin_gravity           Tuint8_t
	Fbacking_planes        Tuint32_t
	Fbacking_pixel         Tuint32_t
	Fsave_under            Tuint8_t
	Fmap_is_installed      Tuint8_t
	Fmap_state             Tuint8_t
	Foverride_redirect     Tuint8_t
	Fcolormap              Txcb_colormap_t
	Fall_event_masks       Tuint32_t
	Fyour_event_mask       Tuint32_t
	Fdo_not_propagate_mask Tuint16_t
	Fpad0                  [2]Tuint8_t
}

type Txcb_destroy_window_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
}

type Txcb_destroy_subwindows_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
}

type Txcb_set_mode_t = int32

type _xcb_set_mode_t = int32

const _XCB_SET_MODE_INSERT = 0
const _XCB_SET_MODE_DELETE = 1

type Txcb_change_save_set_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fmode         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
}

type Txcb_reparent_window_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
	Fparent       Txcb_window_t
	Fx            Tint16_t
	Fy            Tint16_t
}

type Txcb_map_window_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
}

type Txcb_map_subwindows_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
}

type Txcb_unmap_window_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
}

type Txcb_unmap_subwindows_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
}

type Txcb_config_window_t = int32

type _xcb_config_window_t = int32

const _XCB_CONFIG_WINDOW_X = 1
const _XCB_CONFIG_WINDOW_Y = 2
const _XCB_CONFIG_WINDOW_WIDTH = 4
const _XCB_CONFIG_WINDOW_HEIGHT = 8
const _XCB_CONFIG_WINDOW_BORDER_WIDTH = 16
const _XCB_CONFIG_WINDOW_SIBLING = 32
const _XCB_CONFIG_WINDOW_STACK_MODE = 64

type Txcb_stack_mode_t = int32

type _xcb_stack_mode_t = int32

const _XCB_STACK_MODE_ABOVE = 0
const _XCB_STACK_MODE_BELOW = 1
const _XCB_STACK_MODE_TOP_IF = 2
const _XCB_STACK_MODE_BOTTOM_IF = 3
const _XCB_STACK_MODE_OPPOSITE = 4

type Txcb_configure_window_value_list_t = struct {
	Fx            Tint32_t
	Fy            Tint32_t
	Fwidth        Tuint32_t
	Fheight       Tuint32_t
	Fborder_width Tuint32_t
	Fsibling      Txcb_window_t
	Fstack_mode   Tuint32_t
}

type Txcb_configure_window_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
	Fvalue_mask   Tuint16_t
	Fpad1         [2]Tuint8_t
}

type Txcb_circulate_t = int32

type _xcb_circulate_t = int32

const _XCB_CIRCULATE_RAISE_LOWEST = 0
const _XCB_CIRCULATE_LOWER_HIGHEST = 1

type Txcb_circulate_window_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fdirection    Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
}

type Txcb_get_geometry_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_geometry_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fdrawable     Txcb_drawable_t
}

type Txcb_get_geometry_reply_t = struct {
	Fresponse_type Tuint8_t
	Fdepth         Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Froot          Txcb_window_t
	Fx             Tint16_t
	Fy             Tint16_t
	Fwidth         Tuint16_t
	Fheight        Tuint16_t
	Fborder_width  Tuint16_t
	Fpad0          [2]Tuint8_t
}

type Txcb_query_tree_cookie_t = struct {
	Fsequence uint32
}

type Txcb_query_tree_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
}

type Txcb_query_tree_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Froot          Txcb_window_t
	Fparent        Txcb_window_t
	Fchildren_len  Tuint16_t
	Fpad1          [14]Tuint8_t
}

type Txcb_intern_atom_cookie_t = struct {
	Fsequence uint32
}

type Txcb_intern_atom_request_t = struct {
	Fmajor_opcode   Tuint8_t
	Fonly_if_exists Tuint8_t
	Flength         Tuint16_t
	Fname_len       Tuint16_t
	Fpad0           [2]Tuint8_t
}

type Txcb_intern_atom_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fatom          Txcb_atom_t
}

type Txcb_get_atom_name_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_atom_name_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fatom         Txcb_atom_t
}

type Txcb_get_atom_name_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fname_len      Tuint16_t
	Fpad1          [22]Tuint8_t
}

type Txcb_prop_mode_t = int32

type _xcb_prop_mode_t = int32

const _XCB_PROP_MODE_REPLACE = 0
const _XCB_PROP_MODE_PREPEND = 1
const _XCB_PROP_MODE_APPEND = 2

type Txcb_change_property_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fmode         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
	Fproperty     Txcb_atom_t
	Ftype1        Txcb_atom_t
	Fformat       Tuint8_t
	Fpad0         [3]Tuint8_t
	Fdata_len     Tuint32_t
}

type Txcb_delete_property_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
	Fproperty     Txcb_atom_t
}

type Txcb_get_property_type_t = int32

type _xcb_get_property_type_t = int32

const _XCB_GET_PROPERTY_TYPE_ANY = 0

type Txcb_get_property_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_property_request_t = struct {
	Fmajor_opcode Tuint8_t
	F_delete      Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
	Fproperty     Txcb_atom_t
	Ftype1        Txcb_atom_t
	Flong_offset  Tuint32_t
	Flong_length  Tuint32_t
}

type Txcb_get_property_reply_t = struct {
	Fresponse_type Tuint8_t
	Fformat        Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Ftype1         Txcb_atom_t
	Fbytes_after   Tuint32_t
	Fvalue_len     Tuint32_t
	Fpad0          [12]Tuint8_t
}

type Txcb_list_properties_cookie_t = struct {
	Fsequence uint32
}

type Txcb_list_properties_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
}

type Txcb_list_properties_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fatoms_len     Tuint16_t
	Fpad1          [22]Tuint8_t
}

type Txcb_set_selection_owner_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fowner        Txcb_window_t
	Fselection    Txcb_atom_t
	Ftime         Txcb_timestamp_t
}

type Txcb_get_selection_owner_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_selection_owner_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fselection    Txcb_atom_t
}

type Txcb_get_selection_owner_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fowner         Txcb_window_t
}

type Txcb_convert_selection_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Frequestor    Txcb_window_t
	Fselection    Txcb_atom_t
	Ftarget       Txcb_atom_t
	Fproperty     Txcb_atom_t
	Ftime         Txcb_timestamp_t
}

type Txcb_send_event_dest_t = int32

type _xcb_send_event_dest_t = int32

const _XCB_SEND_EVENT_DEST_POINTER_WINDOW = 0
const _XCB_SEND_EVENT_DEST_ITEM_FOCUS = 1

type Txcb_send_event_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpropagate    Tuint8_t
	Flength       Tuint16_t
	Fdestination  Txcb_window_t
	Fevent_mask   Tuint32_t
	Fevent        [32]int8
}

type Txcb_grab_mode_t = int32

type _xcb_grab_mode_t = int32

const _XCB_GRAB_MODE_SYNC = 0
const _XCB_GRAB_MODE_ASYNC = 1

type Txcb_grab_status_t = int32

type _xcb_grab_status_t = int32

const _XCB_GRAB_STATUS_SUCCESS = 0
const _XCB_GRAB_STATUS_ALREADY_GRABBED = 1
const _XCB_GRAB_STATUS_INVALID_TIME = 2
const _XCB_GRAB_STATUS_NOT_VIEWABLE = 3
const _XCB_GRAB_STATUS_FROZEN = 4

type Txcb_cursor_enum_t = int32

type _xcb_cursor_enum_t = int32

const _XCB_CURSOR_NONE = 0

type Txcb_grab_pointer_cookie_t = struct {
	Fsequence uint32
}

type Txcb_grab_pointer_request_t = struct {
	Fmajor_opcode  Tuint8_t
	Fowner_events  Tuint8_t
	Flength        Tuint16_t
	Fgrab_window   Txcb_window_t
	Fevent_mask    Tuint16_t
	Fpointer_mode  Tuint8_t
	Fkeyboard_mode Tuint8_t
	Fconfine_to    Txcb_window_t
	Fcursor        Txcb_cursor_t
	Ftime          Txcb_timestamp_t
}

type Txcb_grab_pointer_reply_t = struct {
	Fresponse_type Tuint8_t
	Fstatus        Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
}

type Txcb_ungrab_pointer_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Ftime         Txcb_timestamp_t
}

type Txcb_button_index_t = int32

type _xcb_button_index_t = int32

const _XCB_BUTTON_INDEX_ANY = 0
const _XCB_BUTTON_INDEX_1 = 1
const _XCB_BUTTON_INDEX_2 = 2
const _XCB_BUTTON_INDEX_3 = 3
const _XCB_BUTTON_INDEX_4 = 4
const _XCB_BUTTON_INDEX_5 = 5

type Txcb_grab_button_request_t = struct {
	Fmajor_opcode  Tuint8_t
	Fowner_events  Tuint8_t
	Flength        Tuint16_t
	Fgrab_window   Txcb_window_t
	Fevent_mask    Tuint16_t
	Fpointer_mode  Tuint8_t
	Fkeyboard_mode Tuint8_t
	Fconfine_to    Txcb_window_t
	Fcursor        Txcb_cursor_t
	Fbutton        Tuint8_t
	Fpad0          Tuint8_t
	Fmodifiers     Tuint16_t
}

type Txcb_ungrab_button_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fbutton       Tuint8_t
	Flength       Tuint16_t
	Fgrab_window  Txcb_window_t
	Fmodifiers    Tuint16_t
	Fpad0         [2]Tuint8_t
}

type Txcb_change_active_pointer_grab_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcursor       Txcb_cursor_t
	Ftime         Txcb_timestamp_t
	Fevent_mask   Tuint16_t
	Fpad1         [2]Tuint8_t
}

type Txcb_grab_keyboard_cookie_t = struct {
	Fsequence uint32
}

type Txcb_grab_keyboard_request_t = struct {
	Fmajor_opcode  Tuint8_t
	Fowner_events  Tuint8_t
	Flength        Tuint16_t
	Fgrab_window   Txcb_window_t
	Ftime          Txcb_timestamp_t
	Fpointer_mode  Tuint8_t
	Fkeyboard_mode Tuint8_t
	Fpad0          [2]Tuint8_t
}

type Txcb_grab_keyboard_reply_t = struct {
	Fresponse_type Tuint8_t
	Fstatus        Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
}

type Txcb_ungrab_keyboard_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Ftime         Txcb_timestamp_t
}

type Txcb_grab_t = int32

type _xcb_grab_t = int32

const _XCB_GRAB_ANY = 0

type Txcb_grab_key_request_t = struct {
	Fmajor_opcode  Tuint8_t
	Fowner_events  Tuint8_t
	Flength        Tuint16_t
	Fgrab_window   Txcb_window_t
	Fmodifiers     Tuint16_t
	Fkey           Txcb_keycode_t
	Fpointer_mode  Tuint8_t
	Fkeyboard_mode Tuint8_t
	Fpad0          [3]Tuint8_t
}

type Txcb_ungrab_key_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fkey          Txcb_keycode_t
	Flength       Tuint16_t
	Fgrab_window  Txcb_window_t
	Fmodifiers    Tuint16_t
	Fpad0         [2]Tuint8_t
}

type Txcb_allow_t = int32

type _xcb_allow_t = int32

const _XCB_ALLOW_ASYNC_POINTER = 0
const _XCB_ALLOW_SYNC_POINTER = 1
const _XCB_ALLOW_REPLAY_POINTER = 2
const _XCB_ALLOW_ASYNC_KEYBOARD = 3
const _XCB_ALLOW_SYNC_KEYBOARD = 4
const _XCB_ALLOW_REPLAY_KEYBOARD = 5
const _XCB_ALLOW_ASYNC_BOTH = 6
const _XCB_ALLOW_SYNC_BOTH = 7

type Txcb_allow_events_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fmode         Tuint8_t
	Flength       Tuint16_t
	Ftime         Txcb_timestamp_t
}

type Txcb_grab_server_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_ungrab_server_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_query_pointer_cookie_t = struct {
	Fsequence uint32
}

type Txcb_query_pointer_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
}

type Txcb_query_pointer_reply_t = struct {
	Fresponse_type Tuint8_t
	Fsame_screen   Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Froot          Txcb_window_t
	Fchild         Txcb_window_t
	Froot_x        Tint16_t
	Froot_y        Tint16_t
	Fwin_x         Tint16_t
	Fwin_y         Tint16_t
	Fmask          Tuint16_t
	Fpad0          [2]Tuint8_t
}

type Txcb_timecoord_t = struct {
	Ftime Txcb_timestamp_t
	Fx    Tint16_t
	Fy    Tint16_t
}

type Txcb_timecoord_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_get_motion_events_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_motion_events_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
	Fstart        Txcb_timestamp_t
	Fstop         Txcb_timestamp_t
}

type Txcb_get_motion_events_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fevents_len    Tuint32_t
	Fpad1          [20]Tuint8_t
}

type Txcb_translate_coordinates_cookie_t = struct {
	Fsequence uint32
}

type Txcb_translate_coordinates_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fsrc_window   Txcb_window_t
	Fdst_window   Txcb_window_t
	Fsrc_x        Tint16_t
	Fsrc_y        Tint16_t
}

type Txcb_translate_coordinates_reply_t = struct {
	Fresponse_type Tuint8_t
	Fsame_screen   Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fchild         Txcb_window_t
	Fdst_x         Tint16_t
	Fdst_y         Tint16_t
}

type Txcb_warp_pointer_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fsrc_window   Txcb_window_t
	Fdst_window   Txcb_window_t
	Fsrc_x        Tint16_t
	Fsrc_y        Tint16_t
	Fsrc_width    Tuint16_t
	Fsrc_height   Tuint16_t
	Fdst_x        Tint16_t
	Fdst_y        Tint16_t
}

type Txcb_input_focus_t = int32

type _xcb_input_focus_t = int32

const _XCB_INPUT_FOCUS_NONE = 0
const _XCB_INPUT_FOCUS_POINTER_ROOT = 1
const _XCB_INPUT_FOCUS_PARENT = 2
const _XCB_INPUT_FOCUS_FOLLOW_KEYBOARD = 3

type Txcb_set_input_focus_request_t = struct {
	Fmajor_opcode Tuint8_t
	Frevert_to    Tuint8_t
	Flength       Tuint16_t
	Ffocus        Txcb_window_t
	Ftime         Txcb_timestamp_t
}

type Txcb_get_input_focus_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_input_focus_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_get_input_focus_reply_t = struct {
	Fresponse_type Tuint8_t
	Frevert_to     Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Ffocus         Txcb_window_t
}

type Txcb_query_keymap_cookie_t = struct {
	Fsequence uint32
}

type Txcb_query_keymap_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_query_keymap_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fkeys          [32]Tuint8_t
}

type Txcb_open_font_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Ffid          Txcb_font_t
	Fname_len     Tuint16_t
	Fpad1         [2]Tuint8_t
}

type Txcb_close_font_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Ffont         Txcb_font_t
}

type Txcb_font_draw_t = int32

type _xcb_font_draw_t = int32

const _XCB_FONT_DRAW_LEFT_TO_RIGHT = 0
const _XCB_FONT_DRAW_RIGHT_TO_LEFT = 1

type Txcb_fontprop_t = struct {
	Fname  Txcb_atom_t
	Fvalue Tuint32_t
}

type Txcb_fontprop_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_charinfo_t = struct {
	Fleft_side_bearing  Tint16_t
	Fright_side_bearing Tint16_t
	Fcharacter_width    Tint16_t
	Fascent             Tint16_t
	Fdescent            Tint16_t
	Fattributes         Tuint16_t
}

type Txcb_charinfo_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_query_font_cookie_t = struct {
	Fsequence uint32
}

type Txcb_query_font_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Ffont         Txcb_fontable_t
}

type Txcb_query_font_reply_t = struct {
	Fresponse_type     Tuint8_t
	Fpad0              Tuint8_t
	Fsequence          Tuint16_t
	Flength            Tuint32_t
	Fmin_bounds        Txcb_charinfo_t
	Fpad1              [4]Tuint8_t
	Fmax_bounds        Txcb_charinfo_t
	Fpad2              [4]Tuint8_t
	Fmin_char_or_byte2 Tuint16_t
	Fmax_char_or_byte2 Tuint16_t
	Fdefault_char      Tuint16_t
	Fproperties_len    Tuint16_t
	Fdraw_direction    Tuint8_t
	Fmin_byte1         Tuint8_t
	Fmax_byte1         Tuint8_t
	Fall_chars_exist   Tuint8_t
	Ffont_ascent       Tint16_t
	Ffont_descent      Tint16_t
	Fchar_infos_len    Tuint32_t
}

type Txcb_query_text_extents_cookie_t = struct {
	Fsequence uint32
}

type Txcb_query_text_extents_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fodd_length   Tuint8_t
	Flength       Tuint16_t
	Ffont         Txcb_fontable_t
}

type Txcb_query_text_extents_reply_t = struct {
	Fresponse_type   Tuint8_t
	Fdraw_direction  Tuint8_t
	Fsequence        Tuint16_t
	Flength          Tuint32_t
	Ffont_ascent     Tint16_t
	Ffont_descent    Tint16_t
	Foverall_ascent  Tint16_t
	Foverall_descent Tint16_t
	Foverall_width   Tint32_t
	Foverall_left    Tint32_t
	Foverall_right   Tint32_t
}

type Txcb_str_t = struct {
	Fname_len Tuint8_t
}

type Txcb_str_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_list_fonts_cookie_t = struct {
	Fsequence uint32
}

type Txcb_list_fonts_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fmax_names    Tuint16_t
	Fpattern_len  Tuint16_t
}

type Txcb_list_fonts_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fnames_len     Tuint16_t
	Fpad1          [22]Tuint8_t
}

type Txcb_list_fonts_with_info_cookie_t = struct {
	Fsequence uint32
}

type Txcb_list_fonts_with_info_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fmax_names    Tuint16_t
	Fpattern_len  Tuint16_t
}

type Txcb_list_fonts_with_info_reply_t = struct {
	Fresponse_type     Tuint8_t
	Fname_len          Tuint8_t
	Fsequence          Tuint16_t
	Flength            Tuint32_t
	Fmin_bounds        Txcb_charinfo_t
	Fpad0              [4]Tuint8_t
	Fmax_bounds        Txcb_charinfo_t
	Fpad1              [4]Tuint8_t
	Fmin_char_or_byte2 Tuint16_t
	Fmax_char_or_byte2 Tuint16_t
	Fdefault_char      Tuint16_t
	Fproperties_len    Tuint16_t
	Fdraw_direction    Tuint8_t
	Fmin_byte1         Tuint8_t
	Fmax_byte1         Tuint8_t
	Fall_chars_exist   Tuint8_t
	Ffont_ascent       Tint16_t
	Ffont_descent      Tint16_t
	Freplies_hint      Tuint32_t
}

type Txcb_set_font_path_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Ffont_qty     Tuint16_t
	Fpad1         [2]Tuint8_t
}

type Txcb_get_font_path_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_font_path_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_get_font_path_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fpath_len      Tuint16_t
	Fpad1          [22]Tuint8_t
}

type Txcb_create_pixmap_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fdepth        Tuint8_t
	Flength       Tuint16_t
	Fpid          Txcb_pixmap_t
	Fdrawable     Txcb_drawable_t
	Fwidth        Tuint16_t
	Fheight       Tuint16_t
}

type Txcb_free_pixmap_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fpixmap       Txcb_pixmap_t
}

type Txcb_gc_t = int32

type _xcb_gc_t = int32

const _XCB_GC_FUNCTION = 1
const _XCB_GC_PLANE_MASK = 2
const _XCB_GC_FOREGROUND = 4
const _XCB_GC_BACKGROUND = 8
const _XCB_GC_LINE_WIDTH = 16
const _XCB_GC_LINE_STYLE = 32
const _XCB_GC_CAP_STYLE = 64
const _XCB_GC_JOIN_STYLE = 128
const _XCB_GC_FILL_STYLE = 256
const _XCB_GC_FILL_RULE = 512
const _XCB_GC_TILE = 1024
const _XCB_GC_STIPPLE = 2048
const _XCB_GC_TILE_STIPPLE_ORIGIN_X = 4096
const _XCB_GC_TILE_STIPPLE_ORIGIN_Y = 8192
const _XCB_GC_FONT = 16384
const _XCB_GC_SUBWINDOW_MODE = 32768
const _XCB_GC_GRAPHICS_EXPOSURES = 65536
const _XCB_GC_CLIP_ORIGIN_X = 131072
const _XCB_GC_CLIP_ORIGIN_Y = 262144
const _XCB_GC_CLIP_MASK = 524288
const _XCB_GC_DASH_OFFSET = 1048576
const _XCB_GC_DASH_LIST = 2097152
const _XCB_GC_ARC_MODE = 4194304

type Txcb_gx_t = int32

type _xcb_gx_t = int32

const _XCB_GX_CLEAR = 0
const _XCB_GX_AND = 1
const _XCB_GX_AND_REVERSE = 2
const _XCB_GX_COPY = 3
const _XCB_GX_AND_INVERTED = 4
const _XCB_GX_NOOP = 5
const _XCB_GX_XOR = 6
const _XCB_GX_OR = 7
const _XCB_GX_NOR = 8
const _XCB_GX_EQUIV = 9
const _XCB_GX_INVERT = 10
const _XCB_GX_OR_REVERSE = 11
const _XCB_GX_COPY_INVERTED = 12
const _XCB_GX_OR_INVERTED = 13
const _XCB_GX_NAND = 14
const _XCB_GX_SET = 15

type Txcb_line_style_t = int32

type _xcb_line_style_t = int32

const _XCB_LINE_STYLE_SOLID = 0
const _XCB_LINE_STYLE_ON_OFF_DASH = 1
const _XCB_LINE_STYLE_DOUBLE_DASH = 2

type Txcb_cap_style_t = int32

type _xcb_cap_style_t = int32

const _XCB_CAP_STYLE_NOT_LAST = 0
const _XCB_CAP_STYLE_BUTT = 1
const _XCB_CAP_STYLE_ROUND = 2
const _XCB_CAP_STYLE_PROJECTING = 3

type Txcb_join_style_t = int32

type _xcb_join_style_t = int32

const _XCB_JOIN_STYLE_MITER = 0
const _XCB_JOIN_STYLE_ROUND = 1
const _XCB_JOIN_STYLE_BEVEL = 2

type Txcb_fill_style_t = int32

type _xcb_fill_style_t = int32

const _XCB_FILL_STYLE_SOLID = 0
const _XCB_FILL_STYLE_TILED = 1
const _XCB_FILL_STYLE_STIPPLED = 2
const _XCB_FILL_STYLE_OPAQUE_STIPPLED = 3

type Txcb_fill_rule_t = int32

type _xcb_fill_rule_t = int32

const _XCB_FILL_RULE_EVEN_ODD = 0
const _XCB_FILL_RULE_WINDING = 1

type Txcb_subwindow_mode_t = int32

type _xcb_subwindow_mode_t = int32

const _XCB_SUBWINDOW_MODE_CLIP_BY_CHILDREN = 0
const _XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS = 1

type Txcb_arc_mode_t = int32

type _xcb_arc_mode_t = int32

const _XCB_ARC_MODE_CHORD = 0
const _XCB_ARC_MODE_PIE_SLICE = 1

type Txcb_create_gc_value_list_t = struct {
	Ffunction              Tuint32_t
	Fplane_mask            Tuint32_t
	Fforeground            Tuint32_t
	Fbackground            Tuint32_t
	Fline_width            Tuint32_t
	Fline_style            Tuint32_t
	Fcap_style             Tuint32_t
	Fjoin_style            Tuint32_t
	Ffill_style            Tuint32_t
	Ffill_rule             Tuint32_t
	Ftile                  Txcb_pixmap_t
	Fstipple               Txcb_pixmap_t
	Ftile_stipple_x_origin Tint32_t
	Ftile_stipple_y_origin Tint32_t
	Ffont                  Txcb_font_t
	Fsubwindow_mode        Tuint32_t
	Fgraphics_exposures    Txcb_bool32_t
	Fclip_x_origin         Tint32_t
	Fclip_y_origin         Tint32_t
	Fclip_mask             Txcb_pixmap_t
	Fdash_offset           Tuint32_t
	Fdashes                Tuint32_t
	Farc_mode              Tuint32_t
}

type Txcb_create_gc_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcid          Txcb_gcontext_t
	Fdrawable     Txcb_drawable_t
	Fvalue_mask   Tuint32_t
}

type Txcb_change_gc_value_list_t = struct {
	Ffunction              Tuint32_t
	Fplane_mask            Tuint32_t
	Fforeground            Tuint32_t
	Fbackground            Tuint32_t
	Fline_width            Tuint32_t
	Fline_style            Tuint32_t
	Fcap_style             Tuint32_t
	Fjoin_style            Tuint32_t
	Ffill_style            Tuint32_t
	Ffill_rule             Tuint32_t
	Ftile                  Txcb_pixmap_t
	Fstipple               Txcb_pixmap_t
	Ftile_stipple_x_origin Tint32_t
	Ftile_stipple_y_origin Tint32_t
	Ffont                  Txcb_font_t
	Fsubwindow_mode        Tuint32_t
	Fgraphics_exposures    Txcb_bool32_t
	Fclip_x_origin         Tint32_t
	Fclip_y_origin         Tint32_t
	Fclip_mask             Txcb_pixmap_t
	Fdash_offset           Tuint32_t
	Fdashes                Tuint32_t
	Farc_mode              Tuint32_t
}

type Txcb_change_gc_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fgc           Txcb_gcontext_t
	Fvalue_mask   Tuint32_t
}

type Txcb_copy_gc_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fsrc_gc       Txcb_gcontext_t
	Fdst_gc       Txcb_gcontext_t
	Fvalue_mask   Tuint32_t
}

type Txcb_set_dashes_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fgc           Txcb_gcontext_t
	Fdash_offset  Tuint16_t
	Fdashes_len   Tuint16_t
}

type Txcb_clip_ordering_t = int32

type _xcb_clip_ordering_t = int32

const _XCB_CLIP_ORDERING_UNSORTED = 0
const _XCB_CLIP_ORDERING_Y_SORTED = 1
const _XCB_CLIP_ORDERING_YX_SORTED = 2
const _XCB_CLIP_ORDERING_YX_BANDED = 3

type Txcb_set_clip_rectangles_request_t = struct {
	Fmajor_opcode  Tuint8_t
	Fordering      Tuint8_t
	Flength        Tuint16_t
	Fgc            Txcb_gcontext_t
	Fclip_x_origin Tint16_t
	Fclip_y_origin Tint16_t
}

type Txcb_free_gc_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fgc           Txcb_gcontext_t
}

type Txcb_clear_area_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fexposures    Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
	Fx            Tint16_t
	Fy            Tint16_t
	Fwidth        Tuint16_t
	Fheight       Tuint16_t
}

type Txcb_copy_area_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fsrc_drawable Txcb_drawable_t
	Fdst_drawable Txcb_drawable_t
	Fgc           Txcb_gcontext_t
	Fsrc_x        Tint16_t
	Fsrc_y        Tint16_t
	Fdst_x        Tint16_t
	Fdst_y        Tint16_t
	Fwidth        Tuint16_t
	Fheight       Tuint16_t
}

type Txcb_copy_plane_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fsrc_drawable Txcb_drawable_t
	Fdst_drawable Txcb_drawable_t
	Fgc           Txcb_gcontext_t
	Fsrc_x        Tint16_t
	Fsrc_y        Tint16_t
	Fdst_x        Tint16_t
	Fdst_y        Tint16_t
	Fwidth        Tuint16_t
	Fheight       Tuint16_t
	Fbit_plane    Tuint32_t
}

type Txcb_coord_mode_t = int32

type _xcb_coord_mode_t = int32

const _XCB_COORD_MODE_ORIGIN = 0
const _XCB_COORD_MODE_PREVIOUS = 1

type Txcb_poly_point_request_t = struct {
	Fmajor_opcode    Tuint8_t
	Fcoordinate_mode Tuint8_t
	Flength          Tuint16_t
	Fdrawable        Txcb_drawable_t
	Fgc              Txcb_gcontext_t
}

type Txcb_poly_line_request_t = struct {
	Fmajor_opcode    Tuint8_t
	Fcoordinate_mode Tuint8_t
	Flength          Tuint16_t
	Fdrawable        Txcb_drawable_t
	Fgc              Txcb_gcontext_t
}

type Txcb_segment_t = struct {
	Fx1 Tint16_t
	Fy1 Tint16_t
	Fx2 Tint16_t
	Fy2 Tint16_t
}

type Txcb_segment_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_poly_segment_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fdrawable     Txcb_drawable_t
	Fgc           Txcb_gcontext_t
}

type Txcb_poly_rectangle_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fdrawable     Txcb_drawable_t
	Fgc           Txcb_gcontext_t
}

type Txcb_poly_arc_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fdrawable     Txcb_drawable_t
	Fgc           Txcb_gcontext_t
}

type Txcb_poly_shape_t = int32

type _xcb_poly_shape_t = int32

const _XCB_POLY_SHAPE_COMPLEX = 0
const _XCB_POLY_SHAPE_NONCONVEX = 1
const _XCB_POLY_SHAPE_CONVEX = 2

type Txcb_fill_poly_request_t = struct {
	Fmajor_opcode    Tuint8_t
	Fpad0            Tuint8_t
	Flength          Tuint16_t
	Fdrawable        Txcb_drawable_t
	Fgc              Txcb_gcontext_t
	Fshape           Tuint8_t
	Fcoordinate_mode Tuint8_t
	Fpad1            [2]Tuint8_t
}

type Txcb_poly_fill_rectangle_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fdrawable     Txcb_drawable_t
	Fgc           Txcb_gcontext_t
}

type Txcb_poly_fill_arc_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fdrawable     Txcb_drawable_t
	Fgc           Txcb_gcontext_t
}

type Txcb_image_format_t = int32

type _xcb_image_format_t = int32

const _XCB_IMAGE_FORMAT_XY_BITMAP = 0
const _XCB_IMAGE_FORMAT_XY_PIXMAP = 1
const _XCB_IMAGE_FORMAT_Z_PIXMAP = 2

type Txcb_put_image_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fformat       Tuint8_t
	Flength       Tuint16_t
	Fdrawable     Txcb_drawable_t
	Fgc           Txcb_gcontext_t
	Fwidth        Tuint16_t
	Fheight       Tuint16_t
	Fdst_x        Tint16_t
	Fdst_y        Tint16_t
	Fleft_pad     Tuint8_t
	Fdepth        Tuint8_t
	Fpad0         [2]Tuint8_t
}

type Txcb_get_image_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_image_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fformat       Tuint8_t
	Flength       Tuint16_t
	Fdrawable     Txcb_drawable_t
	Fx            Tint16_t
	Fy            Tint16_t
	Fwidth        Tuint16_t
	Fheight       Tuint16_t
	Fplane_mask   Tuint32_t
}

type Txcb_get_image_reply_t = struct {
	Fresponse_type Tuint8_t
	Fdepth         Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fvisual        Txcb_visualid_t
	Fpad0          [20]Tuint8_t
}

type Txcb_poly_text_8_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fdrawable     Txcb_drawable_t
	Fgc           Txcb_gcontext_t
	Fx            Tint16_t
	Fy            Tint16_t
}

type Txcb_poly_text_16_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fdrawable     Txcb_drawable_t
	Fgc           Txcb_gcontext_t
	Fx            Tint16_t
	Fy            Tint16_t
}

type Txcb_image_text_8_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fstring_len   Tuint8_t
	Flength       Tuint16_t
	Fdrawable     Txcb_drawable_t
	Fgc           Txcb_gcontext_t
	Fx            Tint16_t
	Fy            Tint16_t
}

type Txcb_image_text_16_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fstring_len   Tuint8_t
	Flength       Tuint16_t
	Fdrawable     Txcb_drawable_t
	Fgc           Txcb_gcontext_t
	Fx            Tint16_t
	Fy            Tint16_t
}

type Txcb_colormap_alloc_t = int32

type _xcb_colormap_alloc_t = int32

const _XCB_COLORMAP_ALLOC_NONE = 0
const _XCB_COLORMAP_ALLOC_ALL = 1

type Txcb_create_colormap_request_t = struct {
	Fmajor_opcode Tuint8_t
	Falloc        Tuint8_t
	Flength       Tuint16_t
	Fmid          Txcb_colormap_t
	Fwindow       Txcb_window_t
	Fvisual       Txcb_visualid_t
}

type Txcb_free_colormap_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcmap         Txcb_colormap_t
}

type Txcb_copy_colormap_and_free_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fmid          Txcb_colormap_t
	Fsrc_cmap     Txcb_colormap_t
}

type Txcb_install_colormap_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcmap         Txcb_colormap_t
}

type Txcb_uninstall_colormap_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcmap         Txcb_colormap_t
}

type Txcb_list_installed_colormaps_cookie_t = struct {
	Fsequence uint32
}

type Txcb_list_installed_colormaps_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
}

type Txcb_list_installed_colormaps_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fcmaps_len     Tuint16_t
	Fpad1          [22]Tuint8_t
}

type Txcb_alloc_color_cookie_t = struct {
	Fsequence uint32
}

type Txcb_alloc_color_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcmap         Txcb_colormap_t
	Fred          Tuint16_t
	Fgreen        Tuint16_t
	Fblue         Tuint16_t
	Fpad1         [2]Tuint8_t
}

type Txcb_alloc_color_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fred           Tuint16_t
	Fgreen         Tuint16_t
	Fblue          Tuint16_t
	Fpad1          [2]Tuint8_t
	Fpixel         Tuint32_t
}

type Txcb_alloc_named_color_cookie_t = struct {
	Fsequence uint32
}

type Txcb_alloc_named_color_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcmap         Txcb_colormap_t
	Fname_len     Tuint16_t
	Fpad1         [2]Tuint8_t
}

type Txcb_alloc_named_color_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fpixel         Tuint32_t
	Fexact_red     Tuint16_t
	Fexact_green   Tuint16_t
	Fexact_blue    Tuint16_t
	Fvisual_red    Tuint16_t
	Fvisual_green  Tuint16_t
	Fvisual_blue   Tuint16_t
}

type Txcb_alloc_color_cells_cookie_t = struct {
	Fsequence uint32
}

type Txcb_alloc_color_cells_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fcontiguous   Tuint8_t
	Flength       Tuint16_t
	Fcmap         Txcb_colormap_t
	Fcolors       Tuint16_t
	Fplanes       Tuint16_t
}

type Txcb_alloc_color_cells_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fpixels_len    Tuint16_t
	Fmasks_len     Tuint16_t
	Fpad1          [20]Tuint8_t
}

type Txcb_alloc_color_planes_cookie_t = struct {
	Fsequence uint32
}

type Txcb_alloc_color_planes_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fcontiguous   Tuint8_t
	Flength       Tuint16_t
	Fcmap         Txcb_colormap_t
	Fcolors       Tuint16_t
	Freds         Tuint16_t
	Fgreens       Tuint16_t
	Fblues        Tuint16_t
}

type Txcb_alloc_color_planes_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fpixels_len    Tuint16_t
	Fpad1          [2]Tuint8_t
	Fred_mask      Tuint32_t
	Fgreen_mask    Tuint32_t
	Fblue_mask     Tuint32_t
	Fpad2          [8]Tuint8_t
}

type Txcb_free_colors_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcmap         Txcb_colormap_t
	Fplane_mask   Tuint32_t
}

type Txcb_color_flag_t = int32

type _xcb_color_flag_t = int32

const _XCB_COLOR_FLAG_RED = 1
const _XCB_COLOR_FLAG_GREEN = 2
const _XCB_COLOR_FLAG_BLUE = 4

type Txcb_coloritem_t = struct {
	Fpixel Tuint32_t
	Fred   Tuint16_t
	Fgreen Tuint16_t
	Fblue  Tuint16_t
	Fflags Tuint8_t
	Fpad0  Tuint8_t
}

type Txcb_coloritem_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_store_colors_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcmap         Txcb_colormap_t
}

type Txcb_store_named_color_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fflags        Tuint8_t
	Flength       Tuint16_t
	Fcmap         Txcb_colormap_t
	Fpixel        Tuint32_t
	Fname_len     Tuint16_t
	Fpad0         [2]Tuint8_t
}

type Txcb_rgb_t = struct {
	Fred   Tuint16_t
	Fgreen Tuint16_t
	Fblue  Tuint16_t
	Fpad0  [2]Tuint8_t
}

type Txcb_rgb_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_query_colors_cookie_t = struct {
	Fsequence uint32
}

type Txcb_query_colors_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcmap         Txcb_colormap_t
}

type Txcb_query_colors_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fcolors_len    Tuint16_t
	Fpad1          [22]Tuint8_t
}

type Txcb_lookup_color_cookie_t = struct {
	Fsequence uint32
}

type Txcb_lookup_color_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcmap         Txcb_colormap_t
	Fname_len     Tuint16_t
	Fpad1         [2]Tuint8_t
}

type Txcb_lookup_color_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fexact_red     Tuint16_t
	Fexact_green   Tuint16_t
	Fexact_blue    Tuint16_t
	Fvisual_red    Tuint16_t
	Fvisual_green  Tuint16_t
	Fvisual_blue   Tuint16_t
}

type Txcb_pixmap_enum_t = int32

type _xcb_pixmap_enum_t = int32

const _XCB_PIXMAP_NONE = 0

type Txcb_create_cursor_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcid          Txcb_cursor_t
	Fsource       Txcb_pixmap_t
	Fmask         Txcb_pixmap_t
	Ffore_red     Tuint16_t
	Ffore_green   Tuint16_t
	Ffore_blue    Tuint16_t
	Fback_red     Tuint16_t
	Fback_green   Tuint16_t
	Fback_blue    Tuint16_t
	Fx            Tuint16_t
	Fy            Tuint16_t
}

type Txcb_font_enum_t = int32

type _xcb_font_enum_t = int32

const _XCB_FONT_NONE = 0

type Txcb_create_glyph_cursor_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcid          Txcb_cursor_t
	Fsource_font  Txcb_font_t
	Fmask_font    Txcb_font_t
	Fsource_char  Tuint16_t
	Fmask_char    Tuint16_t
	Ffore_red     Tuint16_t
	Ffore_green   Tuint16_t
	Ffore_blue    Tuint16_t
	Fback_red     Tuint16_t
	Fback_green   Tuint16_t
	Fback_blue    Tuint16_t
}

type Txcb_free_cursor_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcursor       Txcb_cursor_t
}

type Txcb_recolor_cursor_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fcursor       Txcb_cursor_t
	Ffore_red     Tuint16_t
	Ffore_green   Tuint16_t
	Ffore_blue    Tuint16_t
	Fback_red     Tuint16_t
	Fback_green   Tuint16_t
	Fback_blue    Tuint16_t
}

type Txcb_query_shape_of_t = int32

type _xcb_query_shape_of_t = int32

const _XCB_QUERY_SHAPE_OF_LARGEST_CURSOR = 0
const _XCB_QUERY_SHAPE_OF_FASTEST_TILE = 1
const _XCB_QUERY_SHAPE_OF_FASTEST_STIPPLE = 2

type Txcb_query_best_size_cookie_t = struct {
	Fsequence uint32
}

type Txcb_query_best_size_request_t = struct {
	Fmajor_opcode Tuint8_t
	F_class       Tuint8_t
	Flength       Tuint16_t
	Fdrawable     Txcb_drawable_t
	Fwidth        Tuint16_t
	Fheight       Tuint16_t
}

type Txcb_query_best_size_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fwidth         Tuint16_t
	Fheight        Tuint16_t
}

type Txcb_query_extension_cookie_t = struct {
	Fsequence uint32
}

type Txcb_query_extension_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fname_len     Tuint16_t
	Fpad1         [2]Tuint8_t
}

type Txcb_query_extension_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fpresent       Tuint8_t
	Fmajor_opcode  Tuint8_t
	Ffirst_event   Tuint8_t
	Ffirst_error   Tuint8_t
}

type Txcb_list_extensions_cookie_t = struct {
	Fsequence uint32
}

type Txcb_list_extensions_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_list_extensions_reply_t = struct {
	Fresponse_type Tuint8_t
	Fnames_len     Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fpad0          [24]Tuint8_t
}

type Txcb_change_keyboard_mapping_request_t = struct {
	Fmajor_opcode        Tuint8_t
	Fkeycode_count       Tuint8_t
	Flength              Tuint16_t
	Ffirst_keycode       Txcb_keycode_t
	Fkeysyms_per_keycode Tuint8_t
	Fpad0                [2]Tuint8_t
}

type Txcb_get_keyboard_mapping_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_keyboard_mapping_request_t = struct {
	Fmajor_opcode  Tuint8_t
	Fpad0          Tuint8_t
	Flength        Tuint16_t
	Ffirst_keycode Txcb_keycode_t
	Fcount         Tuint8_t
}

type Txcb_get_keyboard_mapping_reply_t = struct {
	Fresponse_type       Tuint8_t
	Fkeysyms_per_keycode Tuint8_t
	Fsequence            Tuint16_t
	Flength              Tuint32_t
	Fpad0                [24]Tuint8_t
}

type Txcb_kb_t = int32

type _xcb_kb_t = int32

const _XCB_KB_KEY_CLICK_PERCENT = 1
const _XCB_KB_BELL_PERCENT = 2
const _XCB_KB_BELL_PITCH = 4
const _XCB_KB_BELL_DURATION = 8
const _XCB_KB_LED = 16
const _XCB_KB_LED_MODE = 32
const _XCB_KB_KEY = 64
const _XCB_KB_AUTO_REPEAT_MODE = 128

type Txcb_led_mode_t = int32

type _xcb_led_mode_t = int32

const _XCB_LED_MODE_OFF = 0
const _XCB_LED_MODE_ON = 1

type Txcb_auto_repeat_mode_t = int32

type _xcb_auto_repeat_mode_t = int32

const _XCB_AUTO_REPEAT_MODE_OFF = 0
const _XCB_AUTO_REPEAT_MODE_ON = 1
const _XCB_AUTO_REPEAT_MODE_DEFAULT = 2

type Txcb_change_keyboard_control_value_list_t = struct {
	Fkey_click_percent Tint32_t
	Fbell_percent      Tint32_t
	Fbell_pitch        Tint32_t
	Fbell_duration     Tint32_t
	Fled               Tuint32_t
	Fled_mode          Tuint32_t
	Fkey               Txcb_keycode32_t
	Fauto_repeat_mode  Tuint32_t
}

type Txcb_change_keyboard_control_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fvalue_mask   Tuint32_t
}

type Txcb_get_keyboard_control_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_keyboard_control_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_get_keyboard_control_reply_t = struct {
	Fresponse_type      Tuint8_t
	Fglobal_auto_repeat Tuint8_t
	Fsequence           Tuint16_t
	Flength             Tuint32_t
	Fled_mask           Tuint32_t
	Fkey_click_percent  Tuint8_t
	Fbell_percent       Tuint8_t
	Fbell_pitch         Tuint16_t
	Fbell_duration      Tuint16_t
	Fpad0               [2]Tuint8_t
	Fauto_repeats       [32]Tuint8_t
}

type Txcb_bell_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpercent      Tint8_t
	Flength       Tuint16_t
}

type Txcb_change_pointer_control_request_t = struct {
	Fmajor_opcode             Tuint8_t
	Fpad0                     Tuint8_t
	Flength                   Tuint16_t
	Facceleration_numerator   Tint16_t
	Facceleration_denominator Tint16_t
	Fthreshold                Tint16_t
	Fdo_acceleration          Tuint8_t
	Fdo_threshold             Tuint8_t
}

type Txcb_get_pointer_control_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_pointer_control_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_get_pointer_control_reply_t = struct {
	Fresponse_type            Tuint8_t
	Fpad0                     Tuint8_t
	Fsequence                 Tuint16_t
	Flength                   Tuint32_t
	Facceleration_numerator   Tuint16_t
	Facceleration_denominator Tuint16_t
	Fthreshold                Tuint16_t
	Fpad1                     [18]Tuint8_t
}

type Txcb_blanking_t = int32

type _xcb_blanking_t = int32

const _XCB_BLANKING_NOT_PREFERRED = 0
const _XCB_BLANKING_PREFERRED = 1
const _XCB_BLANKING_DEFAULT = 2

type Txcb_exposures_t = int32

type _xcb_exposures_t = int32

const _XCB_EXPOSURES_NOT_ALLOWED = 0
const _XCB_EXPOSURES_ALLOWED = 1
const _XCB_EXPOSURES_DEFAULT = 2

type Txcb_set_screen_saver_request_t = struct {
	Fmajor_opcode    Tuint8_t
	Fpad0            Tuint8_t
	Flength          Tuint16_t
	Ftimeout         Tint16_t
	Finterval        Tint16_t
	Fprefer_blanking Tuint8_t
	Fallow_exposures Tuint8_t
}

type Txcb_get_screen_saver_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_screen_saver_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_get_screen_saver_reply_t = struct {
	Fresponse_type   Tuint8_t
	Fpad0            Tuint8_t
	Fsequence        Tuint16_t
	Flength          Tuint32_t
	Ftimeout         Tuint16_t
	Finterval        Tuint16_t
	Fprefer_blanking Tuint8_t
	Fallow_exposures Tuint8_t
	Fpad1            [18]Tuint8_t
}

type Txcb_host_mode_t = int32

type _xcb_host_mode_t = int32

const _XCB_HOST_MODE_INSERT = 0
const _XCB_HOST_MODE_DELETE = 1

type Txcb_family_t = int32

type _xcb_family_t = int32

const _XCB_FAMILY_INTERNET = 0
const _XCB_FAMILY_DECNET = 1
const _XCB_FAMILY_CHAOS = 2
const _XCB_FAMILY_SERVER_INTERPRETED = 5
const _XCB_FAMILY_INTERNET_6 = 6

type Txcb_change_hosts_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fmode         Tuint8_t
	Flength       Tuint16_t
	Ffamily       Tuint8_t
	Fpad0         Tuint8_t
	Faddress_len  Tuint16_t
}

type Txcb_host_t = struct {
	Ffamily      Tuint8_t
	Fpad0        Tuint8_t
	Faddress_len Tuint16_t
}

type Txcb_host_iterator_t = struct {
	Fdata  uintptr
	Frem   int32
	Findex int32
}

type Txcb_list_hosts_cookie_t = struct {
	Fsequence uint32
}

type Txcb_list_hosts_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_list_hosts_reply_t = struct {
	Fresponse_type Tuint8_t
	Fmode          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fhosts_len     Tuint16_t
	Fpad0          [22]Tuint8_t
}

type Txcb_access_control_t = int32

type _xcb_access_control_t = int32

const _XCB_ACCESS_CONTROL_DISABLE = 0
const _XCB_ACCESS_CONTROL_ENABLE = 1

type Txcb_set_access_control_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fmode         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_close_down_t = int32

type _xcb_close_down_t = int32

const _XCB_CLOSE_DOWN_DESTROY_ALL = 0
const _XCB_CLOSE_DOWN_RETAIN_PERMANENT = 1
const _XCB_CLOSE_DOWN_RETAIN_TEMPORARY = 2

type Txcb_set_close_down_mode_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fmode         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_kill_t = int32

type _xcb_kill_t = int32

const _XCB_KILL_ALL_TEMPORARY = 0

type Txcb_kill_client_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fresource     Tuint32_t
}

type Txcb_rotate_properties_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
	Fwindow       Txcb_window_t
	Fatoms_len    Tuint16_t
	Fdelta        Tint16_t
}

type Txcb_screen_saver_t = int32

type _xcb_screen_saver_t = int32

const _XCB_SCREEN_SAVER_RESET = 0
const _XCB_SCREEN_SAVER_ACTIVE = 1

type Txcb_force_screen_saver_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fmode         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_mapping_status_t = int32

type _xcb_mapping_status_t = int32

const _XCB_MAPPING_STATUS_SUCCESS = 0
const _XCB_MAPPING_STATUS_BUSY = 1
const _XCB_MAPPING_STATUS_FAILURE = 2

type Txcb_set_pointer_mapping_cookie_t = struct {
	Fsequence uint32
}

type Txcb_set_pointer_mapping_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fmap_len      Tuint8_t
	Flength       Tuint16_t
}

type Txcb_set_pointer_mapping_reply_t = struct {
	Fresponse_type Tuint8_t
	Fstatus        Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
}

type Txcb_get_pointer_mapping_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_pointer_mapping_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_get_pointer_mapping_reply_t = struct {
	Fresponse_type Tuint8_t
	Fmap_len       Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fpad0          [24]Tuint8_t
}

type Txcb_map_index_t = int32

type _xcb_map_index_t = int32

const _XCB_MAP_INDEX_SHIFT = 0
const _XCB_MAP_INDEX_LOCK = 1
const _XCB_MAP_INDEX_CONTROL = 2
const _XCB_MAP_INDEX_1 = 3
const _XCB_MAP_INDEX_2 = 4
const _XCB_MAP_INDEX_3 = 5
const _XCB_MAP_INDEX_4 = 6
const _XCB_MAP_INDEX_5 = 7

type Txcb_set_modifier_mapping_cookie_t = struct {
	Fsequence uint32
}

type Txcb_set_modifier_mapping_request_t = struct {
	Fmajor_opcode          Tuint8_t
	Fkeycodes_per_modifier Tuint8_t
	Flength                Tuint16_t
}

type Txcb_set_modifier_mapping_reply_t = struct {
	Fresponse_type Tuint8_t
	Fstatus        Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
}

type Txcb_get_modifier_mapping_cookie_t = struct {
	Fsequence uint32
}

type Txcb_get_modifier_mapping_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_get_modifier_mapping_reply_t = struct {
	Fresponse_type         Tuint8_t
	Fkeycodes_per_modifier Tuint8_t
	Fsequence              Tuint16_t
	Flength                Tuint32_t
	Fpad0                  [24]Tuint8_t
}

type Txcb_no_operation_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fpad0         Tuint8_t
	Flength       Tuint16_t
}

type Txcb_auth_info_t = struct {
	Fnamelen int32
	Fname    uintptr
	Fdatalen int32
	Fdata    uintptr
}

type Txcb_big_requests_enable_cookie_t = struct {
	Fsequence uint32
}

type Txcb_big_requests_enable_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fminor_opcode Tuint8_t
	Flength       Tuint16_t
}

type Txcb_big_requests_enable_reply_t = struct {
	Fresponse_type          Tuint8_t
	Fpad0                   Tuint8_t
	Fsequence               Tuint16_t
	Flength                 Tuint32_t
	Fmaximum_request_length Tuint32_t
}

type _workarounds = int32

const _WORKAROUND_NONE = 0
const _WORKAROUND_GLX_GET_FB_CONFIGS_BUG = 1
const _WORKAROUND_EXTERNAL_SOCKET_OWNER = 2

type _lazy_reply_tag = int32

const _LAZY_NONE = 0
const _LAZY_COOKIE = 1
const _LAZY_FORCED = 2

type Txcb_list_free_func_t = uintptr

type T_xcb_fd = struct {
	Ffd  [16]int32
	Fnfd int32
	Fifd int32
}

type T_xcb_out = struct {
	Fcond                       Tpthread_cond_t
	Fwriting                    int32
	Fsocket_cond                Tpthread_cond_t
	Freturn_socket              uintptr
	Fsocket_closure             uintptr
	Fsocket_moving              int32
	Fqueue                      [16384]int8
	Fqueue_len                  int32
	Frequest                    Tuint64_t
	Frequest_written            Tuint64_t
	Frequest_expected_written   Tuint64_t
	Ftotal_written              Tuint64_t
	Freqlenlock                 Tpthread_mutex_t
	Fmaximum_request_length_tag _lazy_reply_tag
	Fmaximum_request_length     struct {
		Fvalue  [0]Tuint32_t
		Fcookie Txcb_big_requests_enable_cookie_t
	}
	Fout_fd T_xcb_fd
}

type T_xcb_in = struct {
	Fevent_cond           Tpthread_cond_t
	Freading              int32
	Fqueue                [4096]int8
	Fqueue_len            int32
	Frequest_expected     Tuint64_t
	Frequest_read         Tuint64_t
	Frequest_completed    Tuint64_t
	Ftotal_read           Tuint64_t
	Fcurrent_reply        uintptr
	Fcurrent_reply_tail   uintptr
	Freplies              uintptr
	Fevents               uintptr
	Fevents_tail          uintptr
	Freaders              uintptr
	Fspecial_waiters      uintptr
	Fpending_replies      uintptr
	Fpending_replies_tail uintptr
	Fin_fd                T_xcb_fd
	Fspecial_events       uintptr
}

type T_xcb_xid = struct {
	Flock Tpthread_mutex_t
	Flast Tuint32_t
	Fbase Tuint32_t
	Fmax  Tuint32_t
	Finc  Tuint32_t
}

type T_xcb_ext = struct {
	Flock            Tpthread_mutex_t
	Fextensions      uintptr
	Fextensions_size int32
}

type Txcb_connection_t1 = struct {
	Fhas_error int32
	Fsetup     uintptr
	Ffd        int32
	Fiolock    Tpthread_mutex_t
	Fin        T_xcb_in
	Fout       T_xcb_out
	Fext       T_xcb_ext
	Fxid       T_xcb_xid
}

type Tnfds_t = uint32

type Tpollfd = struct {
	Ffd      int32
	Fevents  int16
	Frevents int16
}

type Tcrypt_data = struct {
	Finitialized int32
	F__buf       [256]int8
}

type Tsa_family_t = uint8

type Tsocklen_t = uint32

type Tlinger = struct {
	Fl_onoff  int32
	Fl_linger int32
}

type Taccept_filter_arg = struct {
	Faf_name [16]int8
	Faf_arg  [240]int8
}

type Tsockaddr = struct {
	Fsa_len    uint8
	Fsa_family Tsa_family_t
	Fsa_data   [14]int8
}

type Tsockproto = struct {
	Fsp_family   uint16
	Fsp_protocol uint16
}

type Tsockaddr_storage = struct {
	Fss_len     uint8
	Fss_family  Tsa_family_t
	F__ss_pad1  [6]int8
	F__ss_align t__int64_t
	F__ss_pad2  [112]int8
}

type Tmsghdr = struct {
	Fmsg_name       uintptr
	Fmsg_namelen    Tsocklen_t
	Fmsg_iov        uintptr
	Fmsg_iovlen     int32
	Fmsg_control    uintptr
	Fmsg_controllen Tsocklen_t
	Fmsg_flags      int32
}

type Tcmsghdr = struct {
	Fcmsg_len   Tsocklen_t
	Fcmsg_level int32
	Fcmsg_type  int32
}

type Tcmsgcred = struct {
	Fcmcred_pid     Tpid_t
	Fcmcred_uid     Tuid_t
	Fcmcred_euid    Tuid_t
	Fcmcred_gid     Tgid_t
	Fcmcred_ngroups int16
	Fcmcred_groups  [16]Tgid_t
}

type Tsockcred = struct {
	Fsc_uid     Tuid_t
	Fsc_euid    Tuid_t
	Fsc_gid     Tgid_t
	Fsc_egid    Tgid_t
	Fsc_ngroups int32
	Fsc_groups  [1]Tgid_t
}

type Tsockcred2 = struct {
	Fsc_version int32
	Fsc_pid     Tpid_t
	Fsc_uid     Tuid_t
	Fsc_euid    Tuid_t
	Fsc_gid     Tgid_t
	Fsc_egid    Tgid_t
	Fsc_ngroups int32
	Fsc_groups  [1]Tgid_t
}

type Tsock_timestamp_info = struct {
	Fst_info_flags t__uint32_t
	Fst_info_pad0  t__uint32_t
	Fst_info_rsv   [7]t__uint64_t
}

type Tosockaddr = struct {
	Fsa_family uint16
	Fsa_data   [14]int8
}

type Tomsghdr = struct {
	Fmsg_name         uintptr
	Fmsg_namelen      int32
	Fmsg_iov          uintptr
	Fmsg_iovlen       int32
	Fmsg_accrights    uintptr
	Fmsg_accrightslen int32
}

type Tsf_hdtr = struct {
	Fheaders  uintptr
	Fhdr_cnt  int32
	Ftrailers uintptr
	Ftrl_cnt  int32
}

type Tmmsghdr = struct {
	Fmsg_hdr Tmsghdr
	Fmsg_len Tssize_t
}

type Tsplice = struct {
	Fsp_fd   int32
	Fsp_max  Toff_t
	Fsp_idle Ttimeval
}

type Tin_addr = struct {
	Fs_addr Tin_addr_t
}

type Tsockaddr_in = struct {
	Fsin_len    Tuint8_t
	Fsin_family Tsa_family_t
	Fsin_port   Tin_port_t
	Fsin_addr   Tin_addr
	Fsin_zero   [8]int8
}

type Tip_mreq = struct {
	Fimr_multiaddr Tin_addr
	Fimr_interface Tin_addr
}

type Tip_mreqn = struct {
	Fimr_multiaddr Tin_addr
	Fimr_address   Tin_addr
	Fimr_ifindex   int32
}

type Tip_mreq_source = struct {
	Fimr_multiaddr  Tin_addr
	Fimr_sourceaddr Tin_addr
	Fimr_interface  Tin_addr
}

type Tgroup_req = struct {
	Fgr_interface Tuint32_t
	Fgr_group     Tsockaddr_storage
}

type Tgroup_source_req = struct {
	Fgsr_interface Tuint32_t
	Fgsr_group     Tsockaddr_storage
	Fgsr_source    Tsockaddr_storage
}

type t__msfilterreq = struct {
	Fmsfr_ifindex Tuint32_t
	Fmsfr_fmode   Tuint32_t
	Fmsfr_nsrcs   Tuint32_t
	Fmsfr_group   Tsockaddr_storage
	Fmsfr_srcs    uintptr
}

type Tin6_addr = struct {
	F__u6_addr struct {
		F__u6_addr16 [0][8]Tuint16_t
		F__u6_addr32 [0][4]Tuint32_t
		F__u6_addr8  [16]Tuint8_t
	}
}

type Tsockaddr_in6 = struct {
	Fsin6_len      Tuint8_t
	Fsin6_family   Tsa_family_t
	Fsin6_port     Tin_port_t
	Fsin6_flowinfo Tuint32_t
	Fsin6_addr     Tin6_addr
	Fsin6_scope_id Tuint32_t
}

type Troute_in6 = struct {
	Fro_nh      uintptr
	Fro_lle     uintptr
	Fro_prepend uintptr
	Fro_plen    Tuint16_t
	Fro_flags   Tuint16_t
	Fro_mtu     Tuint16_t
	Fspare      Tuint16_t
	Fro_dst     Tsockaddr_in6
}

type Tipv6_mreq = struct {
	Fipv6mr_multiaddr Tin6_addr
	Fipv6mr_interface uint32
}

type Tin6_pktinfo = struct {
	Fipi6_addr    Tin6_addr
	Fipi6_ifindex uint32
}

type Tip6_mtuinfo = struct {
	Fip6m_addr Tsockaddr_in6
	Fip6m_mtu  Tuint32_t
}

/* SHUT_RDWR is fairly recent and is not available on all platforms */

type Txcb_setup_generic_t = struct {
	Fstatus Tuint8_t
	Fpad0   [5]Tuint8_t
	Flength Tuint16_t
}

var _xcb_error_setup = Txcb_setup_t{}

// C documentation
//
//	/* Keep this list in sync with is_static_error_conn()! */
var _xcb_con_error = int32(m_XCB_CONN_ERROR)
var _xcb_con_closed_mem_er = int32(m_XCB_CONN_CLOSED_MEM_INSUFFICIENT)
var _xcb_con_closed_parse_er = int32(m_XCB_CONN_CLOSED_PARSE_ERR)
var _xcb_con_closed_screen_er = int32(m_XCB_CONN_CLOSED_INVALID_SCREEN)

func _is_static_error_conn(tls *libc.TLS, c uintptr) (r int32) {
	return libc.BoolInt32(c == uintptr(unsafe.Pointer(&_xcb_con_error)) || c == uintptr(unsafe.Pointer(&_xcb_con_closed_mem_er)) || c == uintptr(unsafe.Pointer(&_xcb_con_closed_parse_er)) || c == uintptr(unsafe.Pointer(&_xcb_con_closed_screen_er)))
}

func _set_fd_flags(tls *libc.TLS, fd int32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var flags int32
	_ = flags
	/* Win32 doesn't have file descriptors and the fcntl function. This block sets the socket in non-blocking mode */
	flags = libc.Xfcntl(tls, fd, int32(m_F_GETFL), libc.VaList(bp+8, 0))
	if flags == -int32(1) {
		return 0
	}
	flags |= int32(m_O_NONBLOCK)
	if libc.Xfcntl(tls, fd, int32(m_F_SETFL), libc.VaList(bp+8, flags)) == -int32(1) {
		return 0
	}
	if libc.Xfcntl(tls, fd, int32(m_F_SETFD), libc.VaList(bp+8, int32(m_FD_CLOEXEC))) == -int32(1) {
		return 0
	}
	return int32(1)
}

func _write_setup(tls *libc.TLS, c uintptr, auth_info uintptr) (r int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var count, ret, v1, v2, v4, v5, v7, v8 int32
	var v3, v6 Tuint16_t
	var _ /* out at bp+0 */ Txcb_setup_request_t
	var _ /* parts at bp+16 */ [6]Tiovec
	_, _, _, _, _, _, _, _, _, _ = count, ret, v1, v2, v3, v4, v5, v6, v7, v8
	count = 0
	libc.Xmemset(tls, bp, 0, uint64(12))
	/* B = 0x42 = MSB first, l = 0x6c = LSB first */
	if libc.X__builtin_bswap32(tls, _endian) == _endian {
		(*(*Txcb_setup_request_t)(unsafe.Pointer(bp))).Fbyte_order = uint8(0x42)
	} else {
		(*(*Txcb_setup_request_t)(unsafe.Pointer(bp))).Fbyte_order = uint8(0x6c)
	}
	(*(*Txcb_setup_request_t)(unsafe.Pointer(bp))).Fprotocol_major_version = uint16(m_X_PROTOCOL)
	(*(*Txcb_setup_request_t)(unsafe.Pointer(bp))).Fprotocol_minor_version = uint16(m_X_PROTOCOL_REVISION)
	(*(*Txcb_setup_request_t)(unsafe.Pointer(bp))).Fauthorization_protocol_name_len = uint16(0)
	(*(*Txcb_setup_request_t)(unsafe.Pointer(bp))).Fauthorization_protocol_data_len = uint16(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp + 16)))[count].Fiov_len = uint64(12)
	v1 = count
	count++
	(*(*[6]Tiovec)(unsafe.Pointer(bp + 16)))[v1].Fiov_base = bp
	(*(*[6]Tiovec)(unsafe.Pointer(bp + 16)))[count].Fiov_len = -libc.Uint64FromInt64(12) & libc.Uint64FromInt32(3)
	v2 = count
	count++
	(*(*[6]Tiovec)(unsafe.Pointer(bp + 16)))[v2].Fiov_base = uintptr(unsafe.Pointer(&_pad))
	if auth_info != 0 {
		v3 = libc.Uint16FromInt32((*Txcb_auth_info_t)(unsafe.Pointer(auth_info)).Fnamelen)
		(*(*Txcb_setup_request_t)(unsafe.Pointer(bp))).Fauthorization_protocol_name_len = v3
		(*(*[6]Tiovec)(unsafe.Pointer(bp + 16)))[count].Fiov_len = uint64(v3)
		v4 = count
		count++
		(*(*[6]Tiovec)(unsafe.Pointer(bp + 16)))[v4].Fiov_base = (*Txcb_auth_info_t)(unsafe.Pointer(auth_info)).Fname
		(*(*[6]Tiovec)(unsafe.Pointer(bp + 16)))[count].Fiov_len = libc.Uint64FromInt32(-libc.Int32FromUint16((*(*Txcb_setup_request_t)(unsafe.Pointer(bp))).Fauthorization_protocol_name_len) & libc.Int32FromInt32(3))
		v5 = count
		count++
		(*(*[6]Tiovec)(unsafe.Pointer(bp + 16)))[v5].Fiov_base = uintptr(unsafe.Pointer(&_pad))
		v6 = libc.Uint16FromInt32((*Txcb_auth_info_t)(unsafe.Pointer(auth_info)).Fdatalen)
		(*(*Txcb_setup_request_t)(unsafe.Pointer(bp))).Fauthorization_protocol_data_len = v6
		(*(*[6]Tiovec)(unsafe.Pointer(bp + 16)))[count].Fiov_len = uint64(v6)
		v7 = count
		count++
		(*(*[6]Tiovec)(unsafe.Pointer(bp + 16)))[v7].Fiov_base = (*Txcb_auth_info_t)(unsafe.Pointer(auth_info)).Fdata
		(*(*[6]Tiovec)(unsafe.Pointer(bp + 16)))[count].Fiov_len = libc.Uint64FromInt32(-libc.Int32FromUint16((*(*Txcb_setup_request_t)(unsafe.Pointer(bp))).Fauthorization_protocol_data_len) & libc.Int32FromInt32(3))
		v8 = count
		count++
		(*(*[6]Tiovec)(unsafe.Pointer(bp + 16)))[v8].Fiov_base = uintptr(unsafe.Pointer(&_pad))
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	ret = X_xcb_out_send(tls, c, bp+16, count)
	libc.Xpthread_mutex_unlock(tls, c+24)
	return ret
}

var _pad [3]int8

var _endian = uint32(0x01020304)

func _read_setup(tls *libc.TLS, c uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var setup, setup1, tmp uintptr
	var _ /* newline at bp+0 */ int8
	_, _, _ = setup, setup1, tmp
	*(*int8)(unsafe.Pointer(bp)) = int8('\n')
	/* Read the server response */
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup = libc.Xmalloc(tls, uint64(8))
	if !((*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup != 0) {
		return 0
	}
	if libc.Uint64FromInt32(X_xcb_in_read_block(tls, c, (*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup, int32(8))) != uint64(8) {
		return 0
	}
	tmp = libc.Xrealloc(tls, (*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup, libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_setup_t)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup)).Flength)*int32(4))+uint64(8))
	if !(tmp != 0) {
		return 0
	}
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup = tmp
	if X_xcb_in_read_block(tls, c, (*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup+uintptr(8), libc.Int32FromUint16((*Txcb_setup_t)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup)).Flength)*int32(4)) <= 0 {
		return 0
	}
	/* 0 = failed, 2 = authenticate, 1 = success */
	switch libc.Int32FromUint8((*Txcb_setup_t)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup)).Fstatus) {
	case 0: /* failed */
		setup = (*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup
		libc.Xwrite(tls, int32(m_STDERR_FILENO), Xxcb_setup_failed_reason(tls, setup), libc.Uint64FromInt32(Xxcb_setup_failed_reason_length(tls, setup)))
		libc.Xwrite(tls, int32(m_STDERR_FILENO), bp, uint64(1))
		return 0
	case int32(2): /* authenticate */
		setup1 = (*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup
		libc.Xwrite(tls, int32(m_STDERR_FILENO), Xxcb_setup_authenticate_reason(tls, setup1), libc.Uint64FromInt32(Xxcb_setup_authenticate_reason_length(tls, setup1)))
		libc.Xwrite(tls, int32(m_STDERR_FILENO), bp, uint64(1))
		return 0
	}
	return int32(1)
}

// C documentation
//
//	/* precondition: there must be something for us to write. */
func _write_vec(tls *libc.TLS, c uintptr, vector uintptr, count uintptr) (r int32) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var cur, i, n int32
	var hdr, v1 uintptr
	var _ /* cmsgbuf at bp+0 */ struct {
		Fbuf         [0][80]int8
		Fcmsghdr     Tcmsghdr
		F__ccgo_pad2 [68]byte
	}
	var _ /* msg at bp+80 */ Tmsghdr
	_, _, _, _, _ = cur, hdr, i, n, v1
	n = *(*int32)(unsafe.Pointer(count))
	if n > int32(m_IOV_MAX) {
		n = int32(m_IOV_MAX)
	}
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fout_fd.Fnfd != 0 {
		*(*Tmsghdr)(unsafe.Pointer(bp + 80)) = Tmsghdr{
			Fmsg_iov:        *(*uintptr)(unsafe.Pointer(vector)),
			Fmsg_iovlen:     n,
			Fmsg_control:    bp,
			Fmsg_controllen: uint32((libc.Uint64FromInt64(12)+(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1))) & ^(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1)) + libc.Uint64FromInt32((*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fout_fd.Fnfd)*libc.Uint64FromInt64(4)),
		}
		if uint64((*Tmsghdr)(unsafe.Pointer(bp+80)).Fmsg_controllen) >= uint64(12) {
			v1 = (*Tmsghdr)(unsafe.Pointer(bp + 80)).Fmsg_control
		} else {
			v1 = libc.UintptrFromInt32(0)
		}
		hdr = v1
		(*Tcmsghdr)(unsafe.Pointer(hdr)).Fcmsg_len = (*(*Tmsghdr)(unsafe.Pointer(bp + 80))).Fmsg_controllen
		(*Tcmsghdr)(unsafe.Pointer(hdr)).Fcmsg_level = int32(m_SOL_SOCKET)
		(*Tcmsghdr)(unsafe.Pointer(hdr)).Fcmsg_type = int32(m_SCM_RIGHTS)
		libc.Xmemcpy(tls, hdr+uintptr((libc.Uint64FromInt64(12)+(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1))) & ^(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1))), c+4328+16480, libc.Uint64FromInt32((*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fout_fd.Fnfd)*uint64(4))
		n = int32(libc.Xsendmsg(tls, (*Txcb_connection_t)(unsafe.Pointer(c)).Ffd, bp+80, 0))
		if n < 0 && *(*int32)(unsafe.Pointer(libc.X__error(tls))) == int32(m_EAGAIN) {
			return int32(1)
		}
		i = 0
		for {
			if !(i < (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fout_fd.Fnfd) {
				break
			}
			libc.Xclose(tls, *(*int32)(unsafe.Pointer(c + 4328 + 16480 + uintptr(i)*4)))
			goto _2
		_2:
			;
			i++
		}
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fout_fd.Fnfd = 0
	} else {
		n = int32(libc.Xwritev(tls, (*Txcb_connection_t)(unsafe.Pointer(c)).Ffd, *(*uintptr)(unsafe.Pointer(vector)), n))
		if n < 0 && *(*int32)(unsafe.Pointer(libc.X__error(tls))) == int32(m_EAGAIN) {
			return int32(1)
		}
	}
	if n <= 0 {
		X_xcb_conn_shutdown(tls, c, int32(m_XCB_CONN_ERROR))
		return 0
	}
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Ftotal_written += libc.Uint64FromInt32(n)
	for {
		if !(*(*int32)(unsafe.Pointer(count)) != 0) {
			break
		}
		cur = libc.Int32FromUint64((*Tiovec)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(vector)))).Fiov_len)
		if cur > n {
			cur = n
		}
		if cur != 0 {
			*(*Tsize_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(vector)) + 8)) -= libc.Uint64FromInt32(cur)
			(*Tiovec)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(vector)))).Fiov_base = (*Tiovec)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(vector)))).Fiov_base + uintptr(cur)
			n -= cur
		}
		if (*Tiovec)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(vector)))).Fiov_len != 0 {
			break
		}
		goto _3
	_3:
		;
		*(*int32)(unsafe.Pointer(count))--
		*(*uintptr)(unsafe.Pointer(vector)) += 16
	}
	if !(*(*int32)(unsafe.Pointer(count)) != 0) {
		*(*uintptr)(unsafe.Pointer(vector)) = uintptr(0)
	}
	return int32(1)
}

/* Public interface */

func Xxcb_get_setup(tls *libc.TLS, c uintptr) (r uintptr) {
	if _is_static_error_conn(tls, c) != 0 {
		return uintptr(unsafe.Pointer(&_xcb_error_setup))
	}
	/* doesn't need locking because it's never written to. */
	return (*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup
}

func Xxcb_get_file_descriptor(tls *libc.TLS, c uintptr) (r int32) {
	if _is_static_error_conn(tls, c) != 0 {
		return -int32(1)
	}
	/* doesn't need locking because it's never written to. */
	return (*Txcb_connection_t)(unsafe.Pointer(c)).Ffd
}

func Xxcb_connection_has_error(tls *libc.TLS, c uintptr) (r int32) {
	/* doesn't need locking because it's read and written atomically. */
	return (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error
}

func Xxcb_connect_to_fd(tls *libc.TLS, fd int32, auth_info uintptr) (r uintptr) {
	var c uintptr
	_ = c
	c = libc.Xcalloc(tls, uint64(1), uint64(20928))
	if !(c != 0) {
		libc.Xclose(tls, fd)
		return X_xcb_conn_ret_error(tls, int32(m_XCB_CONN_CLOSED_MEM_INSUFFICIENT))
	}
	(*Txcb_connection_t)(unsafe.Pointer(c)).Ffd = fd
	if !(_set_fd_flags(tls, fd) != 0 && libc.Xpthread_mutex_init(tls, c+24, uintptr(0)) == 0 && X_xcb_in_init(tls, c+32) != 0 && X_xcb_out_init(tls, c+4328) != 0 && _write_setup(tls, c, auth_info) != 0 && _read_setup(tls, c) != 0 && X_xcb_ext_init(tls, c) != 0 && X_xcb_xid_init(tls, c) != 0) {
		Xxcb_disconnect(tls, c)
		return X_xcb_conn_ret_error(tls, int32(m_XCB_CONN_ERROR))
	}
	return c
}

func Xxcb_disconnect(tls *libc.TLS, c uintptr) {
	if c == libc.UintptrFromInt32(0) || _is_static_error_conn(tls, c) != 0 {
		return
	}
	libc.Xfree(tls, (*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup)
	/* disallow further sends and receives */
	libc.Xshutdown(tls, (*Txcb_connection_t)(unsafe.Pointer(c)).Ffd, int32(m_SHUT_RDWR))
	libc.Xclose(tls, (*Txcb_connection_t)(unsafe.Pointer(c)).Ffd)
	libc.Xpthread_mutex_destroy(tls, c+24)
	X_xcb_in_destroy(tls, c+32)
	X_xcb_out_destroy(tls, c+4328)
	X_xcb_ext_destroy(tls, c)
	X_xcb_xid_destroy(tls, c)
	libc.Xfree(tls, c)
}

/* Private interface */

func X_xcb_conn_shutdown(tls *libc.TLS, c uintptr, err int32) {
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error = err
}

// C documentation
//
//	/* Return connection error state.
//	 * To make thread-safe, I need a seperate static
//	 * variable for every possible error.
//	 * has_error is the first field in xcb_connection_t, so just
//	 * return a casted int here; checking has_error (and only
//	 * has_error) will be safe.
//	 */
func X_xcb_conn_ret_error(tls *libc.TLS, err int32) (r uintptr) {
	switch err {
	case int32(m_XCB_CONN_CLOSED_MEM_INSUFFICIENT):
		return uintptr(unsafe.Pointer(&_xcb_con_closed_mem_er))
	case int32(m_XCB_CONN_CLOSED_PARSE_ERR):
		return uintptr(unsafe.Pointer(&_xcb_con_closed_parse_er))
	case int32(m_XCB_CONN_CLOSED_INVALID_SCREEN):
		return uintptr(unsafe.Pointer(&_xcb_con_closed_screen_er))
	case int32(m_XCB_CONN_ERROR):
		fallthrough
	default:
		return uintptr(unsafe.Pointer(&_xcb_con_error))
	}
	return r
}

func X_xcb_conn_wait(tls *libc.TLS, c uintptr, cond uintptr, vector uintptr, count uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var may_read, ret, v1 int32
	var p2 uintptr
	var _ /* fd at bp+0 */ Tpollfd
	_, _, _, _ = may_read, ret, v1, p2
	/* If the thing I should be doing is already being done, wait for it. */
	if count != 0 {
		v1 = (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fwriting
	} else {
		v1 = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freading
	}
	if v1 != 0 {
		libc.Xpthread_cond_wait(tls, cond, c+24)
		return int32(1)
	}
	libc.Xmemset(tls, bp, 0, uint64(8))
	(*(*Tpollfd)(unsafe.Pointer(bp))).Ffd = (*Txcb_connection_t)(unsafe.Pointer(c)).Ffd
	(*(*Tpollfd)(unsafe.Pointer(bp))).Fevents = int16(m_POLLIN)
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freading++
	if count != 0 {
		p2 = bp + 4
		*(*int16)(unsafe.Pointer(p2)) = int16(int32(*(*int16)(unsafe.Pointer(p2))) | libc.Int32FromInt32(m_POLLOUT))
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fwriting++
	}
	libc.Xpthread_mutex_unlock(tls, c+24)
	for cond1 := true; cond1; cond1 = ret == -int32(1) && *(*int32)(unsafe.Pointer(libc.X__error(tls))) == int32(m_EINTR) {
		ret = libc.Xpoll(tls, bp, uint32(1), -int32(1))
		/* If poll() returns an event we didn't expect, such as POLLNVAL, treat
		 * it as if it failed. */
		if ret >= 0 && int32((*(*Tpollfd)(unsafe.Pointer(bp))).Frevents) & ^int32((*(*Tpollfd)(unsafe.Pointer(bp))).Fevents) != 0 {
			ret = -int32(1)
			break
		}
	}
	if ret < 0 {
		X_xcb_conn_shutdown(tls, c, int32(m_XCB_CONN_ERROR))
		ret = 0
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	if ret != 0 {
		/* The code allows two threads to call select()/poll() at the same time.
		 * First thread just wants to read, a second thread wants to write, too.
		 * We have to make sure that we don't steal the reading thread's reply
		 * and let it get stuck in select()/poll().
		 * So a thread may read if either:
		 * - There is no other thread that wants to read (the above situation
		 *   did not occur).
		 * - It is the reading thread (above situation occurred).
		 */
		may_read = libc.BoolInt32((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freading == int32(1) || !(count != 0))
		if may_read != 0 && int32((*(*Tpollfd)(unsafe.Pointer(bp))).Frevents)&int32(m_POLLIN) != 0 {
			ret = libc.BoolInt32(ret != 0 && X_xcb_in_read(tls, c) != 0)
		}
		if int32((*(*Tpollfd)(unsafe.Pointer(bp))).Frevents)&int32(m_POLLOUT) != 0 {
			ret = libc.BoolInt32(ret != 0 && _write_vec(tls, c, vector, count) != 0)
		}
	}
	if count != 0 {
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fwriting--
	}
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freading--
	return ret
}

func Xxcb_total_read(tls *libc.TLS, c uintptr) (r Tuint64_t) {
	var n Tuint64_t
	_ = n
	if Xxcb_connection_has_error(tls, c) != 0 {
		return uint64(0)
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	n = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Ftotal_read
	libc.Xpthread_mutex_unlock(tls, c+24)
	return n
}

func Xxcb_total_written(tls *libc.TLS, c uintptr) (r Tuint64_t) {
	var n Tuint64_t
	_ = n
	if Xxcb_connection_has_error(tls, c) != 0 {
		return uint64(0)
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	n = (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Ftotal_written
	libc.Xpthread_mutex_unlock(tls, c+24)
	return n
}

type Txcb_extension_t = struct {
	Fname      uintptr
	Fglobal_id int32
}

type Txcb_extension_t1 = struct {
	Fname      uintptr
	Fglobal_id int32
}

type Txcb_protocol_request_t = struct {
	Fcount  Tsize_t
	Fext    uintptr
	Fopcode Tuint8_t
	Fisvoid Tuint8_t
}

type _xcb_send_request_flags_t = int32

const _XCB_REQUEST_CHECKED = 1
const _XCB_REQUEST_RAW = 2
const _XCB_REQUEST_DISCARD_REPLY = 4
const _XCB_REQUEST_REPLY_FDS = 8

/*
 * This file generated automatically from bigreq.xml by c_client.py.
 * Edit at your peril.
 */

/**
 * @defgroup XCB_BigRequests_API XCB BigRequests API
 * @brief BigRequests XCB Protocol Implementation.
 * @{
 **/

/**
 * @}
 */

func _send_request(tls *libc.TLS, c uintptr, isvoid int32, workaround _workarounds, flags int32, vector uintptr, count int32) {
	var p1 uintptr
	_ = p1
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return
	}
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest++
	if !(isvoid != 0) {
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_expected = (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest
	}
	if workaround != int32(_WORKAROUND_NONE) || flags != 0 {
		X_xcb_in_expect_reply(tls, c, (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest, workaround, flags)
	}
	for count != 0 && libc.Uint64FromInt32((*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fqueue_len)+(*(*Tiovec)(unsafe.Pointer(vector))).Fiov_len <= uint64(16384) {
		libc.Xmemcpy(tls, c+4328+44+uintptr((*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fqueue_len), (*(*Tiovec)(unsafe.Pointer(vector))).Fiov_base, (*(*Tiovec)(unsafe.Pointer(vector))).Fiov_len)
		p1 = c + 4328 + 16428
		*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + (*(*Tiovec)(unsafe.Pointer(vector))).Fiov_len)
		(*(*Tiovec)(unsafe.Pointer(vector))).Fiov_base = (*(*Tiovec)(unsafe.Pointer(vector))).Fiov_base + uintptr((*(*Tiovec)(unsafe.Pointer(vector))).Fiov_len)
		(*(*Tiovec)(unsafe.Pointer(vector))).Fiov_len = uint64(0)
		vector += 16
		count--
	}
	if !(count != 0) {
		return
	}
	vector -= 16
	count++
	(*(*Tiovec)(unsafe.Pointer(vector))).Fiov_base = c + 4328 + 44
	(*(*Tiovec)(unsafe.Pointer(vector))).Fiov_len = libc.Uint64FromInt32((*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fqueue_len)
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fqueue_len = 0
	X_xcb_out_send(tls, c, vector, count)
}

func _send_sync(tls *libc.TLS, c uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* vector at bp+0 */ [2]Tiovec
	(*(*[2]Tiovec)(unsafe.Pointer(bp)))[int32(1)].Fiov_base = uintptr(unsafe.Pointer(&_sync_req))
	(*(*[2]Tiovec)(unsafe.Pointer(bp)))[int32(1)].Fiov_len = uint64(4)
	_send_request(tls, c, 0, int32(_WORKAROUND_NONE), int32(_XCB_REQUEST_DISCARD_REPLY), bp+uintptr(1)*16, int32(1))
}

var _sync_req = *(*struct {
	Fpacket [0]Tuint32_t
	Ffields struct {
		Fmajor Tuint8_t
		Fpad   Tuint8_t
		Flen1  Tuint16_t
	}
})(unsafe.Pointer(&struct {
	Fmajor uint8
	Fpad   uint8
	Flen1  uint16
}{
	Fmajor: uint8(43),
	Flen1:  uint16(1),
}))

func _get_socket_back(tls *libc.TLS, c uintptr) {
	for (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Freturn_socket != 0 && (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fsocket_moving != 0 {
		libc.Xpthread_cond_wait(tls, c+4328+16, c+24)
	}
	if !((*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Freturn_socket != 0) {
		return
	}
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fsocket_moving = int32(1)
	libc.Xpthread_mutex_unlock(tls, c+24)
	(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Freturn_socket})))(tls, (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fsocket_closure)
	libc.Xpthread_mutex_lock(tls, c+24)
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fsocket_moving = 0
	libc.Xpthread_cond_broadcast(tls, c+4328+16)
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Freturn_socket = uintptr(0)
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fsocket_closure = uintptr(0)
	X_xcb_in_replies_done(tls, c)
}

func _prepare_socket_request(tls *libc.TLS, c uintptr) {
	/* We're about to append data to out.queue, so we need to
	 * atomically test for an external socket owner *and* some other
	 * thread currently writing.
	 *
	 * If we have an external socket owner, we have to get the socket back
	 * before we can use it again.
	 *
	 * If some other thread is writing to the socket, we assume it's
	 * writing from out.queue, and so we can't stick data there.
	 *
	 * We satisfy this condition by first calling get_socket_back
	 * (which may drop the lock, but will return when XCB owns the
	 * socket again) and then checking for another writing thread and
	 * escaping the loop if we're ready to go.
	 */
	for {
		if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
			return
		}
		_get_socket_back(tls, c)
		if !((*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fwriting != 0) {
			break
		}
		libc.Xpthread_cond_wait(tls, c+4328, c+24)
		goto _1
	_1:
	}
}

/* Public interface */

func Xxcb_prefetch_maximum_request_length(tls *libc.TLS, c uintptr) {
	var ext uintptr
	_ = ext
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return
	}
	libc.Xpthread_mutex_lock(tls, c+4328+16464)
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fmaximum_request_length_tag == int32(_LAZY_NONE) {
		ext = Xxcb_get_extension_data(tls, c, uintptr(unsafe.Pointer(&Xxcb_big_requests_id)))
		if ext != 0 && (*Txcb_query_extension_reply_t)(unsafe.Pointer(ext)).Fpresent != 0 {
			(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fmaximum_request_length_tag = int32(_LAZY_COOKIE)
			*(*Txcb_big_requests_enable_cookie_t)(unsafe.Pointer(c + 4328 + 16476)) = Xxcb_big_requests_enable(tls, c)
		} else {
			(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fmaximum_request_length_tag = int32(_LAZY_FORCED)
			*(*Tuint32_t)(unsafe.Pointer(c + 4328 + 16476)) = uint32((*Txcb_setup_t)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup)).Fmaximum_request_length)
		}
	}
	libc.Xpthread_mutex_unlock(tls, c+4328+16464)
}

func Xxcb_get_maximum_request_length(tls *libc.TLS, c uintptr) (r1 Tuint32_t) {
	var r uintptr
	_ = r
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return uint32(0)
	}
	Xxcb_prefetch_maximum_request_length(tls, c)
	libc.Xpthread_mutex_lock(tls, c+4328+16464)
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fmaximum_request_length_tag == int32(_LAZY_COOKIE) {
		r = Xxcb_big_requests_enable_reply(tls, c, *(*Txcb_big_requests_enable_cookie_t)(unsafe.Pointer(c + 4328 + 16476)), uintptr(0))
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fmaximum_request_length_tag = int32(_LAZY_FORCED)
		if r != 0 {
			*(*Tuint32_t)(unsafe.Pointer(c + 4328 + 16476)) = (*Txcb_big_requests_enable_reply_t)(unsafe.Pointer(r)).Fmaximum_request_length
			libc.Xfree(tls, r)
		} else {
			*(*Tuint32_t)(unsafe.Pointer(c + 4328 + 16476)) = uint32((*Txcb_setup_t)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup)).Fmaximum_request_length)
		}
	}
	libc.Xpthread_mutex_unlock(tls, c+4328+16464)
	return *(*Tuint32_t)(unsafe.Pointer(c + 4328 + 16476))
}

func _close_fds(tls *libc.TLS, fds uintptr, num_fds uint32) {
	var index uint32
	_ = index
	index = uint32(0)
	for {
		if !(index < num_fds) {
			break
		}
		libc.Xclose(tls, *(*int32)(unsafe.Pointer(fds + uintptr(index)*4)))
		goto _1
	_1:
		;
		index++
	}
}

func _send_fds(tls *libc.TLS, c uintptr, fds uintptr, num_fds uint32) {
	var v1 int32
	var v2 uintptr
	_, _ = v1, v2
	/* Calling _xcb_out_flush_to() can drop the iolock and wait on a condition
	 * variable if another thread is currently writing (c->out.writing > 0).
	 * This call waits for writers to be done and thus _xcb_out_flush_to() will
	 * do the work itself (in which case we are a writer and
	 * prepare_socket_request() will wait for us to be done if another threads
	 * tries to send fds, too). Thanks to this, we can atomically write out FDs.
	 */
	_prepare_socket_request(tls, c)
	for num_fds > uint32(0) {
		for (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fout_fd.Fnfd == int32(m_XCB_MAX_PASS_FD) && !((*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0) {
			/* XXX: if c->out.writing > 0, this releases the iolock and
			 * potentially allows other threads to interfere with their own fds.
			 */
			X_xcb_out_flush_to(tls, c, (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest)
			if (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fout_fd.Fnfd == int32(m_XCB_MAX_PASS_FD) {
				/* We need some request to send FDs with */
				X_xcb_out_send_sync(tls, c)
			}
		}
		if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
			break
		}
		v2 = c + 4328 + 16480 + 64
		v1 = *(*int32)(unsafe.Pointer(v2))
		*(*int32)(unsafe.Pointer(v2))++
		*(*int32)(unsafe.Pointer(c + 4328 + 16480 + uintptr(v1)*4)) = *(*int32)(unsafe.Pointer(fds))
		fds += 4
		num_fds--
	}
	_close_fds(tls, fds, num_fds)
}

func Xxcb_send_request_with_fds64(tls *libc.TLS, c uintptr, flags int32, vector uintptr, req uintptr, num_fds uint32, fds uintptr) (r Tuint64_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var extension uintptr
	var i uint32
	var longlen, v2 Tsize_t
	var request Tuint64_t
	var shortlen Tuint16_t
	var veclen int32
	var workaround _workarounds
	var v3 uint64
	var _ /* prefix at bp+0 */ [2]Tuint32_t
	_, _, _, _, _, _, _, _, _ = extension, i, longlen, request, shortlen, veclen, workaround, v2, v3
	veclen = libc.Int32FromUint64((*Txcb_protocol_request_t)(unsafe.Pointer(req)).Fcount)
	workaround = int32(_WORKAROUND_NONE)
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		_close_fds(tls, fds, num_fds)
		return uint64(0)
	}
	if !(flags&int32(_XCB_REQUEST_RAW) != 0) {
		shortlen = uint16(0)
		longlen = uint64(0)
		/* set the major opcode, and the minor opcode for extensions */
		if (*Txcb_protocol_request_t)(unsafe.Pointer(req)).Fext != 0 {
			extension = Xxcb_get_extension_data(tls, c, (*Txcb_protocol_request_t)(unsafe.Pointer(req)).Fext)
			if !(extension != 0 && (*Txcb_query_extension_reply_t)(unsafe.Pointer(extension)).Fpresent != 0) {
				_close_fds(tls, fds, num_fds)
				X_xcb_conn_shutdown(tls, c, int32(m_XCB_CONN_CLOSED_EXT_NOTSUPPORTED))
				return uint64(0)
			}
			*(*Tuint8_t)(unsafe.Pointer((*(*Tiovec)(unsafe.Pointer(vector))).Fiov_base)) = (*Txcb_query_extension_reply_t)(unsafe.Pointer(extension)).Fmajor_opcode
			*(*Tuint8_t)(unsafe.Pointer((*(*Tiovec)(unsafe.Pointer(vector))).Fiov_base + 1)) = (*Txcb_protocol_request_t)(unsafe.Pointer(req)).Fopcode
		} else {
			*(*Tuint8_t)(unsafe.Pointer((*(*Tiovec)(unsafe.Pointer(vector))).Fiov_base)) = (*Txcb_protocol_request_t)(unsafe.Pointer(req)).Fopcode
		}
		/* put together the length field, possibly using BIGREQUESTS */
		i = uint32(0)
		for {
			if !(uint64(i) < (*Txcb_protocol_request_t)(unsafe.Pointer(req)).Fcount) {
				break
			}
			longlen += (*(*Tiovec)(unsafe.Pointer(vector + uintptr(i)*16))).Fiov_len
			if !((*(*Tiovec)(unsafe.Pointer(vector + uintptr(i)*16))).Fiov_base != 0) {
				(*(*Tiovec)(unsafe.Pointer(vector + uintptr(i)*16))).Fiov_base = uintptr(unsafe.Pointer(&_pad1))
			}
			goto _1
		_1:
			;
			i++
		}
		longlen >>= uint64(2)
		if longlen <= uint64((*Txcb_setup_t)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup)).Fmaximum_request_length) {
			/* we don't need BIGREQUESTS. */
			shortlen = uint16(longlen)
			longlen = uint64(0)
		} else {
			if longlen > uint64(Xxcb_get_maximum_request_length(tls, c)) {
				_close_fds(tls, fds, num_fds)
				X_xcb_conn_shutdown(tls, c, int32(m_XCB_CONN_CLOSED_REQ_LEN_EXCEED))
				return uint64(0) /* server can't take this; maybe need BIGREQUESTS? */
			}
		}
		/* set the length field. */
		*(*Tuint16_t)(unsafe.Pointer((*(*Tiovec)(unsafe.Pointer(vector))).Fiov_base + 1*2)) = shortlen
		if !(shortlen != 0) {
			(*(*[2]Tuint32_t)(unsafe.Pointer(bp)))[0] = *(*Tuint32_t)(unsafe.Pointer((*(*Tiovec)(unsafe.Pointer(vector))).Fiov_base))
			longlen++
			v2 = longlen
			(*(*[2]Tuint32_t)(unsafe.Pointer(bp)))[int32(1)] = uint32(v2)
			(*(*Tiovec)(unsafe.Pointer(vector))).Fiov_base = (*(*Tiovec)(unsafe.Pointer(vector))).Fiov_base + uintptr(1)*4
			(*(*Tiovec)(unsafe.Pointer(vector))).Fiov_len -= uint64(4)
			vector -= 16
			veclen++
			(*(*Tiovec)(unsafe.Pointer(vector))).Fiov_base = bp
			(*(*Tiovec)(unsafe.Pointer(vector))).Fiov_len = uint64(8)
		}
	}
	flags &= ^int32(_XCB_REQUEST_RAW)
	/* do we need to work around the X server bug described in glx.xml? */
	/* XXX: GetFBConfigs won't use BIG-REQUESTS in any sane
	 * configuration, but that should be handled here anyway. */
	if (*Txcb_protocol_request_t)(unsafe.Pointer(req)).Fext != 0 && !((*Txcb_protocol_request_t)(unsafe.Pointer(req)).Fisvoid != 0) && !(libc.Xstrcmp(tls, (*Txcb_extension_t)(unsafe.Pointer((*Txcb_protocol_request_t)(unsafe.Pointer(req)).Fext)).Fname, __ccgo_ts) != 0) && (libc.Int32FromUint8((*Txcb_protocol_request_t)(unsafe.Pointer(req)).Fopcode) == int32(17) && *(*Tuint32_t)(unsafe.Pointer((*(*Tiovec)(unsafe.Pointer(vector))).Fiov_base + 1*4)) == uint32(0x10004) || libc.Int32FromUint8((*Txcb_protocol_request_t)(unsafe.Pointer(req)).Fopcode) == int32(21)) {
		workaround = int32(_WORKAROUND_GLX_GET_FB_CONFIGS_BUG)
	}
	/* get a sequence number and arrange for delivery. */
	libc.Xpthread_mutex_lock(tls, c+24)
	/* send FDs before establishing a good request number, because this might
	 * call send_sync(), too
	 */
	_send_fds(tls, c, fds, num_fds)
	_prepare_socket_request(tls, c)
	/* send GetInputFocus (sync_req) when 64k-2 requests have been sent without
	 * a reply.
	 * Also send sync_req (could use NoOp) at 32-bit wrap to avoid having
	 * applications see sequence 0 as that is used to indicate
	 * an error in sending the request
	 */
	for (*Txcb_protocol_request_t)(unsafe.Pointer(req)).Fisvoid != 0 && (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest == (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_expected+libc.Uint64FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(16))-uint64(2) || uint32((*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest+libc.Uint64FromInt32(1)) == uint32(0) {
		_send_sync(tls, c)
		_prepare_socket_request(tls, c)
	}
	_send_request(tls, c, libc.Int32FromUint8((*Txcb_protocol_request_t)(unsafe.Pointer(req)).Fisvoid), workaround, flags, vector, veclen)
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		v3 = uint64(0)
	} else {
		v3 = (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest
	}
	request = v3
	libc.Xpthread_mutex_unlock(tls, c+24)
	return request
}

var _pad1 [3]int8

// C documentation
//
//	/* request number are actually uint64_t internally but keep API compat with unsigned int */
func Xxcb_send_request_with_fds(tls *libc.TLS, c uintptr, flags int32, vector uintptr, req uintptr, num_fds uint32, fds uintptr) (r uint32) {
	return uint32(Xxcb_send_request_with_fds64(tls, c, flags, vector, req, num_fds, fds))
}

func Xxcb_send_request64(tls *libc.TLS, c uintptr, flags int32, vector uintptr, req uintptr) (r Tuint64_t) {
	return Xxcb_send_request_with_fds64(tls, c, flags, vector, req, uint32(0), libc.UintptrFromInt32(0))
}

// C documentation
//
//	/* request number are actually uint64_t internally but keep API compat with unsigned int */
func Xxcb_send_request(tls *libc.TLS, c uintptr, flags int32, vector uintptr, req uintptr) (r uint32) {
	return uint32(Xxcb_send_request64(tls, c, flags, vector, req))
}

func Xxcb_send_fd(tls *libc.TLS, c uintptr, fd int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* fds at bp+0 */ [1]int32
	*(*[1]int32)(unsafe.Pointer(bp)) = [1]int32{
		0: fd,
	}
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		libc.Xclose(tls, fd)
		return
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	_send_fds(tls, c, bp, uint32(1))
	libc.Xpthread_mutex_unlock(tls, c+24)
}

func Xxcb_take_socket(tls *libc.TLS, c uintptr, return_socket uintptr, closure uintptr, flags int32, sent uintptr) (r int32) {
	var ret int32
	_ = ret
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return 0
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	_get_socket_back(tls, c)
	/* _xcb_out_flush may drop the iolock allowing other threads to
	 * write requests, so keep flushing until we're done
	 */
	for cond := true; cond; cond = ret != 0 && (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest != (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest_written {
		ret = X_xcb_out_flush_to(tls, c, (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest)
	}
	if ret != 0 {
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Freturn_socket = return_socket
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fsocket_closure = closure
		if flags != 0 {
			/* c->out.request + 1 will be the first request sent by the external
			 * socket owner. If the socket is returned before this request is sent
			 * it will be detected in _xcb_in_replies_done and this pending_reply
			 * will be discarded.
			 */
			X_xcb_in_expect_reply(tls, c, (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest+uint64(1), int32(_WORKAROUND_EXTERNAL_SOCKET_OWNER), flags)
		}
		*(*Tuint64_t)(unsafe.Pointer(sent)) = (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest
	}
	libc.Xpthread_mutex_unlock(tls, c+24)
	return ret
}

func Xxcb_writev(tls *libc.TLS, c uintptr, vector uintptr, count int32, requests Tuint64_t) (r int32) {
	var ret int32
	_ = ret
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return 0
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest += requests
	ret = X_xcb_out_send(tls, c, vector, count)
	libc.Xpthread_mutex_unlock(tls, c+24)
	return ret
}

func Xxcb_flush(tls *libc.TLS, c uintptr) (r int32) {
	var ret int32
	_ = ret
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return 0
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	ret = X_xcb_out_flush_to(tls, c, (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest)
	libc.Xpthread_mutex_unlock(tls, c+24)
	return ret
}

/* Private interface */

func X_xcb_out_init(tls *libc.TLS, out uintptr) (r int32) {
	if libc.Xpthread_cond_init(tls, out+16, uintptr(0)) != 0 {
		return 0
	}
	(*T_xcb_out)(unsafe.Pointer(out)).Freturn_socket = uintptr(0)
	(*T_xcb_out)(unsafe.Pointer(out)).Fsocket_closure = uintptr(0)
	(*T_xcb_out)(unsafe.Pointer(out)).Fsocket_moving = 0
	if libc.Xpthread_cond_init(tls, out, uintptr(0)) != 0 {
		return 0
	}
	(*T_xcb_out)(unsafe.Pointer(out)).Fwriting = 0
	(*T_xcb_out)(unsafe.Pointer(out)).Fqueue_len = 0
	(*T_xcb_out)(unsafe.Pointer(out)).Frequest = uint64(0)
	(*T_xcb_out)(unsafe.Pointer(out)).Frequest_written = uint64(0)
	(*T_xcb_out)(unsafe.Pointer(out)).Frequest_expected_written = uint64(0)
	if libc.Xpthread_mutex_init(tls, out+16464, uintptr(0)) != 0 {
		return 0
	}
	(*T_xcb_out)(unsafe.Pointer(out)).Fmaximum_request_length_tag = int32(_LAZY_NONE)
	return int32(1)
}

func X_xcb_out_destroy(tls *libc.TLS, out uintptr) {
	libc.Xpthread_mutex_destroy(tls, out+16464)
	libc.Xpthread_cond_destroy(tls, out)
	libc.Xpthread_cond_destroy(tls, out+16)
}

func X_xcb_out_send(tls *libc.TLS, c uintptr, _vector uintptr, _count int32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp)) = _vector
	*(*int32)(unsafe.Pointer(bp + 8)) = _count
	var ret int32
	_ = ret
	ret = int32(1)
	for ret != 0 && *(*int32)(unsafe.Pointer(bp + 8)) != 0 {
		ret = X_xcb_conn_wait(tls, c, c+4328, bp, bp+8)
	}
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest_written = (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest_expected_written = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_expected
	libc.Xpthread_cond_broadcast(tls, c+4328)
	X_xcb_in_wake_up_next_reader(tls, c)
	return ret
}

func X_xcb_out_send_sync(tls *libc.TLS, c uintptr) {
	_prepare_socket_request(tls, c)
	_send_sync(tls, c)
}

func X_xcb_out_flush_to(tls *libc.TLS, c uintptr, request Tuint64_t) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* vec at bp+0 */ Tiovec
	if libc.Int64FromUint64((*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest_written-request) >= 0 {
		return int32(1)
	}
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fqueue_len != 0 {
		(*(*Tiovec)(unsafe.Pointer(bp))).Fiov_base = c + 4328 + 44
		(*(*Tiovec)(unsafe.Pointer(bp))).Fiov_len = libc.Uint64FromInt32((*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fqueue_len)
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fqueue_len = 0
		return X_xcb_out_send(tls, c, bp, int32(1))
	}
	for (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Fwriting != 0 {
		libc.Xpthread_cond_wait(tls, c+4328, c+24)
	}
	return int32(1)
}

const m_INT32_MAX1 = 2147483647
const m_MSG_CTRUNC1 = 32
const m_MSG_TRUNC1 = 16
const m_POLLOUT1 = 0x0004
const m_UINT32_MAX1 = 4294967295
const m_XCB_ERROR = 0
const m_XCB_REPLY = 1
const m_XCB_XGE_EVENT = 35

type Txcb_special_event_t = struct {
	Fnext               uintptr
	Fextension          Tuint8_t
	Feid                Tuint32_t
	Fstamp              uintptr
	Fevents             uintptr
	Fevents_tail        uintptr
	Fspecial_event_cond Tpthread_cond_t
}

type Txcb_special_event = Txcb_special_event_t

type Tevent_list = struct {
	Fevent uintptr
	Fnext  uintptr
}

type Treply_list = struct {
	Freply uintptr
	Fnext  uintptr
}

type Tpending_reply = struct {
	Ffirst_request Tuint64_t
	Flast_request  Tuint64_t
	Fworkaround    _workarounds
	Fflags         int32
	Fnext          uintptr
}

type Treader_list = struct {
	Frequest Tuint64_t
	Fdata    uintptr
	Fnext    uintptr
}

type Tspecial_list = struct {
	Fse   uintptr
	Fnext uintptr
}

func _remove_finished_readers(tls *libc.TLS, prev_reader uintptr, completed Tuint64_t) {
	for *(*uintptr)(unsafe.Pointer(prev_reader)) != 0 && libc.Int64FromUint64((*Treader_list)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(prev_reader)))).Frequest-completed) <= 0 {
		/* If you don't have what you're looking for now, you never
		 * will. Wake up and leave me alone. */
		libc.Xpthread_cond_signal(tls, (*Treader_list)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(prev_reader)))).Fdata)
		*(*uintptr)(unsafe.Pointer(prev_reader)) = (*Treader_list)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(prev_reader)))).Fnext
	}
}

func _read_fds(tls *libc.TLS, c uintptr, fds uintptr, nfd int32) (r int32) {
	var ifds uintptr
	var infd int32
	_, _ = ifds, infd
	ifds = c + 32 + 4216 + uintptr((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fifd)*4
	infd = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fnfd - (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fifd
	if nfd > infd {
		return 0
	}
	libc.Xmemcpy(tls, fds, ifds, libc.Uint64FromInt32(nfd)*uint64(4))
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fifd += nfd
	return int32(1)
}

type Txcb_ge_special_event_t = struct {
	Fresponse_type Tuint8_t
	Fextension     Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fevtype        Tuint16_t
	Fpad0          [2]Tuint8_t
	Feid           Tuint32_t
	Fpad1          [16]Tuint8_t
}

func _event_special(tls *libc.TLS, c uintptr, event uintptr) (r int32) {
	var ges, special_event uintptr
	_, _ = ges, special_event
	ges = (*Tevent_list)(unsafe.Pointer(event)).Fevent
	/* Special events are always XGE events */
	if libc.Int32FromUint8((*Txcb_ge_special_event_t1)(unsafe.Pointer(ges)).Fresponse_type)&int32(0x7f) != int32(m_XCB_XGE_EVENT) {
		return 0
	}
	special_event = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fspecial_events
	for {
		if !(special_event != 0) {
			break
		}
		if libc.Int32FromUint8((*Txcb_ge_special_event_t1)(unsafe.Pointer(ges)).Fextension) == libc.Int32FromUint8((*Txcb_special_event)(unsafe.Pointer(special_event)).Fextension) && (*Txcb_ge_special_event_t1)(unsafe.Pointer(ges)).Feid == (*Txcb_special_event)(unsafe.Pointer(special_event)).Feid {
			*(*uintptr)(unsafe.Pointer((*Txcb_special_event)(unsafe.Pointer(special_event)).Fevents_tail)) = event
			(*Txcb_special_event)(unsafe.Pointer(special_event)).Fevents_tail = event + 8
			if (*Txcb_special_event)(unsafe.Pointer(special_event)).Fstamp != 0 {
				*(*Tuint32_t)(unsafe.Pointer((*Txcb_special_event)(unsafe.Pointer(special_event)).Fstamp))++
			}
			libc.Xpthread_cond_signal(tls, special_event+40)
			return int32(1)
		}
		goto _1
	_1:
		;
		special_event = (*Txcb_special_event)(unsafe.Pointer(special_event)).Fnext
	}
	return 0
}

func _read_packet(tls *libc.TLS, c uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var buf, cur, event, oldpend, p, pend uintptr
	var bufsize, eventlength, lastread, length, new_length Tuint64_t
	var nfd int32
	var v1 uint64
	var _ /* genrep at bp+0 */ Txcb_generic_reply_t
	_, _, _, _, _, _, _, _, _, _, _, _, _ = buf, bufsize, cur, event, eventlength, lastread, length, new_length, nfd, oldpend, p, pend, v1
	length = uint64(32)
	eventlength = uint64(0) /* length after first 32 bytes for GenericEvents */
	nfd = 0
	pend = uintptr(0)
	/* Wait for there to be enough data for us to read a whole packet */
	if libc.Uint64FromInt32((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fqueue_len) < length {
		return 0
	}
	/* Get the response type, length, and sequence number. */
	libc.Xmemcpy(tls, bp, c+32+12, uint64(8))
	/* Compute 32-bit sequence number of this packet. */
	if libc.Int32FromUint8((*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Fresponse_type)&int32(0x7f) != int32(m_XCB_KEYMAP_NOTIFY) {
		lastread = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read = lastread&uint64(0xffffffffffff0000) | uint64((*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Fsequence)
		if libc.Int64FromUint64((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read-lastread) < 0 {
			(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read += uint64(0x10000)
		}
		if libc.Int64FromUint64((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read-(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_expected) > 0 {
			(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_expected = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read
		}
		if (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read != lastread {
			if (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fcurrent_reply != 0 {
				X_xcb_map_put(tls, (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freplies, lastread, (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fcurrent_reply)
				(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fcurrent_reply = uintptr(0)
				(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fcurrent_reply_tail = c + 32 + 4144
			}
			(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_completed = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read - uint64(1)
		}
		for (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fpending_replies != 0 && (*Tpending_reply1)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fpending_replies)).Fworkaround != int32(_WORKAROUND_EXTERNAL_SOCKET_OWNER) && libc.Int64FromUint64((*Tpending_reply1)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fpending_replies)).Flast_request-(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_completed) <= 0 {
			oldpend = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fpending_replies
			(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fpending_replies = (*Tpending_reply)(unsafe.Pointer(oldpend)).Fnext
			if !((*Tpending_reply)(unsafe.Pointer(oldpend)).Fnext != 0) {
				(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fpending_replies_tail = c + 32 + 4200
			}
			libc.Xfree(tls, oldpend)
		}
		if libc.Int32FromUint8((*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Fresponse_type) == m_XCB_ERROR {
			(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_completed = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read
		}
		_remove_finished_readers(tls, c+32+4184, (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_completed)
	}
	if libc.Int32FromUint8((*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Fresponse_type) == m_XCB_ERROR || libc.Int32FromUint8((*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Fresponse_type) == int32(m_XCB_REPLY) {
		pend = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fpending_replies
		if pend != 0 && !(libc.Int64FromUint64((*Tpending_reply)(unsafe.Pointer(pend)).Ffirst_request-(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read) <= 0 && ((*Tpending_reply)(unsafe.Pointer(pend)).Fworkaround == int32(_WORKAROUND_EXTERNAL_SOCKET_OWNER) || libc.Int64FromUint64((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read-(*Tpending_reply)(unsafe.Pointer(pend)).Flast_request) <= 0)) {
			pend = uintptr(0)
		}
	}
	/* For reply packets, check that the entire packet is available. */
	if libc.Int32FromUint8((*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Fresponse_type) == int32(m_XCB_REPLY) {
		if pend != 0 && (*Tpending_reply)(unsafe.Pointer(pend)).Fworkaround == int32(_WORKAROUND_GLX_GET_FB_CONFIGS_BUG) {
			p = c + 32 + 12
			new_length = uint64(*(*Tuint32_t)(unsafe.Pointer(p + 2*4))) * uint64(*(*Tuint32_t)(unsafe.Pointer(p + 3*4)))
			if new_length >= uint64(libc.Uint32FromUint32(0xffffffff)/libc.Uint32FromUint32(16)) {
				X_xcb_conn_shutdown(tls, c, int32(m_XCB_CONN_CLOSED_MEM_INSUFFICIENT))
				return 0
			}
			(*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Flength = uint32(new_length * libc.Uint64FromUint64(2))
		}
		length += uint64((*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Flength) * uint64(4)
		/* XXX a bit of a hack -- we "know" that all FD replys place
		 * the number of fds in the pad0 byte */
		if pend != 0 && (*Tpending_reply)(unsafe.Pointer(pend)).Fflags&int32(_XCB_REQUEST_REPLY_FDS) != 0 {
			nfd = libc.Int32FromUint8((*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Fpad0)
		}
	}
	/* XGE events may have sizes > 32 */
	if libc.Int32FromUint8((*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Fresponse_type)&int32(0x7f) == int32(m_XCB_XGE_EVENT) {
		eventlength = uint64((*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Flength) * uint64(4)
	}
	if libc.Int32FromUint8((*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Fresponse_type) == int32(m_XCB_REPLY) {
		v1 = uint64(0)
	} else {
		v1 = uint64(4)
	}
	bufsize = length + eventlength + libc.Uint64FromInt32(nfd)*uint64(4) + v1
	if bufsize < uint64(m_INT32_MAX1) {
		buf = libc.Xmalloc(tls, bufsize)
	} else {
		buf = libc.UintptrFromInt32(0)
	}
	if !(buf != 0) {
		X_xcb_conn_shutdown(tls, c, int32(m_XCB_CONN_CLOSED_MEM_INSUFFICIENT))
		return 0
	}
	if X_xcb_in_read_block(tls, c, buf, libc.Int32FromUint64(length)) <= 0 {
		libc.Xfree(tls, buf)
		return 0
	}
	/* pull in XGE event data if available, append after event struct */
	if eventlength != 0 {
		if X_xcb_in_read_block(tls, c, buf+1*36, libc.Int32FromUint64(eventlength)) <= 0 {
			libc.Xfree(tls, buf)
			return 0
		}
	}
	if nfd != 0 {
		if !(_read_fds(tls, c, buf+uintptr(length), nfd) != 0) {
			libc.Xfree(tls, buf)
			return 0
		}
	}
	if pend != 0 && (*Tpending_reply)(unsafe.Pointer(pend)).Fflags&int32(_XCB_REQUEST_DISCARD_REPLY) != 0 {
		libc.Xfree(tls, buf)
		return int32(1)
	}
	if libc.Int32FromUint8((*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Fresponse_type) != int32(m_XCB_REPLY) {
		(*Txcb_generic_event_t)(unsafe.Pointer(buf)).Ffull_sequence = uint32((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read)
	}
	/* reply, or checked error */
	if libc.Int32FromUint8((*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Fresponse_type) == int32(m_XCB_REPLY) || libc.Int32FromUint8((*(*Txcb_generic_reply_t)(unsafe.Pointer(bp))).Fresponse_type) == m_XCB_ERROR && pend != 0 && (*Tpending_reply)(unsafe.Pointer(pend)).Fflags&int32(_XCB_REQUEST_CHECKED) != 0 {
		cur = libc.Xmalloc(tls, uint64(16))
		if !(cur != 0) {
			X_xcb_conn_shutdown(tls, c, int32(m_XCB_CONN_CLOSED_MEM_INSUFFICIENT))
			libc.Xfree(tls, buf)
			return 0
		}
		(*Treply_list)(unsafe.Pointer(cur)).Freply = buf
		(*Treply_list)(unsafe.Pointer(cur)).Fnext = uintptr(0)
		*(*uintptr)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fcurrent_reply_tail)) = cur
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fcurrent_reply_tail = cur + 8
		if (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freaders != 0 && (*Treader_list1)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freaders)).Frequest == (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read {
			libc.Xpthread_cond_signal(tls, (*Treader_list1)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freaders)).Fdata)
		}
		return int32(1)
	}
	/* event, or unchecked error */
	event = libc.Xmalloc(tls, uint64(16))
	if !(event != 0) {
		X_xcb_conn_shutdown(tls, c, int32(m_XCB_CONN_CLOSED_MEM_INSUFFICIENT))
		libc.Xfree(tls, buf)
		return 0
	}
	(*Tevent_list)(unsafe.Pointer(event)).Fevent = buf
	(*Tevent_list)(unsafe.Pointer(event)).Fnext = uintptr(0)
	if !(_event_special(tls, c, event) != 0) {
		*(*uintptr)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fevents_tail)) = event
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fevents_tail = event + 8
		libc.Xpthread_cond_signal(tls, c+32)
	}
	return int32(1) /* I have something for you... */
}

func _get_event(tls *libc.TLS, c uintptr) (r uintptr) {
	var cur, ret uintptr
	_, _ = cur, ret
	cur = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fevents
	if !((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fevents != 0) {
		return uintptr(0)
	}
	ret = (*Tevent_list)(unsafe.Pointer(cur)).Fevent
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fevents = (*Tevent_list)(unsafe.Pointer(cur)).Fnext
	if !((*Tevent_list)(unsafe.Pointer(cur)).Fnext != 0) {
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fevents_tail = c + 32 + 4168
	}
	libc.Xfree(tls, cur)
	return ret
}

func _free_reply_list(tls *libc.TLS, head uintptr) {
	var cur uintptr
	_ = cur
	for head != 0 {
		cur = head
		head = (*Treply_list)(unsafe.Pointer(cur)).Fnext
		libc.Xfree(tls, (*Treply_list)(unsafe.Pointer(cur)).Freply)
		libc.Xfree(tls, cur)
	}
}

func _read_block(tls *libc.TLS, fd int32, buf uintptr, len1 Tintptr_t) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var done, ret int32
	var _ /* pfd at bp+0 */ Tpollfd
	_, _ = done, ret
	done = 0
	for int64(done) < len1 {
		ret = int32(libc.Xrecv(tls, fd, buf+uintptr(done), libc.Uint64FromInt64(len1-int64(done)), 0))
		if ret > 0 {
			done += ret
		}
		if ret < 0 && *(*int32)(unsafe.Pointer(libc.X__error(tls))) == int32(m_EAGAIN) {
			(*(*Tpollfd)(unsafe.Pointer(bp))).Ffd = fd
			(*(*Tpollfd)(unsafe.Pointer(bp))).Fevents = int16(m_POLLIN)
			(*(*Tpollfd)(unsafe.Pointer(bp))).Frevents = 0
			for cond := true; cond; cond = ret == -int32(1) && *(*int32)(unsafe.Pointer(libc.X__error(tls))) == int32(m_EINTR) {
				ret = libc.Xpoll(tls, bp, uint32(1), -int32(1))
			}
		}
		if ret <= 0 {
			return ret
		}
	}
	return int32(len1)
}

func _poll_for_reply(tls *libc.TLS, c uintptr, request Tuint64_t, reply uintptr, error1 uintptr) (r int32) {
	var head uintptr
	_ = head
	/* If an error occurred when issuing the request, fail immediately. */
	if !(request != 0) {
		head = uintptr(0)
	} else {
		if libc.Int64FromUint64(request-(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read) < 0 {
			head = X_xcb_map_remove(tls, (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freplies, request)
			if head != 0 && (*Treply_list)(unsafe.Pointer(head)).Fnext != 0 {
				X_xcb_map_put(tls, (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freplies, request, (*Treply_list)(unsafe.Pointer(head)).Fnext)
			}
		} else {
			if request == (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_read && (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fcurrent_reply != 0 {
				head = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fcurrent_reply
				(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fcurrent_reply = (*Treply_list)(unsafe.Pointer(head)).Fnext
				if !((*Treply_list)(unsafe.Pointer(head)).Fnext != 0) {
					(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fcurrent_reply_tail = c + 32 + 4144
				}
			} else {
				if request == (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_completed {
					head = uintptr(0)
				} else {
					return 0
				}
			}
		}
	}
	if error1 != 0 {
		*(*uintptr)(unsafe.Pointer(error1)) = uintptr(0)
	}
	*(*uintptr)(unsafe.Pointer(reply)) = uintptr(0)
	if head != 0 {
		if libc.Int32FromUint8((*Txcb_generic_reply_t)(unsafe.Pointer((*Treply_list)(unsafe.Pointer(head)).Freply)).Fresponse_type) == m_XCB_ERROR {
			if error1 != 0 {
				*(*uintptr)(unsafe.Pointer(error1)) = (*Treply_list)(unsafe.Pointer(head)).Freply
			} else {
				libc.Xfree(tls, (*Treply_list)(unsafe.Pointer(head)).Freply)
			}
		} else {
			*(*uintptr)(unsafe.Pointer(reply)) = (*Treply_list)(unsafe.Pointer(head)).Freply
		}
		libc.Xfree(tls, head)
	}
	return int32(1)
}

func _insert_reader(tls *libc.TLS, prev_reader uintptr, reader uintptr, request Tuint64_t, cond uintptr) {
	for *(*uintptr)(unsafe.Pointer(prev_reader)) != 0 && libc.Int64FromUint64((*Treader_list)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(prev_reader)))).Frequest-request) <= 0 {
		prev_reader = *(*uintptr)(unsafe.Pointer(prev_reader)) + 16
	}
	(*Treader_list)(unsafe.Pointer(reader)).Frequest = request
	(*Treader_list)(unsafe.Pointer(reader)).Fdata = cond
	(*Treader_list)(unsafe.Pointer(reader)).Fnext = *(*uintptr)(unsafe.Pointer(prev_reader))
	*(*uintptr)(unsafe.Pointer(prev_reader)) = reader
}

func _remove_reader(tls *libc.TLS, prev_reader uintptr, reader uintptr) {
	for *(*uintptr)(unsafe.Pointer(prev_reader)) != 0 && libc.Int64FromUint64((*Treader_list)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(prev_reader)))).Frequest-(*Treader_list)(unsafe.Pointer(reader)).Frequest) <= 0 {
		if *(*uintptr)(unsafe.Pointer(prev_reader)) == reader {
			*(*uintptr)(unsafe.Pointer(prev_reader)) = (*Treader_list)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(prev_reader)))).Fnext
			break
		}
	}
}

func _insert_special(tls *libc.TLS, prev_special uintptr, special uintptr, se uintptr) {
	(*Tspecial_list)(unsafe.Pointer(special)).Fse = se
	(*Tspecial_list)(unsafe.Pointer(special)).Fnext = *(*uintptr)(unsafe.Pointer(prev_special))
	*(*uintptr)(unsafe.Pointer(prev_special)) = special
}

func _remove_special(tls *libc.TLS, prev_special uintptr, special uintptr) {
	for *(*uintptr)(unsafe.Pointer(prev_special)) != 0 {
		if *(*uintptr)(unsafe.Pointer(prev_special)) == special {
			*(*uintptr)(unsafe.Pointer(prev_special)) = (*Tspecial_list)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(prev_special)))).Fnext
			break
		}
		prev_special = *(*uintptr)(unsafe.Pointer(prev_special)) + 8
	}
}

func _wait_for_reply(tls *libc.TLS, c uintptr, request Tuint64_t, e uintptr) (r uintptr) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var _ /* cond at bp+8 */ Tpthread_cond_t
	var _ /* reader at bp+16 */ Treader_list
	var _ /* ret at bp+0 */ uintptr
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	/* If this request has not been written yet, write it. */
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Freturn_socket != 0 || X_xcb_out_flush_to(tls, c, request) != 0 {
		*(*Tpthread_cond_t)(unsafe.Pointer(bp + 8)) = libc.UintptrFromInt32(0)
		_insert_reader(tls, c+32+4184, bp+16, request, bp+8)
		for !(_poll_for_reply(tls, c, request, bp, e) != 0) {
			if !(X_xcb_conn_wait(tls, c, bp+8, uintptr(0), uintptr(0)) != 0) {
				break
			}
		}
		_remove_reader(tls, c+32+4184, bp+16)
		libc.Xpthread_cond_destroy(tls, bp+8)
	}
	X_xcb_in_wake_up_next_reader(tls, c)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func _widen(tls *libc.TLS, c uintptr, request uint32) (r Tuint64_t) {
	var widened_request Tuint64_t
	_ = widened_request
	widened_request = (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest&uint64(0xffffffff00000000) | uint64(request)
	if widened_request > (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest {
		widened_request -= libc.Uint64FromUint64(1) << libc.Int32FromInt32(32)
	}
	return widened_request
}

/* Public interface */

func Xxcb_wait_for_reply(tls *libc.TLS, c uintptr, request uint32, e uintptr) (r uintptr) {
	var ret uintptr
	_ = ret
	if e != 0 {
		*(*uintptr)(unsafe.Pointer(e)) = uintptr(0)
	}
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return uintptr(0)
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	ret = _wait_for_reply(tls, c, _widen(tls, c, request), e)
	libc.Xpthread_mutex_unlock(tls, c+24)
	return ret
}

func Xxcb_wait_for_reply64(tls *libc.TLS, c uintptr, request Tuint64_t, e uintptr) (r uintptr) {
	var ret uintptr
	_ = ret
	if e != 0 {
		*(*uintptr)(unsafe.Pointer(e)) = uintptr(0)
	}
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return uintptr(0)
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	ret = _wait_for_reply(tls, c, request, e)
	libc.Xpthread_mutex_unlock(tls, c+24)
	return ret
}

func Xxcb_get_reply_fds(tls *libc.TLS, c uintptr, reply uintptr, reply_size Tsize_t) (r uintptr) {
	return reply + uintptr(reply_size)
}

func _insert_pending_discard(tls *libc.TLS, c uintptr, prev_next uintptr, seq Tuint64_t) {
	var pend uintptr
	_ = pend
	pend = libc.Xmalloc(tls, uint64(32))
	if !(pend != 0) {
		X_xcb_conn_shutdown(tls, c, int32(m_XCB_CONN_CLOSED_MEM_INSUFFICIENT))
		return
	}
	(*Tpending_reply)(unsafe.Pointer(pend)).Ffirst_request = seq
	(*Tpending_reply)(unsafe.Pointer(pend)).Flast_request = seq
	(*Tpending_reply)(unsafe.Pointer(pend)).Fworkaround = 0
	(*Tpending_reply)(unsafe.Pointer(pend)).Fflags = int32(_XCB_REQUEST_DISCARD_REPLY)
	(*Tpending_reply)(unsafe.Pointer(pend)).Fnext = *(*uintptr)(unsafe.Pointer(prev_next))
	*(*uintptr)(unsafe.Pointer(prev_next)) = pend
	if !((*Tpending_reply)(unsafe.Pointer(pend)).Fnext != 0) {
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fpending_replies_tail = pend + 24
	}
}

func _discard_reply(tls *libc.TLS, c uintptr, request Tuint64_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var prev_pend uintptr
	var _ /* reply at bp+0 */ uintptr
	_ = prev_pend
	/* Free any replies or errors that we've already read. Stop if
	 * xcb_wait_for_reply would block or we've run out of replies. */
	for _poll_for_reply(tls, c, request, bp, uintptr(0)) != 0 && *(*uintptr)(unsafe.Pointer(bp)) != 0 {
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp)))
	}
	/* If we've proven there are no more responses coming, we're done. */
	if libc.Int64FromUint64(request-(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_completed) <= 0 {
		return
	}
	/* Walk the list of pending requests. Mark the first match for deletion. */
	prev_pend = c + 32 + 4200
	for {
		if !(*(*uintptr)(unsafe.Pointer(prev_pend)) != 0) {
			break
		}
		if libc.Int64FromUint64((*Tpending_reply)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(prev_pend)))).Ffirst_request-request) > 0 {
			break
		}
		if (*Tpending_reply)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(prev_pend)))).Ffirst_request == request {
			/* Pending reply found. Mark for discard: */
			*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(prev_pend)) + 20)) |= int32(_XCB_REQUEST_DISCARD_REPLY)
			return
		}
		goto _1
	_1:
		;
		prev_pend = *(*uintptr)(unsafe.Pointer(prev_pend)) + 24
	}
	/* Pending reply not found (likely due to _unchecked request). Create one: */
	_insert_pending_discard(tls, c, prev_pend, request)
}

func Xxcb_discard_reply(tls *libc.TLS, c uintptr, sequence uint32) {
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return
	}
	/* If an error occurred when issuing the request, fail immediately. */
	if !(sequence != 0) {
		return
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	_discard_reply(tls, c, _widen(tls, c, sequence))
	libc.Xpthread_mutex_unlock(tls, c+24)
}

func Xxcb_discard_reply64(tls *libc.TLS, c uintptr, sequence Tuint64_t) {
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return
	}
	/* If an error occurred when issuing the request, fail immediately. */
	if !(sequence != 0) {
		return
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	_discard_reply(tls, c, sequence)
	libc.Xpthread_mutex_unlock(tls, c+24)
}

func Xxcb_poll_for_reply(tls *libc.TLS, c uintptr, request uint32, reply uintptr, error1 uintptr) (r int32) {
	var ret int32
	_ = ret
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		*(*uintptr)(unsafe.Pointer(reply)) = uintptr(0)
		if error1 != 0 {
			*(*uintptr)(unsafe.Pointer(error1)) = uintptr(0)
		}
		return int32(1) /* would not block */
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	ret = _poll_for_reply(tls, c, _widen(tls, c, request), reply, error1)
	if !(ret != 0) && (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freading == 0 && X_xcb_in_read(tls, c) != 0 { /* _xcb_in_read shuts down the connection on error */
		ret = _poll_for_reply(tls, c, _widen(tls, c, request), reply, error1)
	}
	libc.Xpthread_mutex_unlock(tls, c+24)
	return ret
}

func Xxcb_poll_for_reply64(tls *libc.TLS, c uintptr, request Tuint64_t, reply uintptr, error1 uintptr) (r int32) {
	var ret int32
	_ = ret
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		*(*uintptr)(unsafe.Pointer(reply)) = uintptr(0)
		if error1 != 0 {
			*(*uintptr)(unsafe.Pointer(error1)) = uintptr(0)
		}
		return int32(1) /* would not block */
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	ret = _poll_for_reply(tls, c, request, reply, error1)
	if !(ret != 0) && (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freading == 0 && X_xcb_in_read(tls, c) != 0 { /* _xcb_in_read shuts down the connection on error */
		ret = _poll_for_reply(tls, c, request, reply, error1)
	}
	libc.Xpthread_mutex_unlock(tls, c+24)
	return ret
}

func Xxcb_wait_for_event(tls *libc.TLS, c uintptr) (r uintptr) {
	var ret, v1 uintptr
	_, _ = ret, v1
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return uintptr(0)
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	/* get_event returns 0 on empty list. */
	for {
		v1 = _get_event(tls, c)
		ret = v1
		if !!(v1 != 0) {
			break
		}
		if !(X_xcb_conn_wait(tls, c, c+32, uintptr(0), uintptr(0)) != 0) {
			break
		}
	}
	X_xcb_in_wake_up_next_reader(tls, c)
	libc.Xpthread_mutex_unlock(tls, c+24)
	return ret
}

func _poll_for_next_event(tls *libc.TLS, c uintptr, queued int32) (r uintptr) {
	var ret uintptr
	_ = ret
	ret = uintptr(0)
	if !((*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0) {
		libc.Xpthread_mutex_lock(tls, c+24)
		/* FIXME: follow X meets Z architecture changes. */
		ret = _get_event(tls, c)
		if !(ret != 0) && !(queued != 0) && (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freading == 0 && X_xcb_in_read(tls, c) != 0 { /* _xcb_in_read shuts down the connection on error */
			ret = _get_event(tls, c)
		}
		libc.Xpthread_mutex_unlock(tls, c+24)
	}
	return ret
}

func Xxcb_poll_for_event(tls *libc.TLS, c uintptr) (r uintptr) {
	return _poll_for_next_event(tls, c, 0)
}

func Xxcb_poll_for_queued_event(tls *libc.TLS, c uintptr) (r uintptr) {
	return _poll_for_next_event(tls, c, int32(1))
}

func Xxcb_request_check(tls *libc.TLS, c uintptr, cookie Txcb_void_cookie_t) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var reply uintptr
	var request Tuint64_t
	var _ /* ret at bp+0 */ uintptr
	_, _ = reply, request
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return uintptr(0)
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	request = _widen(tls, c, cookie.Fsequence)
	if libc.Int64FromUint64(request-(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_completed) > 0 {
		if libc.Int64FromUint64(request-(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Frequest_expected) >= 0 {
			X_xcb_out_send_sync(tls, c)
		}
		if libc.Int64FromUint64(request-(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest_expected_written) >= 0 {
			X_xcb_out_flush_to(tls, c, (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest)
		}
	}
	reply = _wait_for_reply(tls, c, request, bp)
	libc.Xpthread_mutex_unlock(tls, c+24)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func _get_special_event(tls *libc.TLS, c uintptr, se uintptr) (r uintptr) {
	var event, events, v1, v2 uintptr
	_, _, _, _ = event, events, v1, v2
	event = libc.UintptrFromInt32(0)
	v1 = (*Txcb_special_event_t)(unsafe.Pointer(se)).Fevents
	events = v1
	if v1 != libc.UintptrFromInt32(0) {
		event = (*Tevent_list)(unsafe.Pointer(events)).Fevent
		v2 = (*Tevent_list)(unsafe.Pointer(events)).Fnext
		(*Txcb_special_event_t)(unsafe.Pointer(se)).Fevents = v2
		if !(v2 != 0) {
			(*Txcb_special_event_t)(unsafe.Pointer(se)).Fevents_tail = se + 24
		}
		libc.Xfree(tls, events)
	}
	return event
}

func Xxcb_poll_for_special_event(tls *libc.TLS, c uintptr, se uintptr) (r uintptr) {
	var event uintptr
	_ = event
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return uintptr(0)
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	event = _get_special_event(tls, c, se)
	if !(event != 0) && (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freading == 0 && X_xcb_in_read(tls, c) != 0 { /* _xcb_in_read shuts down the connection on error */
		event = _get_special_event(tls, c, se)
	}
	libc.Xpthread_mutex_unlock(tls, c+24)
	return event
}

func Xxcb_wait_for_special_event(tls *libc.TLS, c uintptr, se uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var event, v1 uintptr
	var _ /* special at bp+0 */ Tspecial_list
	_, _ = event, v1
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return uintptr(0)
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	_insert_special(tls, c+32+4192, bp, se)
	/* get_special_event returns 0 on empty list. */
	for {
		v1 = _get_special_event(tls, c, se)
		event = v1
		if !!(v1 != 0) {
			break
		}
		if !(X_xcb_conn_wait(tls, c, se+40, uintptr(0), uintptr(0)) != 0) {
			break
		}
	}
	_remove_special(tls, c+32+4192, bp)
	X_xcb_in_wake_up_next_reader(tls, c)
	libc.Xpthread_mutex_unlock(tls, c+24)
	return event
}

func Xxcb_register_for_special_xge(tls *libc.TLS, c uintptr, ext uintptr, eid Tuint32_t, stamp uintptr) (r uintptr) {
	var ext_reply, se uintptr
	_, _ = ext_reply, se
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return libc.UintptrFromInt32(0)
	}
	ext_reply = Xxcb_get_extension_data(tls, c, ext)
	if !(ext_reply != 0) {
		return libc.UintptrFromInt32(0)
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	se = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fspecial_events
	for {
		if !(se != 0) {
			break
		}
		if libc.Int32FromUint8((*Txcb_special_event_t)(unsafe.Pointer(se)).Fextension) == libc.Int32FromUint8((*Txcb_query_extension_reply_t)(unsafe.Pointer(ext_reply)).Fmajor_opcode) && (*Txcb_special_event_t)(unsafe.Pointer(se)).Feid == eid {
			libc.Xpthread_mutex_unlock(tls, c+24)
			return libc.UintptrFromInt32(0)
		}
		goto _1
	_1:
		;
		se = (*Txcb_special_event_t)(unsafe.Pointer(se)).Fnext
	}
	se = libc.Xcalloc(tls, uint64(1), uint64(48))
	if !(se != 0) {
		libc.Xpthread_mutex_unlock(tls, c+24)
		return libc.UintptrFromInt32(0)
	}
	(*Txcb_special_event_t)(unsafe.Pointer(se)).Fextension = (*Txcb_query_extension_reply_t)(unsafe.Pointer(ext_reply)).Fmajor_opcode
	(*Txcb_special_event_t)(unsafe.Pointer(se)).Feid = eid
	(*Txcb_special_event_t)(unsafe.Pointer(se)).Fevents = libc.UintptrFromInt32(0)
	(*Txcb_special_event_t)(unsafe.Pointer(se)).Fevents_tail = se + 24
	(*Txcb_special_event_t)(unsafe.Pointer(se)).Fstamp = stamp
	libc.Xpthread_cond_init(tls, se+40, uintptr(0))
	(*Txcb_special_event_t)(unsafe.Pointer(se)).Fnext = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fspecial_events
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fspecial_events = se
	libc.Xpthread_mutex_unlock(tls, c+24)
	return se
}

func Xxcb_unregister_for_special_event(tls *libc.TLS, c uintptr, se uintptr) {
	var events, next, prev, s, v2 uintptr
	_, _, _, _, _ = events, next, prev, s, v2
	if !(se != 0) {
		return
	}
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return
	}
	libc.Xpthread_mutex_lock(tls, c+24)
	prev = c + 32 + 4288
	for {
		v2 = *(*uintptr)(unsafe.Pointer(prev))
		s = v2
		if !(v2 != libc.UintptrFromInt32(0)) {
			break
		}
		if s == se {
			*(*uintptr)(unsafe.Pointer(prev)) = (*Txcb_special_event_t)(unsafe.Pointer(se)).Fnext
			events = (*Txcb_special_event_t)(unsafe.Pointer(se)).Fevents
			for {
				if !(events != 0) {
					break
				}
				next = (*Tevent_list)(unsafe.Pointer(events)).Fnext
				libc.Xfree(tls, (*Tevent_list)(unsafe.Pointer(events)).Fevent)
				libc.Xfree(tls, events)
				goto _3
			_3:
				;
				events = next
			}
			libc.Xpthread_cond_destroy(tls, se+40)
			libc.Xfree(tls, se)
			break
		}
		goto _1
	_1:
		;
		prev = s
	}
	libc.Xpthread_mutex_unlock(tls, c+24)
}

/* Private interface */

func X_xcb_in_init(tls *libc.TLS, in uintptr) (r int32) {
	if libc.Xpthread_cond_init(tls, in, uintptr(0)) != 0 {
		return 0
	}
	(*T_xcb_in)(unsafe.Pointer(in)).Freading = 0
	(*T_xcb_in)(unsafe.Pointer(in)).Fqueue_len = 0
	(*T_xcb_in)(unsafe.Pointer(in)).Frequest_read = uint64(0)
	(*T_xcb_in)(unsafe.Pointer(in)).Frequest_completed = uint64(0)
	(*T_xcb_in)(unsafe.Pointer(in)).Freplies = X_xcb_map_new(tls)
	if !((*T_xcb_in)(unsafe.Pointer(in)).Freplies != 0) {
		return 0
	}
	(*T_xcb_in)(unsafe.Pointer(in)).Fcurrent_reply_tail = in + 4144
	(*T_xcb_in)(unsafe.Pointer(in)).Fevents_tail = in + 4168
	(*T_xcb_in)(unsafe.Pointer(in)).Fpending_replies_tail = in + 4200
	return int32(1)
}

func X_xcb_in_destroy(tls *libc.TLS, in uintptr) {
	var e, pend uintptr
	_, _ = e, pend
	libc.Xpthread_cond_destroy(tls, in)
	_free_reply_list(tls, (*T_xcb_in)(unsafe.Pointer(in)).Fcurrent_reply)
	X_xcb_map_delete(tls, (*T_xcb_in)(unsafe.Pointer(in)).Freplies, __ccgo_fp(_free_reply_list))
	for (*T_xcb_in)(unsafe.Pointer(in)).Fevents != 0 {
		e = (*T_xcb_in)(unsafe.Pointer(in)).Fevents
		(*T_xcb_in)(unsafe.Pointer(in)).Fevents = (*Tevent_list)(unsafe.Pointer(e)).Fnext
		libc.Xfree(tls, (*Tevent_list)(unsafe.Pointer(e)).Fevent)
		libc.Xfree(tls, e)
	}
	for (*T_xcb_in)(unsafe.Pointer(in)).Fpending_replies != 0 {
		pend = (*T_xcb_in)(unsafe.Pointer(in)).Fpending_replies
		(*T_xcb_in)(unsafe.Pointer(in)).Fpending_replies = (*Tpending_reply)(unsafe.Pointer(pend)).Fnext
		libc.Xfree(tls, pend)
	}
}

func X_xcb_in_wake_up_next_reader(tls *libc.TLS, c uintptr) {
	var pthreadret int32
	_ = pthreadret
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freaders != 0 {
		pthreadret = libc.Xpthread_cond_signal(tls, (*Treader_list1)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Freaders)).Fdata)
	} else {
		if (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fspecial_waiters != 0 {
			pthreadret = libc.Xpthread_cond_signal(tls, (*Tspecial_list1)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fspecial_waiters)).Fse+40)
		} else {
			pthreadret = libc.Xpthread_cond_signal(tls, c+32)
		}
	}
}

func X_xcb_in_expect_reply(tls *libc.TLS, c uintptr, request Tuint64_t, workaround _workarounds, flags int32) (r int32) {
	var pend uintptr
	var v1 Tuint64_t
	_, _ = pend, v1
	pend = libc.Xmalloc(tls, uint64(32))
	if !(pend != 0) {
		X_xcb_conn_shutdown(tls, c, int32(m_XCB_CONN_CLOSED_MEM_INSUFFICIENT))
		return 0
	}
	v1 = request
	(*Tpending_reply)(unsafe.Pointer(pend)).Flast_request = v1
	(*Tpending_reply)(unsafe.Pointer(pend)).Ffirst_request = v1
	(*Tpending_reply)(unsafe.Pointer(pend)).Fworkaround = workaround
	(*Tpending_reply)(unsafe.Pointer(pend)).Fflags = flags
	(*Tpending_reply)(unsafe.Pointer(pend)).Fnext = uintptr(0)
	*(*uintptr)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fpending_replies_tail)) = pend
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fpending_replies_tail = pend + 24
	return int32(1)
}

func X_xcb_in_replies_done(tls *libc.TLS, c uintptr) {
	var pend, prev_next uintptr
	_, _ = pend, prev_next
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fpending_replies_tail != c+32+4200 {
		pend = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fpending_replies_tail - uintptr(Tsize_t(libc.UintptrFromInt32(0)+24))
		if (*Tpending_reply1)(unsafe.Pointer(pend)).Fworkaround == int32(_WORKAROUND_EXTERNAL_SOCKET_OWNER) {
			if libc.Int64FromUint64((*Tpending_reply1)(unsafe.Pointer(pend)).Ffirst_request-(*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest) <= 0 {
				(*Tpending_reply1)(unsafe.Pointer(pend)).Flast_request = (*Txcb_connection_t)(unsafe.Pointer(c)).Fout.Frequest
				(*Tpending_reply1)(unsafe.Pointer(pend)).Fworkaround = int32(_WORKAROUND_NONE)
			} else {
				/* The socket was taken, but no requests were actually sent
				 * so just discard the pending_reply that was created.
				 */
				prev_next = c + 32 + 4200
				for *(*uintptr)(unsafe.Pointer(prev_next)) != pend {
					prev_next = *(*uintptr)(unsafe.Pointer(prev_next)) + 24
				}
				*(*uintptr)(unsafe.Pointer(prev_next)) = libc.UintptrFromInt32(0)
				(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fpending_replies_tail = prev_next
				libc.Xfree(tls, pend)
			}
		}
	}
}

func X_xcb_in_read(tls *libc.TLS, c uintptr) (r int32) {
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var hdr, v2, v3, v4, v5 uintptr
	var i, n, nfd int32
	var _ /* cmsgbuf at bp+16 */ struct {
		Fbuf         [0][80]int8
		Fcmsghdr     Tcmsghdr
		F__ccgo_pad2 [68]byte
	}
	var _ /* iov at bp+0 */ Tiovec
	var _ /* msg at bp+96 */ Tmsghdr
	_, _, _, _, _, _, _, _ = hdr, i, n, nfd, v2, v3, v4, v5
	*(*Tiovec)(unsafe.Pointer(bp)) = Tiovec{
		Fiov_base: c + 32 + 12 + uintptr((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fqueue_len),
		Fiov_len:  uint64(4096) - libc.Uint64FromInt32((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fqueue_len),
	}
	*(*Tmsghdr)(unsafe.Pointer(bp + 96)) = Tmsghdr{
		Fmsg_iov:        bp,
		Fmsg_iovlen:     int32(1),
		Fmsg_control:    bp + 16,
		Fmsg_controllen: uint32((libc.Uint64FromInt64(12)+(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1))) & ^(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1)) + (libc.Uint64FromInt64(4)*libc.Uint64FromInt32(libc.Int32FromInt32(m_XCB_MAX_PASS_FD)-(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fnfd)+(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1))) & ^(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1))),
	}
	n = int32(libc.Xrecvmsg(tls, (*Txcb_connection_t)(unsafe.Pointer(c)).Ffd, bp+96, 0))
	/* Check for truncation errors. Only MSG_CTRUNC is
	 * probably possible here, which would indicate that
	 * the sender tried to transmit more than XCB_MAX_PASS_FD
	 * file descriptors.
	 */
	if (*(*Tmsghdr)(unsafe.Pointer(bp + 96))).Fmsg_flags&(libc.Int32FromInt32(m_MSG_TRUNC1)|libc.Int32FromInt32(m_MSG_CTRUNC1)) != 0 {
		X_xcb_conn_shutdown(tls, c, int32(m_XCB_CONN_CLOSED_FDPASSING_FAILED))
		return 0
	}
	if n > 0 {
		if uint64((*(*Tmsghdr)(unsafe.Pointer(bp + 96))).Fmsg_controllen) >= uint64(12) {
			if uint64((*Tmsghdr)(unsafe.Pointer(bp+96)).Fmsg_controllen) >= uint64(12) {
				v2 = (*Tmsghdr)(unsafe.Pointer(bp + 96)).Fmsg_control
			} else {
				v2 = libc.UintptrFromInt32(0)
			}
			hdr = v2
			for {
				if !(hdr != 0) {
					break
				}
				if (*Tcmsghdr)(unsafe.Pointer(hdr)).Fcmsg_level == int32(m_SOL_SOCKET) && (*Tcmsghdr)(unsafe.Pointer(hdr)).Fcmsg_type == int32(m_SCM_RIGHTS) {
					nfd = libc.Int32FromUint64((uint64((*Tcmsghdr)(unsafe.Pointer(hdr)).Fcmsg_len) - ((libc.Uint64FromInt64(12)+(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1))) & ^(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1)) + libc.Uint64FromInt32(libc.Int32FromInt32(0)))) / uint64(4))
					libc.Xmemcpy(tls, c+32+4216+uintptr((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fnfd)*4, hdr+uintptr((libc.Uint64FromInt64(12)+(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1))) & ^(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1))), libc.Uint64FromInt32(nfd)*uint64(4))
					(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fnfd += nfd
				}
				goto _1
			_1:
				;
				if hdr == libc.UintptrFromInt32(0) {
					if uint64((*Tmsghdr)(unsafe.Pointer(bp+96)).Fmsg_controllen) >= uint64(12) {
						v4 = (*Tmsghdr)(unsafe.Pointer(bp + 96)).Fmsg_control
					} else {
						v4 = libc.UintptrFromInt32(0)
					}
					v3 = v4
				} else {
					if hdr+uintptr((uint64((*Tcmsghdr)(unsafe.Pointer(hdr)).Fcmsg_len)+(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1))) & ^(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1)))+uintptr((libc.Uint64FromInt64(12)+(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1))) & ^(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1))) > (*Tmsghdr)(unsafe.Pointer(bp+96)).Fmsg_control+uintptr((*Tmsghdr)(unsafe.Pointer(bp+96)).Fmsg_controllen) {
						v5 = libc.UintptrFromInt32(0)
					} else {
						v5 = hdr + uintptr((uint64((*Tcmsghdr)(unsafe.Pointer(hdr)).Fcmsg_len)+(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1))) & ^(libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1)))
					}
					v3 = v5
				}
				hdr = v3
			}
		}
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Ftotal_read += libc.Uint64FromInt32(n)
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fqueue_len += n
	}
	for _read_packet(tls, c) != 0 {
		/* empty */
	}
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fnfd != 0 {
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fnfd -= (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fifd
		libc.Xmemmove(tls, c+32+4216, c+32+4216+uintptr((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fifd)*4, libc.Uint64FromInt32((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fnfd)*uint64(4))
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fifd = 0
		/* If we have any left-over file descriptors after emptying
		 * the input buffer, then the server sent some that we weren't
		 * expecting.  Close them and mark the connection as broken;
		 */
		if (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fqueue_len == 0 && (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fnfd != 0 {
			i = 0
			for {
				if !(i < (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fin_fd.Fnfd) {
					break
				}
				libc.Xclose(tls, *(*int32)(unsafe.Pointer(c + 32 + 4216 + uintptr(i)*4)))
				goto _6
			_6:
				;
				i++
			}
			X_xcb_conn_shutdown(tls, c, int32(m_XCB_CONN_CLOSED_FDPASSING_FAILED))
			return 0
		}
	}
	if n > 0 || n < 0 && (*(*int32)(unsafe.Pointer(libc.X__error(tls))) == int32(m_EAGAIN) || *(*int32)(unsafe.Pointer(libc.X__error(tls))) == int32(m_EINTR)) {
		return int32(1)
	}
	X_xcb_conn_shutdown(tls, c, int32(m_XCB_CONN_ERROR))
	return 0
}

func X_xcb_in_read_block(tls *libc.TLS, c uintptr, buf uintptr, len1 int32) (r int32) {
	var done, ret int32
	_, _ = done, ret
	done = (*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fqueue_len
	if len1 < done {
		done = len1
	}
	libc.Xmemcpy(tls, buf, c+32+12, libc.Uint64FromInt32(done))
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fqueue_len -= done
	libc.Xmemmove(tls, c+32+12, c+32+12+uintptr(done), libc.Uint64FromInt32((*Txcb_connection_t)(unsafe.Pointer(c)).Fin.Fqueue_len))
	if len1 > done {
		ret = _read_block(tls, (*Txcb_connection_t)(unsafe.Pointer(c)).Ffd, buf+uintptr(done), int64(len1-done))
		if ret <= 0 {
			X_xcb_conn_shutdown(tls, c, int32(m_XCB_CONN_ERROR))
			return ret
		}
	}
	return len1
}

type Tpending_reply1 = struct {
	Ffirst_request Tuint64_t
	Flast_request  Tuint64_t
	Fworkaround    _workarounds
	Fflags         int32
	Fnext          uintptr
}

type Treader_list1 = struct {
	Frequest Tuint64_t
	Fdata    uintptr
	Fnext    uintptr
}

type Tspecial_list1 = struct {
	Fse   uintptr
	Fnext uintptr
}

type Txcb_ge_special_event_t1 = struct {
	Fresponse_type Tuint8_t
	Fextension     Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fevtype        Tuint16_t
	Fpad0          [2]Tuint8_t
	Feid           Tuint32_t
	Fpad1          [16]Tuint8_t
}

const m_INT32_MAX2 = 0x7fffffff
const m_UINT32_MAX2 = 0xffffffff

type Tlazyreply = struct {
	Ftag   _lazy_reply_tag
	Fvalue struct {
		Freply       [0]uintptr
		Fcookie      Txcb_query_extension_cookie_t
		F__ccgo_pad2 [4]byte
	}
}

func _get_index(tls *libc.TLS, c uintptr, idx int32) (r uintptr) {
	var new_extensions uintptr
	var new_size int32
	_, _ = new_extensions, new_size
	if idx > (*Txcb_connection_t)(unsafe.Pointer(c)).Fext.Fextensions_size {
		new_size = idx << int32(1)
		new_extensions = libc.Xrealloc(tls, (*Txcb_connection_t)(unsafe.Pointer(c)).Fext.Fextensions, uint64(16)*libc.Uint64FromInt32(new_size))
		if !(new_extensions != 0) {
			return uintptr(0)
		}
		libc.Xmemset(tls, new_extensions+uintptr((*Txcb_connection_t)(unsafe.Pointer(c)).Fext.Fextensions_size)*16, 0, uint64(16)*libc.Uint64FromInt32(new_size-(*Txcb_connection_t)(unsafe.Pointer(c)).Fext.Fextensions_size))
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fext.Fextensions = new_extensions
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fext.Fextensions_size = new_size
	}
	return (*Txcb_connection_t)(unsafe.Pointer(c)).Fext.Fextensions + uintptr(idx)*16 - uintptr(1)*16
}

func _get_lazyreply(tls *libc.TLS, c uintptr, ext uintptr) (r uintptr) {
	var data uintptr
	var v1 int32
	_, _ = data, v1
	libc.Xpthread_mutex_lock(tls, uintptr(unsafe.Pointer(&_global_lock)))
	if !((*Txcb_extension_t)(unsafe.Pointer(ext)).Fglobal_id != 0) {
		_next_global_id++
		v1 = _next_global_id
		(*Txcb_extension_t)(unsafe.Pointer(ext)).Fglobal_id = v1
	}
	libc.Xpthread_mutex_unlock(tls, uintptr(unsafe.Pointer(&_global_lock)))
	data = _get_index(tls, c, (*Txcb_extension_t)(unsafe.Pointer(ext)).Fglobal_id)
	if data != 0 && (*Tlazyreply)(unsafe.Pointer(data)).Ftag == int32(_LAZY_NONE) {
		/* cache miss: query the server */
		(*Tlazyreply)(unsafe.Pointer(data)).Ftag = int32(_LAZY_COOKIE)
		(*Tlazyreply)(unsafe.Pointer(data)).Fvalue.Fcookie = Xxcb_query_extension(tls, c, uint16(libc.Xstrlen(tls, (*Txcb_extension_t)(unsafe.Pointer(ext)).Fname)), (*Txcb_extension_t)(unsafe.Pointer(ext)).Fname)
	}
	return data
}

var _global_lock = libc.UintptrFromInt32(0)

var _next_global_id int32

/* Public interface */

// C documentation
//
//	/* Do not free the returned xcb_query_extension_reply_t - on return, it's aliased
//	 * from the cache. */
func Xxcb_get_extension_data(tls *libc.TLS, c uintptr, ext uintptr) (r uintptr) {
	var data, v1 uintptr
	_, _ = data, v1
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return uintptr(0)
	}
	libc.Xpthread_mutex_lock(tls, c+20880)
	data = _get_lazyreply(tls, c, ext)
	if data != 0 && (*Tlazyreply)(unsafe.Pointer(data)).Ftag == int32(_LAZY_COOKIE) {
		(*Tlazyreply)(unsafe.Pointer(data)).Ftag = int32(_LAZY_FORCED)
		*(*uintptr)(unsafe.Pointer(data + 8)) = Xxcb_query_extension_reply(tls, c, (*Tlazyreply)(unsafe.Pointer(data)).Fvalue.Fcookie, uintptr(0))
	}
	libc.Xpthread_mutex_unlock(tls, c+20880)
	if data != 0 {
		v1 = *(*uintptr)(unsafe.Pointer(data + 8))
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func Xxcb_prefetch_extension_data(tls *libc.TLS, c uintptr, ext uintptr) {
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return
	}
	libc.Xpthread_mutex_lock(tls, c+20880)
	_get_lazyreply(tls, c, ext)
	libc.Xpthread_mutex_unlock(tls, c+20880)
}

/* Private interface */

func X_xcb_ext_init(tls *libc.TLS, c uintptr) (r int32) {
	if libc.Xpthread_mutex_init(tls, c+20880, uintptr(0)) != 0 {
		return 0
	}
	return int32(1)
}

func X_xcb_ext_destroy(tls *libc.TLS, c uintptr) {
	var v1 int32
	var v2 uintptr
	_, _ = v1, v2
	libc.Xpthread_mutex_destroy(tls, c+20880)
	for {
		v2 = c + 20880 + 16
		v1 = *(*int32)(unsafe.Pointer(v2))
		*(*int32)(unsafe.Pointer(v2))--
		if !(v1 > 0) {
			break
		}
		if (*(*Tlazyreply1)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fext.Fextensions + uintptr((*Txcb_connection_t)(unsafe.Pointer(c)).Fext.Fextensions_size)*16))).Ftag == int32(_LAZY_FORCED) {
			libc.Xfree(tls, *(*uintptr)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fext.Fextensions + uintptr((*Txcb_connection_t)(unsafe.Pointer(c)).Fext.Fextensions_size)*16 + 8)))
		}
	}
	libc.Xfree(tls, (*Txcb_connection_t)(unsafe.Pointer(c)).Fext.Fextensions)
}

type Tlazyreply1 = struct {
	Ftag   _lazy_reply_tag
	Fvalue struct {
		Freply       [0]uintptr
		Fcookie      Txcb_query_extension_cookie_t
		F__ccgo_pad2 [4]byte
	}
}

const m_XCB_XCMISC_MAJOR_VERSION = 1
const m_XCB_XCMISC_MINOR_VERSION = 1
const m_XCB_XC_MISC_GET_VERSION = 0
const m_XCB_XC_MISC_GET_XID_LIST = 2
const m_XCB_XC_MISC_GET_XID_RANGE = 1

type Txcb_xc_misc_get_version_cookie_t = struct {
	Fsequence uint32
}

type Txcb_xc_misc_get_version_request_t = struct {
	Fmajor_opcode         Tuint8_t
	Fminor_opcode         Tuint8_t
	Flength               Tuint16_t
	Fclient_major_version Tuint16_t
	Fclient_minor_version Tuint16_t
}

type Txcb_xc_misc_get_version_reply_t = struct {
	Fresponse_type        Tuint8_t
	Fpad0                 Tuint8_t
	Fsequence             Tuint16_t
	Flength               Tuint32_t
	Fserver_major_version Tuint16_t
	Fserver_minor_version Tuint16_t
}

type Txcb_xc_misc_get_xid_range_cookie_t = struct {
	Fsequence uint32
}

type Txcb_xc_misc_get_xid_range_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fminor_opcode Tuint8_t
	Flength       Tuint16_t
}

type Txcb_xc_misc_get_xid_range_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fstart_id      Tuint32_t
	Fcount         Tuint32_t
}

type Txcb_xc_misc_get_xid_list_cookie_t = struct {
	Fsequence uint32
}

type Txcb_xc_misc_get_xid_list_request_t = struct {
	Fmajor_opcode Tuint8_t
	Fminor_opcode Tuint8_t
	Flength       Tuint16_t
	Fcount        Tuint32_t
}

type Txcb_xc_misc_get_xid_list_reply_t = struct {
	Fresponse_type Tuint8_t
	Fpad0          Tuint8_t
	Fsequence      Tuint16_t
	Flength        Tuint32_t
	Fids_len       Tuint32_t
	Fpad1          [20]Tuint8_t
}

/**
 * @}
 */

/* Public interface */

func Xxcb_generate_id(tls *libc.TLS, c uintptr) (r Tuint32_t) {
	var range1, xc_misc_reply uintptr
	var ret Tuint32_t
	_, _, _ = range1, ret, xc_misc_reply
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		return libc.Uint32FromInt32(-libc.Int32FromInt32(1))
	}
	libc.Xpthread_mutex_lock(tls, c+20904)
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Flast >= (*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Fmax-(*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Finc+uint32(1) {
		if (*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Flast == uint32(0) {
			/* finish setting up initial range */
			(*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Fmax = (*Txcb_setup_t)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup)).Fresource_id_mask
		} else {
			/* check for extension */
			xc_misc_reply = Xxcb_get_extension_data(tls, c, uintptr(unsafe.Pointer(&Xxcb_xc_misc_id)))
			if !(xc_misc_reply != 0) || !((*Txcb_query_extension_reply_t)(unsafe.Pointer(xc_misc_reply)).Fpresent != 0) {
				libc.Xpthread_mutex_unlock(tls, c+20904)
				return libc.Uint32FromInt32(-libc.Int32FromInt32(1))
			}
			/* get new range */
			range1 = Xxcb_xc_misc_get_xid_range_reply(tls, c, Xxcb_xc_misc_get_xid_range(tls, c), uintptr(0))
			/* XXX The latter disjunct is what the server returns
			   when it is out of XIDs.  Sweet. */
			if !(range1 != 0) || (*Txcb_xc_misc_get_xid_range_reply_t)(unsafe.Pointer(range1)).Fstart_id == uint32(0) && (*Txcb_xc_misc_get_xid_range_reply_t)(unsafe.Pointer(range1)).Fcount == uint32(1) {
				libc.Xpthread_mutex_unlock(tls, c+20904)
				return libc.Uint32FromInt32(-libc.Int32FromInt32(1))
			}
			(*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Flast = (*Txcb_xc_misc_get_xid_range_reply_t)(unsafe.Pointer(range1)).Fstart_id
			(*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Fmax = (*Txcb_xc_misc_get_xid_range_reply_t)(unsafe.Pointer(range1)).Fstart_id + ((*Txcb_xc_misc_get_xid_range_reply_t)(unsafe.Pointer(range1)).Fcount-uint32(1))*(*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Finc
			libc.Xfree(tls, range1)
		}
	} else {
		(*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Flast += (*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Finc
	}
	ret = (*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Flast | (*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Fbase
	libc.Xpthread_mutex_unlock(tls, c+20904)
	return ret
}

/* Private interface */

func X_xcb_xid_init(tls *libc.TLS, c uintptr) (r int32) {
	if libc.Xpthread_mutex_init(tls, c+20904, uintptr(0)) != 0 {
		return 0
	}
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Flast = uint32(0)
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Fmax = uint32(0)
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Fbase = (*Txcb_setup_t)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup)).Fresource_id_base
	(*Txcb_connection_t)(unsafe.Pointer(c)).Fxid.Finc = (*Txcb_setup_t)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup)).Fresource_id_mask & -(*Txcb_setup_t)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup)).Fresource_id_mask
	return int32(1)
}

func X_xcb_xid_destroy(tls *libc.TLS, c uintptr) {
	libc.Xpthread_mutex_destroy(tls, c+20904)
}

type T_xcb_map = struct {
	Fhead uintptr
	Ftail uintptr
}

type Tnode = struct {
	Fnext uintptr
	Fkey  Tuint64_t
	Fdata uintptr
}

type T_xcb_map1 = struct {
	Fhead uintptr
	Ftail uintptr
}

/* Private interface */

func X_xcb_map_new(tls *libc.TLS) (r uintptr) {
	var list uintptr
	_ = list
	list = libc.Xmalloc(tls, uint64(16))
	if !(list != 0) {
		return uintptr(0)
	}
	(*T_xcb_map)(unsafe.Pointer(list)).Fhead = uintptr(0)
	(*T_xcb_map)(unsafe.Pointer(list)).Ftail = list
	return list
}

func X_xcb_map_delete(tls *libc.TLS, list uintptr, do_free Txcb_list_free_func_t) {
	var cur uintptr
	_ = cur
	if !(list != 0) {
		return
	}
	for (*T_xcb_map)(unsafe.Pointer(list)).Fhead != 0 {
		cur = (*T_xcb_map)(unsafe.Pointer(list)).Fhead
		if do_free != 0 {
			(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{do_free})))(tls, (*Tnode)(unsafe.Pointer(cur)).Fdata)
		}
		(*T_xcb_map)(unsafe.Pointer(list)).Fhead = (*Tnode)(unsafe.Pointer(cur)).Fnext
		libc.Xfree(tls, cur)
	}
	libc.Xfree(tls, list)
}

func X_xcb_map_put(tls *libc.TLS, list uintptr, key Tuint64_t, data uintptr) (r int32) {
	var cur uintptr
	_ = cur
	cur = libc.Xmalloc(tls, uint64(24))
	if !(cur != 0) {
		return 0
	}
	(*Tnode)(unsafe.Pointer(cur)).Fkey = key
	(*Tnode)(unsafe.Pointer(cur)).Fdata = data
	(*Tnode)(unsafe.Pointer(cur)).Fnext = uintptr(0)
	*(*uintptr)(unsafe.Pointer((*T_xcb_map)(unsafe.Pointer(list)).Ftail)) = cur
	(*T_xcb_map)(unsafe.Pointer(list)).Ftail = cur
	return int32(1)
}

func X_xcb_map_remove(tls *libc.TLS, list uintptr, key Tuint64_t) (r uintptr) {
	var cur, ret, tmp uintptr
	_, _, _ = cur, ret, tmp
	cur = list
	for {
		if !(*(*uintptr)(unsafe.Pointer(cur)) != 0) {
			break
		}
		if (*Tnode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(cur)))).Fkey == key {
			tmp = *(*uintptr)(unsafe.Pointer(cur))
			ret = (*Tnode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(cur)))).Fdata
			*(*uintptr)(unsafe.Pointer(cur)) = (*Tnode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(cur)))).Fnext
			if !(*(*uintptr)(unsafe.Pointer(cur)) != 0) {
				(*T_xcb_map)(unsafe.Pointer(list)).Ftail = cur
			}
			libc.Xfree(tls, tmp)
			return ret
		}
		goto _1
	_1:
		;
		cur = *(*uintptr)(unsafe.Pointer(cur))
	}
	return uintptr(0)
}

const m_AI_ADDRCONFIG = 0x00000400
const m_AI_ALL = 0x00000100
const m_AI_CANONNAME = 0x00000002
const m_AI_NUMERICHOST = 4
const m_AI_NUMERICSERV = 8
const m_AI_PASSIVE = 0x00000001
const m_AI_V4MAPPED = 0x00000800
const m_AI_V4MAPPED_CFG = 0x00000200
const m_CPUCLOCK_WHICH_PID = 0
const m_CPUCLOCK_WHICH_TID = 1
const m_DST_AUST = 2
const m_DST_CAN = 6
const m_DST_EET = 5
const m_DST_MET = 4
const m_DST_NONE = 0
const m_DST_USA = 1
const m_DST_WET = 3
const m_EAI_ADDRFAMILY = 1
const m_EAI_AGAIN = 2
const m_EAI_BADFLAGS = 3
const m_EAI_BADHINTS = 12
const m_EAI_FAIL = 4
const m_EAI_FAMILY = 5
const m_EAI_MAX = 15
const m_EAI_MEMORY = 6
const m_EAI_NODATA = 7
const m_EAI_NONAME = 8
const m_EAI_OVERFLOW = 14
const m_EAI_PROTOCOL = 13
const m_EAI_SERVICE = 9
const m_EAI_SOCKTYPE = 10
const m_EAI_SYSTEM = 11
const m_HOST_NOT_FOUND = 1
const m_ITIMER_PROF = 2
const m_ITIMER_REAL = 0
const m_ITIMER_VIRTUAL = 1
const m_LOCAL_CONNWAIT = 4
const m_LOCAL_CREDS = 2
const m_LOCAL_CREDS_PERSISTENT = 3
const m_LOCAL_PEERCRED = 1
const m_LOCAL_VENDOR = "SO_VENDOR"
const m_MAX_SACK_BLKS = 6
const m_MAX_TCPOPTLEN = 40
const m_MSG_CTRUNC2 = 0x00000020
const m_MSG_TRUNC2 = 0x00000010
const m_NETDB_SUCCESS = 0
const m_NI_DGRAM = 0x00000010
const m_NI_MAXHOST = 1025
const m_NI_MAXSERV = 32
const m_NI_NAMEREQD = 0x00000004
const m_NI_NOFQDN = 0x00000001
const m_NI_NUMERICHOST = 0x00000002
const m_NI_NUMERICSCOPE = 0x00000020
const m_NI_NUMERICSERV = 0x00000008
const m_NO_ADDRESS = "NO_DATA"
const m_NO_DATA = 4
const m_NO_RECOVERY = 3
const m_O_NONBLOCK1 = 0x0004
const m_PRINT_TH_FLAGS = "\\20\\1FIN\\2SYN\\3RST\\4PUSH\\5ACK\\6URG\\7ECE\\10CWR\\11AE"
const m_SBT_MAX = 0x7fffffffffffffff
const m_SCM_RIGHTS1 = 0x01
const m_SCOPE_DELIMITER = '%'
const m_SF_APPEND = 0x00040000
const m_SF_ARCHIVED = 0x00010000
const m_SF_IMMUTABLE = 0x00020000
const m_SF_NOUNLINK = 0x00100000
const m_SF_SETTABLE = 0xffff0000
const m_SF_SNAPSHOT = 0x00200000
const m_SOCK_CLOEXEC1 = 268435456
const m_SOL_LOCAL = 0
const m_SO_KEEPALIVE1 = 8
const m_SO_SNDBUF1 = 4097
const m_SUNPATHLEN = 104
const m_S_BLKSIZE = 512
const m_S_IEXEC = "S_IXUSR"
const m_S_IFBLK = 0060000
const m_S_IFCHR = 0020000
const m_S_IFDIR = 0040000
const m_S_IFIFO = 0010000
const m_S_IFLNK = 0120000
const m_S_IFMT = 0170000
const m_S_IFREG = 0100000
const m_S_IFSOCK = 0140000
const m_S_IFWHT = 0160000
const m_S_IREAD = "S_IRUSR"
const m_S_IRGRP = 0000040
const m_S_IROTH = 0000004
const m_S_IRUSR = 0000400
const m_S_IRWXG = 0000070
const m_S_IRWXO = 0000007
const m_S_IRWXU = 0000700
const m_S_ISGID = 0002000
const m_S_ISTXT = 0001000
const m_S_ISUID = 0004000
const m_S_ISVTX = 0001000
const m_S_IWGRP = 0000020
const m_S_IWOTH = 0000002
const m_S_IWRITE = "S_IWUSR"
const m_S_IWUSR = 0000200
const m_S_IXGRP = 0000010
const m_S_IXOTH = 0000001
const m_S_IXUSR = 0000100
const m_TCP6_MSS = 1220
const m_TCPI_OPT_ACE = 0x40
const m_TCPI_OPT_ECN = 0x08
const m_TCPI_OPT_SACK = 0x02
const m_TCPI_OPT_TFO = 0x20
const m_TCPI_OPT_TIMESTAMPS = 0x01
const m_TCPI_OPT_TOE = 0x10
const m_TCPI_OPT_WSCALE = 0x04
const m_TCPOLEN_EOL = 1
const m_TCPOLEN_FAST_OPEN_EMPTY = 2
const m_TCPOLEN_MAXSEG = 4
const m_TCPOLEN_NOP = 1
const m_TCPOLEN_PAD = 1
const m_TCPOLEN_SACK = 8
const m_TCPOLEN_SACKHDR = 2
const m_TCPOLEN_SACK_PERMITTED = 2
const m_TCPOLEN_SIGNATURE = 18
const m_TCPOLEN_TIMESTAMP = 10
const m_TCPOLEN_WINDOW = 3
const m_TCPOPT_EOL = 0
const m_TCPOPT_FAST_OPEN = 34
const m_TCPOPT_MAXSEG = 2
const m_TCPOPT_NOP = 1
const m_TCPOPT_PAD = 0
const m_TCPOPT_SACK = 5
const m_TCPOPT_SACK_PERMITTED = 4
const m_TCPOPT_SIGNATURE = 19
const m_TCPOPT_TIMESTAMP = 8
const m_TCPOPT_WINDOW = 3
const m_TCP_BBR_ACK_COMP_ALG = 1096
const m_TCP_BBR_ALGORITHM = 1083
const m_TCP_BBR_DRAIN_INC_EXTRA = 1084
const m_TCP_BBR_DRAIN_PG = 1070
const m_TCP_BBR_EXTRA_GAIN = 1097
const m_TCP_BBR_EXTRA_STATE = 1107
const m_TCP_BBR_FLOOR_MIN_TSO = 1108
const m_TCP_BBR_HDWR_PACE = 1105
const m_TCP_BBR_HOLD_TARGET = 1078
const m_TCP_BBR_IWINTSO = 1067
const m_TCP_BBR_LOWGAIN_FD = 1078
const m_TCP_BBR_LOWGAIN_HALF = 1077
const m_TCP_BBR_LOWGAIN_THRESH = 1076
const m_TCP_BBR_MAX_RTO = 1081
const m_TCP_BBR_MIN_RTO = 1080
const m_TCP_BBR_MIN_TOPACEOUT = 1109
const m_TCP_BBR_ONE_RETRAN = 1073
const m_TCP_BBR_PACE_CROSS = 1090
const m_TCP_BBR_PACE_DEL_TAR = 1087
const m_TCP_BBR_PACE_OH = 1077
const m_TCP_BBR_PACE_PER_SEC = 1086
const m_TCP_BBR_PACE_SEG_MAX = 1088
const m_TCP_BBR_PACE_SEG_MIN = 1089
const m_TCP_BBR_POLICER_DETECT = 1111
const m_TCP_BBR_PROBE_RTT_GAIN = 1101
const m_TCP_BBR_PROBE_RTT_INT = 1072
const m_TCP_BBR_PROBE_RTT_LEN = 1102
const m_TCP_BBR_RACK_INIT_RATE = 1112
const m_TCP_BBR_RACK_RTT_USE = 1098
const m_TCP_BBR_RECFORCE = 1068
const m_TCP_BBR_REC_OVER_HPTS = 1082
const m_TCP_BBR_RETRAN_WTSO = 1099
const m_TCP_BBR_RWND_IS_APP = 1071
const m_TCP_BBR_SEND_IWND_IN_TSO = 1103
const m_TCP_BBR_STARTUP_EXIT_EPOCH = 1085
const m_TCP_BBR_STARTUP_LOSS_EXIT = 1074
const m_TCP_BBR_STARTUP_PG = 1069
const m_TCP_BBR_TMR_PACE_OH = 1096
const m_TCP_BBR_TSLIMITS = 1076
const m_TCP_BBR_TSTMP_RAISES = 1110
const m_TCP_BBR_UNLIMITED = 1083
const m_TCP_BBR_USEDEL_RATE = 1079
const m_TCP_BBR_USE_LOWGAIN = 1075
const m_TCP_BBR_USE_RACK_CHEAT = "TCP_BBR_USE_RACK_RR"
const m_TCP_BBR_USE_RACK_RR = 1104
const m_TCP_BBR_UTTER_MAX_TSO = 1106
const m_TCP_CA_NAME_MAX = 16
const m_TCP_CCALGOOPT = 65
const m_TCP_CONGESTION = 64
const m_TCP_DATA_AFTER_CLOSE = 1100
const m_TCP_DEFER_OPTIONS = 1136
const m_TCP_DELACK = 72
const m_TCP_FASTOPEN = 1025
const m_TCP_FASTOPEN_MAX_COOKIE_LEN = 16
const m_TCP_FASTOPEN_MIN_COOKIE_LEN = 4
const m_TCP_FASTOPEN_PSK_LEN = 16
const m_TCP_FAST_RSM_HACK = 1137
const m_TCP_FIN_IS_RST = 73
const m_TCP_FUNCTION_ALIAS = 8193
const m_TCP_FUNCTION_BLK = 8192
const m_TCP_FUNCTION_NAME_LEN_MAX = 32
const m_TCP_HDWR_RATE_CAP = 1130
const m_TCP_HDWR_UP_ONLY = 1132
const m_TCP_HYBRID_PACING = 1150
const m_TCP_HYBRID_PACING_CSPR = 0x0004
const m_TCP_HYBRID_PACING_CU = 0x0001
const m_TCP_HYBRID_PACING_DTL = 0x0002
const m_TCP_HYBRID_PACING_ENABLE = 0x0010
const m_TCP_HYBRID_PACING_H_MS = 0x0008
const m_TCP_HYBRID_PACING_SETMSS = 0x1000
const m_TCP_HYBRID_PACING_S_MSS = 0x0020
const m_TCP_HYBRID_PACING_WASSET = 0x2000
const m_TCP_IDLE_REDUCE = 70
const m_TCP_INFO = 32
const m_TCP_IWND_NB = 43
const m_TCP_IWND_NSEG = 44
const m_TCP_KEEPCNT = 1024
const m_TCP_KEEPIDLE = 256
const m_TCP_KEEPINIT = 128
const m_TCP_KEEPINTVL = 512
const m_TCP_LOG = 34
const m_TCP_LOGBUF = 35
const m_TCP_LOGDUMP = 37
const m_TCP_LOGDUMPID = 38
const m_TCP_LOGID = 36
const m_TCP_LOGID_CNT = 46
const m_TCP_LOG_HTTPD_RANGE_END = 0x0002
const m_TCP_LOG_HTTPD_RANGE_START = 0x0001
const m_TCP_LOG_HTTPD_TS = 1
const m_TCP_LOG_HTTPD_TS_REQ = 2
const m_TCP_LOG_ID_LEN = 64
const m_TCP_LOG_LIMIT = 74
const m_TCP_LOG_TAG = 47
const m_TCP_LOG_USER_HTTPD = 1
const m_TCP_LRD = 79
const m_TCP_MAXBURST = 4
const m_TCP_MAXPEAKRATE = 69
const m_TCP_MAXSEG = 2
const m_TCP_MAXUNACKTIME = 68
const m_TCP_MAXWIN = 65535
const m_TCP_MAX_SACK = 4
const m_TCP_MAX_WINSHIFT = 14
const m_TCP_MD5SIG = 16
const m_TCP_MINMSS = 216
const m_TCP_MSS = 536
const m_TCP_NODELAY = 1
const m_TCP_NOOPT = 8
const m_TCP_NOPUSH = 4
const m_TCP_NO_PRR = 1122
const m_TCP_NUM_CNT_COUNTERS = 13
const m_TCP_NUM_PROC_COUNTERS = 11
const m_TCP_PACING_DND = 1151
const m_TCP_PACING_RATE_CAP = 1131
const m_TCP_PCAP_IN = 4096
const m_TCP_PCAP_OUT = 2048
const m_TCP_PERF_INFO = 78
const m_TCP_PROC_ACCOUNTING = 76
const m_TCP_RACK_ABC_VAL = 1133
const m_TCP_RACK_CHEAT_NOT_CONF_RATE = "TCP_RACK_RR_CONF"
const m_TCP_RACK_DGP_IN_REC = 1148
const m_TCP_RACK_DO_DETECTION = 1097
const m_TCP_RACK_DSACK_OPT = 1141
const m_TCP_RACK_EARLY_RECOV = 1059
const m_TCP_RACK_EARLY_SEG = 1060
const m_TCP_RACK_ENABLE_HYSTART = 1142
const m_TCP_RACK_FORCE_MSEG = 1117
const m_TCP_RACK_GP_INCREASE = 1094
const m_TCP_RACK_GP_INCREASE_CA = 1114
const m_TCP_RACK_GP_INCREASE_REC = 1116
const m_TCP_RACK_GP_INCREASE_SS = 1115
const m_TCP_RACK_HI_BETA = 1144
const m_TCP_RACK_IDLE_REDUCE_HIGH = 1092
const m_TCP_RACK_MBUF_QUEUE = 1050
const m_TCP_RACK_MEASURE_CNT = 1135
const m_TCP_RACK_MIN_PACE = 1093
const m_TCP_RACK_MIN_PACE_SEG = 1094
const m_TCP_RACK_MIN_TO = 1058
const m_TCP_RACK_NONRXT_CFG_RATE = 1123
const m_TCP_RACK_NO_PUSH_AT_MAX = 1126
const m_TCP_RACK_PACE_ALWAYS = 1055
const m_TCP_RACK_PACE_MAX_SEG = 1054
const m_TCP_RACK_PACE_MIN_SEG = 1147
const m_TCP_RACK_PACE_RATE_CA = 1118
const m_TCP_RACK_PACE_RATE_REC = 1120
const m_TCP_RACK_PACE_RATE_SS = 1119
const m_TCP_RACK_PACE_REDUCE = 1053
const m_TCP_RACK_PACE_TO_FILL = 1127
const m_TCP_RACK_PACING_BETA = 1138
const m_TCP_RACK_PACING_BETA_ECN = 1139
const m_TCP_RACK_PACING_DIVISOR = 1146
const m_TCP_RACK_PKT_DELAY = 1064
const m_TCP_RACK_PROFILE = 1129
const m_TCP_RACK_PROP = 1051
const m_TCP_RACK_PROP_RATE = 1056
const m_TCP_RACK_PRR_SENDALOT = 1057
const m_TCP_RACK_REORD_FADE = 1062
const m_TCP_RACK_REORD_THRESH = 1061
const m_TCP_RACK_RR_CONF = 1113
const m_TCP_RACK_SET_RXT_OPTIONS = 1143
const m_TCP_RACK_SPLIT_LIMIT = 1145
const m_TCP_RACK_TIMER_SLOP = 1140
const m_TCP_RACK_TLP_INC_VAR = 1065
const m_TCP_RACK_TLP_REDUCE = 1052
const m_TCP_RACK_TLP_THRESH = 1063
const m_TCP_RACK_TLP_USE = 1095
const m_TCP_REC_ABC_VAL = 1134
const m_TCP_REMOTE_UDP_ENCAPS_PORT = 71
const m_TCP_REUSPORT_LB_NUMA = 1026
const m_TCP_RXTLS_ENABLE = 41
const m_TCP_RXTLS_MODE = 42
const m_TCP_RXT_CLAMP = 1149
const m_TCP_SHARED_CWND_ALLOWED = 75
const m_TCP_SHARED_CWND_ENABLE = 1124
const m_TCP_SHARED_CWND_TIME_LIMIT = 1128
const m_TCP_STATS = 33
const m_TCP_TIMELY_DYN_ADJ = 1125
const m_TCP_TLS_MODE_IFNET = 2
const m_TCP_TLS_MODE_NONE = 0
const m_TCP_TLS_MODE_SW = 1
const m_TCP_TLS_MODE_TOE = 3
const m_TCP_TXTLS_ENABLE = 39
const m_TCP_TXTLS_MODE = 40
const m_TCP_USER_LOG = 48
const m_TCP_USE_CMP_ACKS = 77
const m_TCP_VENDOR = "SO_VENDOR"
const m_TH_ACK = 0x10
const m_TH_AE = 0x100
const m_TH_CWR = 0x80
const m_TH_ECE = 0x40
const m_TH_FIN = 0x01
const m_TH_PUSH = 0x08
const m_TH_RES1 = 0x800
const m_TH_RES2 = 0x400
const m_TH_RES3 = 0x200
const m_TH_RST = 0x04
const m_TH_SYN = 0x02
const m_TH_URG = 0x20
const m_TLS_GET_RECORD = 2
const m_TLS_SET_RECORD_TYPE = 1
const m_TRY_AGAIN = 2
const m_TTCP_CLIENT_SND_WND = 4096
const m_UF_APPEND = 0x00000004
const m_UF_ARCHIVE = 0x00000800
const m_UF_HIDDEN = 0x00008000
const m_UF_IMMUTABLE = 0x00000002
const m_UF_NODUMP = 0x00000001
const m_UF_NOUNLINK = 0x00000010
const m_UF_OFFLINE = 0x00000200
const m_UF_OPAQUE = 0x00000008
const m_UF_READONLY = 0x00001000
const m_UF_REPARSE = 0x00000400
const m_UF_SETTABLE = 0x0000ffff
const m_UF_SPARSE = 0x00000100
const m_UF_SYSTEM = 0x00000080
const m_VOI_TCP_ACKLEN = 9
const m_VOI_TCP_CALCFRWINDIFF = 7
const m_VOI_TCP_CSIG = 5
const m_VOI_TCP_FRWIN = 2
const m_VOI_TCP_GPUT = 6
const m_VOI_TCP_GPUT_ND = 8
const m_VOI_TCP_LCWIN = 3
const m_VOI_TCP_PATHRTT = 10
const m_VOI_TCP_RETXPB = 1
const m_VOI_TCP_RTT = 4
const m_VOI_TCP_TXPB = 0
const m__PATH_HEQUIV = "/etc/hosts.equiv"
const m__PATH_HOSTS = "/etc/hosts"
const m__PATH_NETWORKS = "/etc/networks"
const m__PATH_PROTOCOLS = "/etc/protocols"
const m__PATH_SERVICES = "/etc/services"
const m__PATH_SERVICES_DB = "/var/db/services.db"
const m___INT_MAX1 = 2147483647
const m_inet_addr = "__inet_addr"
const m_inet_aton = "__inet_aton"
const m_inet_cidr_ntop = "__inet_cidr_ntop"
const m_inet_cidr_pton = "__inet_cidr_pton"
const m_inet_lnaof = "__inet_lnaof"
const m_inet_makeaddr = "__inet_makeaddr"
const m_inet_net_ntop = "__inet_net_ntop"
const m_inet_net_pton = "__inet_net_pton"
const m_inet_neta = "__inet_neta"
const m_inet_netof = "__inet_netof"
const m_inet_network = "__inet_network"
const m_inet_nsap_addr = "__inet_nsap_addr"
const m_inet_nsap_ntoa = "__inet_nsap_ntoa"
const m_inet_ntoa = "__inet_ntoa"
const m_inet_ntoa_r = "__inet_ntoa_r"
const m_inet_ntop = "__inet_ntop"
const m_inet_pton = "__inet_pton"
const m_st_atimespec = "st_atim"
const m_st_birthtimespec = "st_birthtim"
const m_st_ctimespec = "st_ctim"
const m_st_mtimespec = "st_mtim"
const m_tcp6_seq = "tcp_seq"
const m_tcp6hdr = "tcphdr"

type Tptrdiff_t = int64

type Tmax_align_t = struct {
	F__max_align1 int64
	F__max_align2 float64
}

type Tsockaddr_un = struct {
	Fsun_len    uint8
	Fsun_family Tsa_family_t
	Fsun_path   [104]int8
}

type Ttcp_seq = uint32

type Ttcphdr = struct {
	Fth_sport Tu_short
	Fth_dport Tu_short
	Fth_seq   Ttcp_seq
	Fth_ack   Ttcp_seq
	F__ccgo12 uint8
	Fth_flags Tu_char
	Fth_win   Tu_short
	Fth_sum   Tu_short
	Fth_urp   Tu_short
}

type Ttcp_perf_info = struct {
	Ftcp_cnt_counters [13]Tuint64_t
	Ftcp_proc_time    [13]Tuint64_t
	Ftimebase         Tuint64_t
	Ftb_is_stable     Tuint8_t
}

type Ttcp_info = struct {
	Ftcpi_state                Tu_int8_t
	F__tcpi_ca_state           Tu_int8_t
	F__tcpi_retransmits        Tu_int8_t
	F__tcpi_probes             Tu_int8_t
	F__tcpi_backoff            Tu_int8_t
	Ftcpi_options              Tu_int8_t
	F__ccgo6                   uint8
	Ftcpi_rto                  Tu_int32_t
	F__tcpi_ato                Tu_int32_t
	Ftcpi_snd_mss              Tu_int32_t
	Ftcpi_rcv_mss              Tu_int32_t
	F__tcpi_unacked            Tu_int32_t
	F__tcpi_sacked             Tu_int32_t
	F__tcpi_lost               Tu_int32_t
	F__tcpi_retrans            Tu_int32_t
	F__tcpi_fackets            Tu_int32_t
	F__tcpi_last_data_sent     Tu_int32_t
	F__tcpi_last_ack_sent      Tu_int32_t
	Ftcpi_last_data_recv       Tu_int32_t
	F__tcpi_last_ack_recv      Tu_int32_t
	F__tcpi_pmtu               Tu_int32_t
	F__tcpi_rcv_ssthresh       Tu_int32_t
	Ftcpi_rtt                  Tu_int32_t
	Ftcpi_rttvar               Tu_int32_t
	Ftcpi_snd_ssthresh         Tu_int32_t
	Ftcpi_snd_cwnd             Tu_int32_t
	F__tcpi_advmss             Tu_int32_t
	F__tcpi_reordering         Tu_int32_t
	F__tcpi_rcv_rtt            Tu_int32_t
	Ftcpi_rcv_space            Tu_int32_t
	Ftcpi_snd_wnd              Tu_int32_t
	Ftcpi_snd_bwnd             Tu_int32_t
	Ftcpi_snd_nxt              Tu_int32_t
	Ftcpi_rcv_nxt              Tu_int32_t
	Ftcpi_toe_tid              Tu_int32_t
	Ftcpi_snd_rexmitpack       Tu_int32_t
	Ftcpi_rcv_ooopack          Tu_int32_t
	Ftcpi_snd_zerowin          Tu_int32_t
	Ftcpi_delivered_ce         Tu_int32_t
	Ftcpi_received_ce          Tu_int32_t
	F__tcpi_delivered_e1_bytes Tu_int32_t
	F__tcpi_delivered_e0_bytes Tu_int32_t
	F__tcpi_delivered_ce_bytes Tu_int32_t
	F__tcpi_received_e1_bytes  Tu_int32_t
	F__tcpi_received_e0_bytes  Tu_int32_t
	F__tcpi_received_ce_bytes  Tu_int32_t
	Ftcpi_total_tlp            Tu_int32_t
	Ftcpi_total_tlp_bytes      Tu_int64_t
	Ftcpi_snd_una              Tu_int32_t
	Ftcpi_snd_max              Tu_int32_t
	Ftcpi_rcv_numsacks         Tu_int32_t
	Ftcpi_rcv_adv              Tu_int32_t
	Ftcpi_dupacks              Tu_int32_t
	F__tcpi_pad                [10]Tu_int32_t
}

type Ttcp_fastopen = struct {
	Fenable int32
	Fpsk    [16]Tuint8_t
}

type Ttcp_function_set = struct {
	Ffunction_set_name [32]int8
	Fpcbcnt            Tuint32_t
}

type Ttcp_snd_req = struct {
	Ftimestamp Tuint64_t
	Fstart     Tuint64_t
	Fend       Tuint64_t
	Fflags     Tuint32_t
}

type Ttcp_log_userdata = struct {
	Ftcp_req Ttcp_snd_req
}

type Ttcp_log_user = struct {
	Ftype1   Tuint32_t
	Fsubtype Tuint32_t
	Fdata    Ttcp_log_userdata
}

type Ttcp_hybrid_req = struct {
	Freq          Ttcp_snd_req
	Fcspr         Tuint64_t
	Fhint_maxseg  Tuint32_t
	Fhybrid_flags Tuint32_t
}

type Thostent = struct {
	Fh_name      uintptr
	Fh_aliases   uintptr
	Fh_addrtype  int32
	Fh_length    int32
	Fh_addr_list uintptr
}

type Tnetent = struct {
	Fn_name     uintptr
	Fn_aliases  uintptr
	Fn_addrtype int32
	Fn_net      Tuint32_t
}

type Tservent = struct {
	Fs_name    uintptr
	Fs_aliases uintptr
	Fs_port    int32
	Fs_proto   uintptr
}

type Tprotoent = struct {
	Fp_name    uintptr
	Fp_aliases uintptr
	Fp_proto   int32
}

type Taddrinfo = struct {
	Fai_flags     int32
	Fai_family    int32
	Fai_socktype  int32
	Fai_protocol  int32
	Fai_addrlen   Tsocklen_t
	Fai_canonname uintptr
	Fai_addr      uintptr
	Fai_next      uintptr
}

type Ttimezone = struct {
	Ftz_minuteswest int32
	Ftz_dsttime     int32
}

type Tbintime = struct {
	Fsec  Ttime_t
	Ffrac Tuint64_t
}

type Titimerval = struct {
	Fit_interval Ttimeval
	Fit_value    Ttimeval
}

type Tclockinfo = struct {
	Fhz     int32
	Ftick   int32
	Fspare  int32
	Fstathz int32
	Fprofhz int32
}

type Tstat = struct {
	Fst_dev      Tdev_t
	Fst_ino      Tino_t
	Fst_nlink    Tnlink_t
	Fst_mode     Tmode_t
	Fst_padding0 t__int16_t
	Fst_uid      Tuid_t
	Fst_gid      Tgid_t
	Fst_padding1 t__int32_t
	Fst_rdev     Tdev_t
	Fst_atim     Ttimespec
	Fst_mtim     Ttimespec
	Fst_ctim     Ttimespec
	Fst_birthtim Ttimespec
	Fst_size     Toff_t
	Fst_blocks   Tblkcnt_t
	Fst_blksize  Tblksize_t
	Fst_flags    Tfflags_t
	Fst_gen      t__uint64_t
	Fst_spare    [10]t__uint64_t
}

func Xxcb_popcount(tls *libc.TLS, mask Tuint32_t) (r int32) {
	var y Tuint32_t
	_ = y
	y = mask >> libc.Int32FromInt32(1) & uint32(033333333333)
	y = mask - y - y>>libc.Int32FromInt32(1)&uint32(033333333333)
	return libc.Int32FromUint32((y + y>>libc.Int32FromInt32(3)) & uint32(030707070707) % uint32(077))
}

func Xxcb_sumof(tls *libc.TLS, list uintptr, len1 int32) (r int32) {
	var i, s int32
	_, _ = i, s
	s = 0
	i = 0
	for {
		if !(i < len1) {
			break
		}
		s += libc.Int32FromUint8(*(*Tuint8_t)(unsafe.Pointer(list)))
		list++
		goto _1
	_1:
		;
		i++
	}
	return s
}

// C documentation
//
//	/* Return true and parse if name matches <path to socket>[.<screen>]
//	 * Upon success:
//	 *     host = <path to socket>
//	 *     protocol = "unix"
//	 *     display = 0
//	 *     screen = <screen>
//	 */
func __xcb_parse_display_path_to_socket(tls *libc.TLS, name uintptr, host uintptr, protocol uintptr, displayp uintptr, screenp uintptr) (r int32) {
	bp := tls.Alloc(1264)
	defer tls.Free(1264)
	var _screen, res int32
	var dot uintptr
	var len1 Tsize_t
	var lscreen uint64
	var _ /* endptr at bp+1248 */ uintptr
	var _ /* path at bp+224 */ [1024]int8
	var _ /* sbuf at bp+0 */ Tstat
	_, _, _, _, _ = _screen, dot, len1, lscreen, res
	_screen = 0
	len1 = libc.Xstrlen(tls, name)
	if len1 >= uint64(1024) {
		return 0
	}
	libc.Xmemcpy(tls, bp+224, name, len1+uint64(1))
	res = libc.Xstat(tls, bp+224, bp)
	if 0 != res {
		if res != -int32(1) || *(*int32)(unsafe.Pointer(libc.X__error(tls))) != int32(m_ENOENT) && *(*int32)(unsafe.Pointer(libc.X__error(tls))) != int32(m_ENOTDIR) {
			return 0
		}
		dot = libc.Xstrrchr(tls, bp+224, int32('.'))
		if !(dot != 0) || int32(*(*int8)(unsafe.Pointer(dot + 1))) < int32('1') || int32(*(*int8)(unsafe.Pointer(dot + 1))) > int32('9') {
			return 0
		}
		*(*int8)(unsafe.Pointer(dot)) = int8('\000')
		*(*int32)(unsafe.Pointer(libc.X__error(tls))) = 0
		lscreen = libc.Xstrtoul(tls, dot+uintptr(1), bp+1248, int32(10))
		if lscreen > uint64(m___INT_MAX1) || !(*(*uintptr)(unsafe.Pointer(bp + 1248)) != 0) || *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 1248)))) != 0 || *(*int32)(unsafe.Pointer(libc.X__error(tls))) != 0 {
			return 0
		}
		if 0 != libc.Xstat(tls, bp+224, bp) {
			return 0
		}
		_screen = libc.Int32FromUint64(lscreen)
	}
	if host != 0 {
		*(*uintptr)(unsafe.Pointer(host)) = libc.Xstrdup(tls, bp+224)
		if !(*(*uintptr)(unsafe.Pointer(host)) != 0) {
			return 0
		}
	}
	if protocol != 0 {
		*(*uintptr)(unsafe.Pointer(protocol)) = libc.Xstrdup(tls, __ccgo_ts+4)
		if !(*(*uintptr)(unsafe.Pointer(protocol)) != 0) {
			if host != 0 {
				libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(host)))
			}
			return 0
		}
	}
	if displayp != 0 {
		*(*int32)(unsafe.Pointer(displayp)) = 0
	}
	if screenp != 0 {
		*(*int32)(unsafe.Pointer(screenp)) = _screen
	}
	return int32(1)
}

func __xcb_parse_display(tls *libc.TLS, name uintptr, host uintptr, protocol uintptr, displayp uintptr, screenp uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var colon, slash uintptr
	var display, len1, screen int32
	var _ /* dot at bp+0 */ uintptr
	var _ /* end at bp+8 */ uintptr
	_, _, _, _, _ = colon, display, len1, screen, slash
	if !(name != 0) || !(*(*int8)(unsafe.Pointer(name)) != 0) {
		name = libc.Xgetenv(tls, __ccgo_ts+9)
	}
	if !(name != 0) {
		return 0
	}
	/* First check for <path to socket>[.<screen>] */
	if int32(*(*int8)(unsafe.Pointer(name))) == int32('/') {
		return __xcb_parse_display_path_to_socket(tls, name, host, protocol, displayp, screenp)
	}
	if libc.Xstrncmp(tls, name, __ccgo_ts+17, uint64(5)) == 0 {
		return __xcb_parse_display_path_to_socket(tls, name+uintptr(5), host, protocol, displayp, screenp)
	}
	slash = libc.Xstrrchr(tls, name, int32('/'))
	if slash != 0 {
		len1 = int32(int64(slash) - int64(name))
		if protocol != 0 {
			*(*uintptr)(unsafe.Pointer(protocol)) = libc.Xmalloc(tls, libc.Uint64FromInt32(len1+int32(1)))
			if !(*(*uintptr)(unsafe.Pointer(protocol)) != 0) {
				return 0
			}
			libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(protocol)), name, libc.Uint64FromInt32(len1))
			*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(protocol)) + uintptr(len1))) = int8('\000')
		}
		name = slash + uintptr(1)
	} else {
		if protocol != 0 {
			*(*uintptr)(unsafe.Pointer(protocol)) = libc.UintptrFromInt32(0)
		}
	}
	colon = libc.Xstrrchr(tls, name, int32(':'))
	if !(colon != 0) {
		goto error_out
	}
	len1 = int32(int64(colon) - int64(name))
	colon++
	display = libc.Int32FromUint64(libc.Xstrtoul(tls, colon, bp, int32(10)))
	if *(*uintptr)(unsafe.Pointer(bp)) == colon {
		goto error_out
	}
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32('\000') {
		screen = 0
	} else {
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32('.') {
			goto error_out
		}
		*(*uintptr)(unsafe.Pointer(bp))++
		screen = libc.Int32FromUint64(libc.Xstrtoul(tls, *(*uintptr)(unsafe.Pointer(bp)), bp+8, int32(10)))
		if *(*uintptr)(unsafe.Pointer(bp + 8)) == *(*uintptr)(unsafe.Pointer(bp)) || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != int32('\000') {
			goto error_out
		}
	}
	/* At this point, the display string is fully parsed and valid, but
	 * the caller's memory is untouched. */
	*(*uintptr)(unsafe.Pointer(host)) = libc.Xmalloc(tls, libc.Uint64FromInt32(len1+int32(1)))
	if !(*(*uintptr)(unsafe.Pointer(host)) != 0) {
		goto error_out
	}
	libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(host)), name, libc.Uint64FromInt32(len1))
	*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(host)) + uintptr(len1))) = int8('\000')
	*(*int32)(unsafe.Pointer(displayp)) = display
	if screenp != 0 {
		*(*int32)(unsafe.Pointer(screenp)) = screen
	}
	return int32(1)
	goto error_out
error_out:
	;
	if protocol != 0 {
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(protocol)))
		*(*uintptr)(unsafe.Pointer(protocol)) = libc.UintptrFromInt32(0)
	}
	return 0
}

func Xxcb_parse_display(tls *libc.TLS, name uintptr, host uintptr, displayp uintptr, screenp uintptr) (r int32) {
	return __xcb_parse_display(tls, name, host, libc.UintptrFromInt32(0), displayp, screenp)
}

func __xcb_open(tls *libc.TLS, host uintptr, protocol uintptr, display int32) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var actual_filelen, fd int32
	var base, file uintptr
	var filelen Tsize_t
	var port, port1 uint16
	var v1 uint64
	_, _, _, _, _, _, _, _ = actual_filelen, base, fd, file, filelen, port, port1, v1
	base = uintptr(unsafe.Pointer(&_unix_base))
	file = libc.UintptrFromInt32(0)
	if protocol != 0 && libc.Xstrcmp(tls, __ccgo_ts+4, protocol) == 0 && host != 0 && int32(*(*int8)(unsafe.Pointer(host))) == int32('/') {
		/* Full path to socket provided, ignore everything else */
		filelen = libc.Xstrlen(tls, host) + uint64(1)
		if filelen > uint64(m___INT_MAX1) {
			return -int32(1)
		}
		file = libc.Xmalloc(tls, filelen)
		if file == libc.UintptrFromInt32(0) {
			return -int32(1)
		}
		libc.Xmemcpy(tls, file, host, filelen)
		actual_filelen = libc.Int32FromUint64(filelen - libc.Uint64FromInt32(1))
	} else {
		/* If protocol or host is "unix", fall through to Unix socket code below */
		if (!(protocol != 0) || libc.Xstrcmp(tls, __ccgo_ts+4, protocol) != 0) && int32(*(*int8)(unsafe.Pointer(host))) != int32('\000') && libc.Xstrcmp(tls, __ccgo_ts+4, host) != 0 {
			/* display specifies TCP */
			port = libc.Uint16FromInt32(int32(m_X_TCP_PORT) + display)
			return __xcb_open_tcp(tls, host, protocol, port)
		}
		filelen = libc.Xstrlen(tls, base) + uint64(1) + libc.Uint64FromInt64(4)*libc.Uint64FromInt32(3) + uint64(1)
		file = libc.Xmalloc(tls, filelen)
		if file == libc.UintptrFromInt32(0) {
			return -int32(1)
		}
		/* display specifies Unix socket */
		actual_filelen = libc.X__builtin_snprintf(tls, file, filelen, __ccgo_ts+23, libc.VaList(bp+8, base, display))
		if actual_filelen < 0 {
			libc.Xfree(tls, file)
			return -int32(1)
		}
		/* snprintf may truncate the file */
		if libc.Uint64FromInt32(actual_filelen) < filelen-uint64(1) {
			v1 = libc.Uint64FromInt32(actual_filelen)
		} else {
			v1 = filelen - uint64(1)
		}
		filelen = v1
	}
	fd = __xcb_open_unix(tls, protocol, file)
	libc.Xfree(tls, file)
	if fd < 0 && !(protocol != 0) && int32(*(*int8)(unsafe.Pointer(host))) == int32('\000') {
		port1 = libc.Uint16FromInt32(int32(m_X_TCP_PORT) + display)
		fd = __xcb_open_tcp(tls, host, protocol, port1)
	}
	return fd
	return -int32(1) /* if control reaches here then something has gone wrong */
}

var _unix_base = [17]int8{'/', 't', 'm', 'p', '/', '.', 'X', '1', '1', '-', 'u', 'n', 'i', 'x', '/', 'X'}

func __xcb_socket(tls *libc.TLS, family int32, type1 int32, proto int32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var fd int32
	_ = fd
	fd = libc.Xsocket(tls, family, type1|int32(m_SOCK_CLOEXEC1), proto)
	if fd == -int32(1) && *(*int32)(unsafe.Pointer(libc.X__error(tls))) == int32(m_EINVAL) {
		fd = libc.Xsocket(tls, family, type1, proto)
		if fd >= 0 {
			libc.Xfcntl(tls, fd, int32(m_F_SETFD), libc.VaList(bp+8, int32(m_FD_CLOEXEC)))
		}
	}
	return fd
}

func __xcb_do_connect(tls *libc.TLS, fd int32, addr uintptr, addrlen int32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* on at bp+0 */ int32
	*(*int32)(unsafe.Pointer(bp)) = int32(1)
	if fd < 0 {
		return -int32(1)
	}
	libc.Xsetsockopt(tls, fd, int32(m_IPPROTO_TCP), int32(m_TCP_NODELAY), bp, uint32(4))
	libc.Xsetsockopt(tls, fd, int32(m_SOL_SOCKET), int32(m_SO_KEEPALIVE1), bp, uint32(4))
	return libc.Xconnect(tls, fd, addr, libc.Uint32FromInt32(addrlen))
}

func __xcb_open_tcp(tls *libc.TLS, host uintptr, protocol uintptr, port uint16) (r int32) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var addr, bracket, v1 uintptr
	var fd int32
	var v2 bool
	var _ /* hints at bp+0 */ Taddrinfo
	var _ /* results at bp+56 */ uintptr
	var _ /* service at bp+48 */ [6]int8
	_, _, _, _, _ = addr, bracket, fd, v1, v2
	fd = -int32(1)
	if protocol != 0 && libc.Xstrcmp(tls, __ccgo_ts+28, protocol) != 0 && libc.Xstrcmp(tls, __ccgo_ts+32, protocol) != 0 && libc.Xstrcmp(tls, __ccgo_ts+37, protocol) != 0 {
		return -int32(1)
	}
	if int32(*(*int8)(unsafe.Pointer(host))) == int32('\000') {
		host = __ccgo_ts + 43
	}
	libc.Xmemset(tls, bp, 0, uint64(48))
	(*(*Taddrinfo)(unsafe.Pointer(bp))).Fai_flags |= int32(m_AI_NUMERICSERV)
	(*(*Taddrinfo)(unsafe.Pointer(bp))).Fai_family = m_AF_UNSPEC
	(*(*Taddrinfo)(unsafe.Pointer(bp))).Fai_socktype = int32(m_SOCK_STREAM)
	/* Allow IPv6 addresses enclosed in brackets. */
	if v2 = int32(*(*int8)(unsafe.Pointer(host))) == int32('['); v2 {
		v1 = libc.Xstrrchr(tls, host, int32(']'))
		bracket = v1
	}
	if v2 && v1 != 0 && int32(*(*int8)(unsafe.Pointer(bracket + 1))) == int32('\000') {
		*(*int8)(unsafe.Pointer(bracket)) = int8('\000')
		host++
		(*(*Taddrinfo)(unsafe.Pointer(bp))).Fai_flags |= int32(m_AI_NUMERICHOST)
		(*(*Taddrinfo)(unsafe.Pointer(bp))).Fai_family = int32(m_AF_INET6)
	}
	libc.X__builtin_snprintf(tls, bp+48, uint64(6), __ccgo_ts+53, libc.VaList(bp+72, libc.Int32FromUint16(port)))
	if libc.Xgetaddrinfo(tls, host, bp+48, bp, bp+56) != 0 {
		/* FIXME: use gai_strerror, and fill in error connection */
		return -int32(1)
	}
	addr = *(*uintptr)(unsafe.Pointer(bp + 56))
	for {
		if !(addr != 0) {
			break
		}
		fd = __xcb_socket(tls, (*Taddrinfo)(unsafe.Pointer(addr)).Fai_family, (*Taddrinfo)(unsafe.Pointer(addr)).Fai_socktype, (*Taddrinfo)(unsafe.Pointer(addr)).Fai_protocol)
		if __xcb_do_connect(tls, fd, (*Taddrinfo)(unsafe.Pointer(addr)).Fai_addr, libc.Int32FromUint32((*Taddrinfo)(unsafe.Pointer(addr)).Fai_addrlen)) >= 0 {
			break
		}
		libc.Xclose(tls, fd)
		fd = -int32(1)
		goto _3
	_3:
		;
		addr = (*Taddrinfo)(unsafe.Pointer(addr)).Fai_next
	}
	libc.Xfreeaddrinfo(tls, *(*uintptr)(unsafe.Pointer(bp + 56)))
	return fd
}

func __xcb_open_unix(tls *libc.TLS, protocol uintptr, file uintptr) (r int32) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var fd int32
	var _ /* addr at bp+0 */ Tsockaddr_un
	var _ /* len at bp+108 */ Tsocklen_t
	var _ /* val at bp+112 */ int32
	_ = fd
	*(*Tsocklen_t)(unsafe.Pointer(bp + 108)) = uint32(4)
	if protocol != 0 && libc.Xstrcmp(tls, __ccgo_ts+4, protocol) != 0 {
		return -int32(1)
	}
	libc.Xstrcpy(tls, bp+2, file)
	(*(*Tsockaddr_un)(unsafe.Pointer(bp))).Fsun_family = uint8(m_AF_UNIX)
	(*(*Tsockaddr_un)(unsafe.Pointer(bp))).Fsun_len = uint8(libc.Uint64FromInt64(106) - libc.Uint64FromInt64(104) + libc.Xstrlen(tls, bp+2))
	fd = __xcb_socket(tls, int32(m_AF_UNIX), int32(m_SOCK_STREAM), 0)
	if fd == -int32(1) {
		return -int32(1)
	}
	if libc.Xgetsockopt(tls, fd, int32(m_SOL_SOCKET), int32(m_SO_SNDBUF1), bp+112, bp+108) == 0 && *(*int32)(unsafe.Pointer(bp + 112)) < libc.Int32FromInt32(64)*libc.Int32FromInt32(1024) {
		*(*int32)(unsafe.Pointer(bp + 112)) = libc.Int32FromInt32(64) * libc.Int32FromInt32(1024)
		libc.Xsetsockopt(tls, fd, int32(m_SOL_SOCKET), int32(m_SO_SNDBUF1), bp+112, uint32(4))
	}
	if libc.Xconnect(tls, fd, bp, uint32(106)) == -int32(1) {
		libc.Xclose(tls, fd)
		return -int32(1)
	}
	return fd
}

func Xxcb_connect(tls *libc.TLS, displayname uintptr, screenp uintptr) (r uintptr) {
	return Xxcb_connect_to_display_with_auth_info(tls, displayname, libc.UintptrFromInt32(0), screenp)
}

func Xxcb_connect_to_display_with_auth_info(tls *libc.TLS, displayname uintptr, auth uintptr, screenp uintptr) (r uintptr) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var c uintptr
	var fd, parsed int32
	var _ /* display at bp+0 */ int32
	var _ /* host at bp+8 */ uintptr
	var _ /* ourauth at bp+24 */ Txcb_auth_info_t
	var _ /* protocol at bp+16 */ uintptr
	_, _, _ = c, fd, parsed
	*(*int32)(unsafe.Pointer(bp)) = 0
	*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.UintptrFromInt32(0)
	*(*uintptr)(unsafe.Pointer(bp + 16)) = libc.UintptrFromInt32(0)
	parsed = __xcb_parse_display(tls, displayname, bp+8, bp+16, bp, screenp)
	if !(parsed != 0) {
		c = X_xcb_conn_ret_error(tls, int32(m_XCB_CONN_CLOSED_PARSE_ERR))
		goto out
	}
	fd = __xcb_open(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), *(*uintptr)(unsafe.Pointer(bp + 16)), *(*int32)(unsafe.Pointer(bp)))
	if fd == -int32(1) {
		c = X_xcb_conn_ret_error(tls, int32(m_XCB_CONN_ERROR))
		goto out
	}
	if auth != 0 {
		c = Xxcb_connect_to_fd(tls, fd, auth)
	} else {
		if X_xcb_get_auth_info(tls, fd, bp+24, *(*int32)(unsafe.Pointer(bp))) != 0 {
			c = Xxcb_connect_to_fd(tls, fd, bp+24)
			libc.Xfree(tls, (*(*Txcb_auth_info_t)(unsafe.Pointer(bp + 24))).Fname)
			libc.Xfree(tls, (*(*Txcb_auth_info_t)(unsafe.Pointer(bp + 24))).Fdata)
		} else {
			c = Xxcb_connect_to_fd(tls, fd, uintptr(0))
		}
	}
	if (*Txcb_connection_t)(unsafe.Pointer(c)).Fhas_error != 0 {
		goto out
	}
	/* Make sure requested screen number is in bounds for this server */
	if screenp != libc.UintptrFromInt32(0) && *(*int32)(unsafe.Pointer(screenp)) >= libc.Int32FromUint8((*Txcb_setup_t)(unsafe.Pointer((*Txcb_connection_t)(unsafe.Pointer(c)).Fsetup)).Froots_len) {
		Xxcb_disconnect(tls, c)
		c = X_xcb_conn_ret_error(tls, int32(m_XCB_CONN_CLOSED_INVALID_SCREEN))
		goto out
	}
	goto out
out:
	;
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
	return c
}

const m_ALIGNBYTES = "_ALIGNBYTES"
const m_AUTH_PROTO_MIT_MAGIC_COOKIE = "MIT-MAGIC-COOKIE-1"
const m_AUTH_PROTO_XDM_AUTHORIZATION = "XDM-AUTHORIZATION-1"
const m_BADSIG = "SIG_ERR"
const m_BKVASIZE = 16384
const m_BLKDEV_IOSIZE = "PAGE_SIZE"
const m_BSD = 199506
const m_BSD4_3 = 1
const m_BSD4_4 = 1
const m_BUS_ADRALN = 1
const m_BUS_ADRERR = 2
const m_BUS_OBJERR = 3
const m_BUS_OOMERR = 100
const m_CACHE_LINE_SHIFT = 6
const m_CLD_CONTINUED = 6
const m_CLD_DUMPED = 3
const m_CLD_EXITED = 1
const m_CLD_KILLED = 2
const m_CLD_STOPPED = 5
const m_CLD_TRAPPED = 4
const m_CMASK = 022
const m_DEV_BSHIFT = 9
const m_FALSE = 0
const m_FPE_FLTDIV = 3
const m_FPE_FLTIDO = 9
const m_FPE_FLTINV = 7
const m_FPE_FLTOVF = 4
const m_FPE_FLTRES = 6
const m_FPE_FLTSUB = 8
const m_FPE_FLTUND = 5
const m_FPE_INTDIV = 2
const m_FPE_INTOVF = 1
const m_FSHIFT = 11
const m_FUNCPROTO = 15
const m_FamilyKrb5Principal = 253
const m_FamilyLocal = 256
const m_FamilyLocalHost = 252
const m_FamilyNetname = 254
const m_FamilyWild = 65535
const m_ILL_BADSTK = 8
const m_ILL_COPROC = 7
const m_ILL_ILLADR = 3
const m_ILL_ILLOPC = 1
const m_ILL_ILLOPN = 2
const m_ILL_ILLTRP = 4
const m_ILL_PRVOPC = 5
const m_ILL_PRVREG = 6
const m_INITIAL_SOCKNAME_SLACK = 108
const m_IOPAGES = 2
const m_KSTACK_GUARD_PAGES = 1
const m_KSTACK_PAGES = 4
const m_LOCK_ERROR = 1
const m_LOCK_SUCCESS = 0
const m_LOCK_TIMEOUT = 2
const m_MACHINE = "amd64"
const m_MACHINE_ARCH = "amd64"
const m_MACHINE_ARCH32 = "i386"
const m_MAXBCACHEBUF = "MAXBSIZE"
const m_MAXBSIZE = 65536
const m_MAXCOMLEN = 19
const m_MAXCPU = 1
const m_MAXHOSTNAMELEN = 256
const m_MAXINTERP = "PATH_MAX"
const m_MAXLOGNAME = 33
const m_MAXMEMDOM = 8
const m_MAXPAGESIZES = 3
const m_MAXPATHLEN = "PATH_MAX"
const m_MAXSYMLINKS = 32
const m_MAXUPRC = "CHILD_MAX"
const m_MCLSHIFT = 11
const m_MINSIGSTKSZ = "__MINSIGSTKSZ"
const m_MJUMPAGESIZE = "PAGE_SIZE"
const m_MSIZE = 256
const m_NBBY = 8
const m_NCARGS = "ARG_MAX"
const m_NOFILE = "OPEN_MAX"
const m_NOGROUP = 65535
const m_NPDEPGSHIFT = 9
const m_NPDPEPGSHIFT = 9
const m_NPML4EPGSHIFT = 9
const m_NPML5EPGSHIFT = 9
const m_NPTEPGSHIFT = 9
const m_NSIG = 32
const m_NZERO = 0
const m_NeedFunctionPrototypes = 1
const m_NeedNestedPrototypes = 1
const m_NeedVarargsPrototypes = 1
const m_NeedWidePrototypes = 0
const m_PAGE_SHIFT = 12
const m_PCATCH = 0x100
const m_PDPSHIFT = 30
const m_PDROP = 0x200
const m_PDRSHIFT = 21
const m_PML4SHIFT = 39
const m_PML5SHIFT = 48
const m_PNOLOCK = 0x400
const m_POLL_ERR = 4
const m_POLL_HUP = 6
const m_POLL_IN = 1
const m_POLL_MSG = 3
const m_POLL_OUT = 2
const m_POLL_PRI = 5
const m_PRILASTFLAG = 0x400
const m_PRIMASK = 0x0ff
const m_SA_NOCLDSTOP = 0x0008
const m_SA_NOCLDWAIT = 0x0020
const m_SA_NODEFER = 0x0010
const m_SA_ONSTACK = 0x0001
const m_SA_RESETHAND = 0x0004
const m_SA_RESTART = 0x0002
const m_SA_SIGINFO = 0x0040
const m_SEGV_ACCERR = 2
const m_SEGV_MAPERR = 1
const m_SEGV_PKUERR = 100
const m_SIGABRT = 6
const m_SIGALRM = 14
const m_SIGBUS = 10
const m_SIGCHLD = 20
const m_SIGCONT = 19
const m_SIGEMT = 7
const m_SIGEV_KEVENT = 3
const m_SIGEV_NONE = 0
const m_SIGEV_SIGNAL = 1
const m_SIGEV_THREAD = 2
const m_SIGEV_THREAD_ID = 4
const m_SIGFPE = 8
const m_SIGHUP = 1
const m_SIGILL = 4
const m_SIGINFO = 29
const m_SIGINT = 2
const m_SIGIO = 23
const m_SIGIOT = "SIGABRT"
const m_SIGKILL = 9
const m_SIGLIBRT = 33
const m_SIGLWP = "SIGTHR"
const m_SIGPIPE = 13
const m_SIGPROF = 27
const m_SIGQUIT = 3
const m_SIGRTMAX = 126
const m_SIGRTMIN = 65
const m_SIGSEGV = 11
const m_SIGSTOP = 17
const m_SIGSYS = 12
const m_SIGTERM = 15
const m_SIGTHR = 32
const m_SIGTRAP = 5
const m_SIGTSTP = 18
const m_SIGTTIN = 21
const m_SIGTTOU = 22
const m_SIGURG = 16
const m_SIGUSR1 = 30
const m_SIGUSR2 = 31
const m_SIGVTALRM = 26
const m_SIGWINCH = 28
const m_SIGXCPU = 24
const m_SIGXFSZ = 25
const m_SIG_BLOCK = 1
const m_SIG_SETMASK = 3
const m_SIG_UNBLOCK = 2
const m_SI_ASYNCIO = 0x10004
const m_SI_KERNEL = 0x10006
const m_SI_LWP = 0x10007
const m_SI_MESGQ = 0x10005
const m_SI_NOINFO = 0
const m_SI_QUEUE = 0x10002
const m_SI_TIMER = 0x10003
const m_SI_UNDEFINED = 0
const m_SI_USER = 0x10001
const m_SOCK_CLOEXEC2 = 0x10000000
const m_SOL_SOCKET1 = 0xffff
const m_SO_KEEPALIVE2 = 0x00000008
const m_SO_SNDBUF2 = 0x1001
const m_SPECNAMELEN = 255
const m_SS_DISABLE = 0x0004
const m_SS_ONSTACK = 0x0001
const m_SV_INTERRUPT = "SA_RESTART"
const m_SV_NOCLDSTOP = "SA_NOCLDSTOP"
const m_SV_NODEFER = "SA_NODEFER"
const m_SV_ONSTACK = "SA_ONSTACK"
const m_SV_RESETHAND = "SA_RESETHAND"
const m_SV_SIGINFO = "SA_SIGINFO"
const m_TRAP_BRKPT = 1
const m_TRAP_CAP = 4
const m_TRAP_DTRACE = 3
const m_TRAP_TRACE = 2
const m_TRUE = 1
const m_XDM_DEFAULT_MCAST_ADDR6 = "ff02:0:0:0:0:0:0:12b"
const m_XDM_KA_RTX_LIMIT = 4
const m_XDM_MAX_MSGLEN = 8192
const m_XDM_MAX_RTX = 32
const m_XDM_MIN_RTX = 2
const m_XDM_PROTOCOL_VERSION = 1
const m_XDM_RTX_LIMIT = 7
const m_XDM_UDP_PORT = 177
const m_XMD_H = 1
const m__X86_SIGNAL_H = 1
const m__X_INLINE = "inline"
const m__X_RESTRICT_KYWD = "restrict"
const m__Xconst = "const"
const m___INT_MAX2 = 0x7fffffff
const m___SIGQUEUE_RSRV = 0x40000000
const m___SIGQUEUE_TID = 0x80000000
const m___stack_t = "sigaltstack"
const m_sigev_notify_kqueue = "sigev_signo"
const m_sv_onstack = "sv_flags"

type TXauth = struct {
	Ffamily         uint16
	Faddress_length uint16
	Faddress        uintptr
	Fnumber_length  uint16
	Fnumber         uintptr
	Fname_length    uint16
	Fname           uintptr
	Fdata_length    uint16
	Fdata           uintptr
}

type Txauth = TXauth

type Tsigevent = struct {
	Fsigev_notify int32
	Fsigev_signo  int32
	Fsigev_value  Tsigval
	F_sigev_un    struct {
		F_sigev_thread [0]struct {
			F_function  uintptr
			F_attribute uintptr
		}
		F_kevent_flags [0]uint16
		F__spare__     [0][8]int64
		F_threadid     t__lwpid_t
		F__ccgo_pad4   [60]byte
	}
}

type Tsig_atomic_t = int64

type Tsigcontext = struct {
	Fsc_mask          t__sigset
	Fsc_onstack       int64
	Fsc_rdi           int64
	Fsc_rsi           int64
	Fsc_rdx           int64
	Fsc_rcx           int64
	Fsc_r8            int64
	Fsc_r9            int64
	Fsc_rax           int64
	Fsc_rbx           int64
	Fsc_rbp           int64
	Fsc_r10           int64
	Fsc_r11           int64
	Fsc_r12           int64
	Fsc_r13           int64
	Fsc_r14           int64
	Fsc_r15           int64
	Fsc_trapno        int32
	Fsc_fs            int16
	Fsc_gs            int16
	Fsc_addr          int64
	Fsc_flags         int32
	Fsc_es            int16
	Fsc_ds            int16
	Fsc_err           int64
	Fsc_rip           int64
	Fsc_cs            int64
	Fsc_rflags        int64
	Fsc_rsp           int64
	Fsc_ss            int64
	Fsc_len           int64
	Fsc_fpformat      int64
	Fsc_ownedfp       int64
	Fsc_fpstate       [64]int64
	Fsc_fsbase        int64
	Fsc_gsbase        int64
	Fsc_xfpustate     int64
	Fsc_xfpustate_len int64
	Fsc_spare         [4]int64
}

type Tsiginfo_t = struct {
	Fsi_signo  int32
	Fsi_errno  int32
	Fsi_code   int32
	Fsi_pid    t__pid_t
	Fsi_uid    t__uid_t
	Fsi_status int32
	Fsi_addr   uintptr
	Fsi_value  Tsigval
	F_reason   struct {
		F_timer [0]struct {
			F_timerid int32
			F_overrun int32
		}
		F_mesgq [0]struct {
			F_mqd int32
		}
		F_poll [0]struct {
			F_band int64
		}
		F_capsicum [0]struct {
			F_syscall int32
		}
		F__spare__ [0]struct {
			F__spare1__ int64
			F__spare2__ [7]int32
		}
		F_fault struct {
			F_trapno int32
		}
		F__ccgo_pad6 [36]byte
	}
}

type t__siginfo = Tsiginfo_t

type Tsigaction = struct {
	F__sigaction_u struct {
		F__sa_sigaction [0]uintptr
		F__sa_handler   uintptr
	}
	Fsa_flags int32
	Fsa_mask  Tsigset_t
}

type Tsig_t = uintptr

type Tstack_t = struct {
	Fss_sp    uintptr
	Fss_size  t__size_t
	Fss_flags int32
}

type Tsigaltstack = Tstack_t

type Tsigvec = struct {
	Fsv_handler uintptr
	Fsv_mask    int32
	Fsv_flags   int32
}

type Tsigstack = struct {
	Fss_sp      uintptr
	Fss_onstack int32
}

type TINT64 = int64

type TINT32 = int32

type TINT16 = int16

type TINT8 = int8

type TCARD64 = uint64

type TCARD32 = uint32

type TCARD16 = uint16

type TCARD8 = uint8

type TBITS32 = uint32

type TBITS16 = uint16

type TBYTE = uint8

type TBOOL = uint8

type TxdmOpCode = int32

const _BROADCAST_QUERY = 1
const _QUERY = 2
const _INDIRECT_QUERY = 3
const _FORWARD_QUERY = 4
const _WILLING = 5
const _UNWILLING = 6
const _REQUEST = 7
const _ACCEPT = 8
const _DECLINE = 9
const _MANAGE = 10
const _REFUSE = 11
const _FAILED = 12
const _KEEPALIVE = 13
const _ALIVE = 14

type Txdmcp_states = int32

const _XDM_QUERY = 0
const _XDM_BROADCAST = 1
const _XDM_INDIRECT = 2
const _XDM_COLLECT_QUERY = 3
const _XDM_COLLECT_BROADCAST_QUERY = 4
const _XDM_COLLECT_INDIRECT_QUERY = 5
const _XDM_START_CONNECTION = 6
const _XDM_AWAIT_REQUEST_RESPONSE = 7
const _XDM_AWAIT_MANAGE_RESPONSE = 8
const _XDM_MANAGE = 9
const _XDM_RUN_SESSION = 10
const _XDM_OFF = 11
const _XDM_AWAIT_USER_INPUT = 12
const _XDM_KEEPALIVE = 13
const _XDM_AWAIT_ALIVE_RESPONSE = 14
const _XDM_KEEP_ME_LAST = 15

type TCARD8Ptr = uintptr

type TCARD16Ptr = uintptr

type TCARD32Ptr = uintptr

type TARRAY8 = struct {
	Flength TCARD16
	Fdata   TCARD8Ptr
}

type T_ARRAY8 = TARRAY8

type TARRAY8Ptr = uintptr

type TARRAY16 = struct {
	Flength TCARD8
	Fdata   TCARD16Ptr
}

type T_ARRAY16 = TARRAY16

type TARRAY16Ptr = uintptr

type TARRAY32 = struct {
	Flength TCARD8
	Fdata   TCARD32Ptr
}

type T_ARRAY32 = TARRAY32

type TARRAY32Ptr = uintptr

type TARRAYofARRAY8 = struct {
	Flength TCARD8
	Fdata   TARRAY8Ptr
}

type T_ARRAYofARRAY8 = TARRAYofARRAY8

type TARRAYofARRAY8Ptr = uintptr

type TXdmcpHeader = struct {
	Fversion TCARD16
	Fopcode  TCARD16
	Flength  TCARD16
}

type T_XdmcpHeader = TXdmcpHeader

type TXdmcpHeaderPtr = uintptr

type TXdmcpBuffer = struct {
	Fdata    uintptr
	Fsize    int32
	Fpointer int32
	Fcount   int32
}

type T_XdmcpBuffer = TXdmcpBuffer

type TXdmcpBufferPtr = uintptr

type TXdmAuthKeyRec = struct {
	Fdata [8]TBYTE
}

type T_XdmAuthKey = TXdmAuthKeyRec

type TXdmAuthKeyPtr = uintptr

type TXdmcpNetaddr = uintptr

type _auth_protos = int32

const _AUTH_XA1 = 0
const _AUTH_MC1 = 1
const _N_AUTH_PROTOS = 2

var _authnames = [2]uintptr{
	0: __ccgo_ts + 57,
	1: __ccgo_ts + 77,
}

var _authnameslen = [2]int32{
	0: libc.Int32FromUint64(libc.Uint64FromInt64(20) - libc.Uint64FromInt32(1)),
	1: libc.Int32FromUint64(libc.Uint64FromInt64(19) - libc.Uint64FromInt32(1)),
}

func _memdup(tls *libc.TLS, dst uintptr, src uintptr, len1 Tsize_t) (r Tsize_t) {
	if len1 != 0 {
		*(*uintptr)(unsafe.Pointer(dst)) = libc.Xmalloc(tls, len1)
	} else {
		*(*uintptr)(unsafe.Pointer(dst)) = uintptr(0)
	}
	if !(*(*uintptr)(unsafe.Pointer(dst)) != 0) {
		return uint64(0)
	}
	libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(dst)), src, len1)
	return len1
}

func _authname_match(tls *libc.TLS, kind _auth_protos, name uintptr, namelen Tsize_t) (r int32) {
	if libc.Uint64FromInt32(_authnameslen[kind]) != namelen {
		return 0
	}
	if libc.Xmemcmp(tls, _authnames[kind], name, namelen) != 0 {
		return 0
	}
	return int32(1)
}

func _get_authptr(tls *libc.TLS, sockname uintptr, display int32) (r uintptr) {
	bp := tls.Alloc(320)
	defer tls.Free(320)
	var addr uintptr
	var addrlen, dispbuflen int32
	var family uint16
	var v1 uint64
	var _ /* dispbuf at bp+256 */ [40]int8
	var _ /* hostnamebuf at bp+0 */ [256]int8
	_, _, _, _, _ = addr, addrlen, dispbuflen, family, v1
	addr = uintptr(0)
	addrlen = 0
	family = libc.Uint16FromInt32(libc.Int32FromInt32(m_FamilyLocal)) /* 256 */
	switch libc.Int32FromUint8((*Tsockaddr)(unsafe.Pointer(sockname)).Fsa_family) {
	case int32(m_AF_INET6):
		addr = sockname + 8
		addrlen = int32(16)
		if !(*(*Tuint32_t)(unsafe.Pointer(sockname + 8)) == uint32(0) && *(*Tuint32_t)(unsafe.Pointer(sockname + 8 + 1*4)) == uint32(0) && *(*Tuint32_t)(unsafe.Pointer(sockname + 8 + 2*4)) == libc.X__builtin_bswap32(tls, uint32(0x0000ffff))) {
			if !(*(*Tuint32_t)(unsafe.Pointer(sockname + 8)) == uint32(0) && *(*Tuint32_t)(unsafe.Pointer(sockname + 8 + 1*4)) == uint32(0) && *(*Tuint32_t)(unsafe.Pointer(sockname + 8 + 2*4)) == uint32(0) && *(*Tuint32_t)(unsafe.Pointer(sockname + 8 + 3*4)) == libc.X__builtin_bswap32(tls, uint32(1))) {
				family = uint16(_XCB_FAMILY_INTERNET_6)
			}
			break
		}
		addr += uintptr(12)
		/* if v4-mapped, fall through. */
		fallthrough
	case int32(m_AF_INET):
		if !(addr != 0) {
			addr = sockname + 4
		}
		addrlen = int32(4)
		if *(*Tin_addr_t)(unsafe.Pointer(addr)) != libc.X__builtin_bswap32(tls, libc.Uint32FromInt32(0x7f000001)) {
			family = uint16(_XCB_FAMILY_INTERNET)
		}
	case int32(m_AF_UNIX):
	default:
		return uintptr(0) /* cannot authenticate this family */
	}
	dispbuflen = libc.X__builtin_snprintf(tls, bp+256, uint64(40), __ccgo_ts+96, libc.VaList(bp+304, display))
	if dispbuflen < 0 {
		return uintptr(0)
	}
	/* snprintf may have truncate our text */
	if libc.Uint64FromInt32(dispbuflen) < libc.Uint64FromInt64(40)-libc.Uint64FromInt32(1) {
		v1 = libc.Uint64FromInt32(dispbuflen)
	} else {
		v1 = libc.Uint64FromInt64(40) - libc.Uint64FromInt32(1)
	}
	dispbuflen = libc.Int32FromUint64(v1)
	if libc.Int32FromUint16(family) == int32(m_FamilyLocal) {
		if libc.Xgethostname(tls, bp, uint64(256)) == -int32(1) {
			return uintptr(0)
		} /* do not know own hostname */
		addr = bp
		addrlen = libc.Int32FromUint64(libc.Xstrlen(tls, addr))
	}
	return libxau.XXauGetBestAuthByAddr(tls, family, libc.Uint16FromInt32(addrlen), addr, libc.Uint16FromInt32(dispbuflen), bp+256, int32(_N_AUTH_PROTOS), uintptr(unsafe.Pointer(&_authnames)), uintptr(unsafe.Pointer(&_authnameslen)))
}

func _next_nonce(tls *libc.TLS) (r int32) {
	var ret, v1 int32
	_, _ = ret, v1
	libc.Xpthread_mutex_lock(tls, uintptr(unsafe.Pointer(&_nonce_mutex)))
	v1 = _nonce
	_nonce++
	ret = v1
	libc.Xpthread_mutex_unlock(tls, uintptr(unsafe.Pointer(&_nonce_mutex)))
	return ret
}

var _nonce int32

var _nonce_mutex = libc.UintptrFromInt32(0)

func _do_append(tls *libc.TLS, buf uintptr, idxp uintptr, val uintptr, valsize Tsize_t) {
	var p1 uintptr
	_ = p1
	libc.Xmemcpy(tls, buf+uintptr(*(*int32)(unsafe.Pointer(idxp))), val, valsize)
	p1 = idxp
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + valsize)
}

func _compute_auth(tls *libc.TLS, info uintptr, authptr uintptr, sockname uintptr) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var si, si6 uintptr
	var v2 int32
	var _ /* fakeaddr at bp+12 */ Tuint32_t
	var _ /* fakeaddr at bp+4 */ Tuint32_t
	var _ /* fakeport at bp+16 */ Tuint16_t
	var _ /* fakeport at bp+8 */ Tuint16_t
	var _ /* j at bp+0 */ int32
	var _ /* now at bp+20 */ Tuint32_t
	_, _, _ = si, si6, v2
	if _authname_match(tls, int32(_AUTH_MC1), (*TXauth)(unsafe.Pointer(authptr)).Fname, uint64((*TXauth)(unsafe.Pointer(authptr)).Fname_length)) != 0 {
		(*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdatalen = libc.Int32FromUint64(_memdup(tls, info+24, (*TXauth)(unsafe.Pointer(authptr)).Fdata, uint64((*TXauth)(unsafe.Pointer(authptr)).Fdata_length)))
		if !((*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdatalen != 0) {
			return 0
		}
		return int32(1)
	}
	if _authname_match(tls, int32(_AUTH_XA1), (*TXauth)(unsafe.Pointer(authptr)).Fname, uint64((*TXauth)(unsafe.Pointer(authptr)).Fname_length)) != 0 {
		(*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata = libc.Xmalloc(tls, libc.Uint64FromInt32(libc.Int32FromInt32(192)/libc.Int32FromInt32(8)))
		if !((*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata != 0) {
			return 0
		}
		*(*int32)(unsafe.Pointer(bp)) = 0
		for {
			if !(*(*int32)(unsafe.Pointer(bp)) < int32(8)) {
				break
			}
			*(*int8)(unsafe.Pointer((*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata + uintptr(*(*int32)(unsafe.Pointer(bp))))) = *(*int8)(unsafe.Pointer((*TXauth)(unsafe.Pointer(authptr)).Fdata + uintptr(*(*int32)(unsafe.Pointer(bp)))))
			goto _1
		_1:
			;
			*(*int32)(unsafe.Pointer(bp))++
		}
		switch libc.Int32FromUint8((*Tsockaddr)(unsafe.Pointer(sockname)).Fsa_family) {
		case int32(m_AF_INET):
			/*block*/
			si = sockname
			_do_append(tls, (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata, bp, si+4, uint64(4))
			_do_append(tls, (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata, bp, si+2, uint64(2))
		case int32(m_AF_INET6):
			/*block*/
			si6 = sockname
			if *(*Tuint32_t)(unsafe.Pointer(sockname + 8)) == uint32(0) && *(*Tuint32_t)(unsafe.Pointer(sockname + 8 + 1*4)) == uint32(0) && *(*Tuint32_t)(unsafe.Pointer(sockname + 8 + 2*4)) == libc.X__builtin_bswap32(tls, uint32(0x0000ffff)) {
				_do_append(tls, (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata, bp, si6+8+12, uint64(4))
				_do_append(tls, (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata, bp, si6+2, uint64(2))
			} else {
				/* XDM-AUTHORIZATION-1 does not handle IPv6 correctly.  Do the
				   same thing Xlib does: use all zeroes for the 4-byte address
				   and 2-byte port number. */
				*(*Tuint32_t)(unsafe.Pointer(bp + 4)) = uint32(0)
				*(*Tuint16_t)(unsafe.Pointer(bp + 8)) = uint16(0)
				_do_append(tls, (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata, bp, bp+4, uint64(4))
				_do_append(tls, (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata, bp, bp+8, uint64(2))
			}
		case int32(m_AF_UNIX):
			/*block*/
			*(*Tuint32_t)(unsafe.Pointer(bp + 12)) = libc.X__builtin_bswap32(tls, uint32(0xffffffff)-libc.Uint32FromInt32(_next_nonce(tls)))
			*(*Tuint16_t)(unsafe.Pointer(bp + 16)) = libc.X__builtin_bswap16(tls, libc.Uint16FromInt32(libc.Xgetpid(tls)))
			_do_append(tls, (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata, bp, bp+12, uint64(4))
			_do_append(tls, (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata, bp, bp+16, uint64(2))
		default:
			libc.Xfree(tls, (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata)
			return 0 /* do not know how to build this */
		}
		*(*Tuint32_t)(unsafe.Pointer(bp + 20)) = libc.X__builtin_bswap32(tls, libc.Uint32FromInt64(libc.Xtime(tls, uintptr(0))))
		_do_append(tls, (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata, bp, bp+20, uint64(4))
		for *(*int32)(unsafe.Pointer(bp)) < libc.Int32FromInt32(192)/libc.Int32FromInt32(8) {
			v2 = *(*int32)(unsafe.Pointer(bp))
			*(*int32)(unsafe.Pointer(bp))++
			*(*int8)(unsafe.Pointer((*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata + uintptr(v2))) = 0
		}
		(*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdatalen = *(*int32)(unsafe.Pointer(bp))
		libxdmcp.XXdmcpWrap(tls, (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata, (*TXauth)(unsafe.Pointer(authptr)).Fdata+uintptr(8), (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdata, (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fdatalen)
		return int32(1)
	}
	return 0 /* Unknown authorization type */
}

/* `sockaddr_un.sun_path' typical size usually ranges between 92 and 108 */

// C documentation
//
//	/* Return a dynamically allocated socket address structure according
//	   to the value returned by either getpeername() or getsockname()
//	   (according to POSIX, applications should not assume a particular
//	   length for `sockaddr_un.sun_path') */
func _get_peer_sock_name(tls *libc.TLS, socket_func uintptr, fd int32) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var new_sockname, sockname, v1 uintptr
	var socknamelen Tsocklen_t
	var _ /* actual_socknamelen at bp+0 */ Tsocklen_t
	_, _, _, _ = new_sockname, sockname, socknamelen, v1
	socknamelen = uint32(libc.Uint64FromInt64(16) + libc.Uint64FromInt32(m_INITIAL_SOCKNAME_SLACK))
	*(*Tsocklen_t)(unsafe.Pointer(bp)) = socknamelen
	sockname = libc.Xmalloc(tls, uint64(socknamelen))
	if sockname == libc.UintptrFromInt32(0) {
		return libc.UintptrFromInt32(0)
	}
	/* Both getpeername() and getsockname() truncates sockname if
	   there is not enough space and set the required length in
	   actual_socknamelen */
	if (*(*func(*libc.TLS, int32, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{socket_func})))(tls, fd, sockname, bp) == -int32(1) {
		goto sock_or_realloc_error
	}
	if *(*Tsocklen_t)(unsafe.Pointer(bp)) > socknamelen {
		new_sockname = libc.UintptrFromInt32(0)
		socknamelen = *(*Tsocklen_t)(unsafe.Pointer(bp))
		v1 = libc.Xrealloc(tls, sockname, uint64(*(*Tsocklen_t)(unsafe.Pointer(bp))))
		new_sockname = v1
		if v1 == libc.UintptrFromInt32(0) {
			goto sock_or_realloc_error
		}
		sockname = new_sockname
		if (*(*func(*libc.TLS, int32, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{socket_func})))(tls, fd, sockname, bp) == -int32(1) || *(*Tsocklen_t)(unsafe.Pointer(bp)) > socknamelen {
			goto sock_or_realloc_error
		}
	}
	return sockname
	goto sock_or_realloc_error
sock_or_realloc_error:
	;
	libc.Xfree(tls, sockname)
	return libc.UintptrFromInt32(0)
}

func X_xcb_get_auth_info(tls *libc.TLS, fd int32, info uintptr, display int32) (r int32) {
	var authptr, sockname, v1, v2, v3 uintptr
	var gotsockname, ret int32
	_, _, _, _, _, _, _ = authptr, gotsockname, ret, sockname, v1, v2, v3
	/* code adapted from Xlib/ConnDis.c, xtrans/Xtranssocket.c,
	   xtrans/Xtransutils.c */
	sockname = libc.UintptrFromInt32(0)
	gotsockname = 0
	authptr = uintptr(0)
	ret = int32(1)
	/* Some systems like hpux or Hurd do not expose peer names
	 * for UNIX Domain Sockets, but this is irrelevant,
	 * since compute_auth() ignores the peer name in this
	 * case anyway.*/
	v1 = _get_peer_sock_name(tls, __ccgo_fp(libc.Xgetpeername), fd)
	sockname = v1
	if v1 == libc.UintptrFromInt32(0) {
		v2 = _get_peer_sock_name(tls, __ccgo_fp(libc.Xgetsockname), fd)
		sockname = v2
		if v2 == libc.UintptrFromInt32(0) {
			return 0
		} /* can only authenticate sockets */
		if libc.Int32FromUint8((*Tsockaddr)(unsafe.Pointer(sockname)).Fsa_family) != int32(m_AF_UNIX) {
			libc.Xfree(tls, sockname)
			return 0 /* except for AF_UNIX, sockets should have peernames */
		}
		gotsockname = int32(1)
	}
	authptr = _get_authptr(tls, sockname, display)
	if authptr == uintptr(0) {
		libc.Xfree(tls, sockname)
		return 0 /* cannot find good auth data */
	}
	(*Txcb_auth_info_t)(unsafe.Pointer(info)).Fnamelen = libc.Int32FromUint64(_memdup(tls, info+8, (*TXauth)(unsafe.Pointer(authptr)).Fname, uint64((*TXauth)(unsafe.Pointer(authptr)).Fname_length)))
	if !((*Txcb_auth_info_t)(unsafe.Pointer(info)).Fnamelen != 0) {
		goto no_auth
	} /* out of memory */
	if !(gotsockname != 0) {
		libc.Xfree(tls, sockname)
		v3 = _get_peer_sock_name(tls, __ccgo_fp(libc.Xgetsockname), fd)
		sockname = v3
		if v3 == libc.UintptrFromInt32(0) {
			libc.Xfree(tls, (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fname)
			goto no_auth /* can only authenticate sockets */
		}
	}
	ret = _compute_auth(tls, info, authptr, sockname)
	if !(ret != 0) {
		libc.Xfree(tls, (*Txcb_auth_info_t)(unsafe.Pointer(info)).Fname)
		goto no_auth /* cannot build auth record */
	}
	libc.Xfree(tls, sockname)
	sockname = libc.UintptrFromInt32(0)
	libxau.XXauDisposeAuth(tls, authptr)
	return ret
	goto no_auth
no_auth:
	;
	libc.Xfree(tls, sockname)
	(*Txcb_auth_info_t)(unsafe.Pointer(info)).Fname = uintptr(0)
	(*Txcb_auth_info_t)(unsafe.Pointer(info)).Fnamelen = 0
	libxau.XXauDisposeAuth(tls, authptr)
	return 0
}

/*
 * This file generated automatically from xproto.xml by c_client.py.
 * Edit at your peril.
 */

/**
 * @defgroup XCB__API XCB  API
 * @brief  XCB Protocol Implementation.
 * @{
 **/

/**
 * @}
 */

func Xxcb_char2b_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_char2b_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_char2b_iterator_t)(unsafe.Pointer(i)).Fdata += 2
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(2))
}

func Xxcb_char2b_end(tls *libc.TLS, i Txcb_char2b_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*2
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_window_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_window_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_window_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_window_end(tls *libc.TLS, i Txcb_window_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_pixmap_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_pixmap_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_pixmap_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_pixmap_end(tls *libc.TLS, i Txcb_pixmap_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_cursor_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_cursor_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_cursor_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_cursor_end(tls *libc.TLS, i Txcb_cursor_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_font_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_font_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_font_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_font_end(tls *libc.TLS, i Txcb_font_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_gcontext_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_gcontext_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_gcontext_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_gcontext_end(tls *libc.TLS, i Txcb_gcontext_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_colormap_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_colormap_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_colormap_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_colormap_end(tls *libc.TLS, i Txcb_colormap_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_atom_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_atom_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_atom_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_atom_end(tls *libc.TLS, i Txcb_atom_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_drawable_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_drawable_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_drawable_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_drawable_end(tls *libc.TLS, i Txcb_drawable_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_fontable_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_fontable_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_fontable_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_fontable_end(tls *libc.TLS, i Txcb_fontable_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_bool32_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_bool32_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_bool32_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_bool32_end(tls *libc.TLS, i Txcb_bool32_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_visualid_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_visualid_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_visualid_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_visualid_end(tls *libc.TLS, i Txcb_visualid_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_timestamp_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_timestamp_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_timestamp_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_timestamp_end(tls *libc.TLS, i Txcb_timestamp_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_keysym_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_keysym_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_keysym_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_keysym_end(tls *libc.TLS, i Txcb_keysym_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_keycode_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_keycode_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_keycode_iterator_t)(unsafe.Pointer(i)).Fdata++
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(1))
}

func Xxcb_keycode_end(tls *libc.TLS, i Txcb_keycode_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_keycode32_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_keycode32_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_keycode32_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_keycode32_end(tls *libc.TLS, i Txcb_keycode32_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_button_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_button_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_button_iterator_t)(unsafe.Pointer(i)).Fdata++
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(1))
}

func Xxcb_button_end(tls *libc.TLS, i Txcb_button_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_point_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_point_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_point_iterator_t)(unsafe.Pointer(i)).Fdata += 4
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(4))
}

func Xxcb_point_end(tls *libc.TLS, i Txcb_point_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*4
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_rectangle_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_rectangle_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_rectangle_iterator_t)(unsafe.Pointer(i)).Fdata += 8
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(8))
}

func Xxcb_rectangle_end(tls *libc.TLS, i Txcb_rectangle_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*8
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_arc_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_arc_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_arc_iterator_t)(unsafe.Pointer(i)).Fdata += 12
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(12))
}

func Xxcb_arc_end(tls *libc.TLS, i Txcb_arc_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*12
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_format_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_format_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_format_iterator_t)(unsafe.Pointer(i)).Fdata += 8
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(8))
}

func Xxcb_format_end(tls *libc.TLS, i Txcb_format_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*8
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_visualtype_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_visualtype_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_visualtype_iterator_t)(unsafe.Pointer(i)).Fdata += 24
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(24))
}

func Xxcb_visualtype_end(tls *libc.TLS, i Txcb_visualtype_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*24
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_depth_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* visuals */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_depth_t)(unsafe.Pointer(_aux)).Fvisuals_len)*libc.Uint64FromInt64(24))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_depth_visuals(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*8
}

func Xxcb_depth_visuals_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_depth_t)(unsafe.Pointer(R)).Fvisuals_len)
}

func Xxcb_depth_visuals_iterator(tls *libc.TLS, R uintptr) (r Txcb_visualtype_iterator_t) {
	var i Txcb_visualtype_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*8
	i.Frem = libc.Int32FromUint16((*Txcb_depth_t)(unsafe.Pointer(R)).Fvisuals_len)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_depth_next(tls *libc.TLS, i uintptr) {
	var R uintptr
	var child Txcb_generic_iterator_t
	_, _ = R, child
	R = (*Txcb_depth_iterator_t)(unsafe.Pointer(i)).Fdata
	child.Fdata = R + uintptr(Xxcb_depth_sizeof(tls, R))
	(*Txcb_depth_iterator_t)(unsafe.Pointer(i)).Findex = int32(int64(child.Fdata) - int64((*Txcb_depth_iterator_t)(unsafe.Pointer(i)).Fdata))
	(*Txcb_depth_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_depth_iterator_t)(unsafe.Pointer(i)).Fdata = child.Fdata
}

func Xxcb_depth_end(tls *libc.TLS, _i Txcb_depth_iterator_t) (r Txcb_generic_iterator_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Txcb_depth_iterator_t)(unsafe.Pointer(bp)) = _i
	var ret Txcb_generic_iterator_t
	_ = ret
	for (*(*Txcb_depth_iterator_t)(unsafe.Pointer(bp))).Frem > 0 {
		Xxcb_depth_next(tls, bp)
	}
	ret.Fdata = (*(*Txcb_depth_iterator_t)(unsafe.Pointer(bp))).Fdata
	ret.Frem = (*(*Txcb_depth_iterator_t)(unsafe.Pointer(bp))).Frem
	ret.Findex = (*(*Txcb_depth_iterator_t)(unsafe.Pointer(bp))).Findex
	return ret
}

func Xxcb_screen_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp_len uint32
	_, _, _, _, _, _, _, _ = _aux, i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp, xcb_tmp_len
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(40))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* allowed_depths */
	i = uint32(0)
	for {
		if !(i < uint32((*Txcb_screen_t)(unsafe.Pointer(_aux)).Fallowed_depths_len)) {
			break
		}
		xcb_tmp_len = libc.Uint32FromInt32(Xxcb_depth_sizeof(tls, xcb_tmp))
		xcb_block_len += xcb_tmp_len
		xcb_tmp += uintptr(xcb_tmp_len)
		goto _1
	_1:
		;
		i++
	}
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 2))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_screen_allowed_depths_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint8((*Txcb_screen_t)(unsafe.Pointer(R)).Fallowed_depths_len)
}

func Xxcb_screen_allowed_depths_iterator(tls *libc.TLS, R uintptr) (r Txcb_depth_iterator_t) {
	var i Txcb_depth_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*40
	i.Frem = libc.Int32FromUint8((*Txcb_screen_t)(unsafe.Pointer(R)).Fallowed_depths_len)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_screen_next(tls *libc.TLS, i uintptr) {
	var R uintptr
	var child Txcb_generic_iterator_t
	_, _ = R, child
	R = (*Txcb_screen_iterator_t)(unsafe.Pointer(i)).Fdata
	child.Fdata = R + uintptr(Xxcb_screen_sizeof(tls, R))
	(*Txcb_screen_iterator_t)(unsafe.Pointer(i)).Findex = int32(int64(child.Fdata) - int64((*Txcb_screen_iterator_t)(unsafe.Pointer(i)).Fdata))
	(*Txcb_screen_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_screen_iterator_t)(unsafe.Pointer(i)).Fdata = child.Fdata
}

func Xxcb_screen_end(tls *libc.TLS, _i Txcb_screen_iterator_t) (r Txcb_generic_iterator_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Txcb_screen_iterator_t)(unsafe.Pointer(bp)) = _i
	var ret Txcb_generic_iterator_t
	_ = ret
	for (*(*Txcb_screen_iterator_t)(unsafe.Pointer(bp))).Frem > 0 {
		Xxcb_screen_next(tls, bp)
	}
	ret.Fdata = (*(*Txcb_screen_iterator_t)(unsafe.Pointer(bp))).Fdata
	ret.Frem = (*(*Txcb_screen_iterator_t)(unsafe.Pointer(bp))).Frem
	ret.Findex = (*(*Txcb_screen_iterator_t)(unsafe.Pointer(bp))).Findex
	return ret
}

func Xxcb_setup_request_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* authorization_protocol_name */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_setup_request_t)(unsafe.Pointer(_aux)).Fauthorization_protocol_name_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	xcb_align_to = uint32(4)
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	/* authorization_protocol_data */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_setup_request_t)(unsafe.Pointer(_aux)).Fauthorization_protocol_data_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	xcb_align_to = uint32(4)
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_setup_request_authorization_protocol_name(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_setup_request_authorization_protocol_name_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_setup_request_t)(unsafe.Pointer(R)).Fauthorization_protocol_name_len)
}

func Xxcb_setup_request_authorization_protocol_name_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*12 + uintptr((*Txcb_setup_request_t)(unsafe.Pointer(R)).Fauthorization_protocol_name_len)
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_setup_request_authorization_protocol_data(tls *libc.TLS, R uintptr) (r uintptr) {
	var prev Txcb_generic_iterator_t
	_ = prev
	prev = Xxcb_setup_request_authorization_protocol_name_end(tls, R)
	return prev.Fdata + uintptr(-prev.Findex&(libc.Int32FromInt32(4)-libc.Int32FromInt32(1))) + libc.UintptrFromInt32(0)
}

func Xxcb_setup_request_authorization_protocol_data_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_setup_request_t)(unsafe.Pointer(R)).Fauthorization_protocol_data_len)
}

func Xxcb_setup_request_authorization_protocol_data_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i, prev Txcb_generic_iterator_t
	_, _ = i, prev
	prev = Xxcb_setup_request_authorization_protocol_name_end(tls, R)
	i.Fdata = prev.Fdata + uintptr(-prev.Findex&(libc.Int32FromInt32(4)-libc.Int32FromInt32(1))) + uintptr((*Txcb_setup_request_t)(unsafe.Pointer(R)).Fauthorization_protocol_data_len)
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_setup_request_next(tls *libc.TLS, i uintptr) {
	var R uintptr
	var child Txcb_generic_iterator_t
	_, _ = R, child
	R = (*Txcb_setup_request_iterator_t)(unsafe.Pointer(i)).Fdata
	child.Fdata = R + uintptr(Xxcb_setup_request_sizeof(tls, R))
	(*Txcb_setup_request_iterator_t)(unsafe.Pointer(i)).Findex = int32(int64(child.Fdata) - int64((*Txcb_setup_request_iterator_t)(unsafe.Pointer(i)).Fdata))
	(*Txcb_setup_request_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_setup_request_iterator_t)(unsafe.Pointer(i)).Fdata = child.Fdata
}

func Xxcb_setup_request_end(tls *libc.TLS, _i Txcb_setup_request_iterator_t) (r Txcb_generic_iterator_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Txcb_setup_request_iterator_t)(unsafe.Pointer(bp)) = _i
	var ret Txcb_generic_iterator_t
	_ = ret
	for (*(*Txcb_setup_request_iterator_t)(unsafe.Pointer(bp))).Frem > 0 {
		Xxcb_setup_request_next(tls, bp)
	}
	ret.Fdata = (*(*Txcb_setup_request_iterator_t)(unsafe.Pointer(bp))).Fdata
	ret.Frem = (*(*Txcb_setup_request_iterator_t)(unsafe.Pointer(bp))).Frem
	ret.Findex = (*(*Txcb_setup_request_iterator_t)(unsafe.Pointer(bp))).Findex
	return ret
}

func Xxcb_setup_failed_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* reason */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_setup_failed_t)(unsafe.Pointer(_aux)).Freason_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_setup_failed_reason(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*8
}

func Xxcb_setup_failed_reason_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint8((*Txcb_setup_failed_t)(unsafe.Pointer(R)).Freason_len)
}

func Xxcb_setup_failed_reason_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*8 + uintptr((*Txcb_setup_failed_t)(unsafe.Pointer(R)).Freason_len)
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_setup_failed_next(tls *libc.TLS, i uintptr) {
	var R uintptr
	var child Txcb_generic_iterator_t
	_, _ = R, child
	R = (*Txcb_setup_failed_iterator_t)(unsafe.Pointer(i)).Fdata
	child.Fdata = R + uintptr(Xxcb_setup_failed_sizeof(tls, R))
	(*Txcb_setup_failed_iterator_t)(unsafe.Pointer(i)).Findex = int32(int64(child.Fdata) - int64((*Txcb_setup_failed_iterator_t)(unsafe.Pointer(i)).Fdata))
	(*Txcb_setup_failed_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_setup_failed_iterator_t)(unsafe.Pointer(i)).Fdata = child.Fdata
}

func Xxcb_setup_failed_end(tls *libc.TLS, _i Txcb_setup_failed_iterator_t) (r Txcb_generic_iterator_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Txcb_setup_failed_iterator_t)(unsafe.Pointer(bp)) = _i
	var ret Txcb_generic_iterator_t
	_ = ret
	for (*(*Txcb_setup_failed_iterator_t)(unsafe.Pointer(bp))).Frem > 0 {
		Xxcb_setup_failed_next(tls, bp)
	}
	ret.Fdata = (*(*Txcb_setup_failed_iterator_t)(unsafe.Pointer(bp))).Fdata
	ret.Frem = (*(*Txcb_setup_failed_iterator_t)(unsafe.Pointer(bp))).Frem
	ret.Findex = (*(*Txcb_setup_failed_iterator_t)(unsafe.Pointer(bp))).Findex
	return ret
}

func Xxcb_setup_authenticate_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* reason */
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_setup_authenticate_t)(unsafe.Pointer(_aux)).Flength)*libc.Int32FromInt32(4))*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_setup_authenticate_reason(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*8
}

func Xxcb_setup_authenticate_reason_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_setup_authenticate_t)(unsafe.Pointer(R)).Flength) * int32(4)
}

func Xxcb_setup_authenticate_reason_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*8 + uintptr(libc.Int32FromUint16((*Txcb_setup_authenticate_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4))
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_setup_authenticate_next(tls *libc.TLS, i uintptr) {
	var R uintptr
	var child Txcb_generic_iterator_t
	_, _ = R, child
	R = (*Txcb_setup_authenticate_iterator_t)(unsafe.Pointer(i)).Fdata
	child.Fdata = R + uintptr(Xxcb_setup_authenticate_sizeof(tls, R))
	(*Txcb_setup_authenticate_iterator_t)(unsafe.Pointer(i)).Findex = int32(int64(child.Fdata) - int64((*Txcb_setup_authenticate_iterator_t)(unsafe.Pointer(i)).Fdata))
	(*Txcb_setup_authenticate_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_setup_authenticate_iterator_t)(unsafe.Pointer(i)).Fdata = child.Fdata
}

func Xxcb_setup_authenticate_end(tls *libc.TLS, _i Txcb_setup_authenticate_iterator_t) (r Txcb_generic_iterator_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Txcb_setup_authenticate_iterator_t)(unsafe.Pointer(bp)) = _i
	var ret Txcb_generic_iterator_t
	_ = ret
	for (*(*Txcb_setup_authenticate_iterator_t)(unsafe.Pointer(bp))).Frem > 0 {
		Xxcb_setup_authenticate_next(tls, bp)
	}
	ret.Fdata = (*(*Txcb_setup_authenticate_iterator_t)(unsafe.Pointer(bp))).Fdata
	ret.Frem = (*(*Txcb_setup_authenticate_iterator_t)(unsafe.Pointer(bp))).Frem
	ret.Findex = (*(*Txcb_setup_authenticate_iterator_t)(unsafe.Pointer(bp))).Findex
	return ret
}

func Xxcb_setup_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp_len uint32
	_, _, _, _, _, _, _, _ = _aux, i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp, xcb_tmp_len
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(40))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* vendor */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_setup_t)(unsafe.Pointer(_aux)).Fvendor_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	xcb_align_to = uint32(4)
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	/* pixmap_formats */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_setup_t)(unsafe.Pointer(_aux)).Fpixmap_formats_len)*libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	/* roots */
	i = uint32(0)
	for {
		if !(i < uint32((*Txcb_setup_t)(unsafe.Pointer(_aux)).Froots_len)) {
			break
		}
		xcb_tmp_len = libc.Uint32FromInt32(Xxcb_screen_sizeof(tls, xcb_tmp))
		xcb_block_len += xcb_tmp_len
		xcb_tmp += uintptr(xcb_tmp_len)
		goto _1
	_1:
		;
		i++
	}
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_setup_vendor(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*40
}

func Xxcb_setup_vendor_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_setup_t)(unsafe.Pointer(R)).Fvendor_len)
}

func Xxcb_setup_vendor_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*40 + uintptr((*Txcb_setup_t)(unsafe.Pointer(R)).Fvendor_len)
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_setup_pixmap_formats(tls *libc.TLS, R uintptr) (r uintptr) {
	var prev Txcb_generic_iterator_t
	_ = prev
	prev = Xxcb_setup_vendor_end(tls, R)
	return prev.Fdata + uintptr(-prev.Findex&(libc.Int32FromInt32(4)-libc.Int32FromInt32(1))) + libc.UintptrFromInt32(0)
}

func Xxcb_setup_pixmap_formats_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint8((*Txcb_setup_t)(unsafe.Pointer(R)).Fpixmap_formats_len)
}

func Xxcb_setup_pixmap_formats_iterator(tls *libc.TLS, R uintptr) (r Txcb_format_iterator_t) {
	var i Txcb_format_iterator_t
	var prev Txcb_generic_iterator_t
	_, _ = i, prev
	prev = Xxcb_setup_vendor_end(tls, R)
	i.Fdata = prev.Fdata + uintptr(-prev.Findex&(libc.Int32FromInt32(4)-libc.Int32FromInt32(1)))
	i.Frem = libc.Int32FromUint8((*Txcb_setup_t)(unsafe.Pointer(R)).Fpixmap_formats_len)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_setup_roots_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint8((*Txcb_setup_t)(unsafe.Pointer(R)).Froots_len)
}

func Xxcb_setup_roots_iterator(tls *libc.TLS, R uintptr) (r Txcb_screen_iterator_t) {
	var i Txcb_screen_iterator_t
	var prev Txcb_generic_iterator_t
	_, _ = i, prev
	prev = Xxcb_format_end(tls, Xxcb_setup_pixmap_formats_iterator(tls, R))
	i.Fdata = prev.Fdata + uintptr(libc.Uint64FromInt32(-prev.Findex)&libc.Uint64FromInt32(3))
	i.Frem = libc.Int32FromUint8((*Txcb_setup_t)(unsafe.Pointer(R)).Froots_len)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_setup_next(tls *libc.TLS, i uintptr) {
	var R uintptr
	var child Txcb_generic_iterator_t
	_, _ = R, child
	R = (*Txcb_setup_iterator_t)(unsafe.Pointer(i)).Fdata
	child.Fdata = R + uintptr(Xxcb_setup_sizeof(tls, R))
	(*Txcb_setup_iterator_t)(unsafe.Pointer(i)).Findex = int32(int64(child.Fdata) - int64((*Txcb_setup_iterator_t)(unsafe.Pointer(i)).Fdata))
	(*Txcb_setup_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_setup_iterator_t)(unsafe.Pointer(i)).Fdata = child.Fdata
}

func Xxcb_setup_end(tls *libc.TLS, _i Txcb_setup_iterator_t) (r Txcb_generic_iterator_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Txcb_setup_iterator_t)(unsafe.Pointer(bp)) = _i
	var ret Txcb_generic_iterator_t
	_ = ret
	for (*(*Txcb_setup_iterator_t)(unsafe.Pointer(bp))).Frem > 0 {
		Xxcb_setup_next(tls, bp)
	}
	ret.Fdata = (*(*Txcb_setup_iterator_t)(unsafe.Pointer(bp))).Fdata
	ret.Frem = (*(*Txcb_setup_iterator_t)(unsafe.Pointer(bp))).Frem
	ret.Findex = (*(*Txcb_setup_iterator_t)(unsafe.Pointer(bp))).Findex
	return ret
}

func Xxcb_client_message_data_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_client_message_data_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_client_message_data_iterator_t)(unsafe.Pointer(i)).Fdata += 20
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(20))
}

func Xxcb_client_message_data_end(tls *libc.TLS, i Txcb_client_message_data_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*20
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_create_window_value_list_serialize(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t, _aux uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset, xcb_parts_idx uint32
	var xcb_out, xcb_tmp uintptr
	var xcb_parts [16]Tiovec
	var _ /* xcb_pad0 at bp+0 */ [3]int8
	_, _, _, _, _, _, _, _, _, _ = i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_out, xcb_pad, xcb_padding_offset, xcb_parts, xcb_parts_idx, xcb_tmp
	xcb_out = *(*uintptr)(unsafe.Pointer(_buffer))
	xcb_buffer_len = uint32(0)
	xcb_align_to = uint32(0)
	xcb_padding_offset = uint32(0)
	xcb_pad = uint32(0)
	*(*[3]int8)(unsafe.Pointer(bp)) = [3]int8{}
	xcb_parts_idx = uint32(0)
	xcb_block_len = uint32(0)
	if value_mask&uint32(_XCB_CW_BACK_PIXMAP) != 0 {
		/* xcb_create_window_value_list_t.background_pixmap */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACK_PIXEL) != 0 {
		/* xcb_create_window_value_list_t.background_pixel */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 4
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BORDER_PIXMAP) != 0 {
		/* xcb_create_window_value_list_t.border_pixmap */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 8
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BORDER_PIXEL) != 0 {
		/* xcb_create_window_value_list_t.border_pixel */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 12
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BIT_GRAVITY) != 0 {
		/* xcb_create_window_value_list_t.bit_gravity */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 16
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_WIN_GRAVITY) != 0 {
		/* xcb_create_window_value_list_t.win_gravity */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 20
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACKING_STORE) != 0 {
		/* xcb_create_window_value_list_t.backing_store */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 24
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACKING_PLANES) != 0 {
		/* xcb_create_window_value_list_t.backing_planes */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 28
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACKING_PIXEL) != 0 {
		/* xcb_create_window_value_list_t.backing_pixel */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 32
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_OVERRIDE_REDIRECT) != 0 {
		/* xcb_create_window_value_list_t.override_redirect */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 36
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_SAVE_UNDER) != 0 {
		/* xcb_create_window_value_list_t.save_under */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 40
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_EVENT_MASK) != 0 {
		/* xcb_create_window_value_list_t.event_mask */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 44
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_DONT_PROPAGATE) != 0 {
		/* xcb_create_window_value_list_t.do_not_propogate_mask */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 48
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_COLORMAP) != 0 {
		/* xcb_create_window_value_list_t.colormap */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 52
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_CURSOR) != 0 {
		/* xcb_create_window_value_list_t.cursor */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 56
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	/* insert padding */
	xcb_pad = -(xcb_block_len + xcb_padding_offset) & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_parts[xcb_parts_idx].Fiov_base = bp
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(xcb_pad)
		xcb_parts_idx++
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	xcb_padding_offset = uint32(0)
	if libc.UintptrFromInt32(0) == xcb_out {
		/* allocate memory */
		xcb_out = libc.Xmalloc(tls, uint64(xcb_buffer_len))
		*(*uintptr)(unsafe.Pointer(_buffer)) = xcb_out
	}
	xcb_tmp = xcb_out
	i = uint32(0)
	for {
		if !(i < xcb_parts_idx) {
			break
		}
		if uintptr(0) != xcb_parts[i].Fiov_base && uint64(0) != xcb_parts[i].Fiov_len {
			libc.Xmemcpy(tls, xcb_tmp, xcb_parts[i].Fiov_base, xcb_parts[i].Fiov_len)
		}
		if uint64(0) != xcb_parts[i].Fiov_len {
			xcb_tmp += uintptr(xcb_parts[i].Fiov_len)
		}
		goto _1
	_1:
		;
		i++
	}
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_create_window_value_list_unpack(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t, _aux uintptr) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset uint32
	var xcb_tmp uintptr
	_, _, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_padding_offset = uint32(0)
	if value_mask&uint32(_XCB_CW_BACK_PIXMAP) != 0 {
		/* xcb_create_window_value_list_t.background_pixmap */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Fbackground_pixmap = *(*Txcb_pixmap_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACK_PIXEL) != 0 {
		/* xcb_create_window_value_list_t.background_pixel */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Fbackground_pixel = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BORDER_PIXMAP) != 0 {
		/* xcb_create_window_value_list_t.border_pixmap */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Fborder_pixmap = *(*Txcb_pixmap_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BORDER_PIXEL) != 0 {
		/* xcb_create_window_value_list_t.border_pixel */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Fborder_pixel = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BIT_GRAVITY) != 0 {
		/* xcb_create_window_value_list_t.bit_gravity */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Fbit_gravity = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_WIN_GRAVITY) != 0 {
		/* xcb_create_window_value_list_t.win_gravity */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Fwin_gravity = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACKING_STORE) != 0 {
		/* xcb_create_window_value_list_t.backing_store */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Fbacking_store = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACKING_PLANES) != 0 {
		/* xcb_create_window_value_list_t.backing_planes */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Fbacking_planes = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACKING_PIXEL) != 0 {
		/* xcb_create_window_value_list_t.backing_pixel */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Fbacking_pixel = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_OVERRIDE_REDIRECT) != 0 {
		/* xcb_create_window_value_list_t.override_redirect */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Foverride_redirect = *(*Txcb_bool32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_SAVE_UNDER) != 0 {
		/* xcb_create_window_value_list_t.save_under */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Fsave_under = *(*Txcb_bool32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_EVENT_MASK) != 0 {
		/* xcb_create_window_value_list_t.event_mask */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Fevent_mask = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_DONT_PROPAGATE) != 0 {
		/* xcb_create_window_value_list_t.do_not_propogate_mask */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Fdo_not_propogate_mask = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_COLORMAP) != 0 {
		/* xcb_create_window_value_list_t.colormap */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Fcolormap = *(*Txcb_colormap_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_CURSOR) != 0 {
		/* xcb_create_window_value_list_t.cursor */
		(*Txcb_create_window_value_list_t)(unsafe.Pointer(_aux)).Fcursor = *(*Txcb_cursor_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	/* insert padding */
	xcb_pad = -(xcb_block_len + xcb_padding_offset) & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	xcb_padding_offset = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_create_window_value_list_sizeof(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t) (r int32) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var _ /* _aux at bp+0 */ Txcb_create_window_value_list_t
	return Xxcb_create_window_value_list_unpack(tls, _buffer, value_mask, bp)
}

func Xxcb_create_window_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* value_list */
	xcb_block_len += libc.Uint32FromInt32(Xxcb_create_window_value_list_sizeof(tls, xcb_tmp, (*Txcb_create_window_request_t)(unsafe.Pointer(_aux)).Fvalue_mask))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_create_window_checked(tls *libc.TLS, c uintptr, depth Tuint8_t, wid Txcb_window_t, parent Txcb_window_t, x Tint16_t, y Tint16_t, width Tuint16_t, height Tuint16_t, border_width Tuint16_t, _class Tuint16_t, visual Txcb_visualid_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+80 */ Txcb_create_window_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fdepth = depth
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fwid = wid
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fparent = parent
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fx = x
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fy = y
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fwidth = width
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fheight = height
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fborder_width = border_width
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).F_class = _class
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fvisual = visual
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(32)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_create_window_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = value_list
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_create_window_value_list_sizeof(tls, value_list, value_mask))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req)))
	return xcb_ret
}

var _xcb_req = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CREATE_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_create_window(tls *libc.TLS, c uintptr, depth Tuint8_t, wid Txcb_window_t, parent Txcb_window_t, x Tint16_t, y Tint16_t, width Tuint16_t, height Tuint16_t, border_width Tuint16_t, _class Tuint16_t, visual Txcb_visualid_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+80 */ Txcb_create_window_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fdepth = depth
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fwid = wid
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fparent = parent
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fx = x
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fy = y
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fwidth = width
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fheight = height
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fborder_width = border_width
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).F_class = _class
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fvisual = visual
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(32)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_create_window_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = value_list
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_create_window_value_list_sizeof(tls, value_list, value_mask))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req1)))
	return xcb_ret
}

var _xcb_req1 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CREATE_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_create_window_aux_checked(tls *libc.TLS, c uintptr, depth Tuint8_t, wid Txcb_window_t, parent Txcb_window_t, x Tint16_t, y Tint16_t, width Tuint16_t, height Tuint16_t, border_width Tuint16_t, _class Tuint16_t, visual Txcb_visualid_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_aux0 at bp+112 */ uintptr
	var _ /* xcb_out at bp+80 */ Txcb_create_window_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	*(*uintptr)(unsafe.Pointer(bp + 112)) = uintptr(0)
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fdepth = depth
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fwid = wid
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fparent = parent
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fx = x
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fy = y
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fwidth = width
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fheight = height
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fborder_width = border_width
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).F_class = _class
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fvisual = visual
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(32)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_create_window_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_create_window_value_list_serialize(tls, bp+112, value_mask, value_list))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = *(*uintptr)(unsafe.Pointer(bp + 112))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req2)))
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 112)))
	return xcb_ret
}

var _xcb_req2 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CREATE_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_create_window_aux(tls *libc.TLS, c uintptr, depth Tuint8_t, wid Txcb_window_t, parent Txcb_window_t, x Tint16_t, y Tint16_t, width Tuint16_t, height Tuint16_t, border_width Tuint16_t, _class Tuint16_t, visual Txcb_visualid_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_aux0 at bp+112 */ uintptr
	var _ /* xcb_out at bp+80 */ Txcb_create_window_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	*(*uintptr)(unsafe.Pointer(bp + 112)) = uintptr(0)
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fdepth = depth
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fwid = wid
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fparent = parent
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fx = x
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fy = y
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fwidth = width
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fheight = height
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fborder_width = border_width
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).F_class = _class
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fvisual = visual
	(*(*Txcb_create_window_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(32)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_create_window_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_create_window_value_list_serialize(tls, bp+112, value_mask, value_list))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = *(*uintptr)(unsafe.Pointer(bp + 112))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req3)))
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 112)))
	return xcb_ret
}

var _xcb_req3 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CREATE_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_create_window_value_list(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_change_window_attributes_value_list_serialize(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t, _aux uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset, xcb_parts_idx uint32
	var xcb_out, xcb_tmp uintptr
	var xcb_parts [16]Tiovec
	var _ /* xcb_pad0 at bp+0 */ [3]int8
	_, _, _, _, _, _, _, _, _, _ = i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_out, xcb_pad, xcb_padding_offset, xcb_parts, xcb_parts_idx, xcb_tmp
	xcb_out = *(*uintptr)(unsafe.Pointer(_buffer))
	xcb_buffer_len = uint32(0)
	xcb_align_to = uint32(0)
	xcb_padding_offset = uint32(0)
	xcb_pad = uint32(0)
	*(*[3]int8)(unsafe.Pointer(bp)) = [3]int8{}
	xcb_parts_idx = uint32(0)
	xcb_block_len = uint32(0)
	if value_mask&uint32(_XCB_CW_BACK_PIXMAP) != 0 {
		/* xcb_change_window_attributes_value_list_t.background_pixmap */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACK_PIXEL) != 0 {
		/* xcb_change_window_attributes_value_list_t.background_pixel */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 4
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BORDER_PIXMAP) != 0 {
		/* xcb_change_window_attributes_value_list_t.border_pixmap */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 8
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BORDER_PIXEL) != 0 {
		/* xcb_change_window_attributes_value_list_t.border_pixel */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 12
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BIT_GRAVITY) != 0 {
		/* xcb_change_window_attributes_value_list_t.bit_gravity */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 16
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_WIN_GRAVITY) != 0 {
		/* xcb_change_window_attributes_value_list_t.win_gravity */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 20
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACKING_STORE) != 0 {
		/* xcb_change_window_attributes_value_list_t.backing_store */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 24
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACKING_PLANES) != 0 {
		/* xcb_change_window_attributes_value_list_t.backing_planes */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 28
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACKING_PIXEL) != 0 {
		/* xcb_change_window_attributes_value_list_t.backing_pixel */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 32
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_OVERRIDE_REDIRECT) != 0 {
		/* xcb_change_window_attributes_value_list_t.override_redirect */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 36
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_SAVE_UNDER) != 0 {
		/* xcb_change_window_attributes_value_list_t.save_under */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 40
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_EVENT_MASK) != 0 {
		/* xcb_change_window_attributes_value_list_t.event_mask */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 44
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_DONT_PROPAGATE) != 0 {
		/* xcb_change_window_attributes_value_list_t.do_not_propogate_mask */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 48
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_COLORMAP) != 0 {
		/* xcb_change_window_attributes_value_list_t.colormap */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 52
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_CURSOR) != 0 {
		/* xcb_change_window_attributes_value_list_t.cursor */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 56
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	/* insert padding */
	xcb_pad = -(xcb_block_len + xcb_padding_offset) & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_parts[xcb_parts_idx].Fiov_base = bp
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(xcb_pad)
		xcb_parts_idx++
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	xcb_padding_offset = uint32(0)
	if libc.UintptrFromInt32(0) == xcb_out {
		/* allocate memory */
		xcb_out = libc.Xmalloc(tls, uint64(xcb_buffer_len))
		*(*uintptr)(unsafe.Pointer(_buffer)) = xcb_out
	}
	xcb_tmp = xcb_out
	i = uint32(0)
	for {
		if !(i < xcb_parts_idx) {
			break
		}
		if uintptr(0) != xcb_parts[i].Fiov_base && uint64(0) != xcb_parts[i].Fiov_len {
			libc.Xmemcpy(tls, xcb_tmp, xcb_parts[i].Fiov_base, xcb_parts[i].Fiov_len)
		}
		if uint64(0) != xcb_parts[i].Fiov_len {
			xcb_tmp += uintptr(xcb_parts[i].Fiov_len)
		}
		goto _1
	_1:
		;
		i++
	}
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_change_window_attributes_value_list_unpack(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t, _aux uintptr) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset uint32
	var xcb_tmp uintptr
	_, _, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_padding_offset = uint32(0)
	if value_mask&uint32(_XCB_CW_BACK_PIXMAP) != 0 {
		/* xcb_change_window_attributes_value_list_t.background_pixmap */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Fbackground_pixmap = *(*Txcb_pixmap_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACK_PIXEL) != 0 {
		/* xcb_change_window_attributes_value_list_t.background_pixel */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Fbackground_pixel = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BORDER_PIXMAP) != 0 {
		/* xcb_change_window_attributes_value_list_t.border_pixmap */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Fborder_pixmap = *(*Txcb_pixmap_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BORDER_PIXEL) != 0 {
		/* xcb_change_window_attributes_value_list_t.border_pixel */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Fborder_pixel = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BIT_GRAVITY) != 0 {
		/* xcb_change_window_attributes_value_list_t.bit_gravity */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Fbit_gravity = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_WIN_GRAVITY) != 0 {
		/* xcb_change_window_attributes_value_list_t.win_gravity */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Fwin_gravity = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACKING_STORE) != 0 {
		/* xcb_change_window_attributes_value_list_t.backing_store */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Fbacking_store = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACKING_PLANES) != 0 {
		/* xcb_change_window_attributes_value_list_t.backing_planes */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Fbacking_planes = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_BACKING_PIXEL) != 0 {
		/* xcb_change_window_attributes_value_list_t.backing_pixel */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Fbacking_pixel = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_OVERRIDE_REDIRECT) != 0 {
		/* xcb_change_window_attributes_value_list_t.override_redirect */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Foverride_redirect = *(*Txcb_bool32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_SAVE_UNDER) != 0 {
		/* xcb_change_window_attributes_value_list_t.save_under */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Fsave_under = *(*Txcb_bool32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_EVENT_MASK) != 0 {
		/* xcb_change_window_attributes_value_list_t.event_mask */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Fevent_mask = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_DONT_PROPAGATE) != 0 {
		/* xcb_change_window_attributes_value_list_t.do_not_propogate_mask */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Fdo_not_propogate_mask = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_COLORMAP) != 0 {
		/* xcb_change_window_attributes_value_list_t.colormap */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Fcolormap = *(*Txcb_colormap_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_CW_CURSOR) != 0 {
		/* xcb_change_window_attributes_value_list_t.cursor */
		(*Txcb_change_window_attributes_value_list_t)(unsafe.Pointer(_aux)).Fcursor = *(*Txcb_cursor_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	/* insert padding */
	xcb_pad = -(xcb_block_len + xcb_padding_offset) & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	xcb_padding_offset = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_change_window_attributes_value_list_sizeof(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t) (r int32) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var _ /* _aux at bp+0 */ Txcb_change_window_attributes_value_list_t
	return Xxcb_change_window_attributes_value_list_unpack(tls, _buffer, value_mask, bp)
}

func Xxcb_change_window_attributes_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* value_list */
	xcb_block_len += libc.Uint32FromInt32(Xxcb_change_window_attributes_value_list_sizeof(tls, xcb_tmp, (*Txcb_change_window_attributes_request_t)(unsafe.Pointer(_aux)).Fvalue_mask))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_change_window_attributes_checked(tls *libc.TLS, c uintptr, window Txcb_window_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+80 */ Txcb_change_window_attributes_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_window_attributes_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_change_window_attributes_request_t)(unsafe.Pointer(bp + 80))).Fwindow = window
	(*(*Txcb_change_window_attributes_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_change_window_attributes_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = value_list
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_change_window_attributes_value_list_sizeof(tls, value_list, value_mask))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req4)))
	return xcb_ret
}

var _xcb_req4 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CHANGE_WINDOW_ATTRIBUTES),
	Fisvoid: uint8(1),
}

func Xxcb_change_window_attributes(tls *libc.TLS, c uintptr, window Txcb_window_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+80 */ Txcb_change_window_attributes_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_window_attributes_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_change_window_attributes_request_t)(unsafe.Pointer(bp + 80))).Fwindow = window
	(*(*Txcb_change_window_attributes_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_change_window_attributes_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = value_list
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_change_window_attributes_value_list_sizeof(tls, value_list, value_mask))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req5)))
	return xcb_ret
}

var _xcb_req5 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CHANGE_WINDOW_ATTRIBUTES),
	Fisvoid: uint8(1),
}

func Xxcb_change_window_attributes_aux_checked(tls *libc.TLS, c uintptr, window Txcb_window_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_aux0 at bp+96 */ uintptr
	var _ /* xcb_out at bp+80 */ Txcb_change_window_attributes_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	*(*uintptr)(unsafe.Pointer(bp + 96)) = uintptr(0)
	(*(*Txcb_change_window_attributes_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_change_window_attributes_request_t)(unsafe.Pointer(bp + 80))).Fwindow = window
	(*(*Txcb_change_window_attributes_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_change_window_attributes_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_change_window_attributes_value_list_serialize(tls, bp+96, value_mask, value_list))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = *(*uintptr)(unsafe.Pointer(bp + 96))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req6)))
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 96)))
	return xcb_ret
}

var _xcb_req6 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CHANGE_WINDOW_ATTRIBUTES),
	Fisvoid: uint8(1),
}

func Xxcb_change_window_attributes_aux(tls *libc.TLS, c uintptr, window Txcb_window_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_aux0 at bp+96 */ uintptr
	var _ /* xcb_out at bp+80 */ Txcb_change_window_attributes_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	*(*uintptr)(unsafe.Pointer(bp + 96)) = uintptr(0)
	(*(*Txcb_change_window_attributes_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_change_window_attributes_request_t)(unsafe.Pointer(bp + 80))).Fwindow = window
	(*(*Txcb_change_window_attributes_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_change_window_attributes_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_change_window_attributes_value_list_serialize(tls, bp+96, value_mask, value_list))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = *(*uintptr)(unsafe.Pointer(bp + 96))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req7)))
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 96)))
	return xcb_ret
}

var _xcb_req7 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CHANGE_WINDOW_ATTRIBUTES),
	Fisvoid: uint8(1),
}

func Xxcb_change_window_attributes_value_list(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_get_window_attributes(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_get_window_attributes_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_window_attributes_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_window_attributes_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_window_attributes_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_get_window_attributes_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req8)))
	return xcb_ret
}

var _xcb_req8 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_WINDOW_ATTRIBUTES),
}

func Xxcb_get_window_attributes_unchecked(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_get_window_attributes_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_window_attributes_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_window_attributes_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_window_attributes_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_get_window_attributes_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req9)))
	return xcb_ret
}

var _xcb_req9 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_WINDOW_ATTRIBUTES),
}

func Xxcb_get_window_attributes_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_window_attributes_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_destroy_window_checked(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_destroy_window_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_destroy_window_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_destroy_window_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req10)))
	return xcb_ret
}

var _xcb_req10 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_DESTROY_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_destroy_window(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_destroy_window_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_destroy_window_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_destroy_window_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req11)))
	return xcb_ret
}

var _xcb_req11 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_DESTROY_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_destroy_subwindows_checked(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_destroy_subwindows_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_destroy_subwindows_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_destroy_subwindows_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req12)))
	return xcb_ret
}

var _xcb_req12 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_DESTROY_SUBWINDOWS),
	Fisvoid: uint8(1),
}

func Xxcb_destroy_subwindows(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_destroy_subwindows_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_destroy_subwindows_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_destroy_subwindows_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req13)))
	return xcb_ret
}

var _xcb_req13 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_DESTROY_SUBWINDOWS),
	Fisvoid: uint8(1),
}

func Xxcb_change_save_set_checked(tls *libc.TLS, c uintptr, mode Tuint8_t, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_change_save_set_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_save_set_request_t)(unsafe.Pointer(bp + 64))).Fmode = mode
	(*(*Txcb_change_save_set_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req14)))
	return xcb_ret
}

var _xcb_req14 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CHANGE_SAVE_SET),
	Fisvoid: uint8(1),
}

func Xxcb_change_save_set(tls *libc.TLS, c uintptr, mode Tuint8_t, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_change_save_set_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_save_set_request_t)(unsafe.Pointer(bp + 64))).Fmode = mode
	(*(*Txcb_change_save_set_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req15)))
	return xcb_ret
}

var _xcb_req15 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CHANGE_SAVE_SET),
	Fisvoid: uint8(1),
}

func Xxcb_reparent_window_checked(tls *libc.TLS, c uintptr, window Txcb_window_t, parent Txcb_window_t, x Tint16_t, y Tint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_reparent_window_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_reparent_window_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_reparent_window_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*Txcb_reparent_window_request_t)(unsafe.Pointer(bp + 64))).Fparent = parent
	(*(*Txcb_reparent_window_request_t)(unsafe.Pointer(bp + 64))).Fx = x
	(*(*Txcb_reparent_window_request_t)(unsafe.Pointer(bp + 64))).Fy = y
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req16)))
	return xcb_ret
}

var _xcb_req16 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_REPARENT_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_reparent_window(tls *libc.TLS, c uintptr, window Txcb_window_t, parent Txcb_window_t, x Tint16_t, y Tint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_reparent_window_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_reparent_window_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_reparent_window_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*Txcb_reparent_window_request_t)(unsafe.Pointer(bp + 64))).Fparent = parent
	(*(*Txcb_reparent_window_request_t)(unsafe.Pointer(bp + 64))).Fx = x
	(*(*Txcb_reparent_window_request_t)(unsafe.Pointer(bp + 64))).Fy = y
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req17)))
	return xcb_ret
}

var _xcb_req17 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_REPARENT_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_map_window_checked(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_map_window_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_map_window_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_map_window_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req18)))
	return xcb_ret
}

var _xcb_req18 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_MAP_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_map_window(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_map_window_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_map_window_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_map_window_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req19)))
	return xcb_ret
}

var _xcb_req19 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_MAP_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_map_subwindows_checked(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_map_subwindows_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_map_subwindows_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_map_subwindows_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req20)))
	return xcb_ret
}

var _xcb_req20 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_MAP_SUBWINDOWS),
	Fisvoid: uint8(1),
}

func Xxcb_map_subwindows(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_map_subwindows_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_map_subwindows_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_map_subwindows_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req21)))
	return xcb_ret
}

var _xcb_req21 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_MAP_SUBWINDOWS),
	Fisvoid: uint8(1),
}

func Xxcb_unmap_window_checked(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_unmap_window_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_unmap_window_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_unmap_window_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req22)))
	return xcb_ret
}

var _xcb_req22 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNMAP_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_unmap_window(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_unmap_window_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_unmap_window_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_unmap_window_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req23)))
	return xcb_ret
}

var _xcb_req23 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNMAP_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_unmap_subwindows_checked(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_unmap_subwindows_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_unmap_subwindows_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_unmap_subwindows_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req24)))
	return xcb_ret
}

var _xcb_req24 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNMAP_SUBWINDOWS),
	Fisvoid: uint8(1),
}

func Xxcb_unmap_subwindows(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_unmap_subwindows_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_unmap_subwindows_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_unmap_subwindows_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req25)))
	return xcb_ret
}

var _xcb_req25 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNMAP_SUBWINDOWS),
	Fisvoid: uint8(1),
}

func Xxcb_configure_window_value_list_serialize(tls *libc.TLS, _buffer uintptr, value_mask Tuint16_t, _aux uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset, xcb_parts_idx uint32
	var xcb_out, xcb_tmp uintptr
	var xcb_parts [8]Tiovec
	var _ /* xcb_pad0 at bp+0 */ [3]int8
	_, _, _, _, _, _, _, _, _, _ = i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_out, xcb_pad, xcb_padding_offset, xcb_parts, xcb_parts_idx, xcb_tmp
	xcb_out = *(*uintptr)(unsafe.Pointer(_buffer))
	xcb_buffer_len = uint32(0)
	xcb_align_to = uint32(0)
	xcb_padding_offset = uint32(0)
	xcb_pad = uint32(0)
	*(*[3]int8)(unsafe.Pointer(bp)) = [3]int8{}
	xcb_parts_idx = uint32(0)
	xcb_block_len = uint32(0)
	if libc.Int32FromUint16(value_mask)&int32(_XCB_CONFIG_WINDOW_X) != 0 {
		/* xcb_configure_window_value_list_t.x */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if libc.Int32FromUint16(value_mask)&int32(_XCB_CONFIG_WINDOW_Y) != 0 {
		/* xcb_configure_window_value_list_t.y */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 4
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if libc.Int32FromUint16(value_mask)&int32(_XCB_CONFIG_WINDOW_WIDTH) != 0 {
		/* xcb_configure_window_value_list_t.width */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 8
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if libc.Int32FromUint16(value_mask)&int32(_XCB_CONFIG_WINDOW_HEIGHT) != 0 {
		/* xcb_configure_window_value_list_t.height */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 12
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if libc.Int32FromUint16(value_mask)&int32(_XCB_CONFIG_WINDOW_BORDER_WIDTH) != 0 {
		/* xcb_configure_window_value_list_t.border_width */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 16
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if libc.Int32FromUint16(value_mask)&int32(_XCB_CONFIG_WINDOW_SIBLING) != 0 {
		/* xcb_configure_window_value_list_t.sibling */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 20
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if libc.Int32FromUint16(value_mask)&int32(_XCB_CONFIG_WINDOW_STACK_MODE) != 0 {
		/* xcb_configure_window_value_list_t.stack_mode */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 24
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	/* insert padding */
	xcb_pad = -(xcb_block_len + xcb_padding_offset) & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_parts[xcb_parts_idx].Fiov_base = bp
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(xcb_pad)
		xcb_parts_idx++
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	xcb_padding_offset = uint32(0)
	if libc.UintptrFromInt32(0) == xcb_out {
		/* allocate memory */
		xcb_out = libc.Xmalloc(tls, uint64(xcb_buffer_len))
		*(*uintptr)(unsafe.Pointer(_buffer)) = xcb_out
	}
	xcb_tmp = xcb_out
	i = uint32(0)
	for {
		if !(i < xcb_parts_idx) {
			break
		}
		if uintptr(0) != xcb_parts[i].Fiov_base && uint64(0) != xcb_parts[i].Fiov_len {
			libc.Xmemcpy(tls, xcb_tmp, xcb_parts[i].Fiov_base, xcb_parts[i].Fiov_len)
		}
		if uint64(0) != xcb_parts[i].Fiov_len {
			xcb_tmp += uintptr(xcb_parts[i].Fiov_len)
		}
		goto _1
	_1:
		;
		i++
	}
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_configure_window_value_list_unpack(tls *libc.TLS, _buffer uintptr, value_mask Tuint16_t, _aux uintptr) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset uint32
	var xcb_tmp uintptr
	_, _, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_padding_offset = uint32(0)
	if libc.Int32FromUint16(value_mask)&int32(_XCB_CONFIG_WINDOW_X) != 0 {
		/* xcb_configure_window_value_list_t.x */
		(*Txcb_configure_window_value_list_t)(unsafe.Pointer(_aux)).Fx = *(*Tint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if libc.Int32FromUint16(value_mask)&int32(_XCB_CONFIG_WINDOW_Y) != 0 {
		/* xcb_configure_window_value_list_t.y */
		(*Txcb_configure_window_value_list_t)(unsafe.Pointer(_aux)).Fy = *(*Tint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if libc.Int32FromUint16(value_mask)&int32(_XCB_CONFIG_WINDOW_WIDTH) != 0 {
		/* xcb_configure_window_value_list_t.width */
		(*Txcb_configure_window_value_list_t)(unsafe.Pointer(_aux)).Fwidth = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if libc.Int32FromUint16(value_mask)&int32(_XCB_CONFIG_WINDOW_HEIGHT) != 0 {
		/* xcb_configure_window_value_list_t.height */
		(*Txcb_configure_window_value_list_t)(unsafe.Pointer(_aux)).Fheight = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if libc.Int32FromUint16(value_mask)&int32(_XCB_CONFIG_WINDOW_BORDER_WIDTH) != 0 {
		/* xcb_configure_window_value_list_t.border_width */
		(*Txcb_configure_window_value_list_t)(unsafe.Pointer(_aux)).Fborder_width = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if libc.Int32FromUint16(value_mask)&int32(_XCB_CONFIG_WINDOW_SIBLING) != 0 {
		/* xcb_configure_window_value_list_t.sibling */
		(*Txcb_configure_window_value_list_t)(unsafe.Pointer(_aux)).Fsibling = *(*Txcb_window_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if libc.Int32FromUint16(value_mask)&int32(_XCB_CONFIG_WINDOW_STACK_MODE) != 0 {
		/* xcb_configure_window_value_list_t.stack_mode */
		(*Txcb_configure_window_value_list_t)(unsafe.Pointer(_aux)).Fstack_mode = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	/* insert padding */
	xcb_pad = -(xcb_block_len + xcb_padding_offset) & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	xcb_padding_offset = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_configure_window_value_list_sizeof(tls *libc.TLS, _buffer uintptr, value_mask Tuint16_t) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* _aux at bp+0 */ Txcb_configure_window_value_list_t
	return Xxcb_configure_window_value_list_unpack(tls, _buffer, value_mask, bp)
}

func Xxcb_configure_window_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* value_list */
	xcb_block_len += libc.Uint32FromInt32(Xxcb_configure_window_value_list_sizeof(tls, xcb_tmp, (*Txcb_configure_window_request_t)(unsafe.Pointer(_aux)).Fvalue_mask))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_configure_window_checked(tls *libc.TLS, c uintptr, window Txcb_window_t, value_mask Tuint16_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+80 */ Txcb_configure_window_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	(*(*Txcb_configure_window_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_configure_window_request_t)(unsafe.Pointer(bp + 80))).Fwindow = window
	(*(*Txcb_configure_window_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	libc.Xmemset(tls, bp+80+10, 0, uint64(2))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_configure_window_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = value_list
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_configure_window_value_list_sizeof(tls, value_list, value_mask))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req26)))
	return xcb_ret
}

var _xcb_req26 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CONFIGURE_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_configure_window(tls *libc.TLS, c uintptr, window Txcb_window_t, value_mask Tuint16_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+80 */ Txcb_configure_window_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	(*(*Txcb_configure_window_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_configure_window_request_t)(unsafe.Pointer(bp + 80))).Fwindow = window
	(*(*Txcb_configure_window_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	libc.Xmemset(tls, bp+80+10, 0, uint64(2))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_configure_window_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = value_list
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_configure_window_value_list_sizeof(tls, value_list, value_mask))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req27)))
	return xcb_ret
}

var _xcb_req27 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CONFIGURE_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_configure_window_aux_checked(tls *libc.TLS, c uintptr, window Txcb_window_t, value_mask Tuint16_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_aux0 at bp+96 */ uintptr
	var _ /* xcb_out at bp+80 */ Txcb_configure_window_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	*(*uintptr)(unsafe.Pointer(bp + 96)) = uintptr(0)
	(*(*Txcb_configure_window_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_configure_window_request_t)(unsafe.Pointer(bp + 80))).Fwindow = window
	(*(*Txcb_configure_window_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	libc.Xmemset(tls, bp+80+10, 0, uint64(2))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_configure_window_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_configure_window_value_list_serialize(tls, bp+96, value_mask, value_list))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = *(*uintptr)(unsafe.Pointer(bp + 96))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req28)))
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 96)))
	return xcb_ret
}

var _xcb_req28 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CONFIGURE_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_configure_window_aux(tls *libc.TLS, c uintptr, window Txcb_window_t, value_mask Tuint16_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_aux0 at bp+96 */ uintptr
	var _ /* xcb_out at bp+80 */ Txcb_configure_window_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	*(*uintptr)(unsafe.Pointer(bp + 96)) = uintptr(0)
	(*(*Txcb_configure_window_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_configure_window_request_t)(unsafe.Pointer(bp + 80))).Fwindow = window
	(*(*Txcb_configure_window_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	libc.Xmemset(tls, bp+80+10, 0, uint64(2))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_configure_window_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_configure_window_value_list_serialize(tls, bp+96, value_mask, value_list))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = *(*uintptr)(unsafe.Pointer(bp + 96))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req29)))
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 96)))
	return xcb_ret
}

var _xcb_req29 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CONFIGURE_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_configure_window_value_list(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_circulate_window_checked(tls *libc.TLS, c uintptr, direction Tuint8_t, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_circulate_window_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_circulate_window_request_t)(unsafe.Pointer(bp + 64))).Fdirection = direction
	(*(*Txcb_circulate_window_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req30)))
	return xcb_ret
}

var _xcb_req30 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CIRCULATE_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_circulate_window(tls *libc.TLS, c uintptr, direction Tuint8_t, window Txcb_window_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_circulate_window_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_circulate_window_request_t)(unsafe.Pointer(bp + 64))).Fdirection = direction
	(*(*Txcb_circulate_window_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req31)))
	return xcb_ret
}

var _xcb_req31 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CIRCULATE_WINDOW),
	Fisvoid: uint8(1),
}

func Xxcb_get_geometry(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t) (r Txcb_get_geometry_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_geometry_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_geometry_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_geometry_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_get_geometry_request_t)(unsafe.Pointer(bp + 64))).Fdrawable = drawable
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req32)))
	return xcb_ret
}

var _xcb_req32 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_GEOMETRY),
}

func Xxcb_get_geometry_unchecked(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t) (r Txcb_get_geometry_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_geometry_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_geometry_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_geometry_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_get_geometry_request_t)(unsafe.Pointer(bp + 64))).Fdrawable = drawable
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req33)))
	return xcb_ret
}

var _xcb_req33 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_GEOMETRY),
}

func Xxcb_get_geometry_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_geometry_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_query_tree_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* children */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_query_tree_reply_t)(unsafe.Pointer(_aux)).Fchildren_len)*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_query_tree(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_query_tree_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_query_tree_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_query_tree_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_tree_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_query_tree_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req34)))
	return xcb_ret
}

var _xcb_req34 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_QUERY_TREE),
}

func Xxcb_query_tree_unchecked(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_query_tree_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_query_tree_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_query_tree_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_tree_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_query_tree_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req35)))
	return xcb_ret
}

var _xcb_req35 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_QUERY_TREE),
}

func Xxcb_query_tree_children(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_query_tree_children_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_query_tree_reply_t)(unsafe.Pointer(R)).Fchildren_len)
}

func Xxcb_query_tree_children_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32 + uintptr((*Txcb_query_tree_reply_t)(unsafe.Pointer(R)).Fchildren_len)*4
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_query_tree_reply(tls *libc.TLS, c uintptr, cookie Txcb_query_tree_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_intern_atom_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* name */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_intern_atom_request_t)(unsafe.Pointer(_aux)).Fname_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_intern_atom(tls *libc.TLS, c uintptr, only_if_exists Tuint8_t, name_len Tuint16_t, name uintptr) (r Txcb_intern_atom_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_intern_atom_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_intern_atom_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_intern_atom_request_t)(unsafe.Pointer(bp + 96))).Fonly_if_exists = only_if_exists
	(*(*Txcb_intern_atom_request_t)(unsafe.Pointer(bp + 96))).Fname_len = name_len
	libc.Xmemset(tls, bp+96+6, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char name */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = name
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(name_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req36)))
	return xcb_ret
}

var _xcb_req36 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_INTERN_ATOM),
}

func Xxcb_intern_atom_unchecked(tls *libc.TLS, c uintptr, only_if_exists Tuint8_t, name_len Tuint16_t, name uintptr) (r Txcb_intern_atom_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_intern_atom_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_intern_atom_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_intern_atom_request_t)(unsafe.Pointer(bp + 96))).Fonly_if_exists = only_if_exists
	(*(*Txcb_intern_atom_request_t)(unsafe.Pointer(bp + 96))).Fname_len = name_len
	libc.Xmemset(tls, bp+96+6, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char name */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = name
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(name_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req37)))
	return xcb_ret
}

var _xcb_req37 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_INTERN_ATOM),
}

func Xxcb_intern_atom_reply(tls *libc.TLS, c uintptr, cookie Txcb_intern_atom_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_get_atom_name_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* name */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_get_atom_name_reply_t)(unsafe.Pointer(_aux)).Fname_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_get_atom_name(tls *libc.TLS, c uintptr, atom Txcb_atom_t) (r Txcb_get_atom_name_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_atom_name_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_atom_name_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_atom_name_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_get_atom_name_request_t)(unsafe.Pointer(bp + 64))).Fatom = atom
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req38)))
	return xcb_ret
}

var _xcb_req38 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_ATOM_NAME),
}

func Xxcb_get_atom_name_unchecked(tls *libc.TLS, c uintptr, atom Txcb_atom_t) (r Txcb_get_atom_name_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_atom_name_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_atom_name_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_atom_name_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_get_atom_name_request_t)(unsafe.Pointer(bp + 64))).Fatom = atom
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req39)))
	return xcb_ret
}

var _xcb_req39 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_ATOM_NAME),
}

func Xxcb_get_atom_name_name(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_get_atom_name_name_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_get_atom_name_reply_t)(unsafe.Pointer(R)).Fname_len)
}

func Xxcb_get_atom_name_name_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32 + uintptr((*Txcb_get_atom_name_reply_t)(unsafe.Pointer(R)).Fname_len)
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_get_atom_name_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_atom_name_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_change_property_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(24))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* data */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_change_property_request_t)(unsafe.Pointer(_aux)).Fdata_len*uint32((*Txcb_change_property_request_t)(unsafe.Pointer(_aux)).Fformat)/libc.Uint32FromInt32(8))*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_change_property_checked(tls *libc.TLS, c uintptr, mode Tuint8_t, window Txcb_window_t, property Txcb_atom_t, type1 Txcb_atom_t, format Tuint8_t, data_len Tuint32_t, data uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_change_property_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_property_request_t)(unsafe.Pointer(bp + 96))).Fmode = mode
	(*(*Txcb_change_property_request_t)(unsafe.Pointer(bp + 96))).Fwindow = window
	(*(*Txcb_change_property_request_t)(unsafe.Pointer(bp + 96))).Fproperty = property
	(*(*Txcb_change_property_request_t)(unsafe.Pointer(bp + 96))).Ftype1 = type1
	(*(*Txcb_change_property_request_t)(unsafe.Pointer(bp + 96))).Fformat = format
	libc.Xmemset(tls, bp+96+17, 0, uint64(3))
	(*(*Txcb_change_property_request_t)(unsafe.Pointer(bp + 96))).Fdata_len = data_len
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(24)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* void data */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = data
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(data_len*uint32(format)/libc.Uint32FromInt32(8)) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req40)))
	return xcb_ret
}

var _xcb_req40 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_CHANGE_PROPERTY),
	Fisvoid: uint8(1),
}

func Xxcb_change_property(tls *libc.TLS, c uintptr, mode Tuint8_t, window Txcb_window_t, property Txcb_atom_t, type1 Txcb_atom_t, format Tuint8_t, data_len Tuint32_t, data uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_change_property_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_property_request_t)(unsafe.Pointer(bp + 96))).Fmode = mode
	(*(*Txcb_change_property_request_t)(unsafe.Pointer(bp + 96))).Fwindow = window
	(*(*Txcb_change_property_request_t)(unsafe.Pointer(bp + 96))).Fproperty = property
	(*(*Txcb_change_property_request_t)(unsafe.Pointer(bp + 96))).Ftype1 = type1
	(*(*Txcb_change_property_request_t)(unsafe.Pointer(bp + 96))).Fformat = format
	libc.Xmemset(tls, bp+96+17, 0, uint64(3))
	(*(*Txcb_change_property_request_t)(unsafe.Pointer(bp + 96))).Fdata_len = data_len
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(24)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* void data */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = data
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(data_len*uint32(format)/libc.Uint32FromInt32(8)) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req41)))
	return xcb_ret
}

var _xcb_req41 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_CHANGE_PROPERTY),
	Fisvoid: uint8(1),
}

func Xxcb_change_property_data(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*24
}

func Xxcb_change_property_data_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint32((*Txcb_change_property_request_t)(unsafe.Pointer(R)).Fdata_len * uint32((*Txcb_change_property_request_t)(unsafe.Pointer(R)).Fformat) / libc.Uint32FromInt32(8))
}

func Xxcb_change_property_data_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*24 + uintptr((*Txcb_change_property_request_t)(unsafe.Pointer(R)).Fdata_len*uint32((*Txcb_change_property_request_t)(unsafe.Pointer(R)).Fformat)/libc.Uint32FromInt32(8))
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_delete_property_checked(tls *libc.TLS, c uintptr, window Txcb_window_t, property Txcb_atom_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_delete_property_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_delete_property_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_delete_property_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*Txcb_delete_property_request_t)(unsafe.Pointer(bp + 64))).Fproperty = property
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req42)))
	return xcb_ret
}

var _xcb_req42 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_DELETE_PROPERTY),
	Fisvoid: uint8(1),
}

func Xxcb_delete_property(tls *libc.TLS, c uintptr, window Txcb_window_t, property Txcb_atom_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_delete_property_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_delete_property_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_delete_property_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*Txcb_delete_property_request_t)(unsafe.Pointer(bp + 64))).Fproperty = property
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req43)))
	return xcb_ret
}

var _xcb_req43 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_DELETE_PROPERTY),
	Fisvoid: uint8(1),
}

func Xxcb_get_property_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* value */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_get_property_reply_t)(unsafe.Pointer(_aux)).Fvalue_len*libc.Uint32FromInt32(libc.Int32FromUint8((*Txcb_get_property_reply_t)(unsafe.Pointer(_aux)).Fformat)/libc.Int32FromInt32(8)))*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_get_property(tls *libc.TLS, c uintptr, _delete Tuint8_t, window Txcb_window_t, property Txcb_atom_t, type1 Txcb_atom_t, long_offset Tuint32_t, long_length Tuint32_t) (r Txcb_get_property_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_get_property_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_property_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_property_request_t)(unsafe.Pointer(bp + 64))).F_delete = _delete
	(*(*Txcb_get_property_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*Txcb_get_property_request_t)(unsafe.Pointer(bp + 64))).Fproperty = property
	(*(*Txcb_get_property_request_t)(unsafe.Pointer(bp + 64))).Ftype1 = type1
	(*(*Txcb_get_property_request_t)(unsafe.Pointer(bp + 64))).Flong_offset = long_offset
	(*(*Txcb_get_property_request_t)(unsafe.Pointer(bp + 64))).Flong_length = long_length
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(24)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req44)))
	return xcb_ret
}

var _xcb_req44 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_PROPERTY),
}

func Xxcb_get_property_unchecked(tls *libc.TLS, c uintptr, _delete Tuint8_t, window Txcb_window_t, property Txcb_atom_t, type1 Txcb_atom_t, long_offset Tuint32_t, long_length Tuint32_t) (r Txcb_get_property_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_get_property_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_property_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_property_request_t)(unsafe.Pointer(bp + 64))).F_delete = _delete
	(*(*Txcb_get_property_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*Txcb_get_property_request_t)(unsafe.Pointer(bp + 64))).Fproperty = property
	(*(*Txcb_get_property_request_t)(unsafe.Pointer(bp + 64))).Ftype1 = type1
	(*(*Txcb_get_property_request_t)(unsafe.Pointer(bp + 64))).Flong_offset = long_offset
	(*(*Txcb_get_property_request_t)(unsafe.Pointer(bp + 64))).Flong_length = long_length
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(24)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req45)))
	return xcb_ret
}

var _xcb_req45 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_PROPERTY),
}

func Xxcb_get_property_value(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_get_property_value_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint32((*Txcb_get_property_reply_t)(unsafe.Pointer(R)).Fvalue_len * libc.Uint32FromInt32(libc.Int32FromUint8((*Txcb_get_property_reply_t)(unsafe.Pointer(R)).Fformat)/libc.Int32FromInt32(8)))
}

func Xxcb_get_property_value_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32 + uintptr((*Txcb_get_property_reply_t)(unsafe.Pointer(R)).Fvalue_len*libc.Uint32FromInt32(libc.Int32FromUint8((*Txcb_get_property_reply_t)(unsafe.Pointer(R)).Fformat)/libc.Int32FromInt32(8)))
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_get_property_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_property_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_list_properties_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* atoms */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_list_properties_reply_t)(unsafe.Pointer(_aux)).Fatoms_len)*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_list_properties(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_list_properties_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_list_properties_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_list_properties_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_list_properties_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_list_properties_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req46)))
	return xcb_ret
}

var _xcb_req46 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_LIST_PROPERTIES),
}

func Xxcb_list_properties_unchecked(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_list_properties_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_list_properties_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_list_properties_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_list_properties_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_list_properties_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req47)))
	return xcb_ret
}

var _xcb_req47 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_LIST_PROPERTIES),
}

func Xxcb_list_properties_atoms(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_list_properties_atoms_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_list_properties_reply_t)(unsafe.Pointer(R)).Fatoms_len)
}

func Xxcb_list_properties_atoms_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32 + uintptr((*Txcb_list_properties_reply_t)(unsafe.Pointer(R)).Fatoms_len)*4
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_list_properties_reply(tls *libc.TLS, c uintptr, cookie Txcb_list_properties_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_set_selection_owner_checked(tls *libc.TLS, c uintptr, owner Txcb_window_t, selection Txcb_atom_t, time Txcb_timestamp_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_set_selection_owner_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_selection_owner_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_set_selection_owner_request_t)(unsafe.Pointer(bp + 64))).Fowner = owner
	(*(*Txcb_set_selection_owner_request_t)(unsafe.Pointer(bp + 64))).Fselection = selection
	(*(*Txcb_set_selection_owner_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req48)))
	return xcb_ret
}

var _xcb_req48 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_SET_SELECTION_OWNER),
	Fisvoid: uint8(1),
}

func Xxcb_set_selection_owner(tls *libc.TLS, c uintptr, owner Txcb_window_t, selection Txcb_atom_t, time Txcb_timestamp_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_set_selection_owner_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_selection_owner_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_set_selection_owner_request_t)(unsafe.Pointer(bp + 64))).Fowner = owner
	(*(*Txcb_set_selection_owner_request_t)(unsafe.Pointer(bp + 64))).Fselection = selection
	(*(*Txcb_set_selection_owner_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req49)))
	return xcb_ret
}

var _xcb_req49 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_SET_SELECTION_OWNER),
	Fisvoid: uint8(1),
}

func Xxcb_get_selection_owner(tls *libc.TLS, c uintptr, selection Txcb_atom_t) (r Txcb_get_selection_owner_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_selection_owner_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_selection_owner_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_selection_owner_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_get_selection_owner_request_t)(unsafe.Pointer(bp + 64))).Fselection = selection
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req50)))
	return xcb_ret
}

var _xcb_req50 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_SELECTION_OWNER),
}

func Xxcb_get_selection_owner_unchecked(tls *libc.TLS, c uintptr, selection Txcb_atom_t) (r Txcb_get_selection_owner_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_selection_owner_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_selection_owner_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_selection_owner_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_get_selection_owner_request_t)(unsafe.Pointer(bp + 64))).Fselection = selection
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req51)))
	return xcb_ret
}

var _xcb_req51 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_SELECTION_OWNER),
}

func Xxcb_get_selection_owner_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_selection_owner_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_convert_selection_checked(tls *libc.TLS, c uintptr, requestor Txcb_window_t, selection Txcb_atom_t, target Txcb_atom_t, property Txcb_atom_t, time Txcb_timestamp_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_convert_selection_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_convert_selection_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_convert_selection_request_t)(unsafe.Pointer(bp + 64))).Frequestor = requestor
	(*(*Txcb_convert_selection_request_t)(unsafe.Pointer(bp + 64))).Fselection = selection
	(*(*Txcb_convert_selection_request_t)(unsafe.Pointer(bp + 64))).Ftarget = target
	(*(*Txcb_convert_selection_request_t)(unsafe.Pointer(bp + 64))).Fproperty = property
	(*(*Txcb_convert_selection_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(24)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req52)))
	return xcb_ret
}

var _xcb_req52 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CONVERT_SELECTION),
	Fisvoid: uint8(1),
}

func Xxcb_convert_selection(tls *libc.TLS, c uintptr, requestor Txcb_window_t, selection Txcb_atom_t, target Txcb_atom_t, property Txcb_atom_t, time Txcb_timestamp_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_convert_selection_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_convert_selection_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_convert_selection_request_t)(unsafe.Pointer(bp + 64))).Frequestor = requestor
	(*(*Txcb_convert_selection_request_t)(unsafe.Pointer(bp + 64))).Fselection = selection
	(*(*Txcb_convert_selection_request_t)(unsafe.Pointer(bp + 64))).Ftarget = target
	(*(*Txcb_convert_selection_request_t)(unsafe.Pointer(bp + 64))).Fproperty = property
	(*(*Txcb_convert_selection_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(24)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req53)))
	return xcb_ret
}

var _xcb_req53 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CONVERT_SELECTION),
	Fisvoid: uint8(1),
}

func Xxcb_send_event_checked(tls *libc.TLS, c uintptr, propagate Tuint8_t, destination Txcb_window_t, event_mask Tuint32_t, event uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_send_event_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_send_event_request_t)(unsafe.Pointer(bp + 64))).Fpropagate = propagate
	(*(*Txcb_send_event_request_t)(unsafe.Pointer(bp + 64))).Fdestination = destination
	(*(*Txcb_send_event_request_t)(unsafe.Pointer(bp + 64))).Fevent_mask = event_mask
	libc.Xmemcpy(tls, bp+64+12, event, uint64(32))
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(44)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req54)))
	return xcb_ret
}

var _xcb_req54 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_SEND_EVENT),
	Fisvoid: uint8(1),
}

func Xxcb_send_event(tls *libc.TLS, c uintptr, propagate Tuint8_t, destination Txcb_window_t, event_mask Tuint32_t, event uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_send_event_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_send_event_request_t)(unsafe.Pointer(bp + 64))).Fpropagate = propagate
	(*(*Txcb_send_event_request_t)(unsafe.Pointer(bp + 64))).Fdestination = destination
	(*(*Txcb_send_event_request_t)(unsafe.Pointer(bp + 64))).Fevent_mask = event_mask
	libc.Xmemcpy(tls, bp+64+12, event, uint64(32))
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(44)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req55)))
	return xcb_ret
}

var _xcb_req55 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_SEND_EVENT),
	Fisvoid: uint8(1),
}

func Xxcb_grab_pointer(tls *libc.TLS, c uintptr, owner_events Tuint8_t, grab_window Txcb_window_t, event_mask Tuint16_t, pointer_mode Tuint8_t, keyboard_mode Tuint8_t, confine_to Txcb_window_t, cursor Txcb_cursor_t, time Txcb_timestamp_t) (r Txcb_grab_pointer_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_grab_pointer_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_grab_pointer_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fowner_events = owner_events
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fgrab_window = grab_window
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fevent_mask = event_mask
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fpointer_mode = pointer_mode
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fkeyboard_mode = keyboard_mode
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fconfine_to = confine_to
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fcursor = cursor
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(24)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req56)))
	return xcb_ret
}

var _xcb_req56 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GRAB_POINTER),
}

func Xxcb_grab_pointer_unchecked(tls *libc.TLS, c uintptr, owner_events Tuint8_t, grab_window Txcb_window_t, event_mask Tuint16_t, pointer_mode Tuint8_t, keyboard_mode Tuint8_t, confine_to Txcb_window_t, cursor Txcb_cursor_t, time Txcb_timestamp_t) (r Txcb_grab_pointer_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_grab_pointer_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_grab_pointer_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fowner_events = owner_events
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fgrab_window = grab_window
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fevent_mask = event_mask
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fpointer_mode = pointer_mode
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fkeyboard_mode = keyboard_mode
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fconfine_to = confine_to
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fcursor = cursor
	(*(*Txcb_grab_pointer_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(24)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req57)))
	return xcb_ret
}

var _xcb_req57 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GRAB_POINTER),
}

func Xxcb_grab_pointer_reply(tls *libc.TLS, c uintptr, cookie Txcb_grab_pointer_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_ungrab_pointer_checked(tls *libc.TLS, c uintptr, time Txcb_timestamp_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_ungrab_pointer_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_ungrab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_ungrab_pointer_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req58)))
	return xcb_ret
}

var _xcb_req58 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNGRAB_POINTER),
	Fisvoid: uint8(1),
}

func Xxcb_ungrab_pointer(tls *libc.TLS, c uintptr, time Txcb_timestamp_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_ungrab_pointer_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_ungrab_pointer_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_ungrab_pointer_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req59)))
	return xcb_ret
}

var _xcb_req59 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNGRAB_POINTER),
	Fisvoid: uint8(1),
}

func Xxcb_grab_button_checked(tls *libc.TLS, c uintptr, owner_events Tuint8_t, grab_window Txcb_window_t, event_mask Tuint16_t, pointer_mode Tuint8_t, keyboard_mode Tuint8_t, confine_to Txcb_window_t, cursor Txcb_cursor_t, button Tuint8_t, modifiers Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_grab_button_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fowner_events = owner_events
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fgrab_window = grab_window
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fevent_mask = event_mask
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fpointer_mode = pointer_mode
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fkeyboard_mode = keyboard_mode
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fconfine_to = confine_to
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fcursor = cursor
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fbutton = button
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fmodifiers = modifiers
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(24)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req60)))
	return xcb_ret
}

var _xcb_req60 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GRAB_BUTTON),
	Fisvoid: uint8(1),
}

func Xxcb_grab_button(tls *libc.TLS, c uintptr, owner_events Tuint8_t, grab_window Txcb_window_t, event_mask Tuint16_t, pointer_mode Tuint8_t, keyboard_mode Tuint8_t, confine_to Txcb_window_t, cursor Txcb_cursor_t, button Tuint8_t, modifiers Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_grab_button_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fowner_events = owner_events
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fgrab_window = grab_window
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fevent_mask = event_mask
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fpointer_mode = pointer_mode
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fkeyboard_mode = keyboard_mode
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fconfine_to = confine_to
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fcursor = cursor
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fbutton = button
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_grab_button_request_t)(unsafe.Pointer(bp + 64))).Fmodifiers = modifiers
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(24)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req61)))
	return xcb_ret
}

var _xcb_req61 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GRAB_BUTTON),
	Fisvoid: uint8(1),
}

func Xxcb_ungrab_button_checked(tls *libc.TLS, c uintptr, button Tuint8_t, grab_window Txcb_window_t, modifiers Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_ungrab_button_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_ungrab_button_request_t)(unsafe.Pointer(bp + 64))).Fbutton = button
	(*(*Txcb_ungrab_button_request_t)(unsafe.Pointer(bp + 64))).Fgrab_window = grab_window
	(*(*Txcb_ungrab_button_request_t)(unsafe.Pointer(bp + 64))).Fmodifiers = modifiers
	libc.Xmemset(tls, bp+64+10, 0, uint64(2))
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req62)))
	return xcb_ret
}

var _xcb_req62 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNGRAB_BUTTON),
	Fisvoid: uint8(1),
}

func Xxcb_ungrab_button(tls *libc.TLS, c uintptr, button Tuint8_t, grab_window Txcb_window_t, modifiers Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_ungrab_button_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_ungrab_button_request_t)(unsafe.Pointer(bp + 64))).Fbutton = button
	(*(*Txcb_ungrab_button_request_t)(unsafe.Pointer(bp + 64))).Fgrab_window = grab_window
	(*(*Txcb_ungrab_button_request_t)(unsafe.Pointer(bp + 64))).Fmodifiers = modifiers
	libc.Xmemset(tls, bp+64+10, 0, uint64(2))
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req63)))
	return xcb_ret
}

var _xcb_req63 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNGRAB_BUTTON),
	Fisvoid: uint8(1),
}

func Xxcb_change_active_pointer_grab_checked(tls *libc.TLS, c uintptr, cursor Txcb_cursor_t, time Txcb_timestamp_t, event_mask Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_change_active_pointer_grab_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_active_pointer_grab_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_change_active_pointer_grab_request_t)(unsafe.Pointer(bp + 64))).Fcursor = cursor
	(*(*Txcb_change_active_pointer_grab_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*Txcb_change_active_pointer_grab_request_t)(unsafe.Pointer(bp + 64))).Fevent_mask = event_mask
	libc.Xmemset(tls, bp+64+14, 0, uint64(2))
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req64)))
	return xcb_ret
}

var _xcb_req64 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CHANGE_ACTIVE_POINTER_GRAB),
	Fisvoid: uint8(1),
}

func Xxcb_change_active_pointer_grab(tls *libc.TLS, c uintptr, cursor Txcb_cursor_t, time Txcb_timestamp_t, event_mask Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_change_active_pointer_grab_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_active_pointer_grab_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_change_active_pointer_grab_request_t)(unsafe.Pointer(bp + 64))).Fcursor = cursor
	(*(*Txcb_change_active_pointer_grab_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*Txcb_change_active_pointer_grab_request_t)(unsafe.Pointer(bp + 64))).Fevent_mask = event_mask
	libc.Xmemset(tls, bp+64+14, 0, uint64(2))
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req65)))
	return xcb_ret
}

var _xcb_req65 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CHANGE_ACTIVE_POINTER_GRAB),
	Fisvoid: uint8(1),
}

func Xxcb_grab_keyboard(tls *libc.TLS, c uintptr, owner_events Tuint8_t, grab_window Txcb_window_t, time Txcb_timestamp_t, pointer_mode Tuint8_t, keyboard_mode Tuint8_t) (r Txcb_grab_keyboard_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_grab_keyboard_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_grab_keyboard_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_grab_keyboard_request_t)(unsafe.Pointer(bp + 64))).Fowner_events = owner_events
	(*(*Txcb_grab_keyboard_request_t)(unsafe.Pointer(bp + 64))).Fgrab_window = grab_window
	(*(*Txcb_grab_keyboard_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*Txcb_grab_keyboard_request_t)(unsafe.Pointer(bp + 64))).Fpointer_mode = pointer_mode
	(*(*Txcb_grab_keyboard_request_t)(unsafe.Pointer(bp + 64))).Fkeyboard_mode = keyboard_mode
	libc.Xmemset(tls, bp+64+14, 0, uint64(2))
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req66)))
	return xcb_ret
}

var _xcb_req66 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GRAB_KEYBOARD),
}

func Xxcb_grab_keyboard_unchecked(tls *libc.TLS, c uintptr, owner_events Tuint8_t, grab_window Txcb_window_t, time Txcb_timestamp_t, pointer_mode Tuint8_t, keyboard_mode Tuint8_t) (r Txcb_grab_keyboard_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_grab_keyboard_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_grab_keyboard_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_grab_keyboard_request_t)(unsafe.Pointer(bp + 64))).Fowner_events = owner_events
	(*(*Txcb_grab_keyboard_request_t)(unsafe.Pointer(bp + 64))).Fgrab_window = grab_window
	(*(*Txcb_grab_keyboard_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*Txcb_grab_keyboard_request_t)(unsafe.Pointer(bp + 64))).Fpointer_mode = pointer_mode
	(*(*Txcb_grab_keyboard_request_t)(unsafe.Pointer(bp + 64))).Fkeyboard_mode = keyboard_mode
	libc.Xmemset(tls, bp+64+14, 0, uint64(2))
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req67)))
	return xcb_ret
}

var _xcb_req67 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GRAB_KEYBOARD),
}

func Xxcb_grab_keyboard_reply(tls *libc.TLS, c uintptr, cookie Txcb_grab_keyboard_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_ungrab_keyboard_checked(tls *libc.TLS, c uintptr, time Txcb_timestamp_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_ungrab_keyboard_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_ungrab_keyboard_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_ungrab_keyboard_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req68)))
	return xcb_ret
}

var _xcb_req68 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNGRAB_KEYBOARD),
	Fisvoid: uint8(1),
}

func Xxcb_ungrab_keyboard(tls *libc.TLS, c uintptr, time Txcb_timestamp_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_ungrab_keyboard_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_ungrab_keyboard_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_ungrab_keyboard_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req69)))
	return xcb_ret
}

var _xcb_req69 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNGRAB_KEYBOARD),
	Fisvoid: uint8(1),
}

func Xxcb_grab_key_checked(tls *libc.TLS, c uintptr, owner_events Tuint8_t, grab_window Txcb_window_t, modifiers Tuint16_t, key Txcb_keycode_t, pointer_mode Tuint8_t, keyboard_mode Tuint8_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_grab_key_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_grab_key_request_t)(unsafe.Pointer(bp + 64))).Fowner_events = owner_events
	(*(*Txcb_grab_key_request_t)(unsafe.Pointer(bp + 64))).Fgrab_window = grab_window
	(*(*Txcb_grab_key_request_t)(unsafe.Pointer(bp + 64))).Fmodifiers = modifiers
	(*(*Txcb_grab_key_request_t)(unsafe.Pointer(bp + 64))).Fkey = key
	(*(*Txcb_grab_key_request_t)(unsafe.Pointer(bp + 64))).Fpointer_mode = pointer_mode
	(*(*Txcb_grab_key_request_t)(unsafe.Pointer(bp + 64))).Fkeyboard_mode = keyboard_mode
	libc.Xmemset(tls, bp+64+13, 0, uint64(3))
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req70)))
	return xcb_ret
}

var _xcb_req70 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GRAB_KEY),
	Fisvoid: uint8(1),
}

func Xxcb_grab_key(tls *libc.TLS, c uintptr, owner_events Tuint8_t, grab_window Txcb_window_t, modifiers Tuint16_t, key Txcb_keycode_t, pointer_mode Tuint8_t, keyboard_mode Tuint8_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_grab_key_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_grab_key_request_t)(unsafe.Pointer(bp + 64))).Fowner_events = owner_events
	(*(*Txcb_grab_key_request_t)(unsafe.Pointer(bp + 64))).Fgrab_window = grab_window
	(*(*Txcb_grab_key_request_t)(unsafe.Pointer(bp + 64))).Fmodifiers = modifiers
	(*(*Txcb_grab_key_request_t)(unsafe.Pointer(bp + 64))).Fkey = key
	(*(*Txcb_grab_key_request_t)(unsafe.Pointer(bp + 64))).Fpointer_mode = pointer_mode
	(*(*Txcb_grab_key_request_t)(unsafe.Pointer(bp + 64))).Fkeyboard_mode = keyboard_mode
	libc.Xmemset(tls, bp+64+13, 0, uint64(3))
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req71)))
	return xcb_ret
}

var _xcb_req71 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GRAB_KEY),
	Fisvoid: uint8(1),
}

func Xxcb_ungrab_key_checked(tls *libc.TLS, c uintptr, key Txcb_keycode_t, grab_window Txcb_window_t, modifiers Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_ungrab_key_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_ungrab_key_request_t)(unsafe.Pointer(bp + 64))).Fkey = key
	(*(*Txcb_ungrab_key_request_t)(unsafe.Pointer(bp + 64))).Fgrab_window = grab_window
	(*(*Txcb_ungrab_key_request_t)(unsafe.Pointer(bp + 64))).Fmodifiers = modifiers
	libc.Xmemset(tls, bp+64+10, 0, uint64(2))
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req72)))
	return xcb_ret
}

var _xcb_req72 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNGRAB_KEY),
	Fisvoid: uint8(1),
}

func Xxcb_ungrab_key(tls *libc.TLS, c uintptr, key Txcb_keycode_t, grab_window Txcb_window_t, modifiers Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_ungrab_key_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_ungrab_key_request_t)(unsafe.Pointer(bp + 64))).Fkey = key
	(*(*Txcb_ungrab_key_request_t)(unsafe.Pointer(bp + 64))).Fgrab_window = grab_window
	(*(*Txcb_ungrab_key_request_t)(unsafe.Pointer(bp + 64))).Fmodifiers = modifiers
	libc.Xmemset(tls, bp+64+10, 0, uint64(2))
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req73)))
	return xcb_ret
}

var _xcb_req73 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNGRAB_KEY),
	Fisvoid: uint8(1),
}

func Xxcb_allow_events_checked(tls *libc.TLS, c uintptr, mode Tuint8_t, time Txcb_timestamp_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_allow_events_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_allow_events_request_t)(unsafe.Pointer(bp + 64))).Fmode = mode
	(*(*Txcb_allow_events_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req74)))
	return xcb_ret
}

var _xcb_req74 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_ALLOW_EVENTS),
	Fisvoid: uint8(1),
}

func Xxcb_allow_events(tls *libc.TLS, c uintptr, mode Tuint8_t, time Txcb_timestamp_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_allow_events_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_allow_events_request_t)(unsafe.Pointer(bp + 64))).Fmode = mode
	(*(*Txcb_allow_events_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req75)))
	return xcb_ret
}

var _xcb_req75 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_ALLOW_EVENTS),
	Fisvoid: uint8(1),
}

func Xxcb_grab_server_checked(tls *libc.TLS, c uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_grab_server_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_grab_server_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req76)))
	return xcb_ret
}

var _xcb_req76 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GRAB_SERVER),
	Fisvoid: uint8(1),
}

func Xxcb_grab_server(tls *libc.TLS, c uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_grab_server_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_grab_server_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req77)))
	return xcb_ret
}

var _xcb_req77 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GRAB_SERVER),
	Fisvoid: uint8(1),
}

func Xxcb_ungrab_server_checked(tls *libc.TLS, c uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_ungrab_server_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_ungrab_server_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req78)))
	return xcb_ret
}

var _xcb_req78 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNGRAB_SERVER),
	Fisvoid: uint8(1),
}

func Xxcb_ungrab_server(tls *libc.TLS, c uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_ungrab_server_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_ungrab_server_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req79)))
	return xcb_ret
}

var _xcb_req79 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNGRAB_SERVER),
	Fisvoid: uint8(1),
}

func Xxcb_query_pointer(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_query_pointer_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_query_pointer_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_query_pointer_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_pointer_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_query_pointer_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req80)))
	return xcb_ret
}

var _xcb_req80 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_QUERY_POINTER),
}

func Xxcb_query_pointer_unchecked(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_query_pointer_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_query_pointer_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_query_pointer_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_pointer_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_query_pointer_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req81)))
	return xcb_ret
}

var _xcb_req81 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_QUERY_POINTER),
}

func Xxcb_query_pointer_reply(tls *libc.TLS, c uintptr, cookie Txcb_query_pointer_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_timecoord_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_timecoord_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_timecoord_iterator_t)(unsafe.Pointer(i)).Fdata += 8
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(8))
}

func Xxcb_timecoord_end(tls *libc.TLS, i Txcb_timecoord_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*8
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_get_motion_events_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* events */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_get_motion_events_reply_t)(unsafe.Pointer(_aux)).Fevents_len)*libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_get_motion_events(tls *libc.TLS, c uintptr, window Txcb_window_t, start Txcb_timestamp_t, stop Txcb_timestamp_t) (r Txcb_get_motion_events_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_motion_events_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_motion_events_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_motion_events_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_get_motion_events_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*Txcb_get_motion_events_request_t)(unsafe.Pointer(bp + 64))).Fstart = start
	(*(*Txcb_get_motion_events_request_t)(unsafe.Pointer(bp + 64))).Fstop = stop
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req82)))
	return xcb_ret
}

var _xcb_req82 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_MOTION_EVENTS),
}

func Xxcb_get_motion_events_unchecked(tls *libc.TLS, c uintptr, window Txcb_window_t, start Txcb_timestamp_t, stop Txcb_timestamp_t) (r Txcb_get_motion_events_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_motion_events_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_motion_events_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_motion_events_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_get_motion_events_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*Txcb_get_motion_events_request_t)(unsafe.Pointer(bp + 64))).Fstart = start
	(*(*Txcb_get_motion_events_request_t)(unsafe.Pointer(bp + 64))).Fstop = stop
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req83)))
	return xcb_ret
}

var _xcb_req83 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_MOTION_EVENTS),
}

func Xxcb_get_motion_events_events(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_get_motion_events_events_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint32((*Txcb_get_motion_events_reply_t)(unsafe.Pointer(R)).Fevents_len)
}

func Xxcb_get_motion_events_events_iterator(tls *libc.TLS, R uintptr) (r Txcb_timecoord_iterator_t) {
	var i Txcb_timecoord_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32
	i.Frem = libc.Int32FromUint32((*Txcb_get_motion_events_reply_t)(unsafe.Pointer(R)).Fevents_len)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_get_motion_events_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_motion_events_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_translate_coordinates(tls *libc.TLS, c uintptr, src_window Txcb_window_t, dst_window Txcb_window_t, src_x Tint16_t, src_y Tint16_t) (r Txcb_translate_coordinates_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_translate_coordinates_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_translate_coordinates_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_translate_coordinates_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_translate_coordinates_request_t)(unsafe.Pointer(bp + 64))).Fsrc_window = src_window
	(*(*Txcb_translate_coordinates_request_t)(unsafe.Pointer(bp + 64))).Fdst_window = dst_window
	(*(*Txcb_translate_coordinates_request_t)(unsafe.Pointer(bp + 64))).Fsrc_x = src_x
	(*(*Txcb_translate_coordinates_request_t)(unsafe.Pointer(bp + 64))).Fsrc_y = src_y
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req84)))
	return xcb_ret
}

var _xcb_req84 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_TRANSLATE_COORDINATES),
}

func Xxcb_translate_coordinates_unchecked(tls *libc.TLS, c uintptr, src_window Txcb_window_t, dst_window Txcb_window_t, src_x Tint16_t, src_y Tint16_t) (r Txcb_translate_coordinates_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_translate_coordinates_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_translate_coordinates_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_translate_coordinates_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_translate_coordinates_request_t)(unsafe.Pointer(bp + 64))).Fsrc_window = src_window
	(*(*Txcb_translate_coordinates_request_t)(unsafe.Pointer(bp + 64))).Fdst_window = dst_window
	(*(*Txcb_translate_coordinates_request_t)(unsafe.Pointer(bp + 64))).Fsrc_x = src_x
	(*(*Txcb_translate_coordinates_request_t)(unsafe.Pointer(bp + 64))).Fsrc_y = src_y
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req85)))
	return xcb_ret
}

var _xcb_req85 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_TRANSLATE_COORDINATES),
}

func Xxcb_translate_coordinates_reply(tls *libc.TLS, c uintptr, cookie Txcb_translate_coordinates_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_warp_pointer_checked(tls *libc.TLS, c uintptr, src_window Txcb_window_t, dst_window Txcb_window_t, src_x Tint16_t, src_y Tint16_t, src_width Tuint16_t, src_height Tuint16_t, dst_x Tint16_t, dst_y Tint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_warp_pointer_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fsrc_window = src_window
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fdst_window = dst_window
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fsrc_x = src_x
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fsrc_y = src_y
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fsrc_width = src_width
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fsrc_height = src_height
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fdst_x = dst_x
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fdst_y = dst_y
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(24)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req86)))
	return xcb_ret
}

var _xcb_req86 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_WARP_POINTER),
	Fisvoid: uint8(1),
}

func Xxcb_warp_pointer(tls *libc.TLS, c uintptr, src_window Txcb_window_t, dst_window Txcb_window_t, src_x Tint16_t, src_y Tint16_t, src_width Tuint16_t, src_height Tuint16_t, dst_x Tint16_t, dst_y Tint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_warp_pointer_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fsrc_window = src_window
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fdst_window = dst_window
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fsrc_x = src_x
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fsrc_y = src_y
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fsrc_width = src_width
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fsrc_height = src_height
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fdst_x = dst_x
	(*(*Txcb_warp_pointer_request_t)(unsafe.Pointer(bp + 64))).Fdst_y = dst_y
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(24)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req87)))
	return xcb_ret
}

var _xcb_req87 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_WARP_POINTER),
	Fisvoid: uint8(1),
}

func Xxcb_set_input_focus_checked(tls *libc.TLS, c uintptr, revert_to Tuint8_t, focus Txcb_window_t, time Txcb_timestamp_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_set_input_focus_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_input_focus_request_t)(unsafe.Pointer(bp + 64))).Frevert_to = revert_to
	(*(*Txcb_set_input_focus_request_t)(unsafe.Pointer(bp + 64))).Ffocus = focus
	(*(*Txcb_set_input_focus_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req88)))
	return xcb_ret
}

var _xcb_req88 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_SET_INPUT_FOCUS),
	Fisvoid: uint8(1),
}

func Xxcb_set_input_focus(tls *libc.TLS, c uintptr, revert_to Tuint8_t, focus Txcb_window_t, time Txcb_timestamp_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_set_input_focus_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_input_focus_request_t)(unsafe.Pointer(bp + 64))).Frevert_to = revert_to
	(*(*Txcb_set_input_focus_request_t)(unsafe.Pointer(bp + 64))).Ffocus = focus
	(*(*Txcb_set_input_focus_request_t)(unsafe.Pointer(bp + 64))).Ftime = time
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req89)))
	return xcb_ret
}

var _xcb_req89 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_SET_INPUT_FOCUS),
	Fisvoid: uint8(1),
}

func Xxcb_get_input_focus(tls *libc.TLS, c uintptr) (r Txcb_get_input_focus_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_input_focus_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_input_focus_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_input_focus_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req90)))
	return xcb_ret
}

var _xcb_req90 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_INPUT_FOCUS),
}

func Xxcb_get_input_focus_unchecked(tls *libc.TLS, c uintptr) (r Txcb_get_input_focus_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_input_focus_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_input_focus_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_input_focus_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req91)))
	return xcb_ret
}

var _xcb_req91 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_INPUT_FOCUS),
}

func Xxcb_get_input_focus_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_input_focus_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_query_keymap(tls *libc.TLS, c uintptr) (r Txcb_query_keymap_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_query_keymap_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_query_keymap_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_keymap_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req92)))
	return xcb_ret
}

var _xcb_req92 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_QUERY_KEYMAP),
}

func Xxcb_query_keymap_unchecked(tls *libc.TLS, c uintptr) (r Txcb_query_keymap_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_query_keymap_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_query_keymap_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_keymap_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req93)))
	return xcb_ret
}

var _xcb_req93 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_QUERY_KEYMAP),
}

func Xxcb_query_keymap_reply(tls *libc.TLS, c uintptr, cookie Txcb_query_keymap_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_open_font_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* name */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_open_font_request_t)(unsafe.Pointer(_aux)).Fname_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_open_font_checked(tls *libc.TLS, c uintptr, fid Txcb_font_t, name_len Tuint16_t, name uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_open_font_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_open_font_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_open_font_request_t)(unsafe.Pointer(bp + 96))).Ffid = fid
	(*(*Txcb_open_font_request_t)(unsafe.Pointer(bp + 96))).Fname_len = name_len
	libc.Xmemset(tls, bp+96+10, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char name */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = name
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(name_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req94)))
	return xcb_ret
}

var _xcb_req94 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_OPEN_FONT),
	Fisvoid: uint8(1),
}

func Xxcb_open_font(tls *libc.TLS, c uintptr, fid Txcb_font_t, name_len Tuint16_t, name uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_open_font_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_open_font_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_open_font_request_t)(unsafe.Pointer(bp + 96))).Ffid = fid
	(*(*Txcb_open_font_request_t)(unsafe.Pointer(bp + 96))).Fname_len = name_len
	libc.Xmemset(tls, bp+96+10, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char name */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = name
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(name_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req95)))
	return xcb_ret
}

var _xcb_req95 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_OPEN_FONT),
	Fisvoid: uint8(1),
}

func Xxcb_open_font_name(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_open_font_name_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_open_font_request_t)(unsafe.Pointer(R)).Fname_len)
}

func Xxcb_open_font_name_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*12 + uintptr((*Txcb_open_font_request_t)(unsafe.Pointer(R)).Fname_len)
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_close_font_checked(tls *libc.TLS, c uintptr, font Txcb_font_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_close_font_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_close_font_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_close_font_request_t)(unsafe.Pointer(bp + 64))).Ffont = font
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req96)))
	return xcb_ret
}

var _xcb_req96 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CLOSE_FONT),
	Fisvoid: uint8(1),
}

func Xxcb_close_font(tls *libc.TLS, c uintptr, font Txcb_font_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_close_font_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_close_font_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_close_font_request_t)(unsafe.Pointer(bp + 64))).Ffont = font
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req97)))
	return xcb_ret
}

var _xcb_req97 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CLOSE_FONT),
	Fisvoid: uint8(1),
}

func Xxcb_fontprop_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_fontprop_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_fontprop_iterator_t)(unsafe.Pointer(i)).Fdata += 8
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(8))
}

func Xxcb_fontprop_end(tls *libc.TLS, i Txcb_fontprop_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*8
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_charinfo_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_charinfo_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_charinfo_iterator_t)(unsafe.Pointer(i)).Fdata += 12
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(12))
}

func Xxcb_charinfo_end(tls *libc.TLS, i Txcb_charinfo_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*12
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_query_font_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(60))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* properties */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_query_font_reply_t)(unsafe.Pointer(_aux)).Fproperties_len)*libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	/* char_infos */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_query_font_reply_t)(unsafe.Pointer(_aux)).Fchar_infos_len)*libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 2))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_query_font(tls *libc.TLS, c uintptr, font Txcb_fontable_t) (r Txcb_query_font_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_query_font_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_query_font_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_font_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_query_font_request_t)(unsafe.Pointer(bp + 64))).Ffont = font
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req98)))
	return xcb_ret
}

var _xcb_req98 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_QUERY_FONT),
}

func Xxcb_query_font_unchecked(tls *libc.TLS, c uintptr, font Txcb_fontable_t) (r Txcb_query_font_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_query_font_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_query_font_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_font_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_query_font_request_t)(unsafe.Pointer(bp + 64))).Ffont = font
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req99)))
	return xcb_ret
}

var _xcb_req99 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_QUERY_FONT),
}

func Xxcb_query_font_properties(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*60
}

func Xxcb_query_font_properties_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_query_font_reply_t)(unsafe.Pointer(R)).Fproperties_len)
}

func Xxcb_query_font_properties_iterator(tls *libc.TLS, R uintptr) (r Txcb_fontprop_iterator_t) {
	var i Txcb_fontprop_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*60
	i.Frem = libc.Int32FromUint16((*Txcb_query_font_reply_t)(unsafe.Pointer(R)).Fproperties_len)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_query_font_char_infos(tls *libc.TLS, R uintptr) (r uintptr) {
	var prev Txcb_generic_iterator_t
	_ = prev
	prev = Xxcb_fontprop_end(tls, Xxcb_query_font_properties_iterator(tls, R))
	return prev.Fdata + uintptr(libc.Uint64FromInt32(-prev.Findex)&libc.Uint64FromInt32(3)) + libc.UintptrFromInt32(0)
}

func Xxcb_query_font_char_infos_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint32((*Txcb_query_font_reply_t)(unsafe.Pointer(R)).Fchar_infos_len)
}

func Xxcb_query_font_char_infos_iterator(tls *libc.TLS, R uintptr) (r Txcb_charinfo_iterator_t) {
	var i Txcb_charinfo_iterator_t
	var prev Txcb_generic_iterator_t
	_, _ = i, prev
	prev = Xxcb_fontprop_end(tls, Xxcb_query_font_properties_iterator(tls, R))
	i.Fdata = prev.Fdata + uintptr(libc.Uint64FromInt32(-prev.Findex)&libc.Uint64FromInt32(3))
	i.Frem = libc.Int32FromUint32((*Txcb_query_font_reply_t)(unsafe.Pointer(R)).Fchar_infos_len)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_query_font_reply(tls *libc.TLS, c uintptr, cookie Txcb_query_font_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_query_text_extents_sizeof(tls *libc.TLS, _buffer uintptr, string_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* string */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(string_len)*libc.Uint64FromInt64(2))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_query_text_extents(tls *libc.TLS, c uintptr, font Txcb_fontable_t, string_len Tuint32_t, string1 uintptr) (r Txcb_query_text_extents_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_query_text_extents_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_query_text_extents_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_text_extents_request_t)(unsafe.Pointer(bp + 96))).Fodd_length = uint8(string_len & libc.Uint32FromInt32(1))
	(*(*Txcb_query_text_extents_request_t)(unsafe.Pointer(bp + 96))).Ffont = font
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_char2b_t string */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = string1
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(string_len) * uint64(2)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req100)))
	return xcb_ret
}

var _xcb_req100 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_QUERY_TEXT_EXTENTS),
}

func Xxcb_query_text_extents_unchecked(tls *libc.TLS, c uintptr, font Txcb_fontable_t, string_len Tuint32_t, string1 uintptr) (r Txcb_query_text_extents_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_query_text_extents_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_query_text_extents_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_text_extents_request_t)(unsafe.Pointer(bp + 96))).Fodd_length = uint8(string_len & libc.Uint32FromInt32(1))
	(*(*Txcb_query_text_extents_request_t)(unsafe.Pointer(bp + 96))).Ffont = font
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_char2b_t string */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = string1
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(string_len) * uint64(2)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req101)))
	return xcb_ret
}

var _xcb_req101 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_QUERY_TEXT_EXTENTS),
}

func Xxcb_query_text_extents_reply(tls *libc.TLS, c uintptr, cookie Txcb_query_text_extents_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_str_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* name */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_str_t)(unsafe.Pointer(_aux)).Fname_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_str_name(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)
}

func Xxcb_str_name_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint8((*Txcb_str_t)(unsafe.Pointer(R)).Fname_len)
}

func Xxcb_str_name_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1) + uintptr((*Txcb_str_t)(unsafe.Pointer(R)).Fname_len)
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_str_next(tls *libc.TLS, i uintptr) {
	var R uintptr
	var child Txcb_generic_iterator_t
	_, _ = R, child
	R = (*Txcb_str_iterator_t)(unsafe.Pointer(i)).Fdata
	child.Fdata = R + uintptr(Xxcb_str_sizeof(tls, R))
	(*Txcb_str_iterator_t)(unsafe.Pointer(i)).Findex = int32(int64(child.Fdata) - int64((*Txcb_str_iterator_t)(unsafe.Pointer(i)).Fdata))
	(*Txcb_str_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_str_iterator_t)(unsafe.Pointer(i)).Fdata = child.Fdata
}

func Xxcb_str_end(tls *libc.TLS, _i Txcb_str_iterator_t) (r Txcb_generic_iterator_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Txcb_str_iterator_t)(unsafe.Pointer(bp)) = _i
	var ret Txcb_generic_iterator_t
	_ = ret
	for (*(*Txcb_str_iterator_t)(unsafe.Pointer(bp))).Frem > 0 {
		Xxcb_str_next(tls, bp)
	}
	ret.Fdata = (*(*Txcb_str_iterator_t)(unsafe.Pointer(bp))).Fdata
	ret.Frem = (*(*Txcb_str_iterator_t)(unsafe.Pointer(bp))).Frem
	ret.Findex = (*(*Txcb_str_iterator_t)(unsafe.Pointer(bp))).Findex
	return ret
}

func Xxcb_list_fonts_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* pattern */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_list_fonts_request_t)(unsafe.Pointer(_aux)).Fpattern_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_list_fonts(tls *libc.TLS, c uintptr, max_names Tuint16_t, pattern_len Tuint16_t, pattern uintptr) (r Txcb_list_fonts_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_list_fonts_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_list_fonts_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_list_fonts_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_list_fonts_request_t)(unsafe.Pointer(bp + 96))).Fmax_names = max_names
	(*(*Txcb_list_fonts_request_t)(unsafe.Pointer(bp + 96))).Fpattern_len = pattern_len
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char pattern */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = pattern
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(pattern_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req102)))
	return xcb_ret
}

var _xcb_req102 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_LIST_FONTS),
}

func Xxcb_list_fonts_unchecked(tls *libc.TLS, c uintptr, max_names Tuint16_t, pattern_len Tuint16_t, pattern uintptr) (r Txcb_list_fonts_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_list_fonts_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_list_fonts_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_list_fonts_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_list_fonts_request_t)(unsafe.Pointer(bp + 96))).Fmax_names = max_names
	(*(*Txcb_list_fonts_request_t)(unsafe.Pointer(bp + 96))).Fpattern_len = pattern_len
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char pattern */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = pattern
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(pattern_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req103)))
	return xcb_ret
}

var _xcb_req103 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_LIST_FONTS),
}

func Xxcb_list_fonts_names_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_list_fonts_reply_t)(unsafe.Pointer(R)).Fnames_len)
}

func Xxcb_list_fonts_names_iterator(tls *libc.TLS, R uintptr) (r Txcb_str_iterator_t) {
	var i Txcb_str_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32
	i.Frem = libc.Int32FromUint16((*Txcb_list_fonts_reply_t)(unsafe.Pointer(R)).Fnames_len)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_list_fonts_reply(tls *libc.TLS, c uintptr, cookie Txcb_list_fonts_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_list_fonts_with_info_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* pattern */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_list_fonts_with_info_request_t)(unsafe.Pointer(_aux)).Fpattern_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_list_fonts_with_info(tls *libc.TLS, c uintptr, max_names Tuint16_t, pattern_len Tuint16_t, pattern uintptr) (r Txcb_list_fonts_with_info_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_list_fonts_with_info_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_list_fonts_with_info_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_list_fonts_with_info_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_list_fonts_with_info_request_t)(unsafe.Pointer(bp + 96))).Fmax_names = max_names
	(*(*Txcb_list_fonts_with_info_request_t)(unsafe.Pointer(bp + 96))).Fpattern_len = pattern_len
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char pattern */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = pattern
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(pattern_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req104)))
	return xcb_ret
}

var _xcb_req104 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_LIST_FONTS_WITH_INFO),
}

func Xxcb_list_fonts_with_info_unchecked(tls *libc.TLS, c uintptr, max_names Tuint16_t, pattern_len Tuint16_t, pattern uintptr) (r Txcb_list_fonts_with_info_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_list_fonts_with_info_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_list_fonts_with_info_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_list_fonts_with_info_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_list_fonts_with_info_request_t)(unsafe.Pointer(bp + 96))).Fmax_names = max_names
	(*(*Txcb_list_fonts_with_info_request_t)(unsafe.Pointer(bp + 96))).Fpattern_len = pattern_len
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char pattern */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = pattern
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(pattern_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req105)))
	return xcb_ret
}

var _xcb_req105 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_LIST_FONTS_WITH_INFO),
}

func Xxcb_list_fonts_with_info_properties(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*60
}

func Xxcb_list_fonts_with_info_properties_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_list_fonts_with_info_reply_t)(unsafe.Pointer(R)).Fproperties_len)
}

func Xxcb_list_fonts_with_info_properties_iterator(tls *libc.TLS, R uintptr) (r Txcb_fontprop_iterator_t) {
	var i Txcb_fontprop_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*60
	i.Frem = libc.Int32FromUint16((*Txcb_list_fonts_with_info_reply_t)(unsafe.Pointer(R)).Fproperties_len)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_list_fonts_with_info_name(tls *libc.TLS, R uintptr) (r uintptr) {
	var prev Txcb_generic_iterator_t
	_ = prev
	prev = Xxcb_fontprop_end(tls, Xxcb_list_fonts_with_info_properties_iterator(tls, R))
	return prev.Fdata + uintptr(libc.Uint64FromInt32(-prev.Findex)&(libc.Uint64FromInt64(1)-libc.Uint64FromInt32(1))) + libc.UintptrFromInt32(0)
}

func Xxcb_list_fonts_with_info_name_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint8((*Txcb_list_fonts_with_info_reply_t)(unsafe.Pointer(R)).Fname_len)
}

func Xxcb_list_fonts_with_info_name_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i, prev Txcb_generic_iterator_t
	_, _ = i, prev
	prev = Xxcb_fontprop_end(tls, Xxcb_list_fonts_with_info_properties_iterator(tls, R))
	i.Fdata = prev.Fdata + uintptr(libc.Uint64FromInt32(-prev.Findex)&(libc.Uint64FromInt64(1)-libc.Uint64FromInt32(1))) + uintptr((*Txcb_list_fonts_with_info_reply_t)(unsafe.Pointer(R)).Fname_len)
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_list_fonts_with_info_reply(tls *libc.TLS, c uintptr, cookie Txcb_list_fonts_with_info_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_set_font_path_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp_len uint32
	_, _, _, _, _, _, _, _ = _aux, i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp, xcb_tmp_len
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* font */
	i = uint32(0)
	for {
		if !(i < uint32((*Txcb_set_font_path_request_t)(unsafe.Pointer(_aux)).Ffont_qty)) {
			break
		}
		xcb_tmp_len = libc.Uint32FromInt32(Xxcb_str_sizeof(tls, xcb_tmp))
		xcb_block_len += xcb_tmp_len
		xcb_tmp += uintptr(xcb_tmp_len)
		goto _1
	_1:
		;
		i++
	}
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_set_font_path_checked(tls *libc.TLS, c uintptr, font_qty Tuint16_t, font uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var i, xcb_tmp_len uint32
	var xcb_ret Txcb_void_cookie_t
	var xcb_tmp uintptr
	var _ /* xcb_out at bp+96 */ Txcb_set_font_path_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_, _, _, _ = i, xcb_ret, xcb_tmp, xcb_tmp_len
	(*(*Txcb_set_font_path_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_set_font_path_request_t)(unsafe.Pointer(bp + 96))).Ffont_qty = font_qty
	libc.Xmemset(tls, bp+96+6, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_str_t font */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = font
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(0)
	xcb_tmp = font
	i = uint32(0)
	for {
		if !(i < uint32(font_qty)) {
			break
		}
		xcb_tmp_len = libc.Uint32FromInt32(Xxcb_str_sizeof(tls, xcb_tmp))
		(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len += uint64(xcb_tmp_len)
		xcb_tmp += uintptr(xcb_tmp_len)
		goto _1
	_1:
		;
		i++
	}
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req106)))
	return xcb_ret
}

var _xcb_req106 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_SET_FONT_PATH),
	Fisvoid: uint8(1),
}

func Xxcb_set_font_path(tls *libc.TLS, c uintptr, font_qty Tuint16_t, font uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var i, xcb_tmp_len uint32
	var xcb_ret Txcb_void_cookie_t
	var xcb_tmp uintptr
	var _ /* xcb_out at bp+96 */ Txcb_set_font_path_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_, _, _, _ = i, xcb_ret, xcb_tmp, xcb_tmp_len
	(*(*Txcb_set_font_path_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_set_font_path_request_t)(unsafe.Pointer(bp + 96))).Ffont_qty = font_qty
	libc.Xmemset(tls, bp+96+6, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_str_t font */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = font
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(0)
	xcb_tmp = font
	i = uint32(0)
	for {
		if !(i < uint32(font_qty)) {
			break
		}
		xcb_tmp_len = libc.Uint32FromInt32(Xxcb_str_sizeof(tls, xcb_tmp))
		(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len += uint64(xcb_tmp_len)
		xcb_tmp += uintptr(xcb_tmp_len)
		goto _1
	_1:
		;
		i++
	}
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req107)))
	return xcb_ret
}

var _xcb_req107 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_SET_FONT_PATH),
	Fisvoid: uint8(1),
}

func Xxcb_set_font_path_font_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_set_font_path_request_t)(unsafe.Pointer(R)).Ffont_qty)
}

func Xxcb_set_font_path_font_iterator(tls *libc.TLS, R uintptr) (r Txcb_str_iterator_t) {
	var i Txcb_str_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*8
	i.Frem = libc.Int32FromUint16((*Txcb_set_font_path_request_t)(unsafe.Pointer(R)).Ffont_qty)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_get_font_path_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp_len uint32
	_, _, _, _, _, _, _, _ = _aux, i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp, xcb_tmp_len
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* path */
	i = uint32(0)
	for {
		if !(i < uint32((*Txcb_get_font_path_reply_t)(unsafe.Pointer(_aux)).Fpath_len)) {
			break
		}
		xcb_tmp_len = libc.Uint32FromInt32(Xxcb_str_sizeof(tls, xcb_tmp))
		xcb_block_len += xcb_tmp_len
		xcb_tmp += uintptr(xcb_tmp_len)
		goto _1
	_1:
		;
		i++
	}
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_get_font_path(tls *libc.TLS, c uintptr) (r Txcb_get_font_path_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_font_path_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_font_path_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_font_path_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req108)))
	return xcb_ret
}

var _xcb_req108 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_FONT_PATH),
}

func Xxcb_get_font_path_unchecked(tls *libc.TLS, c uintptr) (r Txcb_get_font_path_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_font_path_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_font_path_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_font_path_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req109)))
	return xcb_ret
}

var _xcb_req109 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_FONT_PATH),
}

func Xxcb_get_font_path_path_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_get_font_path_reply_t)(unsafe.Pointer(R)).Fpath_len)
}

func Xxcb_get_font_path_path_iterator(tls *libc.TLS, R uintptr) (r Txcb_str_iterator_t) {
	var i Txcb_str_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32
	i.Frem = libc.Int32FromUint16((*Txcb_get_font_path_reply_t)(unsafe.Pointer(R)).Fpath_len)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_get_font_path_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_font_path_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_create_pixmap_checked(tls *libc.TLS, c uintptr, depth Tuint8_t, pid Txcb_pixmap_t, drawable Txcb_drawable_t, width Tuint16_t, height Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_create_pixmap_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_create_pixmap_request_t)(unsafe.Pointer(bp + 64))).Fdepth = depth
	(*(*Txcb_create_pixmap_request_t)(unsafe.Pointer(bp + 64))).Fpid = pid
	(*(*Txcb_create_pixmap_request_t)(unsafe.Pointer(bp + 64))).Fdrawable = drawable
	(*(*Txcb_create_pixmap_request_t)(unsafe.Pointer(bp + 64))).Fwidth = width
	(*(*Txcb_create_pixmap_request_t)(unsafe.Pointer(bp + 64))).Fheight = height
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req110)))
	return xcb_ret
}

var _xcb_req110 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CREATE_PIXMAP),
	Fisvoid: uint8(1),
}

func Xxcb_create_pixmap(tls *libc.TLS, c uintptr, depth Tuint8_t, pid Txcb_pixmap_t, drawable Txcb_drawable_t, width Tuint16_t, height Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_create_pixmap_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_create_pixmap_request_t)(unsafe.Pointer(bp + 64))).Fdepth = depth
	(*(*Txcb_create_pixmap_request_t)(unsafe.Pointer(bp + 64))).Fpid = pid
	(*(*Txcb_create_pixmap_request_t)(unsafe.Pointer(bp + 64))).Fdrawable = drawable
	(*(*Txcb_create_pixmap_request_t)(unsafe.Pointer(bp + 64))).Fwidth = width
	(*(*Txcb_create_pixmap_request_t)(unsafe.Pointer(bp + 64))).Fheight = height
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req111)))
	return xcb_ret
}

var _xcb_req111 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CREATE_PIXMAP),
	Fisvoid: uint8(1),
}

func Xxcb_free_pixmap_checked(tls *libc.TLS, c uintptr, pixmap Txcb_pixmap_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_free_pixmap_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_free_pixmap_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_free_pixmap_request_t)(unsafe.Pointer(bp + 64))).Fpixmap = pixmap
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req112)))
	return xcb_ret
}

var _xcb_req112 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_FREE_PIXMAP),
	Fisvoid: uint8(1),
}

func Xxcb_free_pixmap(tls *libc.TLS, c uintptr, pixmap Txcb_pixmap_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_free_pixmap_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_free_pixmap_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_free_pixmap_request_t)(unsafe.Pointer(bp + 64))).Fpixmap = pixmap
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req113)))
	return xcb_ret
}

var _xcb_req113 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_FREE_PIXMAP),
	Fisvoid: uint8(1),
}

func Xxcb_create_gc_value_list_serialize(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t, _aux uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset, xcb_parts_idx uint32
	var xcb_out, xcb_tmp uintptr
	var xcb_parts [24]Tiovec
	var _ /* xcb_pad0 at bp+0 */ [3]int8
	_, _, _, _, _, _, _, _, _, _ = i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_out, xcb_pad, xcb_padding_offset, xcb_parts, xcb_parts_idx, xcb_tmp
	xcb_out = *(*uintptr)(unsafe.Pointer(_buffer))
	xcb_buffer_len = uint32(0)
	xcb_align_to = uint32(0)
	xcb_padding_offset = uint32(0)
	xcb_pad = uint32(0)
	*(*[3]int8)(unsafe.Pointer(bp)) = [3]int8{}
	xcb_parts_idx = uint32(0)
	xcb_block_len = uint32(0)
	if value_mask&uint32(_XCB_GC_FUNCTION) != 0 {
		/* xcb_create_gc_value_list_t.function */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_PLANE_MASK) != 0 {
		/* xcb_create_gc_value_list_t.plane_mask */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 4
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FOREGROUND) != 0 {
		/* xcb_create_gc_value_list_t.foreground */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 8
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_BACKGROUND) != 0 {
		/* xcb_create_gc_value_list_t.background */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 12
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_LINE_WIDTH) != 0 {
		/* xcb_create_gc_value_list_t.line_width */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 16
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_LINE_STYLE) != 0 {
		/* xcb_create_gc_value_list_t.line_style */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 20
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CAP_STYLE) != 0 {
		/* xcb_create_gc_value_list_t.cap_style */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 24
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_JOIN_STYLE) != 0 {
		/* xcb_create_gc_value_list_t.join_style */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 28
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FILL_STYLE) != 0 {
		/* xcb_create_gc_value_list_t.fill_style */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 32
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FILL_RULE) != 0 {
		/* xcb_create_gc_value_list_t.fill_rule */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 36
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_TILE) != 0 {
		/* xcb_create_gc_value_list_t.tile */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 40
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_STIPPLE) != 0 {
		/* xcb_create_gc_value_list_t.stipple */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 44
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_TILE_STIPPLE_ORIGIN_X) != 0 {
		/* xcb_create_gc_value_list_t.tile_stipple_x_origin */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 48
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_TILE_STIPPLE_ORIGIN_Y) != 0 {
		/* xcb_create_gc_value_list_t.tile_stipple_y_origin */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 52
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FONT) != 0 {
		/* xcb_create_gc_value_list_t.font */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 56
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_SUBWINDOW_MODE) != 0 {
		/* xcb_create_gc_value_list_t.subwindow_mode */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 60
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_GRAPHICS_EXPOSURES) != 0 {
		/* xcb_create_gc_value_list_t.graphics_exposures */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 64
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CLIP_ORIGIN_X) != 0 {
		/* xcb_create_gc_value_list_t.clip_x_origin */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 68
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CLIP_ORIGIN_Y) != 0 {
		/* xcb_create_gc_value_list_t.clip_y_origin */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 72
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CLIP_MASK) != 0 {
		/* xcb_create_gc_value_list_t.clip_mask */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 76
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_DASH_OFFSET) != 0 {
		/* xcb_create_gc_value_list_t.dash_offset */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 80
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_DASH_LIST) != 0 {
		/* xcb_create_gc_value_list_t.dashes */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 84
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_ARC_MODE) != 0 {
		/* xcb_create_gc_value_list_t.arc_mode */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 88
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	/* insert padding */
	xcb_pad = -(xcb_block_len + xcb_padding_offset) & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_parts[xcb_parts_idx].Fiov_base = bp
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(xcb_pad)
		xcb_parts_idx++
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	xcb_padding_offset = uint32(0)
	if libc.UintptrFromInt32(0) == xcb_out {
		/* allocate memory */
		xcb_out = libc.Xmalloc(tls, uint64(xcb_buffer_len))
		*(*uintptr)(unsafe.Pointer(_buffer)) = xcb_out
	}
	xcb_tmp = xcb_out
	i = uint32(0)
	for {
		if !(i < xcb_parts_idx) {
			break
		}
		if uintptr(0) != xcb_parts[i].Fiov_base && uint64(0) != xcb_parts[i].Fiov_len {
			libc.Xmemcpy(tls, xcb_tmp, xcb_parts[i].Fiov_base, xcb_parts[i].Fiov_len)
		}
		if uint64(0) != xcb_parts[i].Fiov_len {
			xcb_tmp += uintptr(xcb_parts[i].Fiov_len)
		}
		goto _1
	_1:
		;
		i++
	}
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_create_gc_value_list_unpack(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t, _aux uintptr) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset uint32
	var xcb_tmp uintptr
	_, _, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_padding_offset = uint32(0)
	if value_mask&uint32(_XCB_GC_FUNCTION) != 0 {
		/* xcb_create_gc_value_list_t.function */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Ffunction = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_PLANE_MASK) != 0 {
		/* xcb_create_gc_value_list_t.plane_mask */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fplane_mask = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FOREGROUND) != 0 {
		/* xcb_create_gc_value_list_t.foreground */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fforeground = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_BACKGROUND) != 0 {
		/* xcb_create_gc_value_list_t.background */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fbackground = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_LINE_WIDTH) != 0 {
		/* xcb_create_gc_value_list_t.line_width */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fline_width = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_LINE_STYLE) != 0 {
		/* xcb_create_gc_value_list_t.line_style */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fline_style = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CAP_STYLE) != 0 {
		/* xcb_create_gc_value_list_t.cap_style */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fcap_style = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_JOIN_STYLE) != 0 {
		/* xcb_create_gc_value_list_t.join_style */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fjoin_style = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FILL_STYLE) != 0 {
		/* xcb_create_gc_value_list_t.fill_style */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Ffill_style = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FILL_RULE) != 0 {
		/* xcb_create_gc_value_list_t.fill_rule */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Ffill_rule = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_TILE) != 0 {
		/* xcb_create_gc_value_list_t.tile */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Ftile = *(*Txcb_pixmap_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_STIPPLE) != 0 {
		/* xcb_create_gc_value_list_t.stipple */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fstipple = *(*Txcb_pixmap_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_TILE_STIPPLE_ORIGIN_X) != 0 {
		/* xcb_create_gc_value_list_t.tile_stipple_x_origin */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Ftile_stipple_x_origin = *(*Tint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_TILE_STIPPLE_ORIGIN_Y) != 0 {
		/* xcb_create_gc_value_list_t.tile_stipple_y_origin */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Ftile_stipple_y_origin = *(*Tint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FONT) != 0 {
		/* xcb_create_gc_value_list_t.font */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Ffont = *(*Txcb_font_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_SUBWINDOW_MODE) != 0 {
		/* xcb_create_gc_value_list_t.subwindow_mode */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fsubwindow_mode = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_GRAPHICS_EXPOSURES) != 0 {
		/* xcb_create_gc_value_list_t.graphics_exposures */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fgraphics_exposures = *(*Txcb_bool32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CLIP_ORIGIN_X) != 0 {
		/* xcb_create_gc_value_list_t.clip_x_origin */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fclip_x_origin = *(*Tint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CLIP_ORIGIN_Y) != 0 {
		/* xcb_create_gc_value_list_t.clip_y_origin */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fclip_y_origin = *(*Tint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CLIP_MASK) != 0 {
		/* xcb_create_gc_value_list_t.clip_mask */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fclip_mask = *(*Txcb_pixmap_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_DASH_OFFSET) != 0 {
		/* xcb_create_gc_value_list_t.dash_offset */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fdash_offset = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_DASH_LIST) != 0 {
		/* xcb_create_gc_value_list_t.dashes */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Fdashes = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_ARC_MODE) != 0 {
		/* xcb_create_gc_value_list_t.arc_mode */
		(*Txcb_create_gc_value_list_t)(unsafe.Pointer(_aux)).Farc_mode = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	/* insert padding */
	xcb_pad = -(xcb_block_len + xcb_padding_offset) & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	xcb_padding_offset = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_create_gc_value_list_sizeof(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t) (r int32) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var _ /* _aux at bp+0 */ Txcb_create_gc_value_list_t
	return Xxcb_create_gc_value_list_unpack(tls, _buffer, value_mask, bp)
}

func Xxcb_create_gc_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(16))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* value_list */
	xcb_block_len += libc.Uint32FromInt32(Xxcb_create_gc_value_list_sizeof(tls, xcb_tmp, (*Txcb_create_gc_request_t)(unsafe.Pointer(_aux)).Fvalue_mask))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_create_gc_checked(tls *libc.TLS, c uintptr, cid Txcb_gcontext_t, drawable Txcb_drawable_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+80 */ Txcb_create_gc_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fcid = cid
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fdrawable = drawable
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_create_gc_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = value_list
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_create_gc_value_list_sizeof(tls, value_list, value_mask))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req114)))
	return xcb_ret
}

var _xcb_req114 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CREATE_GC),
	Fisvoid: uint8(1),
}

func Xxcb_create_gc(tls *libc.TLS, c uintptr, cid Txcb_gcontext_t, drawable Txcb_drawable_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+80 */ Txcb_create_gc_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fcid = cid
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fdrawable = drawable
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_create_gc_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = value_list
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_create_gc_value_list_sizeof(tls, value_list, value_mask))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req115)))
	return xcb_ret
}

var _xcb_req115 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CREATE_GC),
	Fisvoid: uint8(1),
}

func Xxcb_create_gc_aux_checked(tls *libc.TLS, c uintptr, cid Txcb_gcontext_t, drawable Txcb_drawable_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_aux0 at bp+96 */ uintptr
	var _ /* xcb_out at bp+80 */ Txcb_create_gc_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	*(*uintptr)(unsafe.Pointer(bp + 96)) = uintptr(0)
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fcid = cid
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fdrawable = drawable
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_create_gc_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_create_gc_value_list_serialize(tls, bp+96, value_mask, value_list))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = *(*uintptr)(unsafe.Pointer(bp + 96))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req116)))
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 96)))
	return xcb_ret
}

var _xcb_req116 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CREATE_GC),
	Fisvoid: uint8(1),
}

func Xxcb_create_gc_aux(tls *libc.TLS, c uintptr, cid Txcb_gcontext_t, drawable Txcb_drawable_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_aux0 at bp+96 */ uintptr
	var _ /* xcb_out at bp+80 */ Txcb_create_gc_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	*(*uintptr)(unsafe.Pointer(bp + 96)) = uintptr(0)
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fcid = cid
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fdrawable = drawable
	(*(*Txcb_create_gc_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_create_gc_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_create_gc_value_list_serialize(tls, bp+96, value_mask, value_list))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = *(*uintptr)(unsafe.Pointer(bp + 96))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req117)))
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 96)))
	return xcb_ret
}

var _xcb_req117 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CREATE_GC),
	Fisvoid: uint8(1),
}

func Xxcb_create_gc_value_list(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*16
}

func Xxcb_change_gc_value_list_serialize(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t, _aux uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset, xcb_parts_idx uint32
	var xcb_out, xcb_tmp uintptr
	var xcb_parts [24]Tiovec
	var _ /* xcb_pad0 at bp+0 */ [3]int8
	_, _, _, _, _, _, _, _, _, _ = i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_out, xcb_pad, xcb_padding_offset, xcb_parts, xcb_parts_idx, xcb_tmp
	xcb_out = *(*uintptr)(unsafe.Pointer(_buffer))
	xcb_buffer_len = uint32(0)
	xcb_align_to = uint32(0)
	xcb_padding_offset = uint32(0)
	xcb_pad = uint32(0)
	*(*[3]int8)(unsafe.Pointer(bp)) = [3]int8{}
	xcb_parts_idx = uint32(0)
	xcb_block_len = uint32(0)
	if value_mask&uint32(_XCB_GC_FUNCTION) != 0 {
		/* xcb_change_gc_value_list_t.function */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_PLANE_MASK) != 0 {
		/* xcb_change_gc_value_list_t.plane_mask */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 4
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FOREGROUND) != 0 {
		/* xcb_change_gc_value_list_t.foreground */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 8
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_BACKGROUND) != 0 {
		/* xcb_change_gc_value_list_t.background */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 12
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_LINE_WIDTH) != 0 {
		/* xcb_change_gc_value_list_t.line_width */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 16
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_LINE_STYLE) != 0 {
		/* xcb_change_gc_value_list_t.line_style */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 20
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CAP_STYLE) != 0 {
		/* xcb_change_gc_value_list_t.cap_style */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 24
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_JOIN_STYLE) != 0 {
		/* xcb_change_gc_value_list_t.join_style */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 28
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FILL_STYLE) != 0 {
		/* xcb_change_gc_value_list_t.fill_style */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 32
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FILL_RULE) != 0 {
		/* xcb_change_gc_value_list_t.fill_rule */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 36
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_TILE) != 0 {
		/* xcb_change_gc_value_list_t.tile */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 40
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_STIPPLE) != 0 {
		/* xcb_change_gc_value_list_t.stipple */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 44
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_TILE_STIPPLE_ORIGIN_X) != 0 {
		/* xcb_change_gc_value_list_t.tile_stipple_x_origin */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 48
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_TILE_STIPPLE_ORIGIN_Y) != 0 {
		/* xcb_change_gc_value_list_t.tile_stipple_y_origin */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 52
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FONT) != 0 {
		/* xcb_change_gc_value_list_t.font */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 56
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_SUBWINDOW_MODE) != 0 {
		/* xcb_change_gc_value_list_t.subwindow_mode */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 60
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_GRAPHICS_EXPOSURES) != 0 {
		/* xcb_change_gc_value_list_t.graphics_exposures */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 64
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CLIP_ORIGIN_X) != 0 {
		/* xcb_change_gc_value_list_t.clip_x_origin */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 68
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CLIP_ORIGIN_Y) != 0 {
		/* xcb_change_gc_value_list_t.clip_y_origin */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 72
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CLIP_MASK) != 0 {
		/* xcb_change_gc_value_list_t.clip_mask */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 76
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_DASH_OFFSET) != 0 {
		/* xcb_change_gc_value_list_t.dash_offset */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 80
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_DASH_LIST) != 0 {
		/* xcb_change_gc_value_list_t.dashes */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 84
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_ARC_MODE) != 0 {
		/* xcb_change_gc_value_list_t.arc_mode */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 88
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	/* insert padding */
	xcb_pad = -(xcb_block_len + xcb_padding_offset) & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_parts[xcb_parts_idx].Fiov_base = bp
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(xcb_pad)
		xcb_parts_idx++
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	xcb_padding_offset = uint32(0)
	if libc.UintptrFromInt32(0) == xcb_out {
		/* allocate memory */
		xcb_out = libc.Xmalloc(tls, uint64(xcb_buffer_len))
		*(*uintptr)(unsafe.Pointer(_buffer)) = xcb_out
	}
	xcb_tmp = xcb_out
	i = uint32(0)
	for {
		if !(i < xcb_parts_idx) {
			break
		}
		if uintptr(0) != xcb_parts[i].Fiov_base && uint64(0) != xcb_parts[i].Fiov_len {
			libc.Xmemcpy(tls, xcb_tmp, xcb_parts[i].Fiov_base, xcb_parts[i].Fiov_len)
		}
		if uint64(0) != xcb_parts[i].Fiov_len {
			xcb_tmp += uintptr(xcb_parts[i].Fiov_len)
		}
		goto _1
	_1:
		;
		i++
	}
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_change_gc_value_list_unpack(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t, _aux uintptr) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset uint32
	var xcb_tmp uintptr
	_, _, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_padding_offset = uint32(0)
	if value_mask&uint32(_XCB_GC_FUNCTION) != 0 {
		/* xcb_change_gc_value_list_t.function */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Ffunction = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_PLANE_MASK) != 0 {
		/* xcb_change_gc_value_list_t.plane_mask */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fplane_mask = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FOREGROUND) != 0 {
		/* xcb_change_gc_value_list_t.foreground */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fforeground = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_BACKGROUND) != 0 {
		/* xcb_change_gc_value_list_t.background */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fbackground = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_LINE_WIDTH) != 0 {
		/* xcb_change_gc_value_list_t.line_width */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fline_width = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_LINE_STYLE) != 0 {
		/* xcb_change_gc_value_list_t.line_style */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fline_style = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CAP_STYLE) != 0 {
		/* xcb_change_gc_value_list_t.cap_style */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fcap_style = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_JOIN_STYLE) != 0 {
		/* xcb_change_gc_value_list_t.join_style */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fjoin_style = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FILL_STYLE) != 0 {
		/* xcb_change_gc_value_list_t.fill_style */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Ffill_style = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FILL_RULE) != 0 {
		/* xcb_change_gc_value_list_t.fill_rule */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Ffill_rule = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_TILE) != 0 {
		/* xcb_change_gc_value_list_t.tile */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Ftile = *(*Txcb_pixmap_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_STIPPLE) != 0 {
		/* xcb_change_gc_value_list_t.stipple */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fstipple = *(*Txcb_pixmap_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_TILE_STIPPLE_ORIGIN_X) != 0 {
		/* xcb_change_gc_value_list_t.tile_stipple_x_origin */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Ftile_stipple_x_origin = *(*Tint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_TILE_STIPPLE_ORIGIN_Y) != 0 {
		/* xcb_change_gc_value_list_t.tile_stipple_y_origin */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Ftile_stipple_y_origin = *(*Tint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_FONT) != 0 {
		/* xcb_change_gc_value_list_t.font */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Ffont = *(*Txcb_font_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_SUBWINDOW_MODE) != 0 {
		/* xcb_change_gc_value_list_t.subwindow_mode */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fsubwindow_mode = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_GRAPHICS_EXPOSURES) != 0 {
		/* xcb_change_gc_value_list_t.graphics_exposures */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fgraphics_exposures = *(*Txcb_bool32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CLIP_ORIGIN_X) != 0 {
		/* xcb_change_gc_value_list_t.clip_x_origin */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fclip_x_origin = *(*Tint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CLIP_ORIGIN_Y) != 0 {
		/* xcb_change_gc_value_list_t.clip_y_origin */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fclip_y_origin = *(*Tint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_CLIP_MASK) != 0 {
		/* xcb_change_gc_value_list_t.clip_mask */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fclip_mask = *(*Txcb_pixmap_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_DASH_OFFSET) != 0 {
		/* xcb_change_gc_value_list_t.dash_offset */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fdash_offset = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_DASH_LIST) != 0 {
		/* xcb_change_gc_value_list_t.dashes */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Fdashes = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_GC_ARC_MODE) != 0 {
		/* xcb_change_gc_value_list_t.arc_mode */
		(*Txcb_change_gc_value_list_t)(unsafe.Pointer(_aux)).Farc_mode = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	/* insert padding */
	xcb_pad = -(xcb_block_len + xcb_padding_offset) & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	xcb_padding_offset = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_change_gc_value_list_sizeof(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t) (r int32) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var _ /* _aux at bp+0 */ Txcb_change_gc_value_list_t
	return Xxcb_change_gc_value_list_unpack(tls, _buffer, value_mask, bp)
}

func Xxcb_change_gc_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* value_list */
	xcb_block_len += libc.Uint32FromInt32(Xxcb_change_gc_value_list_sizeof(tls, xcb_tmp, (*Txcb_change_gc_request_t)(unsafe.Pointer(_aux)).Fvalue_mask))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_change_gc_checked(tls *libc.TLS, c uintptr, gc Txcb_gcontext_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+80 */ Txcb_change_gc_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_gc_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_change_gc_request_t)(unsafe.Pointer(bp + 80))).Fgc = gc
	(*(*Txcb_change_gc_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_change_gc_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = value_list
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_change_gc_value_list_sizeof(tls, value_list, value_mask))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req118)))
	return xcb_ret
}

var _xcb_req118 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CHANGE_GC),
	Fisvoid: uint8(1),
}

func Xxcb_change_gc(tls *libc.TLS, c uintptr, gc Txcb_gcontext_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+80 */ Txcb_change_gc_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_gc_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_change_gc_request_t)(unsafe.Pointer(bp + 80))).Fgc = gc
	(*(*Txcb_change_gc_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_change_gc_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = value_list
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_change_gc_value_list_sizeof(tls, value_list, value_mask))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req119)))
	return xcb_ret
}

var _xcb_req119 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CHANGE_GC),
	Fisvoid: uint8(1),
}

func Xxcb_change_gc_aux_checked(tls *libc.TLS, c uintptr, gc Txcb_gcontext_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_aux0 at bp+96 */ uintptr
	var _ /* xcb_out at bp+80 */ Txcb_change_gc_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	*(*uintptr)(unsafe.Pointer(bp + 96)) = uintptr(0)
	(*(*Txcb_change_gc_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_change_gc_request_t)(unsafe.Pointer(bp + 80))).Fgc = gc
	(*(*Txcb_change_gc_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_change_gc_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_change_gc_value_list_serialize(tls, bp+96, value_mask, value_list))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = *(*uintptr)(unsafe.Pointer(bp + 96))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req120)))
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 96)))
	return xcb_ret
}

var _xcb_req120 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CHANGE_GC),
	Fisvoid: uint8(1),
}

func Xxcb_change_gc_aux(tls *libc.TLS, c uintptr, gc Txcb_gcontext_t, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_aux0 at bp+96 */ uintptr
	var _ /* xcb_out at bp+80 */ Txcb_change_gc_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	*(*uintptr)(unsafe.Pointer(bp + 96)) = uintptr(0)
	(*(*Txcb_change_gc_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_change_gc_request_t)(unsafe.Pointer(bp + 80))).Fgc = gc
	(*(*Txcb_change_gc_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_change_gc_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_change_gc_value_list_serialize(tls, bp+96, value_mask, value_list))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = *(*uintptr)(unsafe.Pointer(bp + 96))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req121)))
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 96)))
	return xcb_ret
}

var _xcb_req121 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CHANGE_GC),
	Fisvoid: uint8(1),
}

func Xxcb_change_gc_value_list(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_copy_gc_checked(tls *libc.TLS, c uintptr, src_gc Txcb_gcontext_t, dst_gc Txcb_gcontext_t, value_mask Tuint32_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_copy_gc_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_copy_gc_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_copy_gc_request_t)(unsafe.Pointer(bp + 64))).Fsrc_gc = src_gc
	(*(*Txcb_copy_gc_request_t)(unsafe.Pointer(bp + 64))).Fdst_gc = dst_gc
	(*(*Txcb_copy_gc_request_t)(unsafe.Pointer(bp + 64))).Fvalue_mask = value_mask
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req122)))
	return xcb_ret
}

var _xcb_req122 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_COPY_GC),
	Fisvoid: uint8(1),
}

func Xxcb_copy_gc(tls *libc.TLS, c uintptr, src_gc Txcb_gcontext_t, dst_gc Txcb_gcontext_t, value_mask Tuint32_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_copy_gc_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_copy_gc_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_copy_gc_request_t)(unsafe.Pointer(bp + 64))).Fsrc_gc = src_gc
	(*(*Txcb_copy_gc_request_t)(unsafe.Pointer(bp + 64))).Fdst_gc = dst_gc
	(*(*Txcb_copy_gc_request_t)(unsafe.Pointer(bp + 64))).Fvalue_mask = value_mask
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req123)))
	return xcb_ret
}

var _xcb_req123 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_COPY_GC),
	Fisvoid: uint8(1),
}

func Xxcb_set_dashes_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* dashes */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_set_dashes_request_t)(unsafe.Pointer(_aux)).Fdashes_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_set_dashes_checked(tls *libc.TLS, c uintptr, gc Txcb_gcontext_t, dash_offset Tuint16_t, dashes_len Tuint16_t, dashes uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_set_dashes_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_dashes_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_set_dashes_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_set_dashes_request_t)(unsafe.Pointer(bp + 96))).Fdash_offset = dash_offset
	(*(*Txcb_set_dashes_request_t)(unsafe.Pointer(bp + 96))).Fdashes_len = dashes_len
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint8_t dashes */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = dashes
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(dashes_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req124)))
	return xcb_ret
}

var _xcb_req124 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_SET_DASHES),
	Fisvoid: uint8(1),
}

func Xxcb_set_dashes(tls *libc.TLS, c uintptr, gc Txcb_gcontext_t, dash_offset Tuint16_t, dashes_len Tuint16_t, dashes uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_set_dashes_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_dashes_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_set_dashes_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_set_dashes_request_t)(unsafe.Pointer(bp + 96))).Fdash_offset = dash_offset
	(*(*Txcb_set_dashes_request_t)(unsafe.Pointer(bp + 96))).Fdashes_len = dashes_len
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint8_t dashes */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = dashes
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(dashes_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req125)))
	return xcb_ret
}

var _xcb_req125 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_SET_DASHES),
	Fisvoid: uint8(1),
}

func Xxcb_set_dashes_dashes(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_set_dashes_dashes_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_set_dashes_request_t)(unsafe.Pointer(R)).Fdashes_len)
}

func Xxcb_set_dashes_dashes_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*12 + uintptr((*Txcb_set_dashes_request_t)(unsafe.Pointer(R)).Fdashes_len)
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_set_clip_rectangles_sizeof(tls *libc.TLS, _buffer uintptr, rectangles_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* rectangles */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(rectangles_len)*libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 2))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_set_clip_rectangles_checked(tls *libc.TLS, c uintptr, ordering Tuint8_t, gc Txcb_gcontext_t, clip_x_origin Tint16_t, clip_y_origin Tint16_t, rectangles_len Tuint32_t, rectangles uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_set_clip_rectangles_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_clip_rectangles_request_t)(unsafe.Pointer(bp + 96))).Fordering = ordering
	(*(*Txcb_set_clip_rectangles_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_set_clip_rectangles_request_t)(unsafe.Pointer(bp + 96))).Fclip_x_origin = clip_x_origin
	(*(*Txcb_set_clip_rectangles_request_t)(unsafe.Pointer(bp + 96))).Fclip_y_origin = clip_y_origin
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_rectangle_t rectangles */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = rectangles
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(rectangles_len) * uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req126)))
	return xcb_ret
}

var _xcb_req126 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_SET_CLIP_RECTANGLES),
	Fisvoid: uint8(1),
}

func Xxcb_set_clip_rectangles(tls *libc.TLS, c uintptr, ordering Tuint8_t, gc Txcb_gcontext_t, clip_x_origin Tint16_t, clip_y_origin Tint16_t, rectangles_len Tuint32_t, rectangles uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_set_clip_rectangles_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_clip_rectangles_request_t)(unsafe.Pointer(bp + 96))).Fordering = ordering
	(*(*Txcb_set_clip_rectangles_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_set_clip_rectangles_request_t)(unsafe.Pointer(bp + 96))).Fclip_x_origin = clip_x_origin
	(*(*Txcb_set_clip_rectangles_request_t)(unsafe.Pointer(bp + 96))).Fclip_y_origin = clip_y_origin
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_rectangle_t rectangles */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = rectangles
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(rectangles_len) * uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req127)))
	return xcb_ret
}

var _xcb_req127 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_SET_CLIP_RECTANGLES),
	Fisvoid: uint8(1),
}

func Xxcb_set_clip_rectangles_rectangles(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_set_clip_rectangles_rectangles_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_set_clip_rectangles_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(8))
}

func Xxcb_set_clip_rectangles_rectangles_iterator(tls *libc.TLS, R uintptr) (r Txcb_rectangle_iterator_t) {
	var i Txcb_rectangle_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*12
	i.Frem = libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_set_clip_rectangles_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(8))
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_free_gc_checked(tls *libc.TLS, c uintptr, gc Txcb_gcontext_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_free_gc_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_free_gc_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_free_gc_request_t)(unsafe.Pointer(bp + 64))).Fgc = gc
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req128)))
	return xcb_ret
}

var _xcb_req128 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_FREE_GC),
	Fisvoid: uint8(1),
}

func Xxcb_free_gc(tls *libc.TLS, c uintptr, gc Txcb_gcontext_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_free_gc_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_free_gc_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_free_gc_request_t)(unsafe.Pointer(bp + 64))).Fgc = gc
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req129)))
	return xcb_ret
}

var _xcb_req129 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_FREE_GC),
	Fisvoid: uint8(1),
}

func Xxcb_clear_area_checked(tls *libc.TLS, c uintptr, exposures Tuint8_t, window Txcb_window_t, x Tint16_t, y Tint16_t, width Tuint16_t, height Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_clear_area_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_clear_area_request_t)(unsafe.Pointer(bp + 64))).Fexposures = exposures
	(*(*Txcb_clear_area_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*Txcb_clear_area_request_t)(unsafe.Pointer(bp + 64))).Fx = x
	(*(*Txcb_clear_area_request_t)(unsafe.Pointer(bp + 64))).Fy = y
	(*(*Txcb_clear_area_request_t)(unsafe.Pointer(bp + 64))).Fwidth = width
	(*(*Txcb_clear_area_request_t)(unsafe.Pointer(bp + 64))).Fheight = height
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req130)))
	return xcb_ret
}

var _xcb_req130 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CLEAR_AREA),
	Fisvoid: uint8(1),
}

func Xxcb_clear_area(tls *libc.TLS, c uintptr, exposures Tuint8_t, window Txcb_window_t, x Tint16_t, y Tint16_t, width Tuint16_t, height Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_clear_area_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_clear_area_request_t)(unsafe.Pointer(bp + 64))).Fexposures = exposures
	(*(*Txcb_clear_area_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*Txcb_clear_area_request_t)(unsafe.Pointer(bp + 64))).Fx = x
	(*(*Txcb_clear_area_request_t)(unsafe.Pointer(bp + 64))).Fy = y
	(*(*Txcb_clear_area_request_t)(unsafe.Pointer(bp + 64))).Fwidth = width
	(*(*Txcb_clear_area_request_t)(unsafe.Pointer(bp + 64))).Fheight = height
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req131)))
	return xcb_ret
}

var _xcb_req131 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CLEAR_AREA),
	Fisvoid: uint8(1),
}

func Xxcb_copy_area_checked(tls *libc.TLS, c uintptr, src_drawable Txcb_drawable_t, dst_drawable Txcb_drawable_t, gc Txcb_gcontext_t, src_x Tint16_t, src_y Tint16_t, dst_x Tint16_t, dst_y Tint16_t, width Tuint16_t, height Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_copy_area_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fsrc_drawable = src_drawable
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fdst_drawable = dst_drawable
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fgc = gc
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fsrc_x = src_x
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fsrc_y = src_y
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fdst_x = dst_x
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fdst_y = dst_y
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fwidth = width
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fheight = height
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(28)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req132)))
	return xcb_ret
}

var _xcb_req132 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_COPY_AREA),
	Fisvoid: uint8(1),
}

func Xxcb_copy_area(tls *libc.TLS, c uintptr, src_drawable Txcb_drawable_t, dst_drawable Txcb_drawable_t, gc Txcb_gcontext_t, src_x Tint16_t, src_y Tint16_t, dst_x Tint16_t, dst_y Tint16_t, width Tuint16_t, height Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_copy_area_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fsrc_drawable = src_drawable
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fdst_drawable = dst_drawable
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fgc = gc
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fsrc_x = src_x
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fsrc_y = src_y
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fdst_x = dst_x
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fdst_y = dst_y
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fwidth = width
	(*(*Txcb_copy_area_request_t)(unsafe.Pointer(bp + 64))).Fheight = height
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(28)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req133)))
	return xcb_ret
}

var _xcb_req133 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_COPY_AREA),
	Fisvoid: uint8(1),
}

func Xxcb_copy_plane_checked(tls *libc.TLS, c uintptr, src_drawable Txcb_drawable_t, dst_drawable Txcb_drawable_t, gc Txcb_gcontext_t, src_x Tint16_t, src_y Tint16_t, dst_x Tint16_t, dst_y Tint16_t, width Tuint16_t, height Tuint16_t, bit_plane Tuint32_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_copy_plane_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fsrc_drawable = src_drawable
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fdst_drawable = dst_drawable
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fgc = gc
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fsrc_x = src_x
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fsrc_y = src_y
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fdst_x = dst_x
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fdst_y = dst_y
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fwidth = width
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fheight = height
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fbit_plane = bit_plane
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(32)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req134)))
	return xcb_ret
}

var _xcb_req134 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_COPY_PLANE),
	Fisvoid: uint8(1),
}

func Xxcb_copy_plane(tls *libc.TLS, c uintptr, src_drawable Txcb_drawable_t, dst_drawable Txcb_drawable_t, gc Txcb_gcontext_t, src_x Tint16_t, src_y Tint16_t, dst_x Tint16_t, dst_y Tint16_t, width Tuint16_t, height Tuint16_t, bit_plane Tuint32_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_copy_plane_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fsrc_drawable = src_drawable
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fdst_drawable = dst_drawable
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fgc = gc
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fsrc_x = src_x
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fsrc_y = src_y
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fdst_x = dst_x
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fdst_y = dst_y
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fwidth = width
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fheight = height
	(*(*Txcb_copy_plane_request_t)(unsafe.Pointer(bp + 64))).Fbit_plane = bit_plane
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(32)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req135)))
	return xcb_ret
}

var _xcb_req135 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_COPY_PLANE),
	Fisvoid: uint8(1),
}

func Xxcb_poly_point_sizeof(tls *libc.TLS, _buffer uintptr, points_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* points */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(points_len)*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 2))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_poly_point_checked(tls *libc.TLS, c uintptr, coordinate_mode Tuint8_t, drawable Txcb_drawable_t, gc Txcb_gcontext_t, points_len Tuint32_t, points uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_point_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_point_request_t)(unsafe.Pointer(bp + 96))).Fcoordinate_mode = coordinate_mode
	(*(*Txcb_poly_point_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_point_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_point_t points */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = points
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(points_len) * uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req136)))
	return xcb_ret
}

var _xcb_req136 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_POINT),
	Fisvoid: uint8(1),
}

func Xxcb_poly_point(tls *libc.TLS, c uintptr, coordinate_mode Tuint8_t, drawable Txcb_drawable_t, gc Txcb_gcontext_t, points_len Tuint32_t, points uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_point_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_point_request_t)(unsafe.Pointer(bp + 96))).Fcoordinate_mode = coordinate_mode
	(*(*Txcb_poly_point_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_point_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_point_t points */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = points
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(points_len) * uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req137)))
	return xcb_ret
}

var _xcb_req137 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_POINT),
	Fisvoid: uint8(1),
}

func Xxcb_poly_point_points(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_poly_point_points_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_point_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(4))
}

func Xxcb_poly_point_points_iterator(tls *libc.TLS, R uintptr) (r Txcb_point_iterator_t) {
	var i Txcb_point_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*12
	i.Frem = libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_point_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(4))
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_poly_line_sizeof(tls *libc.TLS, _buffer uintptr, points_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* points */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(points_len)*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 2))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_poly_line_checked(tls *libc.TLS, c uintptr, coordinate_mode Tuint8_t, drawable Txcb_drawable_t, gc Txcb_gcontext_t, points_len Tuint32_t, points uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_line_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_line_request_t)(unsafe.Pointer(bp + 96))).Fcoordinate_mode = coordinate_mode
	(*(*Txcb_poly_line_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_line_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_point_t points */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = points
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(points_len) * uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req138)))
	return xcb_ret
}

var _xcb_req138 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_LINE),
	Fisvoid: uint8(1),
}

func Xxcb_poly_line(tls *libc.TLS, c uintptr, coordinate_mode Tuint8_t, drawable Txcb_drawable_t, gc Txcb_gcontext_t, points_len Tuint32_t, points uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_line_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_line_request_t)(unsafe.Pointer(bp + 96))).Fcoordinate_mode = coordinate_mode
	(*(*Txcb_poly_line_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_line_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_point_t points */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = points
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(points_len) * uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req139)))
	return xcb_ret
}

var _xcb_req139 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_LINE),
	Fisvoid: uint8(1),
}

func Xxcb_poly_line_points(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_poly_line_points_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_line_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(4))
}

func Xxcb_poly_line_points_iterator(tls *libc.TLS, R uintptr) (r Txcb_point_iterator_t) {
	var i Txcb_point_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*12
	i.Frem = libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_line_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(4))
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_segment_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_segment_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_segment_iterator_t)(unsafe.Pointer(i)).Fdata += 8
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(8))
}

func Xxcb_segment_end(tls *libc.TLS, i Txcb_segment_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*8
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_poly_segment_sizeof(tls *libc.TLS, _buffer uintptr, segments_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* segments */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(segments_len)*libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 2))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_poly_segment_checked(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, segments_len Tuint32_t, segments uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_segment_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_segment_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_poly_segment_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_segment_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_segment_t segments */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = segments
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(segments_len) * uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req140)))
	return xcb_ret
}

var _xcb_req140 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_SEGMENT),
	Fisvoid: uint8(1),
}

func Xxcb_poly_segment(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, segments_len Tuint32_t, segments uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_segment_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_segment_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_poly_segment_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_segment_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_segment_t segments */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = segments
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(segments_len) * uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req141)))
	return xcb_ret
}

var _xcb_req141 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_SEGMENT),
	Fisvoid: uint8(1),
}

func Xxcb_poly_segment_segments(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_poly_segment_segments_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_segment_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(8))
}

func Xxcb_poly_segment_segments_iterator(tls *libc.TLS, R uintptr) (r Txcb_segment_iterator_t) {
	var i Txcb_segment_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*12
	i.Frem = libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_segment_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(8))
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_poly_rectangle_sizeof(tls *libc.TLS, _buffer uintptr, rectangles_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* rectangles */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(rectangles_len)*libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 2))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_poly_rectangle_checked(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, rectangles_len Tuint32_t, rectangles uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_rectangle_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_rectangle_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_poly_rectangle_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_rectangle_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_rectangle_t rectangles */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = rectangles
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(rectangles_len) * uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req142)))
	return xcb_ret
}

var _xcb_req142 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_RECTANGLE),
	Fisvoid: uint8(1),
}

func Xxcb_poly_rectangle(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, rectangles_len Tuint32_t, rectangles uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_rectangle_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_rectangle_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_poly_rectangle_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_rectangle_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_rectangle_t rectangles */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = rectangles
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(rectangles_len) * uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req143)))
	return xcb_ret
}

var _xcb_req143 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_RECTANGLE),
	Fisvoid: uint8(1),
}

func Xxcb_poly_rectangle_rectangles(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_poly_rectangle_rectangles_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_rectangle_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(8))
}

func Xxcb_poly_rectangle_rectangles_iterator(tls *libc.TLS, R uintptr) (r Txcb_rectangle_iterator_t) {
	var i Txcb_rectangle_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*12
	i.Frem = libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_rectangle_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(8))
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_poly_arc_sizeof(tls *libc.TLS, _buffer uintptr, arcs_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* arcs */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(arcs_len)*libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 2))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_poly_arc_checked(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, arcs_len Tuint32_t, arcs uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_arc_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_arc_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_poly_arc_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_arc_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_arc_t arcs */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = arcs
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(arcs_len) * uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req144)))
	return xcb_ret
}

var _xcb_req144 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_ARC),
	Fisvoid: uint8(1),
}

func Xxcb_poly_arc(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, arcs_len Tuint32_t, arcs uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_arc_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_arc_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_poly_arc_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_arc_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_arc_t arcs */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = arcs
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(arcs_len) * uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req145)))
	return xcb_ret
}

var _xcb_req145 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_ARC),
	Fisvoid: uint8(1),
}

func Xxcb_poly_arc_arcs(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_poly_arc_arcs_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_arc_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(12))
}

func Xxcb_poly_arc_arcs_iterator(tls *libc.TLS, R uintptr) (r Txcb_arc_iterator_t) {
	var i Txcb_arc_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*12
	i.Frem = libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_arc_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(12))
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_fill_poly_sizeof(tls *libc.TLS, _buffer uintptr, points_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(16))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* points */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(points_len)*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 2))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_fill_poly_checked(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, shape Tuint8_t, coordinate_mode Tuint8_t, points_len Tuint32_t, points uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_fill_poly_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_fill_poly_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_fill_poly_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_fill_poly_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_fill_poly_request_t)(unsafe.Pointer(bp + 96))).Fshape = shape
	(*(*Txcb_fill_poly_request_t)(unsafe.Pointer(bp + 96))).Fcoordinate_mode = coordinate_mode
	libc.Xmemset(tls, bp+96+14, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_point_t points */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = points
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(points_len) * uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req146)))
	return xcb_ret
}

var _xcb_req146 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_FILL_POLY),
	Fisvoid: uint8(1),
}

func Xxcb_fill_poly(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, shape Tuint8_t, coordinate_mode Tuint8_t, points_len Tuint32_t, points uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_fill_poly_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_fill_poly_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_fill_poly_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_fill_poly_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_fill_poly_request_t)(unsafe.Pointer(bp + 96))).Fshape = shape
	(*(*Txcb_fill_poly_request_t)(unsafe.Pointer(bp + 96))).Fcoordinate_mode = coordinate_mode
	libc.Xmemset(tls, bp+96+14, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_point_t points */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = points
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(points_len) * uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req147)))
	return xcb_ret
}

var _xcb_req147 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_FILL_POLY),
	Fisvoid: uint8(1),
}

func Xxcb_fill_poly_points(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*16
}

func Xxcb_fill_poly_points_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_fill_poly_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(16)) / libc.Uint64FromInt64(4))
}

func Xxcb_fill_poly_points_iterator(tls *libc.TLS, R uintptr) (r Txcb_point_iterator_t) {
	var i Txcb_point_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*16
	i.Frem = libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_fill_poly_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(16)) / libc.Uint64FromInt64(4))
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_poly_fill_rectangle_sizeof(tls *libc.TLS, _buffer uintptr, rectangles_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* rectangles */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(rectangles_len)*libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 2))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_poly_fill_rectangle_checked(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, rectangles_len Tuint32_t, rectangles uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_fill_rectangle_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_fill_rectangle_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_poly_fill_rectangle_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_fill_rectangle_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_rectangle_t rectangles */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = rectangles
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(rectangles_len) * uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req148)))
	return xcb_ret
}

var _xcb_req148 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_FILL_RECTANGLE),
	Fisvoid: uint8(1),
}

func Xxcb_poly_fill_rectangle(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, rectangles_len Tuint32_t, rectangles uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_fill_rectangle_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_fill_rectangle_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_poly_fill_rectangle_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_fill_rectangle_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_rectangle_t rectangles */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = rectangles
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(rectangles_len) * uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req149)))
	return xcb_ret
}

var _xcb_req149 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_FILL_RECTANGLE),
	Fisvoid: uint8(1),
}

func Xxcb_poly_fill_rectangle_rectangles(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_poly_fill_rectangle_rectangles_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_fill_rectangle_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(8))
}

func Xxcb_poly_fill_rectangle_rectangles_iterator(tls *libc.TLS, R uintptr) (r Txcb_rectangle_iterator_t) {
	var i Txcb_rectangle_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*12
	i.Frem = libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_fill_rectangle_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(8))
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_poly_fill_arc_sizeof(tls *libc.TLS, _buffer uintptr, arcs_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* arcs */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(arcs_len)*libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 2))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_poly_fill_arc_checked(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, arcs_len Tuint32_t, arcs uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_fill_arc_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_fill_arc_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_poly_fill_arc_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_fill_arc_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_arc_t arcs */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = arcs
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(arcs_len) * uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req150)))
	return xcb_ret
}

var _xcb_req150 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_FILL_ARC),
	Fisvoid: uint8(1),
}

func Xxcb_poly_fill_arc(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, arcs_len Tuint32_t, arcs uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_fill_arc_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_fill_arc_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_poly_fill_arc_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_fill_arc_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_arc_t arcs */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = arcs
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(arcs_len) * uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req151)))
	return xcb_ret
}

var _xcb_req151 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_FILL_ARC),
	Fisvoid: uint8(1),
}

func Xxcb_poly_fill_arc_arcs(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_poly_fill_arc_arcs_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_fill_arc_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(12))
}

func Xxcb_poly_fill_arc_arcs_iterator(tls *libc.TLS, R uintptr) (r Txcb_arc_iterator_t) {
	var i Txcb_arc_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*12
	i.Frem = libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_fill_arc_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(12))
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_put_image_sizeof(tls *libc.TLS, _buffer uintptr, data_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(24))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* data */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(data_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_put_image_checked(tls *libc.TLS, c uintptr, format Tuint8_t, drawable Txcb_drawable_t, gc Txcb_gcontext_t, width Tuint16_t, height Tuint16_t, dst_x Tint16_t, dst_y Tint16_t, left_pad Tuint8_t, depth Tuint8_t, data_len Tuint32_t, data uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_put_image_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fformat = format
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fwidth = width
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fheight = height
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fdst_x = dst_x
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fdst_y = dst_y
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fleft_pad = left_pad
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fdepth = depth
	libc.Xmemset(tls, bp+96+22, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(24)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint8_t data */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = data
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(data_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req152)))
	return xcb_ret
}

var _xcb_req152 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_PUT_IMAGE),
	Fisvoid: uint8(1),
}

func Xxcb_put_image(tls *libc.TLS, c uintptr, format Tuint8_t, drawable Txcb_drawable_t, gc Txcb_gcontext_t, width Tuint16_t, height Tuint16_t, dst_x Tint16_t, dst_y Tint16_t, left_pad Tuint8_t, depth Tuint8_t, data_len Tuint32_t, data uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_put_image_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fformat = format
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fwidth = width
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fheight = height
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fdst_x = dst_x
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fdst_y = dst_y
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fleft_pad = left_pad
	(*(*Txcb_put_image_request_t)(unsafe.Pointer(bp + 96))).Fdepth = depth
	libc.Xmemset(tls, bp+96+22, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(24)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint8_t data */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = data
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(data_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req153)))
	return xcb_ret
}

var _xcb_req153 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_PUT_IMAGE),
	Fisvoid: uint8(1),
}

func Xxcb_put_image_data(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*24
}

func Xxcb_put_image_data_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_put_image_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(24)) / libc.Uint64FromInt64(1))
}

func Xxcb_put_image_data_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*24 + uintptr((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_put_image_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4))-libc.Uint64FromInt64(24))/libc.Uint64FromInt64(1))
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_get_image_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* data */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_get_image_reply_t)(unsafe.Pointer(_aux)).Flength*libc.Uint32FromInt32(4))*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_get_image(tls *libc.TLS, c uintptr, format Tuint8_t, drawable Txcb_drawable_t, x Tint16_t, y Tint16_t, width Tuint16_t, height Tuint16_t, plane_mask Tuint32_t) (r Txcb_get_image_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_get_image_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_image_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_image_request_t)(unsafe.Pointer(bp + 64))).Fformat = format
	(*(*Txcb_get_image_request_t)(unsafe.Pointer(bp + 64))).Fdrawable = drawable
	(*(*Txcb_get_image_request_t)(unsafe.Pointer(bp + 64))).Fx = x
	(*(*Txcb_get_image_request_t)(unsafe.Pointer(bp + 64))).Fy = y
	(*(*Txcb_get_image_request_t)(unsafe.Pointer(bp + 64))).Fwidth = width
	(*(*Txcb_get_image_request_t)(unsafe.Pointer(bp + 64))).Fheight = height
	(*(*Txcb_get_image_request_t)(unsafe.Pointer(bp + 64))).Fplane_mask = plane_mask
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(20)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req154)))
	return xcb_ret
}

var _xcb_req154 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_IMAGE),
}

func Xxcb_get_image_unchecked(tls *libc.TLS, c uintptr, format Tuint8_t, drawable Txcb_drawable_t, x Tint16_t, y Tint16_t, width Tuint16_t, height Tuint16_t, plane_mask Tuint32_t) (r Txcb_get_image_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_get_image_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_image_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_image_request_t)(unsafe.Pointer(bp + 64))).Fformat = format
	(*(*Txcb_get_image_request_t)(unsafe.Pointer(bp + 64))).Fdrawable = drawable
	(*(*Txcb_get_image_request_t)(unsafe.Pointer(bp + 64))).Fx = x
	(*(*Txcb_get_image_request_t)(unsafe.Pointer(bp + 64))).Fy = y
	(*(*Txcb_get_image_request_t)(unsafe.Pointer(bp + 64))).Fwidth = width
	(*(*Txcb_get_image_request_t)(unsafe.Pointer(bp + 64))).Fheight = height
	(*(*Txcb_get_image_request_t)(unsafe.Pointer(bp + 64))).Fplane_mask = plane_mask
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(20)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req155)))
	return xcb_ret
}

var _xcb_req155 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_IMAGE),
}

func Xxcb_get_image_data(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_get_image_data_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint32((*Txcb_get_image_reply_t)(unsafe.Pointer(R)).Flength * libc.Uint32FromInt32(4))
}

func Xxcb_get_image_data_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32 + uintptr((*Txcb_get_image_reply_t)(unsafe.Pointer(R)).Flength*libc.Uint32FromInt32(4))
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_get_image_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_image_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_poly_text_8_sizeof(tls *libc.TLS, _buffer uintptr, items_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(16))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* items */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(items_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_poly_text_8_checked(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, x Tint16_t, y Tint16_t, items_len Tuint32_t, items uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_text_8_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_text_8_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_poly_text_8_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_text_8_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_poly_text_8_request_t)(unsafe.Pointer(bp + 96))).Fx = x
	(*(*Txcb_poly_text_8_request_t)(unsafe.Pointer(bp + 96))).Fy = y
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint8_t items */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = items
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(items_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req156)))
	return xcb_ret
}

var _xcb_req156 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_TEXT_8),
	Fisvoid: uint8(1),
}

func Xxcb_poly_text_8(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, x Tint16_t, y Tint16_t, items_len Tuint32_t, items uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_text_8_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_text_8_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_poly_text_8_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_text_8_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_poly_text_8_request_t)(unsafe.Pointer(bp + 96))).Fx = x
	(*(*Txcb_poly_text_8_request_t)(unsafe.Pointer(bp + 96))).Fy = y
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint8_t items */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = items
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(items_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req157)))
	return xcb_ret
}

var _xcb_req157 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_TEXT_8),
	Fisvoid: uint8(1),
}

func Xxcb_poly_text_8_items(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*16
}

func Xxcb_poly_text_8_items_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_text_8_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(16)) / libc.Uint64FromInt64(1))
}

func Xxcb_poly_text_8_items_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*16 + uintptr((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_text_8_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4))-libc.Uint64FromInt64(16))/libc.Uint64FromInt64(1))
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_poly_text_16_sizeof(tls *libc.TLS, _buffer uintptr, items_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(16))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* items */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(items_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_poly_text_16_checked(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, x Tint16_t, y Tint16_t, items_len Tuint32_t, items uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_text_16_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_text_16_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_poly_text_16_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_text_16_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_poly_text_16_request_t)(unsafe.Pointer(bp + 96))).Fx = x
	(*(*Txcb_poly_text_16_request_t)(unsafe.Pointer(bp + 96))).Fy = y
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint8_t items */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = items
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(items_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req158)))
	return xcb_ret
}

var _xcb_req158 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_TEXT_16),
	Fisvoid: uint8(1),
}

func Xxcb_poly_text_16(tls *libc.TLS, c uintptr, drawable Txcb_drawable_t, gc Txcb_gcontext_t, x Tint16_t, y Tint16_t, items_len Tuint32_t, items uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_poly_text_16_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_poly_text_16_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_poly_text_16_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_poly_text_16_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_poly_text_16_request_t)(unsafe.Pointer(bp + 96))).Fx = x
	(*(*Txcb_poly_text_16_request_t)(unsafe.Pointer(bp + 96))).Fy = y
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint8_t items */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = items
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(items_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req159)))
	return xcb_ret
}

var _xcb_req159 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_POLY_TEXT_16),
	Fisvoid: uint8(1),
}

func Xxcb_poly_text_16_items(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*16
}

func Xxcb_poly_text_16_items_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_text_16_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(16)) / libc.Uint64FromInt64(1))
}

func Xxcb_poly_text_16_items_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*16 + uintptr((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_poly_text_16_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4))-libc.Uint64FromInt64(16))/libc.Uint64FromInt64(1))
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_image_text_8_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(16))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* string */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_image_text_8_request_t)(unsafe.Pointer(_aux)).Fstring_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_image_text_8_checked(tls *libc.TLS, c uintptr, string_len Tuint8_t, drawable Txcb_drawable_t, gc Txcb_gcontext_t, x Tint16_t, y Tint16_t, string1 uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_image_text_8_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_image_text_8_request_t)(unsafe.Pointer(bp + 96))).Fstring_len = string_len
	(*(*Txcb_image_text_8_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_image_text_8_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_image_text_8_request_t)(unsafe.Pointer(bp + 96))).Fx = x
	(*(*Txcb_image_text_8_request_t)(unsafe.Pointer(bp + 96))).Fy = y
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char string */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = string1
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(string_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req160)))
	return xcb_ret
}

var _xcb_req160 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_IMAGE_TEXT_8),
	Fisvoid: uint8(1),
}

func Xxcb_image_text_8(tls *libc.TLS, c uintptr, string_len Tuint8_t, drawable Txcb_drawable_t, gc Txcb_gcontext_t, x Tint16_t, y Tint16_t, string1 uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_image_text_8_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_image_text_8_request_t)(unsafe.Pointer(bp + 96))).Fstring_len = string_len
	(*(*Txcb_image_text_8_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_image_text_8_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_image_text_8_request_t)(unsafe.Pointer(bp + 96))).Fx = x
	(*(*Txcb_image_text_8_request_t)(unsafe.Pointer(bp + 96))).Fy = y
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char string */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = string1
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(string_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req161)))
	return xcb_ret
}

var _xcb_req161 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_IMAGE_TEXT_8),
	Fisvoid: uint8(1),
}

func Xxcb_image_text_8_string(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*16
}

func Xxcb_image_text_8_string_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint8((*Txcb_image_text_8_request_t)(unsafe.Pointer(R)).Fstring_len)
}

func Xxcb_image_text_8_string_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*16 + uintptr((*Txcb_image_text_8_request_t)(unsafe.Pointer(R)).Fstring_len)
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_image_text_16_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(16))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* string */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_image_text_16_request_t)(unsafe.Pointer(_aux)).Fstring_len)*libc.Uint64FromInt64(2))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_image_text_16_checked(tls *libc.TLS, c uintptr, string_len Tuint8_t, drawable Txcb_drawable_t, gc Txcb_gcontext_t, x Tint16_t, y Tint16_t, string1 uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_image_text_16_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_image_text_16_request_t)(unsafe.Pointer(bp + 96))).Fstring_len = string_len
	(*(*Txcb_image_text_16_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_image_text_16_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_image_text_16_request_t)(unsafe.Pointer(bp + 96))).Fx = x
	(*(*Txcb_image_text_16_request_t)(unsafe.Pointer(bp + 96))).Fy = y
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_char2b_t string */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = string1
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(string_len) * uint64(2)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req162)))
	return xcb_ret
}

var _xcb_req162 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_IMAGE_TEXT_16),
	Fisvoid: uint8(1),
}

func Xxcb_image_text_16(tls *libc.TLS, c uintptr, string_len Tuint8_t, drawable Txcb_drawable_t, gc Txcb_gcontext_t, x Tint16_t, y Tint16_t, string1 uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_image_text_16_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_image_text_16_request_t)(unsafe.Pointer(bp + 96))).Fstring_len = string_len
	(*(*Txcb_image_text_16_request_t)(unsafe.Pointer(bp + 96))).Fdrawable = drawable
	(*(*Txcb_image_text_16_request_t)(unsafe.Pointer(bp + 96))).Fgc = gc
	(*(*Txcb_image_text_16_request_t)(unsafe.Pointer(bp + 96))).Fx = x
	(*(*Txcb_image_text_16_request_t)(unsafe.Pointer(bp + 96))).Fy = y
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_char2b_t string */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = string1
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(string_len) * uint64(2)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req163)))
	return xcb_ret
}

var _xcb_req163 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_IMAGE_TEXT_16),
	Fisvoid: uint8(1),
}

func Xxcb_image_text_16_string(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*16
}

func Xxcb_image_text_16_string_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint8((*Txcb_image_text_16_request_t)(unsafe.Pointer(R)).Fstring_len)
}

func Xxcb_image_text_16_string_iterator(tls *libc.TLS, R uintptr) (r Txcb_char2b_iterator_t) {
	var i Txcb_char2b_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*16
	i.Frem = libc.Int32FromUint8((*Txcb_image_text_16_request_t)(unsafe.Pointer(R)).Fstring_len)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_create_colormap_checked(tls *libc.TLS, c uintptr, alloc Tuint8_t, mid Txcb_colormap_t, window Txcb_window_t, visual Txcb_visualid_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_create_colormap_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_create_colormap_request_t)(unsafe.Pointer(bp + 64))).Falloc = alloc
	(*(*Txcb_create_colormap_request_t)(unsafe.Pointer(bp + 64))).Fmid = mid
	(*(*Txcb_create_colormap_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*Txcb_create_colormap_request_t)(unsafe.Pointer(bp + 64))).Fvisual = visual
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req164)))
	return xcb_ret
}

var _xcb_req164 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CREATE_COLORMAP),
	Fisvoid: uint8(1),
}

func Xxcb_create_colormap(tls *libc.TLS, c uintptr, alloc Tuint8_t, mid Txcb_colormap_t, window Txcb_window_t, visual Txcb_visualid_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_create_colormap_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_create_colormap_request_t)(unsafe.Pointer(bp + 64))).Falloc = alloc
	(*(*Txcb_create_colormap_request_t)(unsafe.Pointer(bp + 64))).Fmid = mid
	(*(*Txcb_create_colormap_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*Txcb_create_colormap_request_t)(unsafe.Pointer(bp + 64))).Fvisual = visual
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req165)))
	return xcb_ret
}

var _xcb_req165 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CREATE_COLORMAP),
	Fisvoid: uint8(1),
}

func Xxcb_free_colormap_checked(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_free_colormap_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_free_colormap_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_free_colormap_request_t)(unsafe.Pointer(bp + 64))).Fcmap = cmap
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req166)))
	return xcb_ret
}

var _xcb_req166 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_FREE_COLORMAP),
	Fisvoid: uint8(1),
}

func Xxcb_free_colormap(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_free_colormap_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_free_colormap_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_free_colormap_request_t)(unsafe.Pointer(bp + 64))).Fcmap = cmap
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req167)))
	return xcb_ret
}

var _xcb_req167 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_FREE_COLORMAP),
	Fisvoid: uint8(1),
}

func Xxcb_copy_colormap_and_free_checked(tls *libc.TLS, c uintptr, mid Txcb_colormap_t, src_cmap Txcb_colormap_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_copy_colormap_and_free_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_copy_colormap_and_free_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_copy_colormap_and_free_request_t)(unsafe.Pointer(bp + 64))).Fmid = mid
	(*(*Txcb_copy_colormap_and_free_request_t)(unsafe.Pointer(bp + 64))).Fsrc_cmap = src_cmap
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req168)))
	return xcb_ret
}

var _xcb_req168 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_COPY_COLORMAP_AND_FREE),
	Fisvoid: uint8(1),
}

func Xxcb_copy_colormap_and_free(tls *libc.TLS, c uintptr, mid Txcb_colormap_t, src_cmap Txcb_colormap_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_copy_colormap_and_free_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_copy_colormap_and_free_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_copy_colormap_and_free_request_t)(unsafe.Pointer(bp + 64))).Fmid = mid
	(*(*Txcb_copy_colormap_and_free_request_t)(unsafe.Pointer(bp + 64))).Fsrc_cmap = src_cmap
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req169)))
	return xcb_ret
}

var _xcb_req169 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_COPY_COLORMAP_AND_FREE),
	Fisvoid: uint8(1),
}

func Xxcb_install_colormap_checked(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_install_colormap_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_install_colormap_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_install_colormap_request_t)(unsafe.Pointer(bp + 64))).Fcmap = cmap
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req170)))
	return xcb_ret
}

var _xcb_req170 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_INSTALL_COLORMAP),
	Fisvoid: uint8(1),
}

func Xxcb_install_colormap(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_install_colormap_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_install_colormap_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_install_colormap_request_t)(unsafe.Pointer(bp + 64))).Fcmap = cmap
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req171)))
	return xcb_ret
}

var _xcb_req171 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_INSTALL_COLORMAP),
	Fisvoid: uint8(1),
}

func Xxcb_uninstall_colormap_checked(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_uninstall_colormap_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_uninstall_colormap_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_uninstall_colormap_request_t)(unsafe.Pointer(bp + 64))).Fcmap = cmap
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req172)))
	return xcb_ret
}

var _xcb_req172 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNINSTALL_COLORMAP),
	Fisvoid: uint8(1),
}

func Xxcb_uninstall_colormap(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_uninstall_colormap_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_uninstall_colormap_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_uninstall_colormap_request_t)(unsafe.Pointer(bp + 64))).Fcmap = cmap
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req173)))
	return xcb_ret
}

var _xcb_req173 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_UNINSTALL_COLORMAP),
	Fisvoid: uint8(1),
}

func Xxcb_list_installed_colormaps_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* cmaps */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_list_installed_colormaps_reply_t)(unsafe.Pointer(_aux)).Fcmaps_len)*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_list_installed_colormaps(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_list_installed_colormaps_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_list_installed_colormaps_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_list_installed_colormaps_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_list_installed_colormaps_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_list_installed_colormaps_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req174)))
	return xcb_ret
}

var _xcb_req174 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_LIST_INSTALLED_COLORMAPS),
}

func Xxcb_list_installed_colormaps_unchecked(tls *libc.TLS, c uintptr, window Txcb_window_t) (r Txcb_list_installed_colormaps_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_list_installed_colormaps_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_list_installed_colormaps_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_list_installed_colormaps_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_list_installed_colormaps_request_t)(unsafe.Pointer(bp + 64))).Fwindow = window
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req175)))
	return xcb_ret
}

var _xcb_req175 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_LIST_INSTALLED_COLORMAPS),
}

func Xxcb_list_installed_colormaps_cmaps(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_list_installed_colormaps_cmaps_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_list_installed_colormaps_reply_t)(unsafe.Pointer(R)).Fcmaps_len)
}

func Xxcb_list_installed_colormaps_cmaps_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32 + uintptr((*Txcb_list_installed_colormaps_reply_t)(unsafe.Pointer(R)).Fcmaps_len)*4
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_list_installed_colormaps_reply(tls *libc.TLS, c uintptr, cookie Txcb_list_installed_colormaps_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_alloc_color(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t, red Tuint16_t, green Tuint16_t, blue Tuint16_t) (r Txcb_alloc_color_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_alloc_color_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_alloc_color_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_alloc_color_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_alloc_color_request_t)(unsafe.Pointer(bp + 64))).Fcmap = cmap
	(*(*Txcb_alloc_color_request_t)(unsafe.Pointer(bp + 64))).Fred = red
	(*(*Txcb_alloc_color_request_t)(unsafe.Pointer(bp + 64))).Fgreen = green
	(*(*Txcb_alloc_color_request_t)(unsafe.Pointer(bp + 64))).Fblue = blue
	libc.Xmemset(tls, bp+64+14, 0, uint64(2))
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req176)))
	return xcb_ret
}

var _xcb_req176 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_ALLOC_COLOR),
}

func Xxcb_alloc_color_unchecked(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t, red Tuint16_t, green Tuint16_t, blue Tuint16_t) (r Txcb_alloc_color_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_alloc_color_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_alloc_color_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_alloc_color_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_alloc_color_request_t)(unsafe.Pointer(bp + 64))).Fcmap = cmap
	(*(*Txcb_alloc_color_request_t)(unsafe.Pointer(bp + 64))).Fred = red
	(*(*Txcb_alloc_color_request_t)(unsafe.Pointer(bp + 64))).Fgreen = green
	(*(*Txcb_alloc_color_request_t)(unsafe.Pointer(bp + 64))).Fblue = blue
	libc.Xmemset(tls, bp+64+14, 0, uint64(2))
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req177)))
	return xcb_ret
}

var _xcb_req177 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_ALLOC_COLOR),
}

func Xxcb_alloc_color_reply(tls *libc.TLS, c uintptr, cookie Txcb_alloc_color_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_alloc_named_color_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* name */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_alloc_named_color_request_t)(unsafe.Pointer(_aux)).Fname_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_alloc_named_color(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t, name_len Tuint16_t, name uintptr) (r Txcb_alloc_named_color_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_alloc_named_color_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_alloc_named_color_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_alloc_named_color_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_alloc_named_color_request_t)(unsafe.Pointer(bp + 96))).Fcmap = cmap
	(*(*Txcb_alloc_named_color_request_t)(unsafe.Pointer(bp + 96))).Fname_len = name_len
	libc.Xmemset(tls, bp+96+10, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char name */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = name
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(name_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req178)))
	return xcb_ret
}

var _xcb_req178 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_ALLOC_NAMED_COLOR),
}

func Xxcb_alloc_named_color_unchecked(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t, name_len Tuint16_t, name uintptr) (r Txcb_alloc_named_color_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_alloc_named_color_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_alloc_named_color_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_alloc_named_color_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_alloc_named_color_request_t)(unsafe.Pointer(bp + 96))).Fcmap = cmap
	(*(*Txcb_alloc_named_color_request_t)(unsafe.Pointer(bp + 96))).Fname_len = name_len
	libc.Xmemset(tls, bp+96+10, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char name */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = name
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(name_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req179)))
	return xcb_ret
}

var _xcb_req179 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_ALLOC_NAMED_COLOR),
}

func Xxcb_alloc_named_color_reply(tls *libc.TLS, c uintptr, cookie Txcb_alloc_named_color_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_alloc_color_cells_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* pixels */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_alloc_color_cells_reply_t)(unsafe.Pointer(_aux)).Fpixels_len)*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	/* masks */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_alloc_color_cells_reply_t)(unsafe.Pointer(_aux)).Fmasks_len)*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_alloc_color_cells(tls *libc.TLS, c uintptr, contiguous Tuint8_t, cmap Txcb_colormap_t, colors Tuint16_t, planes Tuint16_t) (r Txcb_alloc_color_cells_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_alloc_color_cells_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_alloc_color_cells_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_alloc_color_cells_request_t)(unsafe.Pointer(bp + 64))).Fcontiguous = contiguous
	(*(*Txcb_alloc_color_cells_request_t)(unsafe.Pointer(bp + 64))).Fcmap = cmap
	(*(*Txcb_alloc_color_cells_request_t)(unsafe.Pointer(bp + 64))).Fcolors = colors
	(*(*Txcb_alloc_color_cells_request_t)(unsafe.Pointer(bp + 64))).Fplanes = planes
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req180)))
	return xcb_ret
}

var _xcb_req180 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_ALLOC_COLOR_CELLS),
}

func Xxcb_alloc_color_cells_unchecked(tls *libc.TLS, c uintptr, contiguous Tuint8_t, cmap Txcb_colormap_t, colors Tuint16_t, planes Tuint16_t) (r Txcb_alloc_color_cells_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_alloc_color_cells_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_alloc_color_cells_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_alloc_color_cells_request_t)(unsafe.Pointer(bp + 64))).Fcontiguous = contiguous
	(*(*Txcb_alloc_color_cells_request_t)(unsafe.Pointer(bp + 64))).Fcmap = cmap
	(*(*Txcb_alloc_color_cells_request_t)(unsafe.Pointer(bp + 64))).Fcolors = colors
	(*(*Txcb_alloc_color_cells_request_t)(unsafe.Pointer(bp + 64))).Fplanes = planes
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req181)))
	return xcb_ret
}

var _xcb_req181 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_ALLOC_COLOR_CELLS),
}

func Xxcb_alloc_color_cells_pixels(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_alloc_color_cells_pixels_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_alloc_color_cells_reply_t)(unsafe.Pointer(R)).Fpixels_len)
}

func Xxcb_alloc_color_cells_pixels_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32 + uintptr((*Txcb_alloc_color_cells_reply_t)(unsafe.Pointer(R)).Fpixels_len)*4
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_alloc_color_cells_masks(tls *libc.TLS, R uintptr) (r uintptr) {
	var prev Txcb_generic_iterator_t
	_ = prev
	prev = Xxcb_alloc_color_cells_pixels_end(tls, R)
	return prev.Fdata + uintptr(libc.Uint64FromInt32(-prev.Findex)&(libc.Uint64FromInt64(4)-libc.Uint64FromInt32(1))) + libc.UintptrFromInt32(0)
}

func Xxcb_alloc_color_cells_masks_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_alloc_color_cells_reply_t)(unsafe.Pointer(R)).Fmasks_len)
}

func Xxcb_alloc_color_cells_masks_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i, prev Txcb_generic_iterator_t
	_, _ = i, prev
	prev = Xxcb_alloc_color_cells_pixels_end(tls, R)
	i.Fdata = prev.Fdata + uintptr(libc.Uint64FromInt32(-prev.Findex)&(libc.Uint64FromInt64(4)-libc.Uint64FromInt32(1))) + uintptr((*Txcb_alloc_color_cells_reply_t)(unsafe.Pointer(R)).Fmasks_len)*4
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_alloc_color_cells_reply(tls *libc.TLS, c uintptr, cookie Txcb_alloc_color_cells_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_alloc_color_planes_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* pixels */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_alloc_color_planes_reply_t)(unsafe.Pointer(_aux)).Fpixels_len)*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_alloc_color_planes(tls *libc.TLS, c uintptr, contiguous Tuint8_t, cmap Txcb_colormap_t, colors Tuint16_t, reds Tuint16_t, greens Tuint16_t, blues Tuint16_t) (r Txcb_alloc_color_planes_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_alloc_color_planes_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_alloc_color_planes_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_alloc_color_planes_request_t)(unsafe.Pointer(bp + 64))).Fcontiguous = contiguous
	(*(*Txcb_alloc_color_planes_request_t)(unsafe.Pointer(bp + 64))).Fcmap = cmap
	(*(*Txcb_alloc_color_planes_request_t)(unsafe.Pointer(bp + 64))).Fcolors = colors
	(*(*Txcb_alloc_color_planes_request_t)(unsafe.Pointer(bp + 64))).Freds = reds
	(*(*Txcb_alloc_color_planes_request_t)(unsafe.Pointer(bp + 64))).Fgreens = greens
	(*(*Txcb_alloc_color_planes_request_t)(unsafe.Pointer(bp + 64))).Fblues = blues
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req182)))
	return xcb_ret
}

var _xcb_req182 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_ALLOC_COLOR_PLANES),
}

func Xxcb_alloc_color_planes_unchecked(tls *libc.TLS, c uintptr, contiguous Tuint8_t, cmap Txcb_colormap_t, colors Tuint16_t, reds Tuint16_t, greens Tuint16_t, blues Tuint16_t) (r Txcb_alloc_color_planes_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_alloc_color_planes_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_alloc_color_planes_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_alloc_color_planes_request_t)(unsafe.Pointer(bp + 64))).Fcontiguous = contiguous
	(*(*Txcb_alloc_color_planes_request_t)(unsafe.Pointer(bp + 64))).Fcmap = cmap
	(*(*Txcb_alloc_color_planes_request_t)(unsafe.Pointer(bp + 64))).Fcolors = colors
	(*(*Txcb_alloc_color_planes_request_t)(unsafe.Pointer(bp + 64))).Freds = reds
	(*(*Txcb_alloc_color_planes_request_t)(unsafe.Pointer(bp + 64))).Fgreens = greens
	(*(*Txcb_alloc_color_planes_request_t)(unsafe.Pointer(bp + 64))).Fblues = blues
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req183)))
	return xcb_ret
}

var _xcb_req183 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_ALLOC_COLOR_PLANES),
}

func Xxcb_alloc_color_planes_pixels(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_alloc_color_planes_pixels_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_alloc_color_planes_reply_t)(unsafe.Pointer(R)).Fpixels_len)
}

func Xxcb_alloc_color_planes_pixels_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32 + uintptr((*Txcb_alloc_color_planes_reply_t)(unsafe.Pointer(R)).Fpixels_len)*4
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_alloc_color_planes_reply(tls *libc.TLS, c uintptr, cookie Txcb_alloc_color_planes_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_free_colors_sizeof(tls *libc.TLS, _buffer uintptr, pixels_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* pixels */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(pixels_len)*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_free_colors_checked(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t, plane_mask Tuint32_t, pixels_len Tuint32_t, pixels uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_free_colors_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_free_colors_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_free_colors_request_t)(unsafe.Pointer(bp + 96))).Fcmap = cmap
	(*(*Txcb_free_colors_request_t)(unsafe.Pointer(bp + 96))).Fplane_mask = plane_mask
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint32_t pixels */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = pixels
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(pixels_len) * uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req184)))
	return xcb_ret
}

var _xcb_req184 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_FREE_COLORS),
	Fisvoid: uint8(1),
}

func Xxcb_free_colors(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t, plane_mask Tuint32_t, pixels_len Tuint32_t, pixels uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_free_colors_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_free_colors_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_free_colors_request_t)(unsafe.Pointer(bp + 96))).Fcmap = cmap
	(*(*Txcb_free_colors_request_t)(unsafe.Pointer(bp + 96))).Fplane_mask = plane_mask
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint32_t pixels */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = pixels
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(pixels_len) * uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req185)))
	return xcb_ret
}

var _xcb_req185 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_FREE_COLORS),
	Fisvoid: uint8(1),
}

func Xxcb_free_colors_pixels(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_free_colors_pixels_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_free_colors_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(12)) / libc.Uint64FromInt64(4))
}

func Xxcb_free_colors_pixels_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*12 + uintptr((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_free_colors_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4))-libc.Uint64FromInt64(12))/libc.Uint64FromInt64(4))*4
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_coloritem_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_coloritem_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_coloritem_iterator_t)(unsafe.Pointer(i)).Fdata += 12
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(12))
}

func Xxcb_coloritem_end(tls *libc.TLS, i Txcb_coloritem_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*12
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_store_colors_sizeof(tls *libc.TLS, _buffer uintptr, items_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* items */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(items_len)*libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_store_colors_checked(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t, items_len Tuint32_t, items uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_store_colors_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_store_colors_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_store_colors_request_t)(unsafe.Pointer(bp + 96))).Fcmap = cmap
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_coloritem_t items */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = items
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(items_len) * uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req186)))
	return xcb_ret
}

var _xcb_req186 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_STORE_COLORS),
	Fisvoid: uint8(1),
}

func Xxcb_store_colors(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t, items_len Tuint32_t, items uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_store_colors_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_store_colors_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_store_colors_request_t)(unsafe.Pointer(bp + 96))).Fcmap = cmap
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_coloritem_t items */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = items
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(items_len) * uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req187)))
	return xcb_ret
}

var _xcb_req187 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_STORE_COLORS),
	Fisvoid: uint8(1),
}

func Xxcb_store_colors_items(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*8
}

func Xxcb_store_colors_items_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_store_colors_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(8)) / libc.Uint64FromInt64(12))
}

func Xxcb_store_colors_items_iterator(tls *libc.TLS, R uintptr) (r Txcb_coloritem_iterator_t) {
	var i Txcb_coloritem_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*8
	i.Frem = libc.Int32FromUint64((libc.Uint64FromInt32(libc.Int32FromUint16((*Txcb_store_colors_request_t)(unsafe.Pointer(R)).Flength)*libc.Int32FromInt32(4)) - libc.Uint64FromInt64(8)) / libc.Uint64FromInt64(12))
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_store_named_color_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(16))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* name */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_store_named_color_request_t)(unsafe.Pointer(_aux)).Fname_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_store_named_color_checked(tls *libc.TLS, c uintptr, flags Tuint8_t, cmap Txcb_colormap_t, pixel Tuint32_t, name_len Tuint16_t, name uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_store_named_color_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_store_named_color_request_t)(unsafe.Pointer(bp + 96))).Fflags = flags
	(*(*Txcb_store_named_color_request_t)(unsafe.Pointer(bp + 96))).Fcmap = cmap
	(*(*Txcb_store_named_color_request_t)(unsafe.Pointer(bp + 96))).Fpixel = pixel
	(*(*Txcb_store_named_color_request_t)(unsafe.Pointer(bp + 96))).Fname_len = name_len
	libc.Xmemset(tls, bp+96+14, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char name */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = name
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(name_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req188)))
	return xcb_ret
}

var _xcb_req188 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_STORE_NAMED_COLOR),
	Fisvoid: uint8(1),
}

func Xxcb_store_named_color(tls *libc.TLS, c uintptr, flags Tuint8_t, cmap Txcb_colormap_t, pixel Tuint32_t, name_len Tuint16_t, name uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_store_named_color_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_store_named_color_request_t)(unsafe.Pointer(bp + 96))).Fflags = flags
	(*(*Txcb_store_named_color_request_t)(unsafe.Pointer(bp + 96))).Fcmap = cmap
	(*(*Txcb_store_named_color_request_t)(unsafe.Pointer(bp + 96))).Fpixel = pixel
	(*(*Txcb_store_named_color_request_t)(unsafe.Pointer(bp + 96))).Fname_len = name_len
	libc.Xmemset(tls, bp+96+14, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(16)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char name */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = name
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(name_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req189)))
	return xcb_ret
}

var _xcb_req189 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_STORE_NAMED_COLOR),
	Fisvoid: uint8(1),
}

func Xxcb_store_named_color_name(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*16
}

func Xxcb_store_named_color_name_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_store_named_color_request_t)(unsafe.Pointer(R)).Fname_len)
}

func Xxcb_store_named_color_name_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*16 + uintptr((*Txcb_store_named_color_request_t)(unsafe.Pointer(R)).Fname_len)
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_rgb_next(tls *libc.TLS, i uintptr) {
	var p1 uintptr
	_ = p1
	(*Txcb_rgb_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_rgb_iterator_t)(unsafe.Pointer(i)).Fdata += 8
	p1 = i + 12
	*(*int32)(unsafe.Pointer(p1)) = int32(uint64(*(*int32)(unsafe.Pointer(p1))) + libc.Uint64FromInt64(8))
}

func Xxcb_rgb_end(tls *libc.TLS, i Txcb_rgb_iterator_t) (r Txcb_generic_iterator_t) {
	var ret Txcb_generic_iterator_t
	_ = ret
	ret.Fdata = i.Fdata + uintptr(i.Frem)*8
	ret.Findex = int32(int64(i.Findex) + (int64(ret.Fdata) - int64(i.Fdata)))
	ret.Frem = 0
	return ret
}

func Xxcb_query_colors_sizeof(tls *libc.TLS, _buffer uintptr, pixels_len Tuint32_t) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	var xcb_tmp uintptr
	_, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* pixels */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64(pixels_len)*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_query_colors(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t, pixels_len Tuint32_t, pixels uintptr) (r Txcb_query_colors_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_query_colors_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_query_colors_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_colors_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_query_colors_request_t)(unsafe.Pointer(bp + 96))).Fcmap = cmap
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint32_t pixels */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = pixels
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(pixels_len) * uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req190)))
	return xcb_ret
}

var _xcb_req190 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_QUERY_COLORS),
}

func Xxcb_query_colors_unchecked(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t, pixels_len Tuint32_t, pixels uintptr) (r Txcb_query_colors_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_query_colors_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_query_colors_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_colors_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_query_colors_request_t)(unsafe.Pointer(bp + 96))).Fcmap = cmap
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint32_t pixels */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = pixels
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(pixels_len) * uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req191)))
	return xcb_ret
}

var _xcb_req191 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_QUERY_COLORS),
}

func Xxcb_query_colors_colors(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_query_colors_colors_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_query_colors_reply_t)(unsafe.Pointer(R)).Fcolors_len)
}

func Xxcb_query_colors_colors_iterator(tls *libc.TLS, R uintptr) (r Txcb_rgb_iterator_t) {
	var i Txcb_rgb_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32
	i.Frem = libc.Int32FromUint16((*Txcb_query_colors_reply_t)(unsafe.Pointer(R)).Fcolors_len)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_query_colors_reply(tls *libc.TLS, c uintptr, cookie Txcb_query_colors_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_lookup_color_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* name */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_lookup_color_request_t)(unsafe.Pointer(_aux)).Fname_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_lookup_color(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t, name_len Tuint16_t, name uintptr) (r Txcb_lookup_color_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_lookup_color_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_lookup_color_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_lookup_color_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_lookup_color_request_t)(unsafe.Pointer(bp + 96))).Fcmap = cmap
	(*(*Txcb_lookup_color_request_t)(unsafe.Pointer(bp + 96))).Fname_len = name_len
	libc.Xmemset(tls, bp+96+10, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char name */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = name
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(name_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req192)))
	return xcb_ret
}

var _xcb_req192 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_LOOKUP_COLOR),
}

func Xxcb_lookup_color_unchecked(tls *libc.TLS, c uintptr, cmap Txcb_colormap_t, name_len Tuint16_t, name uintptr) (r Txcb_lookup_color_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_lookup_color_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_lookup_color_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_lookup_color_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_lookup_color_request_t)(unsafe.Pointer(bp + 96))).Fcmap = cmap
	(*(*Txcb_lookup_color_request_t)(unsafe.Pointer(bp + 96))).Fname_len = name_len
	libc.Xmemset(tls, bp+96+10, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char name */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = name
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(name_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req193)))
	return xcb_ret
}

var _xcb_req193 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_LOOKUP_COLOR),
}

func Xxcb_lookup_color_reply(tls *libc.TLS, c uintptr, cookie Txcb_lookup_color_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_create_cursor_checked(tls *libc.TLS, c uintptr, cid Txcb_cursor_t, source Txcb_pixmap_t, mask Txcb_pixmap_t, fore_red Tuint16_t, fore_green Tuint16_t, fore_blue Tuint16_t, back_red Tuint16_t, back_green Tuint16_t, back_blue Tuint16_t, x Tuint16_t, y Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_create_cursor_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fcid = cid
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fsource = source
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fmask = mask
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_red = fore_red
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_green = fore_green
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_blue = fore_blue
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_red = back_red
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_green = back_green
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_blue = back_blue
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fx = x
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fy = y
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(32)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req194)))
	return xcb_ret
}

var _xcb_req194 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CREATE_CURSOR),
	Fisvoid: uint8(1),
}

func Xxcb_create_cursor(tls *libc.TLS, c uintptr, cid Txcb_cursor_t, source Txcb_pixmap_t, mask Txcb_pixmap_t, fore_red Tuint16_t, fore_green Tuint16_t, fore_blue Tuint16_t, back_red Tuint16_t, back_green Tuint16_t, back_blue Tuint16_t, x Tuint16_t, y Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_create_cursor_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fcid = cid
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fsource = source
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fmask = mask
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_red = fore_red
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_green = fore_green
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_blue = fore_blue
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_red = back_red
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_green = back_green
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_blue = back_blue
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fx = x
	(*(*Txcb_create_cursor_request_t)(unsafe.Pointer(bp + 64))).Fy = y
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(32)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req195)))
	return xcb_ret
}

var _xcb_req195 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CREATE_CURSOR),
	Fisvoid: uint8(1),
}

func Xxcb_create_glyph_cursor_checked(tls *libc.TLS, c uintptr, cid Txcb_cursor_t, source_font Txcb_font_t, mask_font Txcb_font_t, source_char Tuint16_t, mask_char Tuint16_t, fore_red Tuint16_t, fore_green Tuint16_t, fore_blue Tuint16_t, back_red Tuint16_t, back_green Tuint16_t, back_blue Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_create_glyph_cursor_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fcid = cid
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fsource_font = source_font
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fmask_font = mask_font
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fsource_char = source_char
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fmask_char = mask_char
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_red = fore_red
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_green = fore_green
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_blue = fore_blue
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_red = back_red
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_green = back_green
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_blue = back_blue
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(32)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req196)))
	return xcb_ret
}

var _xcb_req196 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CREATE_GLYPH_CURSOR),
	Fisvoid: uint8(1),
}

func Xxcb_create_glyph_cursor(tls *libc.TLS, c uintptr, cid Txcb_cursor_t, source_font Txcb_font_t, mask_font Txcb_font_t, source_char Tuint16_t, mask_char Tuint16_t, fore_red Tuint16_t, fore_green Tuint16_t, fore_blue Tuint16_t, back_red Tuint16_t, back_green Tuint16_t, back_blue Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_create_glyph_cursor_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fcid = cid
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fsource_font = source_font
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fmask_font = mask_font
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fsource_char = source_char
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fmask_char = mask_char
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_red = fore_red
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_green = fore_green
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_blue = fore_blue
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_red = back_red
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_green = back_green
	(*(*Txcb_create_glyph_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_blue = back_blue
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(32)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req197)))
	return xcb_ret
}

var _xcb_req197 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CREATE_GLYPH_CURSOR),
	Fisvoid: uint8(1),
}

func Xxcb_free_cursor_checked(tls *libc.TLS, c uintptr, cursor Txcb_cursor_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_free_cursor_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_free_cursor_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_free_cursor_request_t)(unsafe.Pointer(bp + 64))).Fcursor = cursor
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req198)))
	return xcb_ret
}

var _xcb_req198 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_FREE_CURSOR),
	Fisvoid: uint8(1),
}

func Xxcb_free_cursor(tls *libc.TLS, c uintptr, cursor Txcb_cursor_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_free_cursor_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_free_cursor_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_free_cursor_request_t)(unsafe.Pointer(bp + 64))).Fcursor = cursor
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req199)))
	return xcb_ret
}

var _xcb_req199 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_FREE_CURSOR),
	Fisvoid: uint8(1),
}

func Xxcb_recolor_cursor_checked(tls *libc.TLS, c uintptr, cursor Txcb_cursor_t, fore_red Tuint16_t, fore_green Tuint16_t, fore_blue Tuint16_t, back_red Tuint16_t, back_green Tuint16_t, back_blue Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_recolor_cursor_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Fcursor = cursor
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_red = fore_red
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_green = fore_green
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_blue = fore_blue
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_red = back_red
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_green = back_green
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_blue = back_blue
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(20)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req200)))
	return xcb_ret
}

var _xcb_req200 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_RECOLOR_CURSOR),
	Fisvoid: uint8(1),
}

func Xxcb_recolor_cursor(tls *libc.TLS, c uintptr, cursor Txcb_cursor_t, fore_red Tuint16_t, fore_green Tuint16_t, fore_blue Tuint16_t, back_red Tuint16_t, back_green Tuint16_t, back_blue Tuint16_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_recolor_cursor_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Fcursor = cursor
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_red = fore_red
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_green = fore_green
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Ffore_blue = fore_blue
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_red = back_red
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_green = back_green
	(*(*Txcb_recolor_cursor_request_t)(unsafe.Pointer(bp + 64))).Fback_blue = back_blue
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(20)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req201)))
	return xcb_ret
}

var _xcb_req201 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_RECOLOR_CURSOR),
	Fisvoid: uint8(1),
}

func Xxcb_query_best_size(tls *libc.TLS, c uintptr, _class Tuint8_t, drawable Txcb_drawable_t, width Tuint16_t, height Tuint16_t) (r Txcb_query_best_size_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_query_best_size_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_query_best_size_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_best_size_request_t)(unsafe.Pointer(bp + 64))).F_class = _class
	(*(*Txcb_query_best_size_request_t)(unsafe.Pointer(bp + 64))).Fdrawable = drawable
	(*(*Txcb_query_best_size_request_t)(unsafe.Pointer(bp + 64))).Fwidth = width
	(*(*Txcb_query_best_size_request_t)(unsafe.Pointer(bp + 64))).Fheight = height
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req202)))
	return xcb_ret
}

var _xcb_req202 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_QUERY_BEST_SIZE),
}

func Xxcb_query_best_size_unchecked(tls *libc.TLS, c uintptr, _class Tuint8_t, drawable Txcb_drawable_t, width Tuint16_t, height Tuint16_t) (r Txcb_query_best_size_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_query_best_size_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_query_best_size_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_best_size_request_t)(unsafe.Pointer(bp + 64))).F_class = _class
	(*(*Txcb_query_best_size_request_t)(unsafe.Pointer(bp + 64))).Fdrawable = drawable
	(*(*Txcb_query_best_size_request_t)(unsafe.Pointer(bp + 64))).Fwidth = width
	(*(*Txcb_query_best_size_request_t)(unsafe.Pointer(bp + 64))).Fheight = height
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req203)))
	return xcb_ret
}

var _xcb_req203 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_QUERY_BEST_SIZE),
}

func Xxcb_query_best_size_reply(tls *libc.TLS, c uintptr, cookie Txcb_query_best_size_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_query_extension_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* name */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_query_extension_request_t)(unsafe.Pointer(_aux)).Fname_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_query_extension(tls *libc.TLS, c uintptr, name_len Tuint16_t, name uintptr) (r Txcb_query_extension_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_query_extension_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_query_extension_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_extension_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_query_extension_request_t)(unsafe.Pointer(bp + 96))).Fname_len = name_len
	libc.Xmemset(tls, bp+96+6, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char name */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = name
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(name_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req204)))
	return xcb_ret
}

var _xcb_req204 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_QUERY_EXTENSION),
}

func Xxcb_query_extension_unchecked(tls *libc.TLS, c uintptr, name_len Tuint16_t, name uintptr) (r Txcb_query_extension_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_query_extension_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_query_extension_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_query_extension_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_query_extension_request_t)(unsafe.Pointer(bp + 96))).Fname_len = name_len
	libc.Xmemset(tls, bp+96+6, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* char name */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = name
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(name_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req205)))
	return xcb_ret
}

var _xcb_req205 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_QUERY_EXTENSION),
}

func Xxcb_query_extension_reply(tls *libc.TLS, c uintptr, cookie Txcb_query_extension_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_list_extensions_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp_len uint32
	_, _, _, _, _, _, _, _ = _aux, i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp, xcb_tmp_len
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* names */
	i = uint32(0)
	for {
		if !(i < uint32((*Txcb_list_extensions_reply_t)(unsafe.Pointer(_aux)).Fnames_len)) {
			break
		}
		xcb_tmp_len = libc.Uint32FromInt32(Xxcb_str_sizeof(tls, xcb_tmp))
		xcb_block_len += xcb_tmp_len
		xcb_tmp += uintptr(xcb_tmp_len)
		goto _1
	_1:
		;
		i++
	}
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_list_extensions(tls *libc.TLS, c uintptr) (r Txcb_list_extensions_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_list_extensions_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_list_extensions_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_list_extensions_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req206)))
	return xcb_ret
}

var _xcb_req206 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_LIST_EXTENSIONS),
}

func Xxcb_list_extensions_unchecked(tls *libc.TLS, c uintptr) (r Txcb_list_extensions_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_list_extensions_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_list_extensions_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_list_extensions_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req207)))
	return xcb_ret
}

var _xcb_req207 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_LIST_EXTENSIONS),
}

func Xxcb_list_extensions_names_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint8((*Txcb_list_extensions_reply_t)(unsafe.Pointer(R)).Fnames_len)
}

func Xxcb_list_extensions_names_iterator(tls *libc.TLS, R uintptr) (r Txcb_str_iterator_t) {
	var i Txcb_str_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32
	i.Frem = libc.Int32FromUint8((*Txcb_list_extensions_reply_t)(unsafe.Pointer(R)).Fnames_len)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_list_extensions_reply(tls *libc.TLS, c uintptr, cookie Txcb_list_extensions_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_change_keyboard_mapping_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* keysyms */
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt32(libc.Int32FromUint8((*Txcb_change_keyboard_mapping_request_t)(unsafe.Pointer(_aux)).Fkeycode_count)*libc.Int32FromUint8((*Txcb_change_keyboard_mapping_request_t)(unsafe.Pointer(_aux)).Fkeysyms_per_keycode))*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_change_keyboard_mapping_checked(tls *libc.TLS, c uintptr, keycode_count Tuint8_t, first_keycode Txcb_keycode_t, keysyms_per_keycode Tuint8_t, keysyms uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_change_keyboard_mapping_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_keyboard_mapping_request_t)(unsafe.Pointer(bp + 96))).Fkeycode_count = keycode_count
	(*(*Txcb_change_keyboard_mapping_request_t)(unsafe.Pointer(bp + 96))).Ffirst_keycode = first_keycode
	(*(*Txcb_change_keyboard_mapping_request_t)(unsafe.Pointer(bp + 96))).Fkeysyms_per_keycode = keysyms_per_keycode
	libc.Xmemset(tls, bp+96+6, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_keysym_t keysyms */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = keysyms
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(libc.Int32FromUint8(keycode_count)*libc.Int32FromUint8(keysyms_per_keycode)) * uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req208)))
	return xcb_ret
}

var _xcb_req208 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_CHANGE_KEYBOARD_MAPPING),
	Fisvoid: uint8(1),
}

func Xxcb_change_keyboard_mapping(tls *libc.TLS, c uintptr, keycode_count Tuint8_t, first_keycode Txcb_keycode_t, keysyms_per_keycode Tuint8_t, keysyms uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_change_keyboard_mapping_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_keyboard_mapping_request_t)(unsafe.Pointer(bp + 96))).Fkeycode_count = keycode_count
	(*(*Txcb_change_keyboard_mapping_request_t)(unsafe.Pointer(bp + 96))).Ffirst_keycode = first_keycode
	(*(*Txcb_change_keyboard_mapping_request_t)(unsafe.Pointer(bp + 96))).Fkeysyms_per_keycode = keysyms_per_keycode
	libc.Xmemset(tls, bp+96+6, 0, uint64(2))
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_keysym_t keysyms */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = keysyms
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(libc.Int32FromUint8(keycode_count)*libc.Int32FromUint8(keysyms_per_keycode)) * uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req209)))
	return xcb_ret
}

var _xcb_req209 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_CHANGE_KEYBOARD_MAPPING),
	Fisvoid: uint8(1),
}

func Xxcb_change_keyboard_mapping_keysyms(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*8
}

func Xxcb_change_keyboard_mapping_keysyms_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint8((*Txcb_change_keyboard_mapping_request_t)(unsafe.Pointer(R)).Fkeycode_count) * libc.Int32FromUint8((*Txcb_change_keyboard_mapping_request_t)(unsafe.Pointer(R)).Fkeysyms_per_keycode)
}

func Xxcb_change_keyboard_mapping_keysyms_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*8 + uintptr(libc.Int32FromUint8((*Txcb_change_keyboard_mapping_request_t)(unsafe.Pointer(R)).Fkeycode_count)*libc.Int32FromUint8((*Txcb_change_keyboard_mapping_request_t)(unsafe.Pointer(R)).Fkeysyms_per_keycode))*4
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_get_keyboard_mapping_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* keysyms */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_get_keyboard_mapping_reply_t)(unsafe.Pointer(_aux)).Flength)*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_get_keyboard_mapping(tls *libc.TLS, c uintptr, first_keycode Txcb_keycode_t, count Tuint8_t) (r Txcb_get_keyboard_mapping_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_keyboard_mapping_cookie_t
	var _ /* xcb_out at bp+66 */ Txcb_get_keyboard_mapping_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_keyboard_mapping_request_t)(unsafe.Pointer(bp + 66))).Fpad0 = uint8(0)
	(*(*Txcb_get_keyboard_mapping_request_t)(unsafe.Pointer(bp + 66))).Ffirst_keycode = first_keycode
	(*(*Txcb_get_keyboard_mapping_request_t)(unsafe.Pointer(bp + 66))).Fcount = count
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 66
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(6)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req210)))
	return xcb_ret
}

var _xcb_req210 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_KEYBOARD_MAPPING),
}

func Xxcb_get_keyboard_mapping_unchecked(tls *libc.TLS, c uintptr, first_keycode Txcb_keycode_t, count Tuint8_t) (r Txcb_get_keyboard_mapping_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_keyboard_mapping_cookie_t
	var _ /* xcb_out at bp+66 */ Txcb_get_keyboard_mapping_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_keyboard_mapping_request_t)(unsafe.Pointer(bp + 66))).Fpad0 = uint8(0)
	(*(*Txcb_get_keyboard_mapping_request_t)(unsafe.Pointer(bp + 66))).Ffirst_keycode = first_keycode
	(*(*Txcb_get_keyboard_mapping_request_t)(unsafe.Pointer(bp + 66))).Fcount = count
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 66
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(6)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req211)))
	return xcb_ret
}

var _xcb_req211 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_KEYBOARD_MAPPING),
}

func Xxcb_get_keyboard_mapping_keysyms(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_get_keyboard_mapping_keysyms_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint32((*Txcb_get_keyboard_mapping_reply_t)(unsafe.Pointer(R)).Flength)
}

func Xxcb_get_keyboard_mapping_keysyms_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32 + uintptr((*Txcb_get_keyboard_mapping_reply_t)(unsafe.Pointer(R)).Flength)*4
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_get_keyboard_mapping_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_keyboard_mapping_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_change_keyboard_control_value_list_serialize(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t, _aux uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset, xcb_parts_idx uint32
	var xcb_out, xcb_tmp uintptr
	var xcb_parts [9]Tiovec
	var _ /* xcb_pad0 at bp+0 */ [3]int8
	_, _, _, _, _, _, _, _, _, _ = i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_out, xcb_pad, xcb_padding_offset, xcb_parts, xcb_parts_idx, xcb_tmp
	xcb_out = *(*uintptr)(unsafe.Pointer(_buffer))
	xcb_buffer_len = uint32(0)
	xcb_align_to = uint32(0)
	xcb_padding_offset = uint32(0)
	xcb_pad = uint32(0)
	*(*[3]int8)(unsafe.Pointer(bp)) = [3]int8{}
	xcb_parts_idx = uint32(0)
	xcb_block_len = uint32(0)
	if value_mask&uint32(_XCB_KB_KEY_CLICK_PERCENT) != 0 {
		/* xcb_change_keyboard_control_value_list_t.key_click_percent */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_KB_BELL_PERCENT) != 0 {
		/* xcb_change_keyboard_control_value_list_t.bell_percent */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 4
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_KB_BELL_PITCH) != 0 {
		/* xcb_change_keyboard_control_value_list_t.bell_pitch */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 8
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_KB_BELL_DURATION) != 0 {
		/* xcb_change_keyboard_control_value_list_t.bell_duration */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 12
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_KB_LED) != 0 {
		/* xcb_change_keyboard_control_value_list_t.led */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 16
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_KB_LED_MODE) != 0 {
		/* xcb_change_keyboard_control_value_list_t.led_mode */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 20
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_KB_KEY) != 0 {
		/* xcb_change_keyboard_control_value_list_t.key */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 24
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_KB_AUTO_REPEAT_MODE) != 0 {
		/* xcb_change_keyboard_control_value_list_t.auto_repeat_mode */
		xcb_parts[xcb_parts_idx].Fiov_base = _aux + 28
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(4)
		xcb_parts_idx++
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	/* insert padding */
	xcb_pad = -(xcb_block_len + xcb_padding_offset) & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_parts[xcb_parts_idx].Fiov_base = bp
		xcb_parts[xcb_parts_idx].Fiov_len = uint64(xcb_pad)
		xcb_parts_idx++
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	xcb_padding_offset = uint32(0)
	if libc.UintptrFromInt32(0) == xcb_out {
		/* allocate memory */
		xcb_out = libc.Xmalloc(tls, uint64(xcb_buffer_len))
		*(*uintptr)(unsafe.Pointer(_buffer)) = xcb_out
	}
	xcb_tmp = xcb_out
	i = uint32(0)
	for {
		if !(i < xcb_parts_idx) {
			break
		}
		if uintptr(0) != xcb_parts[i].Fiov_base && uint64(0) != xcb_parts[i].Fiov_len {
			libc.Xmemcpy(tls, xcb_tmp, xcb_parts[i].Fiov_base, xcb_parts[i].Fiov_len)
		}
		if uint64(0) != xcb_parts[i].Fiov_len {
			xcb_tmp += uintptr(xcb_parts[i].Fiov_len)
		}
		goto _1
	_1:
		;
		i++
	}
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_change_keyboard_control_value_list_unpack(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t, _aux uintptr) (r int32) {
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset uint32
	var xcb_tmp uintptr
	_, _, _, _, _, _ = xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_padding_offset, xcb_tmp
	xcb_tmp = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_padding_offset = uint32(0)
	if value_mask&uint32(_XCB_KB_KEY_CLICK_PERCENT) != 0 {
		/* xcb_change_keyboard_control_value_list_t.key_click_percent */
		(*Txcb_change_keyboard_control_value_list_t)(unsafe.Pointer(_aux)).Fkey_click_percent = *(*Tint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_KB_BELL_PERCENT) != 0 {
		/* xcb_change_keyboard_control_value_list_t.bell_percent */
		(*Txcb_change_keyboard_control_value_list_t)(unsafe.Pointer(_aux)).Fbell_percent = *(*Tint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_KB_BELL_PITCH) != 0 {
		/* xcb_change_keyboard_control_value_list_t.bell_pitch */
		(*Txcb_change_keyboard_control_value_list_t)(unsafe.Pointer(_aux)).Fbell_pitch = *(*Tint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_KB_BELL_DURATION) != 0 {
		/* xcb_change_keyboard_control_value_list_t.bell_duration */
		(*Txcb_change_keyboard_control_value_list_t)(unsafe.Pointer(_aux)).Fbell_duration = *(*Tint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_KB_LED) != 0 {
		/* xcb_change_keyboard_control_value_list_t.led */
		(*Txcb_change_keyboard_control_value_list_t)(unsafe.Pointer(_aux)).Fled = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_KB_LED_MODE) != 0 {
		/* xcb_change_keyboard_control_value_list_t.led_mode */
		(*Txcb_change_keyboard_control_value_list_t)(unsafe.Pointer(_aux)).Fled_mode = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_KB_KEY) != 0 {
		/* xcb_change_keyboard_control_value_list_t.key */
		(*Txcb_change_keyboard_control_value_list_t)(unsafe.Pointer(_aux)).Fkey = *(*Txcb_keycode32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	if value_mask&uint32(_XCB_KB_AUTO_REPEAT_MODE) != 0 {
		/* xcb_change_keyboard_control_value_list_t.auto_repeat_mode */
		(*Txcb_change_keyboard_control_value_list_t)(unsafe.Pointer(_aux)).Fauto_repeat_mode = *(*Tuint32_t)(unsafe.Pointer(xcb_tmp))
		xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
		xcb_tmp += uintptr(4)
		xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	}
	/* insert padding */
	xcb_pad = -(xcb_block_len + xcb_padding_offset) & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	xcb_padding_offset = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_change_keyboard_control_value_list_sizeof(tls *libc.TLS, _buffer uintptr, value_mask Tuint32_t) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* _aux at bp+0 */ Txcb_change_keyboard_control_value_list_t
	return Xxcb_change_keyboard_control_value_list_unpack(tls, _buffer, value_mask, bp)
}

func Xxcb_change_keyboard_control_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* value_list */
	xcb_block_len += libc.Uint32FromInt32(Xxcb_change_keyboard_control_value_list_sizeof(tls, xcb_tmp, (*Txcb_change_keyboard_control_request_t)(unsafe.Pointer(_aux)).Fvalue_mask))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_change_keyboard_control_checked(tls *libc.TLS, c uintptr, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+80 */ Txcb_change_keyboard_control_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_keyboard_control_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_change_keyboard_control_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_change_keyboard_control_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = value_list
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_change_keyboard_control_value_list_sizeof(tls, value_list, value_mask))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req212)))
	return xcb_ret
}

var _xcb_req212 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CHANGE_KEYBOARD_CONTROL),
	Fisvoid: uint8(1),
}

func Xxcb_change_keyboard_control(tls *libc.TLS, c uintptr, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+80 */ Txcb_change_keyboard_control_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_keyboard_control_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_change_keyboard_control_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_change_keyboard_control_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = value_list
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_change_keyboard_control_value_list_sizeof(tls, value_list, value_mask))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req213)))
	return xcb_ret
}

var _xcb_req213 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CHANGE_KEYBOARD_CONTROL),
	Fisvoid: uint8(1),
}

func Xxcb_change_keyboard_control_aux_checked(tls *libc.TLS, c uintptr, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_aux0 at bp+88 */ uintptr
	var _ /* xcb_out at bp+80 */ Txcb_change_keyboard_control_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	*(*uintptr)(unsafe.Pointer(bp + 88)) = uintptr(0)
	(*(*Txcb_change_keyboard_control_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_change_keyboard_control_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_change_keyboard_control_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_change_keyboard_control_value_list_serialize(tls, bp+88, value_mask, value_list))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = *(*uintptr)(unsafe.Pointer(bp + 88))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req214)))
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 88)))
	return xcb_ret
}

var _xcb_req214 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CHANGE_KEYBOARD_CONTROL),
	Fisvoid: uint8(1),
}

func Xxcb_change_keyboard_control_aux(tls *libc.TLS, c uintptr, value_mask Tuint32_t, value_list uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_aux0 at bp+88 */ uintptr
	var _ /* xcb_out at bp+80 */ Txcb_change_keyboard_control_request_t
	var _ /* xcb_parts at bp+0 */ [5]Tiovec
	_ = xcb_ret
	*(*uintptr)(unsafe.Pointer(bp + 88)) = uintptr(0)
	(*(*Txcb_change_keyboard_control_request_t)(unsafe.Pointer(bp + 80))).Fpad0 = uint8(0)
	(*(*Txcb_change_keyboard_control_request_t)(unsafe.Pointer(bp + 80))).Fvalue_mask = value_mask
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 80
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_change_keyboard_control_value_list_t value_list */
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(Xxcb_change_keyboard_control_value_list_serialize(tls, bp+88, value_mask, value_list))
	(*(*[5]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = *(*uintptr)(unsafe.Pointer(bp + 88))
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req215)))
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 88)))
	return xcb_ret
}

var _xcb_req215 = Txcb_protocol_request_t{
	Fcount:  uint64(3),
	Fopcode: uint8(m_XCB_CHANGE_KEYBOARD_CONTROL),
	Fisvoid: uint8(1),
}

func Xxcb_change_keyboard_control_value_list(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*8
}

func Xxcb_get_keyboard_control(tls *libc.TLS, c uintptr) (r Txcb_get_keyboard_control_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_keyboard_control_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_keyboard_control_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_keyboard_control_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req216)))
	return xcb_ret
}

var _xcb_req216 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_KEYBOARD_CONTROL),
}

func Xxcb_get_keyboard_control_unchecked(tls *libc.TLS, c uintptr) (r Txcb_get_keyboard_control_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_keyboard_control_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_keyboard_control_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_keyboard_control_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req217)))
	return xcb_ret
}

var _xcb_req217 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_KEYBOARD_CONTROL),
}

func Xxcb_get_keyboard_control_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_keyboard_control_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_bell_checked(tls *libc.TLS, c uintptr, percent Tint8_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_bell_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_bell_request_t)(unsafe.Pointer(bp + 64))).Fpercent = percent
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req218)))
	return xcb_ret
}

var _xcb_req218 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_BELL),
	Fisvoid: uint8(1),
}

func Xxcb_bell(tls *libc.TLS, c uintptr, percent Tint8_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_bell_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_bell_request_t)(unsafe.Pointer(bp + 64))).Fpercent = percent
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req219)))
	return xcb_ret
}

var _xcb_req219 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_BELL),
	Fisvoid: uint8(1),
}

func Xxcb_change_pointer_control_checked(tls *libc.TLS, c uintptr, acceleration_numerator Tint16_t, acceleration_denominator Tint16_t, threshold Tint16_t, do_acceleration Tuint8_t, do_threshold Tuint8_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_change_pointer_control_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_pointer_control_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_change_pointer_control_request_t)(unsafe.Pointer(bp + 64))).Facceleration_numerator = acceleration_numerator
	(*(*Txcb_change_pointer_control_request_t)(unsafe.Pointer(bp + 64))).Facceleration_denominator = acceleration_denominator
	(*(*Txcb_change_pointer_control_request_t)(unsafe.Pointer(bp + 64))).Fthreshold = threshold
	(*(*Txcb_change_pointer_control_request_t)(unsafe.Pointer(bp + 64))).Fdo_acceleration = do_acceleration
	(*(*Txcb_change_pointer_control_request_t)(unsafe.Pointer(bp + 64))).Fdo_threshold = do_threshold
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req220)))
	return xcb_ret
}

var _xcb_req220 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CHANGE_POINTER_CONTROL),
	Fisvoid: uint8(1),
}

func Xxcb_change_pointer_control(tls *libc.TLS, c uintptr, acceleration_numerator Tint16_t, acceleration_denominator Tint16_t, threshold Tint16_t, do_acceleration Tuint8_t, do_threshold Tuint8_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_change_pointer_control_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_pointer_control_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_change_pointer_control_request_t)(unsafe.Pointer(bp + 64))).Facceleration_numerator = acceleration_numerator
	(*(*Txcb_change_pointer_control_request_t)(unsafe.Pointer(bp + 64))).Facceleration_denominator = acceleration_denominator
	(*(*Txcb_change_pointer_control_request_t)(unsafe.Pointer(bp + 64))).Fthreshold = threshold
	(*(*Txcb_change_pointer_control_request_t)(unsafe.Pointer(bp + 64))).Fdo_acceleration = do_acceleration
	(*(*Txcb_change_pointer_control_request_t)(unsafe.Pointer(bp + 64))).Fdo_threshold = do_threshold
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req221)))
	return xcb_ret
}

var _xcb_req221 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_CHANGE_POINTER_CONTROL),
	Fisvoid: uint8(1),
}

func Xxcb_get_pointer_control(tls *libc.TLS, c uintptr) (r Txcb_get_pointer_control_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_pointer_control_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_pointer_control_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_pointer_control_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req222)))
	return xcb_ret
}

var _xcb_req222 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_POINTER_CONTROL),
}

func Xxcb_get_pointer_control_unchecked(tls *libc.TLS, c uintptr) (r Txcb_get_pointer_control_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_pointer_control_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_pointer_control_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_pointer_control_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req223)))
	return xcb_ret
}

var _xcb_req223 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_POINTER_CONTROL),
}

func Xxcb_get_pointer_control_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_pointer_control_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_set_screen_saver_checked(tls *libc.TLS, c uintptr, timeout Tint16_t, interval Tint16_t, prefer_blanking Tuint8_t, allow_exposures Tuint8_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_set_screen_saver_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_screen_saver_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_set_screen_saver_request_t)(unsafe.Pointer(bp + 64))).Ftimeout = timeout
	(*(*Txcb_set_screen_saver_request_t)(unsafe.Pointer(bp + 64))).Finterval = interval
	(*(*Txcb_set_screen_saver_request_t)(unsafe.Pointer(bp + 64))).Fprefer_blanking = prefer_blanking
	(*(*Txcb_set_screen_saver_request_t)(unsafe.Pointer(bp + 64))).Fallow_exposures = allow_exposures
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(10)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req224)))
	return xcb_ret
}

var _xcb_req224 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_SET_SCREEN_SAVER),
	Fisvoid: uint8(1),
}

func Xxcb_set_screen_saver(tls *libc.TLS, c uintptr, timeout Tint16_t, interval Tint16_t, prefer_blanking Tuint8_t, allow_exposures Tuint8_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_set_screen_saver_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_screen_saver_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_set_screen_saver_request_t)(unsafe.Pointer(bp + 64))).Ftimeout = timeout
	(*(*Txcb_set_screen_saver_request_t)(unsafe.Pointer(bp + 64))).Finterval = interval
	(*(*Txcb_set_screen_saver_request_t)(unsafe.Pointer(bp + 64))).Fprefer_blanking = prefer_blanking
	(*(*Txcb_set_screen_saver_request_t)(unsafe.Pointer(bp + 64))).Fallow_exposures = allow_exposures
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(10)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req225)))
	return xcb_ret
}

var _xcb_req225 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_SET_SCREEN_SAVER),
	Fisvoid: uint8(1),
}

func Xxcb_get_screen_saver(tls *libc.TLS, c uintptr) (r Txcb_get_screen_saver_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_screen_saver_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_screen_saver_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_screen_saver_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req226)))
	return xcb_ret
}

var _xcb_req226 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_SCREEN_SAVER),
}

func Xxcb_get_screen_saver_unchecked(tls *libc.TLS, c uintptr) (r Txcb_get_screen_saver_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_screen_saver_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_screen_saver_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_screen_saver_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req227)))
	return xcb_ret
}

var _xcb_req227 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_SCREEN_SAVER),
}

func Xxcb_get_screen_saver_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_screen_saver_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_change_hosts_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(8))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* address */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_change_hosts_request_t)(unsafe.Pointer(_aux)).Faddress_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_change_hosts_checked(tls *libc.TLS, c uintptr, mode Tuint8_t, family Tuint8_t, address_len Tuint16_t, address uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_change_hosts_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_hosts_request_t)(unsafe.Pointer(bp + 96))).Fmode = mode
	(*(*Txcb_change_hosts_request_t)(unsafe.Pointer(bp + 96))).Ffamily = family
	(*(*Txcb_change_hosts_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_change_hosts_request_t)(unsafe.Pointer(bp + 96))).Faddress_len = address_len
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint8_t address */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = address
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(address_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req228)))
	return xcb_ret
}

var _xcb_req228 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_CHANGE_HOSTS),
	Fisvoid: uint8(1),
}

func Xxcb_change_hosts(tls *libc.TLS, c uintptr, mode Tuint8_t, family Tuint8_t, address_len Tuint16_t, address uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_change_hosts_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_change_hosts_request_t)(unsafe.Pointer(bp + 96))).Fmode = mode
	(*(*Txcb_change_hosts_request_t)(unsafe.Pointer(bp + 96))).Ffamily = family
	(*(*Txcb_change_hosts_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_change_hosts_request_t)(unsafe.Pointer(bp + 96))).Faddress_len = address_len
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint8_t address */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = address
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(address_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req229)))
	return xcb_ret
}

var _xcb_req229 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_CHANGE_HOSTS),
	Fisvoid: uint8(1),
}

func Xxcb_change_hosts_address(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*8
}

func Xxcb_change_hosts_address_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_change_hosts_request_t)(unsafe.Pointer(R)).Faddress_len)
}

func Xxcb_change_hosts_address_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*8 + uintptr((*Txcb_change_hosts_request_t)(unsafe.Pointer(R)).Faddress_len)
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_host_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* address */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_host_t)(unsafe.Pointer(_aux)).Faddress_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	xcb_align_to = uint32(4)
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_host_address(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*4
}

func Xxcb_host_address_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_host_t)(unsafe.Pointer(R)).Faddress_len)
}

func Xxcb_host_address_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*4 + uintptr((*Txcb_host_t)(unsafe.Pointer(R)).Faddress_len)
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_host_next(tls *libc.TLS, i uintptr) {
	var R uintptr
	var child Txcb_generic_iterator_t
	_, _ = R, child
	R = (*Txcb_host_iterator_t)(unsafe.Pointer(i)).Fdata
	child.Fdata = R + uintptr(Xxcb_host_sizeof(tls, R))
	(*Txcb_host_iterator_t)(unsafe.Pointer(i)).Findex = int32(int64(child.Fdata) - int64((*Txcb_host_iterator_t)(unsafe.Pointer(i)).Fdata))
	(*Txcb_host_iterator_t)(unsafe.Pointer(i)).Frem--
	(*Txcb_host_iterator_t)(unsafe.Pointer(i)).Fdata = child.Fdata
}

func Xxcb_host_end(tls *libc.TLS, _i Txcb_host_iterator_t) (r Txcb_generic_iterator_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Txcb_host_iterator_t)(unsafe.Pointer(bp)) = _i
	var ret Txcb_generic_iterator_t
	_ = ret
	for (*(*Txcb_host_iterator_t)(unsafe.Pointer(bp))).Frem > 0 {
		Xxcb_host_next(tls, bp)
	}
	ret.Fdata = (*(*Txcb_host_iterator_t)(unsafe.Pointer(bp))).Fdata
	ret.Frem = (*(*Txcb_host_iterator_t)(unsafe.Pointer(bp))).Frem
	ret.Findex = (*(*Txcb_host_iterator_t)(unsafe.Pointer(bp))).Findex
	return ret
}

func Xxcb_list_hosts_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp_len uint32
	_, _, _, _, _, _, _, _ = _aux, i, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp, xcb_tmp_len
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* hosts */
	i = uint32(0)
	for {
		if !(i < uint32((*Txcb_list_hosts_reply_t)(unsafe.Pointer(_aux)).Fhosts_len)) {
			break
		}
		xcb_tmp_len = libc.Uint32FromInt32(Xxcb_host_sizeof(tls, xcb_tmp))
		xcb_block_len += xcb_tmp_len
		xcb_tmp += uintptr(xcb_tmp_len)
		goto _1
	_1:
		;
		i++
	}
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 2))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_list_hosts(tls *libc.TLS, c uintptr) (r Txcb_list_hosts_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_list_hosts_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_list_hosts_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_list_hosts_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req230)))
	return xcb_ret
}

var _xcb_req230 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_LIST_HOSTS),
}

func Xxcb_list_hosts_unchecked(tls *libc.TLS, c uintptr) (r Txcb_list_hosts_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_list_hosts_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_list_hosts_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_list_hosts_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req231)))
	return xcb_ret
}

var _xcb_req231 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_LIST_HOSTS),
}

func Xxcb_list_hosts_hosts_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_list_hosts_reply_t)(unsafe.Pointer(R)).Fhosts_len)
}

func Xxcb_list_hosts_hosts_iterator(tls *libc.TLS, R uintptr) (r Txcb_host_iterator_t) {
	var i Txcb_host_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32
	i.Frem = libc.Int32FromUint16((*Txcb_list_hosts_reply_t)(unsafe.Pointer(R)).Fhosts_len)
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_list_hosts_reply(tls *libc.TLS, c uintptr, cookie Txcb_list_hosts_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_set_access_control_checked(tls *libc.TLS, c uintptr, mode Tuint8_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_set_access_control_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_access_control_request_t)(unsafe.Pointer(bp + 64))).Fmode = mode
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req232)))
	return xcb_ret
}

var _xcb_req232 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_SET_ACCESS_CONTROL),
	Fisvoid: uint8(1),
}

func Xxcb_set_access_control(tls *libc.TLS, c uintptr, mode Tuint8_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_set_access_control_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_access_control_request_t)(unsafe.Pointer(bp + 64))).Fmode = mode
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req233)))
	return xcb_ret
}

var _xcb_req233 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_SET_ACCESS_CONTROL),
	Fisvoid: uint8(1),
}

func Xxcb_set_close_down_mode_checked(tls *libc.TLS, c uintptr, mode Tuint8_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_set_close_down_mode_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_close_down_mode_request_t)(unsafe.Pointer(bp + 64))).Fmode = mode
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req234)))
	return xcb_ret
}

var _xcb_req234 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_SET_CLOSE_DOWN_MODE),
	Fisvoid: uint8(1),
}

func Xxcb_set_close_down_mode(tls *libc.TLS, c uintptr, mode Tuint8_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_set_close_down_mode_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_close_down_mode_request_t)(unsafe.Pointer(bp + 64))).Fmode = mode
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req235)))
	return xcb_ret
}

var _xcb_req235 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_SET_CLOSE_DOWN_MODE),
	Fisvoid: uint8(1),
}

func Xxcb_kill_client_checked(tls *libc.TLS, c uintptr, resource Tuint32_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_kill_client_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_kill_client_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_kill_client_request_t)(unsafe.Pointer(bp + 64))).Fresource = resource
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req236)))
	return xcb_ret
}

var _xcb_req236 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_KILL_CLIENT),
	Fisvoid: uint8(1),
}

func Xxcb_kill_client(tls *libc.TLS, c uintptr, resource Tuint32_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_kill_client_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_kill_client_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*Txcb_kill_client_request_t)(unsafe.Pointer(bp + 64))).Fresource = resource
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req237)))
	return xcb_ret
}

var _xcb_req237 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_KILL_CLIENT),
	Fisvoid: uint8(1),
}

func Xxcb_rotate_properties_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(12))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* atoms */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_rotate_properties_request_t)(unsafe.Pointer(_aux)).Fatoms_len)*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_rotate_properties_checked(tls *libc.TLS, c uintptr, window Txcb_window_t, atoms_len Tuint16_t, delta Tint16_t, atoms uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_rotate_properties_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_rotate_properties_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_rotate_properties_request_t)(unsafe.Pointer(bp + 96))).Fwindow = window
	(*(*Txcb_rotate_properties_request_t)(unsafe.Pointer(bp + 96))).Fatoms_len = atoms_len
	(*(*Txcb_rotate_properties_request_t)(unsafe.Pointer(bp + 96))).Fdelta = delta
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_atom_t atoms */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = atoms
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(atoms_len) * uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req238)))
	return xcb_ret
}

var _xcb_req238 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_ROTATE_PROPERTIES),
	Fisvoid: uint8(1),
}

func Xxcb_rotate_properties(tls *libc.TLS, c uintptr, window Txcb_window_t, atoms_len Tuint16_t, delta Tint16_t, atoms uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_rotate_properties_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_rotate_properties_request_t)(unsafe.Pointer(bp + 96))).Fpad0 = uint8(0)
	(*(*Txcb_rotate_properties_request_t)(unsafe.Pointer(bp + 96))).Fwindow = window
	(*(*Txcb_rotate_properties_request_t)(unsafe.Pointer(bp + 96))).Fatoms_len = atoms_len
	(*(*Txcb_rotate_properties_request_t)(unsafe.Pointer(bp + 96))).Fdelta = delta
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(12)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_atom_t atoms */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = atoms
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(atoms_len) * uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req239)))
	return xcb_ret
}

var _xcb_req239 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_ROTATE_PROPERTIES),
	Fisvoid: uint8(1),
}

func Xxcb_rotate_properties_atoms(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*12
}

func Xxcb_rotate_properties_atoms_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint16((*Txcb_rotate_properties_request_t)(unsafe.Pointer(R)).Fatoms_len)
}

func Xxcb_rotate_properties_atoms_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*12 + uintptr((*Txcb_rotate_properties_request_t)(unsafe.Pointer(R)).Fatoms_len)*4
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_force_screen_saver_checked(tls *libc.TLS, c uintptr, mode Tuint8_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_force_screen_saver_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_force_screen_saver_request_t)(unsafe.Pointer(bp + 64))).Fmode = mode
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req240)))
	return xcb_ret
}

var _xcb_req240 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_FORCE_SCREEN_SAVER),
	Fisvoid: uint8(1),
}

func Xxcb_force_screen_saver(tls *libc.TLS, c uintptr, mode Tuint8_t) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_force_screen_saver_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_force_screen_saver_request_t)(unsafe.Pointer(bp + 64))).Fmode = mode
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req241)))
	return xcb_ret
}

var _xcb_req241 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_FORCE_SCREEN_SAVER),
	Fisvoid: uint8(1),
}

func Xxcb_set_pointer_mapping_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* map */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_set_pointer_mapping_request_t)(unsafe.Pointer(_aux)).Fmap_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_set_pointer_mapping(tls *libc.TLS, c uintptr, map_len Tuint8_t, map1 uintptr) (r Txcb_set_pointer_mapping_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_set_pointer_mapping_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_set_pointer_mapping_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_pointer_mapping_request_t)(unsafe.Pointer(bp + 96))).Fmap_len = map_len
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint8_t map */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = map1
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(map_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req242)))
	return xcb_ret
}

var _xcb_req242 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_SET_POINTER_MAPPING),
}

func Xxcb_set_pointer_mapping_unchecked(tls *libc.TLS, c uintptr, map_len Tuint8_t, map1 uintptr) (r Txcb_set_pointer_mapping_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_set_pointer_mapping_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_set_pointer_mapping_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_pointer_mapping_request_t)(unsafe.Pointer(bp + 96))).Fmap_len = map_len
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* uint8_t map */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = map1
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = uint64(map_len) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req243)))
	return xcb_ret
}

var _xcb_req243 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_SET_POINTER_MAPPING),
}

func Xxcb_set_pointer_mapping_reply(tls *libc.TLS, c uintptr, cookie Txcb_set_pointer_mapping_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_get_pointer_mapping_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* map */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_get_pointer_mapping_reply_t)(unsafe.Pointer(_aux)).Fmap_len)*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_get_pointer_mapping(tls *libc.TLS, c uintptr) (r Txcb_get_pointer_mapping_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_pointer_mapping_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_pointer_mapping_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_pointer_mapping_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req244)))
	return xcb_ret
}

var _xcb_req244 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_POINTER_MAPPING),
}

func Xxcb_get_pointer_mapping_unchecked(tls *libc.TLS, c uintptr) (r Txcb_get_pointer_mapping_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_pointer_mapping_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_pointer_mapping_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_pointer_mapping_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req245)))
	return xcb_ret
}

var _xcb_req245 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_POINTER_MAPPING),
}

func Xxcb_get_pointer_mapping_map(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_get_pointer_mapping_map_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint8((*Txcb_get_pointer_mapping_reply_t)(unsafe.Pointer(R)).Fmap_len)
}

func Xxcb_get_pointer_mapping_map_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32 + uintptr((*Txcb_get_pointer_mapping_reply_t)(unsafe.Pointer(R)).Fmap_len)
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_get_pointer_mapping_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_pointer_mapping_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_set_modifier_mapping_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* keycodes */
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt32(libc.Int32FromUint8((*Txcb_set_modifier_mapping_request_t)(unsafe.Pointer(_aux)).Fkeycodes_per_modifier)*libc.Int32FromInt32(8))*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_set_modifier_mapping(tls *libc.TLS, c uintptr, keycodes_per_modifier Tuint8_t, keycodes uintptr) (r Txcb_set_modifier_mapping_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_set_modifier_mapping_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_set_modifier_mapping_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_modifier_mapping_request_t)(unsafe.Pointer(bp + 96))).Fkeycodes_per_modifier = keycodes_per_modifier
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_keycode_t keycodes */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = keycodes
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(libc.Int32FromUint8(keycodes_per_modifier)*libc.Int32FromInt32(8)) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req246)))
	return xcb_ret
}

var _xcb_req246 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_SET_MODIFIER_MAPPING),
}

func Xxcb_set_modifier_mapping_unchecked(tls *libc.TLS, c uintptr, keycodes_per_modifier Tuint8_t, keycodes uintptr) (r Txcb_set_modifier_mapping_cookie_t) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var xcb_ret Txcb_set_modifier_mapping_cookie_t
	var _ /* xcb_out at bp+96 */ Txcb_set_modifier_mapping_request_t
	var _ /* xcb_parts at bp+0 */ [6]Tiovec
	_ = xcb_ret
	(*(*Txcb_set_modifier_mapping_request_t)(unsafe.Pointer(bp + 96))).Fkeycodes_per_modifier = keycodes_per_modifier
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 96
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	/* xcb_keycode_t keycodes */
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_base = keycodes
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len = libc.Uint64FromInt32(libc.Int32FromUint8(keycodes_per_modifier)*libc.Int32FromInt32(8)) * uint64(1)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_base = uintptr(0)
	(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(5)].Fiov_len = -(*(*[6]Tiovec)(unsafe.Pointer(bp)))[int32(4)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req247)))
	return xcb_ret
}

var _xcb_req247 = Txcb_protocol_request_t{
	Fcount:  uint64(4),
	Fopcode: uint8(m_XCB_SET_MODIFIER_MAPPING),
}

func Xxcb_set_modifier_mapping_reply(tls *libc.TLS, c uintptr, cookie Txcb_set_modifier_mapping_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_get_modifier_mapping_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* keycodes */
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt32(libc.Int32FromUint8((*Txcb_get_modifier_mapping_reply_t)(unsafe.Pointer(_aux)).Fkeycodes_per_modifier)*libc.Int32FromInt32(8))*libc.Uint64FromInt64(1))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 1))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_get_modifier_mapping(tls *libc.TLS, c uintptr) (r Txcb_get_modifier_mapping_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_modifier_mapping_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_modifier_mapping_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_modifier_mapping_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req248)))
	return xcb_ret
}

var _xcb_req248 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_MODIFIER_MAPPING),
}

func Xxcb_get_modifier_mapping_unchecked(tls *libc.TLS, c uintptr) (r Txcb_get_modifier_mapping_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_get_modifier_mapping_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_get_modifier_mapping_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_get_modifier_mapping_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req249)))
	return xcb_ret
}

var _xcb_req249 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_GET_MODIFIER_MAPPING),
}

func Xxcb_get_modifier_mapping_keycodes(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_get_modifier_mapping_keycodes_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint8((*Txcb_get_modifier_mapping_reply_t)(unsafe.Pointer(R)).Fkeycodes_per_modifier) * int32(8)
}

func Xxcb_get_modifier_mapping_keycodes_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32 + uintptr(libc.Int32FromUint8((*Txcb_get_modifier_mapping_reply_t)(unsafe.Pointer(R)).Fkeycodes_per_modifier)*libc.Int32FromInt32(8))
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_get_modifier_mapping_reply(tls *libc.TLS, c uintptr, cookie Txcb_get_modifier_mapping_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_no_operation_checked(tls *libc.TLS, c uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_no_operation_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_no_operation_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req250)))
	return xcb_ret
}

var _xcb_req250 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_NO_OPERATION),
	Fisvoid: uint8(1),
}

func Xxcb_no_operation(tls *libc.TLS, c uintptr) (r Txcb_void_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_void_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_no_operation_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_no_operation_request_t)(unsafe.Pointer(bp + 64))).Fpad0 = uint8(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req251)))
	return xcb_ret
}

var _xcb_req251 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fopcode: uint8(m_XCB_NO_OPERATION),
	Fisvoid: uint8(1),
}

func Xxcb_big_requests_enable(tls *libc.TLS, c uintptr) (r Txcb_big_requests_enable_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_big_requests_enable_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_big_requests_enable_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req252)))
	return xcb_ret
}

var _xcb_req252 = Txcb_protocol_request_t{
	Fcount: uint64(2),
	Fext:   uintptr(unsafe.Pointer(&Xxcb_big_requests_id)),
}

func Xxcb_big_requests_enable_unchecked(tls *libc.TLS, c uintptr) (r Txcb_big_requests_enable_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_big_requests_enable_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_big_requests_enable_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req253)))
	return xcb_ret
}

var _xcb_req253 = Txcb_protocol_request_t{
	Fcount: uint64(2),
	Fext:   uintptr(unsafe.Pointer(&Xxcb_big_requests_id)),
}

func Xxcb_big_requests_enable_reply(tls *libc.TLS, c uintptr, cookie Txcb_big_requests_enable_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_xc_misc_get_version(tls *libc.TLS, c uintptr, client_major_version Tuint16_t, client_minor_version Tuint16_t) (r Txcb_xc_misc_get_version_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_xc_misc_get_version_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_xc_misc_get_version_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_xc_misc_get_version_request_t)(unsafe.Pointer(bp + 64))).Fclient_major_version = client_major_version
	(*(*Txcb_xc_misc_get_version_request_t)(unsafe.Pointer(bp + 64))).Fclient_minor_version = client_minor_version
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req254)))
	return xcb_ret
}

var _xcb_req254 = Txcb_protocol_request_t{
	Fcount: uint64(2),
	Fext:   uintptr(unsafe.Pointer(&Xxcb_xc_misc_id)),
}

func Xxcb_xc_misc_get_version_unchecked(tls *libc.TLS, c uintptr, client_major_version Tuint16_t, client_minor_version Tuint16_t) (r Txcb_xc_misc_get_version_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_xc_misc_get_version_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_xc_misc_get_version_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_xc_misc_get_version_request_t)(unsafe.Pointer(bp + 64))).Fclient_major_version = client_major_version
	(*(*Txcb_xc_misc_get_version_request_t)(unsafe.Pointer(bp + 64))).Fclient_minor_version = client_minor_version
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req255)))
	return xcb_ret
}

var _xcb_req255 = Txcb_protocol_request_t{
	Fcount: uint64(2),
	Fext:   uintptr(unsafe.Pointer(&Xxcb_xc_misc_id)),
}

func Xxcb_xc_misc_get_version_reply(tls *libc.TLS, c uintptr, cookie Txcb_xc_misc_get_version_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_xc_misc_get_xid_range(tls *libc.TLS, c uintptr) (r Txcb_xc_misc_get_xid_range_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_xc_misc_get_xid_range_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_xc_misc_get_xid_range_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req256)))
	return xcb_ret
}

var _xcb_req256 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fext:    uintptr(unsafe.Pointer(&Xxcb_xc_misc_id)),
	Fopcode: uint8(m_XCB_XC_MISC_GET_XID_RANGE),
}

func Xxcb_xc_misc_get_xid_range_unchecked(tls *libc.TLS, c uintptr) (r Txcb_xc_misc_get_xid_range_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_xc_misc_get_xid_range_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_xc_misc_get_xid_range_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(4)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req257)))
	return xcb_ret
}

var _xcb_req257 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fext:    uintptr(unsafe.Pointer(&Xxcb_xc_misc_id)),
	Fopcode: uint8(m_XCB_XC_MISC_GET_XID_RANGE),
}

func Xxcb_xc_misc_get_xid_range_reply(tls *libc.TLS, c uintptr, cookie Txcb_xc_misc_get_xid_range_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func Xxcb_xc_misc_get_xid_list_sizeof(tls *libc.TLS, _buffer uintptr) (r int32) {
	var _aux, xcb_tmp uintptr
	var xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad uint32
	_, _, _, _, _, _ = _aux, xcb_align_to, xcb_block_len, xcb_buffer_len, xcb_pad, xcb_tmp
	xcb_tmp = _buffer
	_aux = _buffer
	xcb_buffer_len = uint32(0)
	xcb_block_len = uint32(0)
	xcb_pad = uint32(0)
	xcb_align_to = uint32(0)
	xcb_block_len = uint32(uint64(xcb_block_len) + libc.Uint64FromInt64(32))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_buffer_len += xcb_block_len
	xcb_block_len = uint32(0)
	/* ids */
	xcb_block_len = uint32(uint64(xcb_block_len) + uint64((*Txcb_xc_misc_get_xid_list_reply_t)(unsafe.Pointer(_aux)).Fids_len)*libc.Uint64FromInt64(4))
	xcb_tmp += uintptr(xcb_block_len)
	xcb_align_to = uint32(uint64(libc.UintptrFromInt32(0) + 4))
	/* insert padding */
	xcb_pad = -xcb_block_len & (xcb_align_to - uint32(1))
	xcb_buffer_len += xcb_block_len + xcb_pad
	if uint32(0) != xcb_pad {
		xcb_tmp += uintptr(xcb_pad)
		xcb_pad = uint32(0)
	}
	xcb_block_len = uint32(0)
	return libc.Int32FromUint32(xcb_buffer_len)
}

func Xxcb_xc_misc_get_xid_list(tls *libc.TLS, c uintptr, count Tuint32_t) (r Txcb_xc_misc_get_xid_list_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_xc_misc_get_xid_list_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_xc_misc_get_xid_list_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_xc_misc_get_xid_list_request_t)(unsafe.Pointer(bp + 64))).Fcount = count
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, int32(_XCB_REQUEST_CHECKED), bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req258)))
	return xcb_ret
}

var _xcb_req258 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fext:    uintptr(unsafe.Pointer(&Xxcb_xc_misc_id)),
	Fopcode: uint8(m_XCB_XC_MISC_GET_XID_LIST),
}

func Xxcb_xc_misc_get_xid_list_unchecked(tls *libc.TLS, c uintptr, count Tuint32_t) (r Txcb_xc_misc_get_xid_list_cookie_t) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var xcb_ret Txcb_xc_misc_get_xid_list_cookie_t
	var _ /* xcb_out at bp+64 */ Txcb_xc_misc_get_xid_list_request_t
	var _ /* xcb_parts at bp+0 */ [4]Tiovec
	_ = xcb_ret
	(*(*Txcb_xc_misc_get_xid_list_request_t)(unsafe.Pointer(bp + 64))).Fcount = count
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_base = bp + 64
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len = uint64(8)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_base = uintptr(0)
	(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(3)].Fiov_len = -(*(*[4]Tiovec)(unsafe.Pointer(bp)))[int32(2)].Fiov_len & uint64(3)
	xcb_ret.Fsequence = Xxcb_send_request(tls, c, 0, bp+uintptr(2)*16, uintptr(unsafe.Pointer(&_xcb_req259)))
	return xcb_ret
}

var _xcb_req259 = Txcb_protocol_request_t{
	Fcount:  uint64(2),
	Fext:    uintptr(unsafe.Pointer(&Xxcb_xc_misc_id)),
	Fopcode: uint8(m_XCB_XC_MISC_GET_XID_LIST),
}

func Xxcb_xc_misc_get_xid_list_ids(tls *libc.TLS, R uintptr) (r uintptr) {
	return R + libc.UintptrFromInt32(1)*32
}

func Xxcb_xc_misc_get_xid_list_ids_length(tls *libc.TLS, R uintptr) (r int32) {
	return libc.Int32FromUint32((*Txcb_xc_misc_get_xid_list_reply_t)(unsafe.Pointer(R)).Fids_len)
}

func Xxcb_xc_misc_get_xid_list_ids_end(tls *libc.TLS, R uintptr) (r Txcb_generic_iterator_t) {
	var i Txcb_generic_iterator_t
	_ = i
	i.Fdata = R + libc.UintptrFromInt32(1)*32 + uintptr((*Txcb_xc_misc_get_xid_list_reply_t)(unsafe.Pointer(R)).Fids_len)*4
	i.Frem = 0
	i.Findex = int32(int64(i.Fdata) - int64(R))
	return i
}

func Xxcb_xc_misc_get_xid_list_reply(tls *libc.TLS, c uintptr, cookie Txcb_xc_misc_get_xid_list_cookie_t, e uintptr) (r uintptr) {
	return Xxcb_wait_for_reply(tls, c, cookie.Fsequence, e)
}

func __ccgo_fp(f interface{}) uintptr {
	type iface [2]uintptr
	return (*iface)(unsafe.Pointer(&f))[1]
}

/**
 * @}
 */

var Xxcb_big_requests_id = Txcb_extension_t{
	Fname: __ccgo_ts + 99,
}

/**
 * @}
 */

var Xxcb_xc_misc_id = Txcb_extension_t{
	Fname: __ccgo_ts + 112,
}

var __ccgo_ts = (*reflect.StringHeader)(unsafe.Pointer(&__ccgo_ts1)).Data

var __ccgo_ts1 = "GLX\x00unix\x00DISPLAY\x00unix:\x00%s%d\x00tcp\x00inet\x00inet6\x00localhost\x00%hu\x00XDM-AUTHORIZATION-1\x00MIT-MAGIC-COOKIE-1\x00%d\x00BIG-REQUESTS\x00XC-MISC\x00"
