//go:build freebsd && amd64

package libxft

import (
	"reflect"
	"unsafe"

	"modernc.org/libX11"
	"modernc.org/libXrender"
	"modernc.org/libc"
	"modernc.org/libfontconfig"
	"modernc.org/libfreetype"
)

var (
	_ reflect.Type
	_ unsafe.Pointer
)

const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_2_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_3_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_4_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_1_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_2_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_4_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_13 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_Above = 0
const m_AllTemporary = 0
const m_AllValues = 0x000F
const m_AllocAll = 1
const m_AllocNone = 0
const m_AllowExposures = 1
const m_AlreadyGrabbed = 1
const m_Always = 2
const m_AnyButton = 0
const m_AnyKey = 0
const m_AnyPropertyType = 0
const m_ArcChord = 0
const m_ArcPieSlice = 1
const m_AsyncBoth = 6
const m_AsyncKeyboard = 3
const m_AsyncPointer = 0
const m_AutoRepeatModeDefault = 2
const m_AutoRepeatModeOff = 0
const m_AutoRepeatModeOn = 1
const m_BADSIG = "SIG_ERR"
const m_BIG_ENDIAN = "__DARWIN_BIG_ENDIAN"
const m_BUFSIZ = 1024
const m_BUFSIZE = 2048
const m_BUS_ADRALN = 1
const m_BUS_ADRERR = 2
const m_BUS_NOOP = 0
const m_BUS_OBJERR = 3
const m_BYTE_ORDER = "__DARWIN_BYTE_ORDER"
const m_BadAccess = 10
const m_BadAlloc = 11
const m_BadAtom = 5
const m_BadColor = 12
const m_BadCursor = 6
const m_BadDrawable = 9
const m_BadFont = 7
const m_BadGC = 13
const m_BadGlyph = 4
const m_BadGlyphSet = 3
const m_BadIDChoice = 14
const m_BadImplementation = 17
const m_BadLength = 16
const m_BadMatch = 8
const m_BadName = 15
const m_BadPictFormat = 0
const m_BadPictOp = 2
const m_BadPicture = 1
const m_BadPixmap = 4
const m_BadRequest = 1
const m_BadValue = 2
const m_BadWindow = 3
const m_Below = 1
const m_BitmapFileInvalid = 2
const m_BitmapNoMemory = 3
const m_BitmapOpenFailed = 1
const m_BitmapSuccess = 0
const m_Bool = "int"
const m_BottomIf = 3
const m_Button1 = 1
const m_Button2 = 2
const m_Button3 = 3
const m_Button4 = 4
const m_Button5 = 5
const m_ButtonPress = 4
const m_ButtonRelease = 5
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 = 500
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 = 1000
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3 = 1667
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4 = 2333
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1 = 400
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2 = 275
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3 = 275
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4 = 0
const m_CLD_CONTINUED = 6
const m_CLD_DUMPED = 3
const m_CLD_EXITED = 1
const m_CLD_KILLED = 2
const m_CLD_NOOP = 0
const m_CLD_STOPPED = 5
const m_CLD_TRAPPED = 4
const m_CLOCK_MONOTONIC = "_CLOCK_MONOTONIC"
const m_CLOCK_MONOTONIC_RAW = "_CLOCK_MONOTONIC_RAW"
const m_CLOCK_MONOTONIC_RAW_APPROX = "_CLOCK_MONOTONIC_RAW_APPROX"
const m_CLOCK_PROCESS_CPUTIME_ID = "_CLOCK_PROCESS_CPUTIME_ID"
const m_CLOCK_REALTIME = "_CLOCK_REALTIME"
const m_CLOCK_THREAD_CPUTIME_ID = "_CLOCK_THREAD_CPUTIME_ID"
const m_CLOCK_UPTIME_RAW = "_CLOCK_UPTIME_RAW"
const m_CLOCK_UPTIME_RAW_APPROX = "_CLOCK_UPTIME_RAW_APPROX"
const m_CPLastBit = 12
const m_CPUMON_MAKE_FATAL = 0x1000
const m_CURSORFONT = "cursor"
const m_CapButt = 1
const m_CapNotLast = 0
const m_CapProjecting = 3
const m_CapRound = 2
const m_CenterGravity = 5
const m_CirculateNotify = 26
const m_CirculateRequest = 27
const m_ClientMessage = 33
const m_ClipByChildren = 0
const m_ColormapInstalled = 1
const m_ColormapNotify = 32
const m_ColormapUninstalled = 0
const m_Complex = 0
const m_ConfigureNotify = 22
const m_ConfigureRequest = 23
const m_ControlMapIndex = 2
const m_Convex = 2
const m_CoordModeOrigin = 0
const m_CoordModePrevious = 1
const m_CopyFromParent = 0
const m_CreateNotify = 16
const m_CurrentTime = 0
const m_CursorShape = 0
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_0_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_13_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_14_4_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_1_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_2_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_3_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_4_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_8_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_9_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DefaultBlanking = 2
const m_DefaultExposures = 2
const m_DestroyAll = 0
const m_DestroyNotify = 17
const m_DirectColor = 5
const m_DisableAccess = 0
const m_DisableScreenInterval = 0
const m_DisableScreenSaver = 0
const m_DontAllowExposures = 0
const m_DontCareState = 0
const m_DontPreferBlanking = 0
const m_E2BIG = 7
const m_EACCES = 13
const m_EADDRINUSE = 48
const m_EADDRNOTAVAIL = 49
const m_EAFNOSUPPORT = 47
const m_EAGAIN = 35
const m_EALREADY = 37
const m_EAUTH = 80
const m_EBADARCH = 86
const m_EBADEXEC = 85
const m_EBADF = 9
const m_EBADMACHO = 88
const m_EBADMSG = 94
const m_EBADRPC = 72
const m_EBUSY = 16
const m_ECANCELED = 89
const m_ECHILD = 10
const m_ECONNABORTED = 53
const m_ECONNREFUSED = 61
const m_ECONNRESET = 54
const m_EDEADLK = 11
const m_EDESTADDRREQ = 39
const m_EDEVERR = 83
const m_EDOM = 33
const m_EDQUOT = 69
const m_EEXIST = 17
const m_EFAULT = 14
const m_EFBIG = 27
const m_EFTYPE = 79
const m_EF_IS_PURGEABLE = 0x00000008
const m_EF_IS_SPARSE = 0x00000010
const m_EF_IS_SYNC_ROOT = 0x00000004
const m_EF_IS_SYNTHETIC = 0x00000020
const m_EF_MAY_SHARE_BLOCKS = 0x00000001
const m_EF_NO_XATTRS = 0x00000002
const m_EF_SHARES_ALL_BLOCKS = 0x00000040
const m_EHOSTDOWN = 64
const m_EHOSTUNREACH = 65
const m_EIDRM = 90
const m_EILSEQ = 92
const m_EINPROGRESS = 36
const m_EINTR = 4
const m_EINVAL = 22
const m_EIO = 5
const m_EISCONN = 56
const m_EISDIR = 21
const m_ELAST = 106
const m_ELOOP = 62
const m_EMFILE = 24
const m_EMLINK = 31
const m_EMSGSIZE = 40
const m_EMULTIHOP = 95
const m_ENAMETOOLONG = 63
const m_ENEEDAUTH = 81
const m_ENETDOWN = 50
const m_ENETRESET = 52
const m_ENETUNREACH = 51
const m_ENFILE = 23
const m_ENOATTR = 93
const m_ENOBUFS = 55
const m_ENODATA = 96
const m_ENODEV = 19
const m_ENOENT = 2
const m_ENOEXEC = 8
const m_ENOLCK = 77
const m_ENOLINK = 97
const m_ENOMEM = 12
const m_ENOMSG = 91
const m_ENOPOLICY = 103
const m_ENOPROTOOPT = 42
const m_ENOSPC = 28
const m_ENOSR = 98
const m_ENOSTR = 99
const m_ENOSYS = 78
const m_ENOTBLK = 15
const m_ENOTCONN = 57
const m_ENOTDIR = 20
const m_ENOTEMPTY = 66
const m_ENOTRECOVERABLE = 104
const m_ENOTSOCK = 38
const m_ENOTSUP = 45
const m_ENOTTY = 25
const m_ENXIO = 6
const m_EOPNOTSUPP = 102
const m_EOVERFLOW = 84
const m_EOWNERDEAD = 105
const m_EPERM = 1
const m_EPFNOSUPPORT = 46
const m_EPIPE = 32
const m_EPROCLIM = 67
const m_EPROCUNAVAIL = 76
const m_EPROGMISMATCH = 75
const m_EPROGUNAVAIL = 74
const m_EPROTO = 100
const m_EPROTONOSUPPORT = 43
const m_EPROTOTYPE = 41
const m_EPWROFF = 82
const m_EQFULL = 106
const m_ERANGE = 34
const m_EREMOTE = 71
const m_EROFS = 30
const m_ERPCMISMATCH = 73
const m_ESHLIBVERS = 87
const m_ESHUTDOWN = 58
const m_ESOCKTNOSUPPORT = 44
const m_ESPIPE = 29
const m_ESRCH = 3
const m_ESTALE = 70
const m_ETIME = 101
const m_ETIMEDOUT = 60
const m_ETOOMANYREFS = 59
const m_ETXTBSY = 26
const m_EUSERS = 68
const m_EWOULDBLOCK = "EAGAIN"
const m_EXDEV = 18
const m_EXIT_FAILURE = 1
const m_EXIT_SUCCESS = 0
const m_EastGravity = 6
const m_EnableAccess = 1
const m_EnterNotify = 7
const m_EvenOddRule = 0
const m_Expose = 12
const m_FARCSPERBATCH = 256
const m_FC_ANTIALIAS = "antialias"
const m_FC_ASPECT = "aspect"
const m_FC_AUTOHINT = "autohint"
const m_FC_CACHE_VERSION_NUMBER = 8
const m_FC_CAPABILITY = "capability"
const m_FC_CHARCELL = 110
const m_FC_CHARSET = "charset"
const m_FC_CHARWIDTH = "charwidth"
const m_FC_CHAR_HEIGHT = "charheight"
const m_FC_CHAR_WIDTH = "FC_CHARWIDTH"
const m_FC_COLOR = "color"
const m_FC_DECORATIVE = "decorative"
const m_FC_DPI = "dpi"
const m_FC_DUAL = 90
const m_FC_EMBEDDED_BITMAP = "embeddedbitmap"
const m_FC_EMBOLDEN = "embolden"
const m_FC_FAMILY = "family"
const m_FC_FAMILYLANG = "familylang"
const m_FC_FILE = "file"
const m_FC_FONTFORMAT = "fontformat"
const m_FC_FONTVERSION = "fontversion"
const m_FC_FONT_FEATURES = "fontfeatures"
const m_FC_FONT_HAS_HINT = "fonthashint"
const m_FC_FONT_VARIATIONS = "fontvariations"
const m_FC_FOUNDRY = "foundry"
const m_FC_FT_FACE = "ftface"
const m_FC_FULLNAME = "fullname"
const m_FC_FULLNAMELANG = "fullnamelang"
const m_FC_GLOBAL_ADVANCE = "globaladvance"
const m_FC_HASH = "hash"
const m_FC_HINTING = "hinting"
const m_FC_HINT_FULL = 3
const m_FC_HINT_MEDIUM = 2
const m_FC_HINT_NONE = 0
const m_FC_HINT_SLIGHT = 1
const m_FC_HINT_STYLE = "hintstyle"
const m_FC_INDEX = "index"
const m_FC_LANG = "lang"
const m_FC_LCD_DEFAULT = 1
const m_FC_LCD_FILTER = "lcdfilter"
const m_FC_LCD_LEGACY = 3
const m_FC_LCD_LIGHT = 2
const m_FC_LCD_NONE = 0
const m_FC_MAJOR = 2
const m_FC_MATRIX = "matrix"
const m_FC_MINOR = 14
const m_FC_MINSPACE = "minspace"
const m_FC_MONO = 100
const m_FC_NAMELANG = "namelang"
const m_FC_ORDER = "order"
const m_FC_OUTLINE = "outline"
const m_FC_PIXEL_SIZE = "pixelsize"
const m_FC_POSTSCRIPT_NAME = "postscriptname"
const m_FC_PRGNAME = "prgname"
const m_FC_PROPORTIONAL = 0
const m_FC_RASTERIZER = "rasterizer"
const m_FC_REVISION = 1
const m_FC_RGBA = "rgba"
const m_FC_RGBA_BGR = 2
const m_FC_RGBA_NONE = 5
const m_FC_RGBA_RGB = 1
const m_FC_RGBA_UNKNOWN = 0
const m_FC_RGBA_VBGR = 4
const m_FC_RGBA_VRGB = 3
const m_FC_SCALABLE = "scalable"
const m_FC_SCALE = "scale"
const m_FC_SIZE = "size"
const m_FC_SLANT = "slant"
const m_FC_SLANT_ITALIC = 100
const m_FC_SLANT_OBLIQUE = 110
const m_FC_SLANT_ROMAN = 0
const m_FC_SOURCE = "source"
const m_FC_SPACING = "spacing"
const m_FC_STYLE = "style"
const m_FC_STYLELANG = "stylelang"
const m_FC_SYMBOL = "symbol"
const m_FC_UTF8_MAX_LEN = 6
const m_FC_VARIABLE = "variable"
const m_FC_VERTICAL_LAYOUT = "verticallayout"
const m_FC_WEIGHT = "weight"
const m_FC_WEIGHT_BLACK = 210
const m_FC_WEIGHT_BOLD = 200
const m_FC_WEIGHT_BOOK = 75
const m_FC_WEIGHT_DEMIBOLD = 180
const m_FC_WEIGHT_DEMILIGHT = 55
const m_FC_WEIGHT_EXTRABLACK = 215
const m_FC_WEIGHT_EXTRABOLD = 205
const m_FC_WEIGHT_EXTRALIGHT = 40
const m_FC_WEIGHT_HEAVY = "FC_WEIGHT_BLACK"
const m_FC_WEIGHT_LIGHT = 50
const m_FC_WEIGHT_MEDIUM = 100
const m_FC_WEIGHT_NORMAL = "FC_WEIGHT_REGULAR"
const m_FC_WEIGHT_REGULAR = 80
const m_FC_WEIGHT_SEMIBOLD = "FC_WEIGHT_DEMIBOLD"
const m_FC_WEIGHT_SEMILIGHT = "FC_WEIGHT_DEMILIGHT"
const m_FC_WEIGHT_THIN = 0
const m_FC_WEIGHT_ULTRABLACK = "FC_WEIGHT_EXTRABLACK"
const m_FC_WEIGHT_ULTRABOLD = "FC_WEIGHT_EXTRABOLD"
const m_FC_WEIGHT_ULTRALIGHT = "FC_WEIGHT_EXTRALIGHT"
const m_FC_WIDTH = "width"
const m_FC_WIDTH_CONDENSED = 75
const m_FC_WIDTH_EXPANDED = 125
const m_FC_WIDTH_EXTRACONDENSED = 63
const m_FC_WIDTH_EXTRAEXPANDED = 150
const m_FC_WIDTH_NORMAL = 100
const m_FC_WIDTH_SEMICONDENSED = 87
const m_FC_WIDTH_SEMIEXPANDED = 113
const m_FC_WIDTH_ULTRACONDENSED = 50
const m_FC_WIDTH_ULTRAEXPANDED = 200
const m_FD_SETSIZE = "__DARWIN_FD_SETSIZE"
const m_FILENAME_MAX = 1024
const m_FOOTPRINT_INTERVAL_RESET = 0x1
const m_FOPEN_MAX = 20
const m_FPE_FLTDIV = 1
const m_FPE_FLTINV = 5
const m_FPE_FLTOVF = 2
const m_FPE_FLTRES = 4
const m_FPE_FLTSUB = 6
const m_FPE_FLTUND = 3
const m_FPE_INTDIV = 7
const m_FPE_INTOVF = 8
const m_FPE_NOOP = 0
const m_FP_CHOP = 3
const m_FP_PREC_24B = 0
const m_FP_PREC_53B = 2
const m_FP_PREC_64B = 3
const m_FP_RND_DOWN = 1
const m_FP_RND_NEAR = 0
const m_FP_RND_UP = 2
const m_FP_STATE_BYTES = 512
const m_FRCTSPERBATCH = 256
const m_FREETYPE_MAJOR = 2
const m_FREETYPE_MINOR = 10
const m_FREETYPE_PATCH = 4
const m_FT_AUTOHINTER_H = "FT_DRIVER_H"
const m_FT_CACHE_CHARMAP_H = "FT_CACHE_H"
const m_FT_CACHE_IMAGE_H = "FT_CACHE_H"
const m_FT_CACHE_INTERNAL_CACHE_H = "FT_CACHE_H"
const m_FT_CACHE_INTERNAL_GLYPH_H = "FT_CACHE_H"
const m_FT_CACHE_INTERNAL_IMAGE_H = "FT_CACHE_H"
const m_FT_CACHE_INTERNAL_MANAGER_H = "FT_CACHE_H"
const m_FT_CACHE_INTERNAL_MRU_H = "FT_CACHE_H"
const m_FT_CACHE_INTERNAL_SBITS_H = "FT_CACHE_H"
const m_FT_CACHE_MANAGER_H = "FT_CACHE_H"
const m_FT_CACHE_SMALL_BITMAPS_H = "FT_CACHE_H"
const m_FT_CFF_DRIVER_H = "FT_DRIVER_H"
const m_FT_CHAR_BIT = "CHAR_BIT"
const m_FT_CURVE_TAG_CONIC = 0x00
const m_FT_CURVE_TAG_CUBIC = 0x02
const m_FT_CURVE_TAG_HAS_SCANMODE = 0x04
const m_FT_CURVE_TAG_ON = 0x01
const m_FT_CURVE_TAG_TOUCH_X = 0x08
const m_FT_CURVE_TAG_TOUCH_Y = 0x10
const m_FT_Curve_Tag_Conic = "FT_CURVE_TAG_CONIC"
const m_FT_Curve_Tag_Cubic = "FT_CURVE_TAG_CUBIC"
const m_FT_Curve_Tag_On = "FT_CURVE_TAG_ON"
const m_FT_Curve_Tag_Touch_X = "FT_CURVE_TAG_TOUCH_X"
const m_FT_Curve_Tag_Touch_Y = "FT_CURVE_TAG_TOUCH_Y"
const m_FT_FILE = "FILE"
const m_FT_FSTYPE_BITMAP_EMBEDDING_ONLY = 0x0200
const m_FT_FSTYPE_EDITABLE_EMBEDDING = 0x0008
const m_FT_FSTYPE_INSTALLABLE_EMBEDDING = 0x0000
const m_FT_FSTYPE_NO_SUBSETTING = 0x0100
const m_FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING = 0x0004
const m_FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING = 0x0002
const m_FT_INT64 = "long"
const m_FT_INT_MAX = "INT_MAX"
const m_FT_INT_MIN = "INT_MIN"
const m_FT_LOAD_DEFAULT = 0x0
const m_FT_LONG_MAX = "LONG_MAX"
const m_FT_LONG_MIN = "LONG_MIN"
const m_FT_MAX_MODULES = 32
const m_FT_OPEN_DRIVER = 0x8
const m_FT_OPEN_MEMORY = 0x1
const m_FT_OPEN_PARAMS = 0x10
const m_FT_OPEN_PATHNAME = 0x4
const m_FT_OPEN_STREAM = 0x2
const m_FT_OUTLINE_CONTOURS_MAX = "SHRT_MAX"
const m_FT_OUTLINE_EVEN_ODD_FILL = 0x2
const m_FT_OUTLINE_HIGH_PRECISION = 0x100
const m_FT_OUTLINE_IGNORE_DROPOUTS = 0x8
const m_FT_OUTLINE_INCLUDE_STUBS = 0x20
const m_FT_OUTLINE_NONE = 0x0
const m_FT_OUTLINE_OVERLAP = 0x40
const m_FT_OUTLINE_OWNER = 0x1
const m_FT_OUTLINE_POINTS_MAX = "SHRT_MAX"
const m_FT_OUTLINE_REVERSE_FILL = 0x4
const m_FT_OUTLINE_SINGLE_PASS = 0x200
const m_FT_OUTLINE_SMART_DROPOUTS = 0x10
const m_FT_Outline_ConicTo_Func = "FT_Outline_ConicToFunc"
const m_FT_Outline_CubicTo_Func = "FT_Outline_CubicToFunc"
const m_FT_Outline_LineTo_Func = "FT_Outline_LineToFunc"
const m_FT_Outline_MoveTo_Func = "FT_Outline_MoveToFunc"
const m_FT_PCF_DRIVER_H = "FT_DRIVER_H"
const m_FT_RASTER_FLAG_AA = 0x1
const m_FT_RASTER_FLAG_CLIP = 0x4
const m_FT_RASTER_FLAG_DEFAULT = 0x0
const m_FT_RASTER_FLAG_DIRECT = 0x2
const m_FT_RENDER_POOL_SIZE = 16384
const m_FT_Raster_Done_Func = "FT_Raster_DoneFunc"
const m_FT_Raster_New_Func = "FT_Raster_NewFunc"
const m_FT_Raster_Render_Func = "FT_Raster_RenderFunc"
const m_FT_Raster_Reset_Func = "FT_Raster_ResetFunc"
const m_FT_Raster_Set_Mode_Func = "FT_Raster_SetModeFunc"
const m_FT_Raster_Span_Func = "FT_SpanFunc"
const m_FT_SUBGLYPH_FLAG_2X2 = 0x80
const m_FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS = 1
const m_FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES = 2
const m_FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID = 4
const m_FT_SUBGLYPH_FLAG_SCALE = 8
const m_FT_SUBGLYPH_FLAG_USE_MY_METRICS = 0x200
const m_FT_SUBGLYPH_FLAG_XY_SCALE = 0x40
const m_FT_TRUETYPE_DRIVER_H = "FT_DRIVER_H"
const m_FT_UINT_MAX = "UINT_MAX"
const m_FT_ULONG_MAX = "ULONG_MAX"
const m_FT_USHORT_MAX = "USHRT_MAX"
const m_FT_XFREE86_H = "FT_FONT_FORMATS_H"
const m_FUNCPROTO = 15
const m_False = 0
const m_FamilyChaos = 2
const m_FamilyDECnet = 1
const m_FamilyInternet = 0
const m_FamilyInternet6 = 6
const m_FamilyServerInterpreted = 5
const m_FcConfigGetRescanInverval = "FcConfigGetRescanInverval_REPLACE_BY_FcConfigGetRescanInterval"
const m_FcConfigSetRescanInverval = "FcConfigSetRescanInverval_REPLACE_BY_FcConfigSetRescanInterval"
const m_FcDontCare = 2
const m_FcFalse = 0
const m_FcTrue = 1
const m_FillOpaqueStippled = 3
const m_FillSolid = 0
const m_FillStippled = 2
const m_FillTiled = 1
const m_FilterBest = "best"
const m_FilterBilinear = "bilinear"
const m_FilterConvolution = "convolution"
const m_FilterFast = "fast"
const m_FilterGood = "good"
const m_FilterNearest = "nearest"
const m_FirstExtensionError = 128
const m_FocusIn = 9
const m_FocusOut = 10
const m_FontChange = 255
const m_FontLeftToRight = 0
const m_FontRightToLeft = 1
const m_ForgetGravity = 0
const m_GCLastBit = 22
const m_GXand = 0x1
const m_GXandInverted = 0x4
const m_GXandReverse = 0x2
const m_GXclear = 0x0
const m_GXcopy = 0x3
const m_GXcopyInverted = 0xc
const m_GXequiv = 0x9
const m_GXinvert = 0xa
const m_GXnand = 0xe
const m_GXnoop = 0x5
const m_GXnor = 0x8
const m_GXor = 0x7
const m_GXorInverted = 0xd
const m_GXorReverse = 0xb
const m_GXset = 0xf
const m_GXxor = 0x6
const m_GenericEvent = 35
const m_GrabFrozen = 4
const m_GrabInvalidTime = 2
const m_GrabModeAsync = 1
const m_GrabModeSync = 0
const m_GrabNotViewable = 3
const m_GrabSuccess = 0
const m_GraphicsExpose = 13
const m_GravityNotify = 24
const m_GrayScale = 1
const m_HAVE_CONFIG_H = 1
const m_HAVE_DLFCN_H = 1
const m_HAVE_INTTYPES_H = 1
const m_HAVE_STDINT_H = 1
const m_HAVE_STDIO_H = 1
const m_HAVE_STDLIB_H = 1
const m_HAVE_STRINGS_H = 1
const m_HAVE_STRING_H = 1
const m_HAVE_SYS_STAT_H = 1
const m_HAVE_SYS_TYPES_H = 1
const m_HAVE_UNISTD_H = 1
const m_HeightValue = 0x0008
const m_HostDelete = 1
const m_HostInsert = 0
const m_ILL_BADSTK = 8
const m_ILL_COPROC = 7
const m_ILL_ILLADR = 5
const m_ILL_ILLOPC = 1
const m_ILL_ILLOPN = 4
const m_ILL_ILLTRP = 2
const m_ILL_NOOP = 0
const m_ILL_PRVOPC = 3
const m_ILL_PRVREG = 6
const m_INTMAX_MAX = "__INTMAX_MAX__"
const m_INTPTR_MAX = "__INTPTR_MAX__"
const m_INT_FAST16_MAX = "__INT_LEAST16_MAX"
const m_INT_FAST16_MIN = "__INT_LEAST16_MIN"
const m_INT_FAST32_MAX = "__INT_LEAST32_MAX"
const m_INT_FAST32_MIN = "__INT_LEAST32_MIN"
const m_INT_FAST64_MAX = "__INT_LEAST64_MAX"
const m_INT_FAST64_MIN = "__INT_LEAST64_MIN"
const m_INT_FAST8_MAX = "__INT_LEAST8_MAX"
const m_INT_FAST8_MIN = "__INT_LEAST8_MIN"
const m_INT_LEAST16_MAX = "__INT_LEAST16_MAX"
const m_INT_LEAST16_MIN = "__INT_LEAST16_MIN"
const m_INT_LEAST32_MAX = "__INT_LEAST32_MAX"
const m_INT_LEAST32_MIN = "__INT_LEAST32_MIN"
const m_INT_LEAST64_MAX = "__INT_LEAST64_MAX"
const m_INT_LEAST64_MIN = "__INT_LEAST64_MIN"
const m_INT_LEAST8_MAX = "__INT_LEAST8_MAX"
const m_INT_LEAST8_MIN = "__INT_LEAST8_MIN"
const m_IOPOL_APPLICATION = "IOPOL_STANDARD"
const m_IOPOL_ATIME_UPDATES_DEFAULT = 0
const m_IOPOL_ATIME_UPDATES_OFF = 1
const m_IOPOL_DEFAULT = 0
const m_IOPOL_IMPORTANT = 1
const m_IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = 0
const m_IOPOL_MATERIALIZE_DATALESS_FILES_OFF = 1
const m_IOPOL_MATERIALIZE_DATALESS_FILES_ON = 2
const m_IOPOL_NORMAL = "IOPOL_IMPORTANT"
const m_IOPOL_PASSIVE = 2
const m_IOPOL_SCOPE_DARWIN_BG = 2
const m_IOPOL_SCOPE_PROCESS = 0
const m_IOPOL_SCOPE_THREAD = 1
const m_IOPOL_STANDARD = 5
const m_IOPOL_THROTTLE = 3
const m_IOPOL_TYPE_DISK = 0
const m_IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = 9
const m_IOPOL_TYPE_VFS_ATIME_UPDATES = 2
const m_IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = 10
const m_IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = 6
const m_IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = 7
const m_IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3
const m_IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = 8
const m_IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = 4
const m_IOPOL_TYPE_VFS_TRIGGER_RESOLVE = 5
const m_IOPOL_UTILITY = 4
const m_IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = 0
const m_IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = 1
const m_IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = 0
const m_IOPOL_VFS_CONTENT_PROTECTION_IGNORE = 1
const m_IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = 0
const m_IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = 1
const m_IOPOL_VFS_IGNORE_PERMISSIONS_OFF = 0
const m_IOPOL_VFS_IGNORE_PERMISSIONS_ON = 1
const m_IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = 0
const m_IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = 1
const m_IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = 0
const m_IOPOL_VFS_SKIP_MTIME_UPDATE_ON = 1
const m_IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = 1
const m_IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = 0
const m_IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = 0
const m_IOPOL_VFS_TRIGGER_RESOLVE_OFF = 1
const m_IconicState = 3
const m_InactiveState = 4
const m_IncludeInferiors = 1
const m_InputFocus = 1
const m_InputOnly = 2
const m_InputOutput = 1
const m_IsUnmapped = 0
const m_IsUnviewable = 1
const m_IsViewable = 2
const m_JoinBevel = 2
const m_JoinMiter = 0
const m_JoinRound = 1
const m_KeyPress = 2
const m_KeyRelease = 3
const m_KeymapNotify = 11
const m_LASTEvent = 36
const m_LITTLE_ENDIAN = "__DARWIN_LITTLE_ENDIAN"
const m_LOCKED = 1
const m_LSBFirst = 0
const m_LT_OBJDIR = ".libs/"
const m_L_ctermid = 1024
const m_L_tmpnam = 1024
const m_LastExtensionError = 255
const m_LeaveNotify = 8
const m_LedModeOff = 0
const m_LedModeOn = 1
const m_LineDoubleDash = 2
const m_LineOnOffDash = 1
const m_LineSolid = 0
const m_LockMapIndex = 1
const m_LowerHighest = 1
const m_MAC_OS_VERSION_11_0 = "__MAC_11_0"
const m_MAC_OS_VERSION_11_1 = "__MAC_11_1"
const m_MAC_OS_VERSION_11_3 = "__MAC_11_3"
const m_MAC_OS_VERSION_11_4 = "__MAC_11_4"
const m_MAC_OS_VERSION_11_5 = "__MAC_11_5"
const m_MAC_OS_VERSION_11_6 = "__MAC_11_6"
const m_MAC_OS_VERSION_12_0 = "__MAC_12_0"
const m_MAC_OS_VERSION_12_1 = "__MAC_12_1"
const m_MAC_OS_VERSION_12_2 = "__MAC_12_2"
const m_MAC_OS_VERSION_12_3 = "__MAC_12_3"
const m_MAC_OS_VERSION_12_4 = "__MAC_12_4"
const m_MAC_OS_VERSION_12_5 = "__MAC_12_5"
const m_MAC_OS_VERSION_12_6 = "__MAC_12_6"
const m_MAC_OS_VERSION_12_7 = "__MAC_12_7"
const m_MAC_OS_VERSION_13_0 = "__MAC_13_0"
const m_MAC_OS_VERSION_13_1 = "__MAC_13_1"
const m_MAC_OS_VERSION_13_2 = "__MAC_13_2"
const m_MAC_OS_VERSION_13_3 = "__MAC_13_3"
const m_MAC_OS_VERSION_13_4 = "__MAC_13_4"
const m_MAC_OS_VERSION_13_5 = "__MAC_13_5"
const m_MAC_OS_VERSION_13_6 = "__MAC_13_6"
const m_MAC_OS_VERSION_14_0 = "__MAC_14_0"
const m_MAC_OS_VERSION_14_1 = "__MAC_14_1"
const m_MAC_OS_VERSION_14_2 = "__MAC_14_2"
const m_MAC_OS_VERSION_14_3 = "__MAC_14_3"
const m_MAC_OS_VERSION_14_4 = "__MAC_14_4"
const m_MAC_OS_X_VERSION_10_0 = "__MAC_10_0"
const m_MAC_OS_X_VERSION_10_1 = "__MAC_10_1"
const m_MAC_OS_X_VERSION_10_10 = "__MAC_10_10"
const m_MAC_OS_X_VERSION_10_10_2 = "__MAC_10_10_2"
const m_MAC_OS_X_VERSION_10_10_3 = "__MAC_10_10_3"
const m_MAC_OS_X_VERSION_10_11 = "__MAC_10_11"
const m_MAC_OS_X_VERSION_10_11_2 = "__MAC_10_11_2"
const m_MAC_OS_X_VERSION_10_11_3 = "__MAC_10_11_3"
const m_MAC_OS_X_VERSION_10_11_4 = "__MAC_10_11_4"
const m_MAC_OS_X_VERSION_10_12 = "__MAC_10_12"
const m_MAC_OS_X_VERSION_10_12_1 = "__MAC_10_12_1"
const m_MAC_OS_X_VERSION_10_12_2 = "__MAC_10_12_2"
const m_MAC_OS_X_VERSION_10_12_4 = "__MAC_10_12_4"
const m_MAC_OS_X_VERSION_10_13 = "__MAC_10_13"
const m_MAC_OS_X_VERSION_10_13_1 = "__MAC_10_13_1"
const m_MAC_OS_X_VERSION_10_13_2 = "__MAC_10_13_2"
const m_MAC_OS_X_VERSION_10_13_4 = "__MAC_10_13_4"
const m_MAC_OS_X_VERSION_10_14 = "__MAC_10_14"
const m_MAC_OS_X_VERSION_10_14_1 = "__MAC_10_14_1"
const m_MAC_OS_X_VERSION_10_14_4 = "__MAC_10_14_4"
const m_MAC_OS_X_VERSION_10_14_5 = "__MAC_10_14_5"
const m_MAC_OS_X_VERSION_10_14_6 = "__MAC_10_14_6"
const m_MAC_OS_X_VERSION_10_15 = "__MAC_10_15"
const m_MAC_OS_X_VERSION_10_15_1 = "__MAC_10_15_1"
const m_MAC_OS_X_VERSION_10_15_4 = "__MAC_10_15_4"
const m_MAC_OS_X_VERSION_10_16 = "__MAC_10_16"
const m_MAC_OS_X_VERSION_10_2 = "__MAC_10_2"
const m_MAC_OS_X_VERSION_10_3 = "__MAC_10_3"
const m_MAC_OS_X_VERSION_10_4 = "__MAC_10_4"
const m_MAC_OS_X_VERSION_10_5 = "__MAC_10_5"
const m_MAC_OS_X_VERSION_10_6 = "__MAC_10_6"
const m_MAC_OS_X_VERSION_10_7 = "__MAC_10_7"
const m_MAC_OS_X_VERSION_10_8 = "__MAC_10_8"
const m_MAC_OS_X_VERSION_10_9 = "__MAC_10_9"
const m_MAC_OS_X_VERSION_MAX_ALLOWED = "MAC_OS_VERSION_14_0"
const m_MAC_OS_X_VERSION_MIN_REQUIRED = "__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__"
const m_MB_CUR_MAX = "__mb_cur_max"
const m_MB_LEN_MAX = 1
const m_MINSIGSTKSZ = 32768
const m_MSBFirst = 1
const m_MapNotify = 19
const m_MapRequest = 20
const m_MappingBusy = 1
const m_MappingFailed = 2
const m_MappingKeyboard = 1
const m_MappingModifier = 0
const m_MappingNotify = 34
const m_MappingPointer = 2
const m_MappingSuccess = 0
const m_Mod1MapIndex = 3
const m_Mod2MapIndex = 4
const m_Mod3MapIndex = 5
const m_Mod4MapIndex = 6
const m_Mod5MapIndex = 7
const m_MotionNotify = 6
const m_NBBY = "__DARWIN_NBBY"
const m_NDEBUG = 1
const m_NFDBITS = "__DARWIN_NFDBITS"
const m_NSIG = "__DARWIN_NSIG"
const m_NeedFunctionPrototypes = 1
const m_NeedNestedPrototypes = 1
const m_NeedVarargsPrototypes = 1
const m_NeedWidePrototypes = 1
const m_NoEventMask = 0
const m_NoExpose = 14
const m_NoSymbol = 0
const m_NoValue = 0x0000
const m_Nonconvex = 1
const m_None = 0
const m_NormalState = 1
const m_NorthEastGravity = 3
const m_NorthGravity = 2
const m_NorthWestGravity = 1
const m_NotUseful = 0
const m_NotifyAncestor = 0
const m_NotifyDetailNone = 7
const m_NotifyGrab = 1
const m_NotifyHint = 1
const m_NotifyInferior = 2
const m_NotifyNonlinear = 3
const m_NotifyNonlinearVirtual = 4
const m_NotifyNormal = 0
const m_NotifyPointer = 5
const m_NotifyPointerRoot = 6
const m_NotifyUngrab = 2
const m_NotifyVirtual = 1
const m_NotifyWhileGrabbed = 3
const m_Opposite = 4
const m_PACKAGE = "libXft"
const m_PACKAGE_BUGREPORT = "https://gitlab.freedesktop.org/xorg/lib/libXft/issues"
const m_PACKAGE_NAME = "libXft"
const m_PACKAGE_STRING = "libXft 2.3.8"
const m_PACKAGE_TARNAME = "libXft"
const m_PACKAGE_URL = ""
const m_PACKAGE_VERSION = "2.3.8"
const m_PACKAGE_VERSION_MAJOR = 2
const m_PACKAGE_VERSION_MINOR = 3
const m_PACKAGE_VERSION_PATCHLEVEL = 8
const m_PDP_ENDIAN = "__DARWIN_PDP_ENDIAN"
const m_POLL_ERR = 4
const m_POLL_HUP = 6
const m_POLL_IN = 1
const m_POLL_MSG = 3
const m_POLL_OUT = 2
const m_POLL_PRI = 5
const m_PRIO_DARWIN_BG = 0x1000
const m_PRIO_DARWIN_NONUI = 0x1001
const m_PRIO_DARWIN_PROCESS = 4
const m_PRIO_DARWIN_THREAD = 3
const m_PRIO_MAX = 20
const m_PRIO_PGRP = 1
const m_PRIO_PROCESS = 0
const m_PRIO_USER = 2
const m_PTHREAD_CANCEL_ASYNCHRONOUS = 0x00
const m_PTHREAD_CANCEL_DEFERRED = 0x02
const m_PTHREAD_CANCEL_DISABLE = 0x00
const m_PTHREAD_CANCEL_ENABLE = 0x01
const m_PTHREAD_CREATE_DETACHED = 2
const m_PTHREAD_CREATE_JOINABLE = 1
const m_PTHREAD_EXPLICIT_SCHED = 2
const m_PTHREAD_INHERIT_SCHED = 1
const m_PTHREAD_MUTEX_DEFAULT = "PTHREAD_MUTEX_NORMAL"
const m_PTHREAD_MUTEX_ERRORCHECK = 1
const m_PTHREAD_MUTEX_NORMAL = 0
const m_PTHREAD_MUTEX_POLICY_FAIRSHARE_NP = 1
const m_PTHREAD_MUTEX_POLICY_FIRSTFIT_NP = 3
const m_PTHREAD_MUTEX_RECURSIVE = 2
const m_PTHREAD_PRIO_INHERIT = 1
const m_PTHREAD_PRIO_NONE = 0
const m_PTHREAD_PRIO_PROTECT = 2
const m_PTHREAD_PROCESS_PRIVATE = 2
const m_PTHREAD_PROCESS_SHARED = 1
const m_PTHREAD_SCOPE_PROCESS = 2
const m_PTHREAD_SCOPE_SYSTEM = 1
const m_PTRDIFF_MAX = "__PTRDIFF_MAX__"
const m_PTSPERBATCH = 1024
const m_P_tmpdir = "/var/tmp/"
const m_ParentRelative = 1
const m_PictOpAdd = 12
const m_PictOpAtop = 9
const m_PictOpAtopReverse = 10
const m_PictOpBlendMaximum = 0x3e
const m_PictOpBlendMinimum = 0x30
const m_PictOpClear = 0
const m_PictOpColorBurn = 0x36
const m_PictOpColorDodge = 0x35
const m_PictOpConjointAtop = 0x29
const m_PictOpConjointAtopReverse = 0x2a
const m_PictOpConjointClear = 0x20
const m_PictOpConjointDst = 0x22
const m_PictOpConjointIn = 0x25
const m_PictOpConjointInReverse = 0x26
const m_PictOpConjointMaximum = 0x2b
const m_PictOpConjointMinimum = 0x20
const m_PictOpConjointOut = 0x27
const m_PictOpConjointOutReverse = 0x28
const m_PictOpConjointOver = 0x23
const m_PictOpConjointOverReverse = 0x24
const m_PictOpConjointSrc = 0x21
const m_PictOpConjointXor = 0x2b
const m_PictOpDarken = 0x33
const m_PictOpDifference = 0x39
const m_PictOpDisjointAtop = 0x19
const m_PictOpDisjointAtopReverse = 0x1a
const m_PictOpDisjointClear = 0x10
const m_PictOpDisjointDst = 0x12
const m_PictOpDisjointIn = 0x15
const m_PictOpDisjointInReverse = 0x16
const m_PictOpDisjointMaximum = 0x1b
const m_PictOpDisjointMinimum = 0x10
const m_PictOpDisjointOut = 0x17
const m_PictOpDisjointOutReverse = 0x18
const m_PictOpDisjointOver = 0x13
const m_PictOpDisjointOverReverse = 0x14
const m_PictOpDisjointSrc = 0x11
const m_PictOpDisjointXor = 0x1b
const m_PictOpDst = 2
const m_PictOpExclusion = 0x3a
const m_PictOpHSLColor = 0x3d
const m_PictOpHSLHue = 0x3b
const m_PictOpHSLLuminosity = 0x3e
const m_PictOpHSLSaturation = 0x3c
const m_PictOpHardLight = 0x37
const m_PictOpIn = 5
const m_PictOpInReverse = 6
const m_PictOpLighten = 0x34
const m_PictOpMaximum = 13
const m_PictOpMinimum = 0
const m_PictOpMultiply = 0x30
const m_PictOpOut = 7
const m_PictOpOutReverse = 8
const m_PictOpOver = 3
const m_PictOpOverReverse = 4
const m_PictOpOverlay = 0x32
const m_PictOpSaturate = 13
const m_PictOpScreen = 0x31
const m_PictOpSoftLight = 0x38
const m_PictOpSrc = 1
const m_PictOpXor = 11
const m_PictStandardA1 = 4
const m_PictStandardA4 = 3
const m_PictStandardA8 = 2
const m_PictStandardARGB32 = 0
const m_PictStandardNUM = 5
const m_PictStandardRGB24 = 1
const m_PictTypeDirect = 1
const m_PictTypeIndexed = 0
const m_PlaceOnBottom = 1
const m_PlaceOnTop = 0
const m_PointerRoot = 1
const m_PointerWindow = 0
const m_PolyEdgeSharp = 0
const m_PolyEdgeSmooth = 1
const m_PolyModeImprecise = 1
const m_PolyModePrecise = 0
const m_PreferBlanking = 1
const m_PropModeAppend = 2
const m_PropModePrepend = 1
const m_PropModeReplace = 0
const m_PropertyDelete = 1
const m_PropertyNewValue = 0
const m_PropertyNotify = 28
const m_PseudoColor = 3
const m_QueuedAfterFlush = 2
const m_QueuedAfterReading = 1
const m_QueuedAlready = 0
const m_RAND_MAX = 0x7fffffff
const m_RENAME_EXCL = 0x00000004
const m_RENAME_NOFOLLOW_ANY = 0x00000010
const m_RENAME_RESERVED1 = 0x00000008
const m_RENAME_SECLUDE = 0x00000001
const m_RENAME_SWAP = 0x00000002
const m_RENDER_MAJOR = 0
const m_RENDER_MINOR = 11
const m_RENDER_NAME = "RENDER"
const m_RLIMIT_AS = 5
const m_RLIMIT_CORE = 4
const m_RLIMIT_CPU = 0
const m_RLIMIT_CPU_USAGE_MONITOR = 0x2
const m_RLIMIT_DATA = 2
const m_RLIMIT_FOOTPRINT_INTERVAL = 0x4
const m_RLIMIT_FSIZE = 1
const m_RLIMIT_MEMLOCK = 6
const m_RLIMIT_NOFILE = 8
const m_RLIMIT_NPROC = 7
const m_RLIMIT_RSS = "RLIMIT_AS"
const m_RLIMIT_STACK = 3
const m_RLIMIT_THREAD_CPULIMITS = 0x3
const m_RLIMIT_WAKEUPS_MONITOR = 0x1
const m_RLIM_NLIMITS = 9
const m_RLIM_SAVED_CUR = "RLIM_INFINITY"
const m_RLIM_SAVED_MAX = "RLIM_INFINITY"
const m_RUSAGE_INFO_CURRENT = "RUSAGE_INFO_V6"
const m_RUSAGE_INFO_V0 = 0
const m_RUSAGE_INFO_V1 = 1
const m_RUSAGE_INFO_V2 = 2
const m_RUSAGE_INFO_V3 = 3
const m_RUSAGE_INFO_V4 = 4
const m_RUSAGE_INFO_V5 = 5
const m_RUSAGE_INFO_V6 = 6
const m_RUSAGE_SELF = 0
const m_RU_PROC_RUNS_RESLIDE = 0x00000001
const m_RaiseLowest = 0
const m_RectangleIn = 1
const m_RectangleOut = 0
const m_RectanglePart = 2
const m_ReparentNotify = 21
const m_RepeatNone = 0
const m_RepeatNormal = 1
const m_RepeatPad = 2
const m_RepeatReflect = 3
const m_ReplayKeyboard = 5
const m_ReplayPointer = 2
const m_ResizeRequest = 25
const m_RetainPermanent = 1
const m_RetainTemporary = 2
const m_RevertToParent = 2
const m_SA_64REGSET = 0x0200
const m_SA_NOCLDSTOP = 0x0008
const m_SA_NOCLDWAIT = 0x0020
const m_SA_NODEFER = 0x0010
const m_SA_ONSTACK = 0x0001
const m_SA_RESETHAND = 0x0004
const m_SA_RESTART = 0x0002
const m_SA_SIGINFO = 0x0040
const m_SA_USERTRAMP = 0x0100
const m_SCHED_FIFO = 4
const m_SCHED_OTHER = 1
const m_SCHED_RR = 2
const m_SEEK_CUR = 1
const m_SEEK_DATA = 4
const m_SEEK_END = 2
const m_SEEK_HOLE = 3
const m_SEEK_SET = 0
const m_SEGV_ACCERR = 2
const m_SEGV_MAPERR = 1
const m_SEGV_NOOP = 0
const m_SF_APPEND = 0x00040000
const m_SF_ARCHIVED = 0x00010000
const m_SF_DATALESS = 0x40000000
const m_SF_FIRMLINK = 0x00800000
const m_SF_IMMUTABLE = 0x00020000
const m_SF_NOUNLINK = 0x00100000
const m_SF_RESTRICTED = 0x00080000
const m_SF_SETTABLE = 0x3fff0000
const m_SF_SUPPORTED = 0x009f0000
const m_SF_SYNTHETIC = 0xc0000000
const m_SIGABRT = 6
const m_SIGALRM = 14
const m_SIGBUS = 10
const m_SIGCHLD = 20
const m_SIGCONT = 19
const m_SIGEMT = 7
const m_SIGEV_NONE = 0
const m_SIGEV_SIGNAL = 1
const m_SIGEV_THREAD = 3
const m_SIGFPE = 8
const m_SIGHUP = 1
const m_SIGILL = 4
const m_SIGINFO = 29
const m_SIGINT = 2
const m_SIGIO = 23
const m_SIGIOT = "SIGABRT"
const m_SIGKILL = 9
const m_SIGPIPE = 13
const m_SIGPROF = 27
const m_SIGQUIT = 3
const m_SIGSEGV = 11
const m_SIGSTKSZ = 131072
const m_SIGSTOP = 17
const m_SIGSYS = 12
const m_SIGTERM = 15
const m_SIGTRAP = 5
const m_SIGTSTP = 18
const m_SIGTTIN = 21
const m_SIGTTOU = 22
const m_SIGURG = 16
const m_SIGUSR1 = 30
const m_SIGUSR2 = 31
const m_SIGVTALRM = 26
const m_SIGWINCH = 28
const m_SIGXCPU = 24
const m_SIGXFSZ = 25
const m_SIG_BLOCK = 1
const m_SIG_SETMASK = 3
const m_SIG_UNBLOCK = 2
const m_SIZE_MAX = "__SIZE_MAX__"
const m_SI_ASYNCIO = 0x10004
const m_SI_MESGQ = 0x10005
const m_SI_QUEUE = 0x10002
const m_SI_TIMER = 0x10003
const m_SI_USER = 0x10001
const m_SS_DISABLE = 0x0004
const m_SS_ONSTACK = 0x0001
const m_STDC_HEADERS = 1
const m_SV_INTERRUPT = "SA_RESTART"
const m_SV_NOCLDSTOP = "SA_NOCLDSTOP"
const m_SV_NODEFER = "SA_NODEFER"
const m_SV_ONSTACK = "SA_ONSTACK"
const m_SV_RESETHAND = "SA_RESETHAND"
const m_SV_SIGINFO = "SA_SIGINFO"
const m_S_BLKSIZE = 512
const m_S_IEXEC = "S_IXUSR"
const m_S_IFBLK = 0060000
const m_S_IFCHR = 0020000
const m_S_IFDIR = 0040000
const m_S_IFIFO = 0010000
const m_S_IFLNK = 0120000
const m_S_IFMT = 0170000
const m_S_IFREG = 0100000
const m_S_IFSOCK = 0140000
const m_S_IFWHT = 0160000
const m_S_IREAD = "S_IRUSR"
const m_S_IRGRP = 0000040
const m_S_IROTH = 0000004
const m_S_IRUSR = 0000400
const m_S_IRWXG = 0000070
const m_S_IRWXO = 0000007
const m_S_IRWXU = 0000700
const m_S_ISGID = 0002000
const m_S_ISTXT = "S_ISVTX"
const m_S_ISUID = 0004000
const m_S_ISVTX = 0001000
const m_S_IWGRP = 0000020
const m_S_IWOTH = 0000002
const m_S_IWRITE = "S_IWUSR"
const m_S_IWUSR = 0000200
const m_S_IXGRP = 0000010
const m_S_IXOTH = 0000001
const m_S_IXUSR = 0000100
const m_ScreenSaverActive = 1
const m_ScreenSaverReset = 0
const m_SelectionClear = 29
const m_SelectionNotify = 31
const m_SelectionRequest = 30
const m_SetModeDelete = 1
const m_SetModeInsert = 0
const m_ShiftMapIndex = 0
const m_SouthEastGravity = 9
const m_SouthGravity = 8
const m_SouthWestGravity = 7
const m_StaticColor = 2
const m_StaticGravity = 10
const m_StaticGray = 0
const m_Status = "int"
const m_StippleShape = 2
const m_SubPixelHorizontalBGR = 2
const m_SubPixelHorizontalRGB = 1
const m_SubPixelNone = 5
const m_SubPixelUnknown = 0
const m_SubPixelVerticalBGR = 4
const m_SubPixelVerticalRGB = 3
const m_Success = 0
const m_SyncBoth = 7
const m_SyncKeyboard = 4
const m_SyncPointer = 1
const m_T1_MAX_CHARSTRINGS_OPERANDS = 256
const m_T1_MAX_DICT_DEPTH = 5
const m_T1_MAX_SUBRS_CALLS = 16
const m_TIME_UTC = 1
const m_TMP_MAX = 308915776
const m_TRAP_BRKPT = 1
const m_TRAP_TRACE = 2
const m_TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES = 1000000
const m_TT_CONFIG_OPTION_SUBPIXEL_HINTING = 2
const m_TileShape = 1
const m_TopIf = 2
const m_True = 1
const m_TrueColor = 4
const m_UF_APPEND = 0x00000004
const m_UF_COMPRESSED = 0x00000020
const m_UF_DATAVAULT = 0x00000080
const m_UF_HIDDEN = 0x00008000
const m_UF_IMMUTABLE = 0x00000002
const m_UF_NODUMP = 0x00000001
const m_UF_OPAQUE = 0x00000008
const m_UF_SETTABLE = 0x0000ffff
const m_UF_TRACKED = 0x00000040
const m_UINTMAX_MAX = "__UINTMAX_MAX__"
const m_UINTPTR_MAX = "__UINTPTR_MAX__"
const m_UINT_FAST16_MAX = "__UINT_LEAST16_MAX"
const m_UINT_FAST32_MAX = "__UINT_LEAST32_MAX"
const m_UINT_FAST64_MAX = "__UINT_LEAST64_MAX"
const m_UINT_FAST8_MAX = "__UINT_LEAST8_MAX"
const m_UINT_LEAST16_MAX = "__UINT_LEAST16_MAX"
const m_UINT_LEAST32_MAX = "__UINT_LEAST32_MAX"
const m_UINT_LEAST64_MAX = "__UINT_LEAST64_MAX"
const m_UINT_LEAST8_MAX = "__UINT_LEAST8_MAX"
const m_UNLOCKED = 0
const m_UnmapGravity = 0
const m_UnmapNotify = 18
const m_Unsorted = 0
const m_VERSION = "2.3.8"
const m_VisibilityFullyObscured = 2
const m_VisibilityNotify = 15
const m_VisibilityPartiallyObscured = 1
const m_VisibilityUnobscured = 0
const m_VisualAllMask = 0x1FF
const m_VisualBitsPerRGBMask = 0x100
const m_VisualBlueMaskMask = 0x40
const m_VisualClassMask = 0x8
const m_VisualColormapSizeMask = 0x80
const m_VisualDepthMask = 0x4
const m_VisualGreenMaskMask = 0x20
const m_VisualIDMask = 0x1
const m_VisualNoMask = 0x0
const m_VisualRedMaskMask = 0x10
const m_VisualScreenMask = 0x2
const m_WAIT_MYPGRP = 0
const m_WAKEMON_DISABLE = 0x02
const m_WAKEMON_ENABLE = 0x01
const m_WAKEMON_GET_PARAMS = 0x04
const m_WAKEMON_MAKE_FATAL = 0x10
const m_WAKEMON_SET_DEFAULTS = 0x08
const m_WCHAR_MAX = "__WCHAR_MAX__"
const m_WCONTINUED = 0x00000010
const m_WCOREFLAG = 0200
const m_WEXITED = 0x00000004
const m_WLNSPERBATCH = 50
const m_WNOHANG = 0x00000001
const m_WNOWAIT = 0x00000020
const m_WRCTSPERBATCH = 10
const m_WSTOPPED = 0x00000008
const m_WUNTRACED = 0x00000002
const m_WestGravity = 4
const m_WhenMapped = 1
const m_WidthValue = 0x0004
const m_WindingRule = 1
const m_WithdrawnState = 0
const m_XCNOENT = 2
const m_XCNOMEM = 1
const m_XCSUCCESS = 0
const m_XFT_ASSUME_PIXMAP = 20
const m_XFT_CORE = "core"
const m_XFT_DBG_CACHE = 128
const m_XFT_DBG_CACHEV = 256
const m_XFT_DBG_DRAW = 8
const m_XFT_DBG_GLYPH = 32
const m_XFT_DBG_GLYPHV = 64
const m_XFT_DBG_MEMORY = 512
const m_XFT_DBG_OPEN = 1
const m_XFT_DBG_OPENV = 2
const m_XFT_DBG_REF = 16
const m_XFT_DBG_RENDER = 4
const m_XFT_DBG_USAGE = 1024
const m_XFT_DPY_MAX_UNREF_FONTS = 16
const m_XFT_MAJOR = 2
const m_XFT_MAX_GLYPH_MEMORY = "maxglyphmemory"
const m_XFT_MAX_UNREF_FONTS = "maxunreffonts"
const m_XFT_MINOR = 3
const m_XFT_NMISSING = 256
const m_XFT_NUM_FONT_HASH = 127
const m_XFT_NUM_SOLID_COLOR = 16
const m_XFT_RENDER = "render"
const m_XFT_REVISION = 8
const m_XFT_TRACK_MEM_USAGE = "trackmemusage"
const m_XFT_XLFD = "xlfd"
const m_XIMHotKeyStateOFF = 0x0002
const m_XIMHotKeyStateON = 0x0001
const m_XIMInitialState = 1
const m_XIMPreeditArea = 0x0001
const m_XIMPreeditCallbacks = 0x0002
const m_XIMPreeditEnable = 1
const m_XIMPreeditNone = 0x0010
const m_XIMPreeditNothing = 0x0008
const m_XIMPreeditPosition = 0x0004
const m_XIMPreeditUnKnown = 0
const m_XIMReverse = 1
const m_XIMStatusArea = 0x0100
const m_XIMStatusCallbacks = 0x0200
const m_XIMStatusNone = 0x0800
const m_XIMStatusNothing = 0x0400
const m_XIMStringConversionBottomEdge = 0x00000008
const m_XIMStringConversionBuffer = 0x0001
const m_XIMStringConversionChar = 0x0004
const m_XIMStringConversionConcealed = 0x00000010
const m_XIMStringConversionLeftEdge = 0x00000001
const m_XIMStringConversionLine = 0x0002
const m_XIMStringConversionRetrieval = 0x0002
const m_XIMStringConversionRightEdge = 0x00000002
const m_XIMStringConversionSubstitution = 0x0001
const m_XIMStringConversionTopEdge = 0x00000004
const m_XIMStringConversionWord = 0x0003
const m_XIMStringConversionWrapped = 0x00000020
const m_XK_0 = 0x0030
const m_XK_1 = 0x0031
const m_XK_2 = 0x0032
const m_XK_3 = 0x0033
const m_XK_4 = 0x0034
const m_XK_5 = 0x0035
const m_XK_6 = 0x0036
const m_XK_7 = 0x0037
const m_XK_8 = 0x0038
const m_XK_9 = 0x0039
const m_XK_A = 0x0041
const m_XK_AE = 0x00c6
const m_XK_Aacute = 0x00c1
const m_XK_Abelowdot = 0x1001ea0
const m_XK_Abreve = 0x01c3
const m_XK_Abreveacute = 0x1001eae
const m_XK_Abrevebelowdot = 0x1001eb6
const m_XK_Abrevegrave = 0x1001eb0
const m_XK_Abrevehook = 0x1001eb2
const m_XK_Abrevetilde = 0x1001eb4
const m_XK_AccessX_Enable = 0xfe70
const m_XK_AccessX_Feedback_Enable = 0xfe71
const m_XK_Acircumflex = 0x00c2
const m_XK_Acircumflexacute = 0x1001ea4
const m_XK_Acircumflexbelowdot = 0x1001eac
const m_XK_Acircumflexgrave = 0x1001ea6
const m_XK_Acircumflexhook = 0x1001ea8
const m_XK_Acircumflextilde = 0x1001eaa
const m_XK_Adiaeresis = 0x00c4
const m_XK_Agrave = 0x00c0
const m_XK_Ahook = 0x1001ea2
const m_XK_Alt_L = 0xffe9
const m_XK_Alt_R = 0xffea
const m_XK_Amacron = 0x03c0
const m_XK_Aogonek = 0x01a1
const m_XK_Arabic_0 = 0x1000660
const m_XK_Arabic_1 = 0x1000661
const m_XK_Arabic_2 = 0x1000662
const m_XK_Arabic_3 = 0x1000663
const m_XK_Arabic_4 = 0x1000664
const m_XK_Arabic_5 = 0x1000665
const m_XK_Arabic_6 = 0x1000666
const m_XK_Arabic_7 = 0x1000667
const m_XK_Arabic_8 = 0x1000668
const m_XK_Arabic_9 = 0x1000669
const m_XK_Arabic_ain = 0x05d9
const m_XK_Arabic_alef = 0x05c7
const m_XK_Arabic_alefmaksura = 0x05e9
const m_XK_Arabic_beh = 0x05c8
const m_XK_Arabic_comma = 0x05ac
const m_XK_Arabic_dad = 0x05d6
const m_XK_Arabic_dal = 0x05cf
const m_XK_Arabic_damma = 0x05ef
const m_XK_Arabic_dammatan = 0x05ec
const m_XK_Arabic_ddal = 0x1000688
const m_XK_Arabic_farsi_yeh = 0x10006cc
const m_XK_Arabic_fatha = 0x05ee
const m_XK_Arabic_fathatan = 0x05eb
const m_XK_Arabic_feh = 0x05e1
const m_XK_Arabic_fullstop = 0x10006d4
const m_XK_Arabic_gaf = 0x10006af
const m_XK_Arabic_ghain = 0x05da
const m_XK_Arabic_ha = 0x05e7
const m_XK_Arabic_hah = 0x05cd
const m_XK_Arabic_hamza = 0x05c1
const m_XK_Arabic_hamza_above = 0x1000654
const m_XK_Arabic_hamza_below = 0x1000655
const m_XK_Arabic_hamzaonalef = 0x05c3
const m_XK_Arabic_hamzaonwaw = 0x05c4
const m_XK_Arabic_hamzaonyeh = 0x05c6
const m_XK_Arabic_hamzaunderalef = 0x05c5
const m_XK_Arabic_heh = 0x05e7
const m_XK_Arabic_heh_doachashmee = 0x10006be
const m_XK_Arabic_heh_goal = 0x10006c1
const m_XK_Arabic_jeem = 0x05cc
const m_XK_Arabic_jeh = 0x1000698
const m_XK_Arabic_kaf = 0x05e3
const m_XK_Arabic_kasra = 0x05f0
const m_XK_Arabic_kasratan = 0x05ed
const m_XK_Arabic_keheh = 0x10006a9
const m_XK_Arabic_khah = 0x05ce
const m_XK_Arabic_lam = 0x05e4
const m_XK_Arabic_madda_above = 0x1000653
const m_XK_Arabic_maddaonalef = 0x05c2
const m_XK_Arabic_meem = 0x05e5
const m_XK_Arabic_noon = 0x05e6
const m_XK_Arabic_noon_ghunna = 0x10006ba
const m_XK_Arabic_peh = 0x100067e
const m_XK_Arabic_percent = 0x100066a
const m_XK_Arabic_qaf = 0x05e2
const m_XK_Arabic_question_mark = 0x05bf
const m_XK_Arabic_ra = 0x05d1
const m_XK_Arabic_rreh = 0x1000691
const m_XK_Arabic_sad = 0x05d5
const m_XK_Arabic_seen = 0x05d3
const m_XK_Arabic_semicolon = 0x05bb
const m_XK_Arabic_shadda = 0x05f1
const m_XK_Arabic_sheen = 0x05d4
const m_XK_Arabic_sukun = 0x05f2
const m_XK_Arabic_superscript_alef = 0x1000670
const m_XK_Arabic_switch = 0xff7e
const m_XK_Arabic_tah = 0x05d7
const m_XK_Arabic_tatweel = 0x05e0
const m_XK_Arabic_tcheh = 0x1000686
const m_XK_Arabic_teh = 0x05ca
const m_XK_Arabic_tehmarbuta = 0x05c9
const m_XK_Arabic_thal = 0x05d0
const m_XK_Arabic_theh = 0x05cb
const m_XK_Arabic_tteh = 0x1000679
const m_XK_Arabic_veh = 0x10006a4
const m_XK_Arabic_waw = 0x05e8
const m_XK_Arabic_yeh = 0x05ea
const m_XK_Arabic_yeh_baree = 0x10006d2
const m_XK_Arabic_zah = 0x05d8
const m_XK_Arabic_zain = 0x05d2
const m_XK_Aring = 0x00c5
const m_XK_Armenian_AT = 0x1000538
const m_XK_Armenian_AYB = 0x1000531
const m_XK_Armenian_BEN = 0x1000532
const m_XK_Armenian_CHA = 0x1000549
const m_XK_Armenian_DA = 0x1000534
const m_XK_Armenian_DZA = 0x1000541
const m_XK_Armenian_E = 0x1000537
const m_XK_Armenian_FE = 0x1000556
const m_XK_Armenian_GHAT = 0x1000542
const m_XK_Armenian_GIM = 0x1000533
const m_XK_Armenian_HI = 0x1000545
const m_XK_Armenian_HO = 0x1000540
const m_XK_Armenian_INI = 0x100053b
const m_XK_Armenian_JE = 0x100054b
const m_XK_Armenian_KE = 0x1000554
const m_XK_Armenian_KEN = 0x100053f
const m_XK_Armenian_KHE = 0x100053d
const m_XK_Armenian_LYUN = 0x100053c
const m_XK_Armenian_MEN = 0x1000544
const m_XK_Armenian_NU = 0x1000546
const m_XK_Armenian_O = 0x1000555
const m_XK_Armenian_PE = 0x100054a
const m_XK_Armenian_PYUR = 0x1000553
const m_XK_Armenian_RA = 0x100054c
const m_XK_Armenian_RE = 0x1000550
const m_XK_Armenian_SE = 0x100054d
const m_XK_Armenian_SHA = 0x1000547
const m_XK_Armenian_TCHE = 0x1000543
const m_XK_Armenian_TO = 0x1000539
const m_XK_Armenian_TSA = 0x100053e
const m_XK_Armenian_TSO = 0x1000551
const m_XK_Armenian_TYUN = 0x100054f
const m_XK_Armenian_VEV = 0x100054e
const m_XK_Armenian_VO = 0x1000548
const m_XK_Armenian_VYUN = 0x1000552
const m_XK_Armenian_YECH = 0x1000535
const m_XK_Armenian_ZA = 0x1000536
const m_XK_Armenian_ZHE = 0x100053a
const m_XK_Armenian_accent = 0x100055b
const m_XK_Armenian_amanak = 0x100055c
const m_XK_Armenian_apostrophe = 0x100055a
const m_XK_Armenian_at = 0x1000568
const m_XK_Armenian_ayb = 0x1000561
const m_XK_Armenian_ben = 0x1000562
const m_XK_Armenian_but = 0x100055d
const m_XK_Armenian_cha = 0x1000579
const m_XK_Armenian_da = 0x1000564
const m_XK_Armenian_dza = 0x1000571
const m_XK_Armenian_e = 0x1000567
const m_XK_Armenian_exclam = 0x100055c
const m_XK_Armenian_fe = 0x1000586
const m_XK_Armenian_full_stop = 0x1000589
const m_XK_Armenian_ghat = 0x1000572
const m_XK_Armenian_gim = 0x1000563
const m_XK_Armenian_hi = 0x1000575
const m_XK_Armenian_ho = 0x1000570
const m_XK_Armenian_hyphen = 0x100058a
const m_XK_Armenian_ini = 0x100056b
const m_XK_Armenian_je = 0x100057b
const m_XK_Armenian_ke = 0x1000584
const m_XK_Armenian_ken = 0x100056f
const m_XK_Armenian_khe = 0x100056d
const m_XK_Armenian_ligature_ew = 0x1000587
const m_XK_Armenian_lyun = 0x100056c
const m_XK_Armenian_men = 0x1000574
const m_XK_Armenian_nu = 0x1000576
const m_XK_Armenian_o = 0x1000585
const m_XK_Armenian_paruyk = 0x100055e
const m_XK_Armenian_pe = 0x100057a
const m_XK_Armenian_pyur = 0x1000583
const m_XK_Armenian_question = 0x100055e
const m_XK_Armenian_ra = 0x100057c
const m_XK_Armenian_re = 0x1000580
const m_XK_Armenian_se = 0x100057d
const m_XK_Armenian_separation_mark = 0x100055d
const m_XK_Armenian_sha = 0x1000577
const m_XK_Armenian_shesht = 0x100055b
const m_XK_Armenian_tche = 0x1000573
const m_XK_Armenian_to = 0x1000569
const m_XK_Armenian_tsa = 0x100056e
const m_XK_Armenian_tso = 0x1000581
const m_XK_Armenian_tyun = 0x100057f
const m_XK_Armenian_verjaket = 0x1000589
const m_XK_Armenian_vev = 0x100057e
const m_XK_Armenian_vo = 0x1000578
const m_XK_Armenian_vyun = 0x1000582
const m_XK_Armenian_yech = 0x1000565
const m_XK_Armenian_yentamna = 0x100058a
const m_XK_Armenian_za = 0x1000566
const m_XK_Armenian_zhe = 0x100056a
const m_XK_Atilde = 0x00c3
const m_XK_AudibleBell_Enable = 0xfe7a
const m_XK_B = 0x0042
const m_XK_Babovedot = 0x1001e02
const m_XK_BackSpace = 0xff08
const m_XK_Begin = 0xff58
const m_XK_BounceKeys_Enable = 0xfe74
const m_XK_Break = 0xff6b
const m_XK_Byelorussian_SHORTU = 0x06be
const m_XK_Byelorussian_shortu = 0x06ae
const m_XK_C = 0x0043
const m_XK_CH = 0xfea2
const m_XK_C_H = 0xfea5
const m_XK_C_h = 0xfea4
const m_XK_Cabovedot = 0x02c5
const m_XK_Cacute = 0x01c6
const m_XK_Cancel = 0xff69
const m_XK_Caps_Lock = 0xffe5
const m_XK_Ccaron = 0x01c8
const m_XK_Ccedilla = 0x00c7
const m_XK_Ccircumflex = 0x02c6
const m_XK_Ch = 0xfea1
const m_XK_Clear = 0xff0b
const m_XK_Codeinput = 0xff37
const m_XK_ColonSign = 0x10020a1
const m_XK_Control_L = 0xffe3
const m_XK_Control_R = 0xffe4
const m_XK_CruzeiroSign = 0x10020a2
const m_XK_Cyrillic_A = 0x06e1
const m_XK_Cyrillic_BE = 0x06e2
const m_XK_Cyrillic_CHE = 0x06fe
const m_XK_Cyrillic_CHE_descender = 0x10004b6
const m_XK_Cyrillic_CHE_vertstroke = 0x10004b8
const m_XK_Cyrillic_DE = 0x06e4
const m_XK_Cyrillic_DZHE = 0x06bf
const m_XK_Cyrillic_E = 0x06fc
const m_XK_Cyrillic_EF = 0x06e6
const m_XK_Cyrillic_EL = 0x06ec
const m_XK_Cyrillic_EM = 0x06ed
const m_XK_Cyrillic_EN = 0x06ee
const m_XK_Cyrillic_EN_descender = 0x10004a2
const m_XK_Cyrillic_ER = 0x06f2
const m_XK_Cyrillic_ES = 0x06f3
const m_XK_Cyrillic_GHE = 0x06e7
const m_XK_Cyrillic_GHE_bar = 0x1000492
const m_XK_Cyrillic_HA = 0x06e8
const m_XK_Cyrillic_HARDSIGN = 0x06ff
const m_XK_Cyrillic_HA_descender = 0x10004b2
const m_XK_Cyrillic_I = 0x06e9
const m_XK_Cyrillic_IE = 0x06e5
const m_XK_Cyrillic_IO = 0x06b3
const m_XK_Cyrillic_I_macron = 0x10004e2
const m_XK_Cyrillic_JE = 0x06b8
const m_XK_Cyrillic_KA = 0x06eb
const m_XK_Cyrillic_KA_descender = 0x100049a
const m_XK_Cyrillic_KA_vertstroke = 0x100049c
const m_XK_Cyrillic_LJE = 0x06b9
const m_XK_Cyrillic_NJE = 0x06ba
const m_XK_Cyrillic_O = 0x06ef
const m_XK_Cyrillic_O_bar = 0x10004e8
const m_XK_Cyrillic_PE = 0x06f0
const m_XK_Cyrillic_SCHWA = 0x10004d8
const m_XK_Cyrillic_SHA = 0x06fb
const m_XK_Cyrillic_SHCHA = 0x06fd
const m_XK_Cyrillic_SHHA = 0x10004ba
const m_XK_Cyrillic_SHORTI = 0x06ea
const m_XK_Cyrillic_SOFTSIGN = 0x06f8
const m_XK_Cyrillic_TE = 0x06f4
const m_XK_Cyrillic_TSE = 0x06e3
const m_XK_Cyrillic_U = 0x06f5
const m_XK_Cyrillic_U_macron = 0x10004ee
const m_XK_Cyrillic_U_straight = 0x10004ae
const m_XK_Cyrillic_U_straight_bar = 0x10004b0
const m_XK_Cyrillic_VE = 0x06f7
const m_XK_Cyrillic_YA = 0x06f1
const m_XK_Cyrillic_YERU = 0x06f9
const m_XK_Cyrillic_YU = 0x06e0
const m_XK_Cyrillic_ZE = 0x06fa
const m_XK_Cyrillic_ZHE = 0x06f6
const m_XK_Cyrillic_ZHE_descender = 0x1000496
const m_XK_Cyrillic_a = 0x06c1
const m_XK_Cyrillic_be = 0x06c2
const m_XK_Cyrillic_che = 0x06de
const m_XK_Cyrillic_che_descender = 0x10004b7
const m_XK_Cyrillic_che_vertstroke = 0x10004b9
const m_XK_Cyrillic_de = 0x06c4
const m_XK_Cyrillic_dzhe = 0x06af
const m_XK_Cyrillic_e = 0x06dc
const m_XK_Cyrillic_ef = 0x06c6
const m_XK_Cyrillic_el = 0x06cc
const m_XK_Cyrillic_em = 0x06cd
const m_XK_Cyrillic_en = 0x06ce
const m_XK_Cyrillic_en_descender = 0x10004a3
const m_XK_Cyrillic_er = 0x06d2
const m_XK_Cyrillic_es = 0x06d3
const m_XK_Cyrillic_ghe = 0x06c7
const m_XK_Cyrillic_ghe_bar = 0x1000493
const m_XK_Cyrillic_ha = 0x06c8
const m_XK_Cyrillic_ha_descender = 0x10004b3
const m_XK_Cyrillic_hardsign = 0x06df
const m_XK_Cyrillic_i = 0x06c9
const m_XK_Cyrillic_i_macron = 0x10004e3
const m_XK_Cyrillic_ie = 0x06c5
const m_XK_Cyrillic_io = 0x06a3
const m_XK_Cyrillic_je = 0x06a8
const m_XK_Cyrillic_ka = 0x06cb
const m_XK_Cyrillic_ka_descender = 0x100049b
const m_XK_Cyrillic_ka_vertstroke = 0x100049d
const m_XK_Cyrillic_lje = 0x06a9
const m_XK_Cyrillic_nje = 0x06aa
const m_XK_Cyrillic_o = 0x06cf
const m_XK_Cyrillic_o_bar = 0x10004e9
const m_XK_Cyrillic_pe = 0x06d0
const m_XK_Cyrillic_schwa = 0x10004d9
const m_XK_Cyrillic_sha = 0x06db
const m_XK_Cyrillic_shcha = 0x06dd
const m_XK_Cyrillic_shha = 0x10004bb
const m_XK_Cyrillic_shorti = 0x06ca
const m_XK_Cyrillic_softsign = 0x06d8
const m_XK_Cyrillic_te = 0x06d4
const m_XK_Cyrillic_tse = 0x06c3
const m_XK_Cyrillic_u = 0x06d5
const m_XK_Cyrillic_u_macron = 0x10004ef
const m_XK_Cyrillic_u_straight = 0x10004af
const m_XK_Cyrillic_u_straight_bar = 0x10004b1
const m_XK_Cyrillic_ve = 0x06d7
const m_XK_Cyrillic_ya = 0x06d1
const m_XK_Cyrillic_yeru = 0x06d9
const m_XK_Cyrillic_yu = 0x06c0
const m_XK_Cyrillic_ze = 0x06da
const m_XK_Cyrillic_zhe = 0x06d6
const m_XK_Cyrillic_zhe_descender = 0x1000497
const m_XK_D = 0x0044
const m_XK_Dabovedot = 0x1001e0a
const m_XK_Dcaron = 0x01cf
const m_XK_Delete = 0xffff
const m_XK_DongSign = 0x10020ab
const m_XK_Down = 0xff54
const m_XK_Dstroke = 0x01d0
const m_XK_E = 0x0045
const m_XK_ENG = 0x03bd
const m_XK_ETH = 0x00d0
const m_XK_EZH = 0x10001b7
const m_XK_Eabovedot = 0x03cc
const m_XK_Eacute = 0x00c9
const m_XK_Ebelowdot = 0x1001eb8
const m_XK_Ecaron = 0x01cc
const m_XK_Ecircumflex = 0x00ca
const m_XK_Ecircumflexacute = 0x1001ebe
const m_XK_Ecircumflexbelowdot = 0x1001ec6
const m_XK_Ecircumflexgrave = 0x1001ec0
const m_XK_Ecircumflexhook = 0x1001ec2
const m_XK_Ecircumflextilde = 0x1001ec4
const m_XK_EcuSign = 0x10020a0
const m_XK_Ediaeresis = 0x00cb
const m_XK_Egrave = 0x00c8
const m_XK_Ehook = 0x1001eba
const m_XK_Eisu_Shift = 0xff2f
const m_XK_Eisu_toggle = 0xff30
const m_XK_Emacron = 0x03aa
const m_XK_End = 0xff57
const m_XK_Eogonek = 0x01ca
const m_XK_Escape = 0xff1b
const m_XK_Eth = 0x00d0
const m_XK_Etilde = 0x1001ebc
const m_XK_EuroSign = 0x20ac
const m_XK_Execute = 0xff62
const m_XK_F = 0x0046
const m_XK_F1 = 0xffbe
const m_XK_F10 = 0xffc7
const m_XK_F11 = 0xffc8
const m_XK_F12 = 0xffc9
const m_XK_F13 = 0xffca
const m_XK_F14 = 0xffcb
const m_XK_F15 = 0xffcc
const m_XK_F16 = 0xffcd
const m_XK_F17 = 0xffce
const m_XK_F18 = 0xffcf
const m_XK_F19 = 0xffd0
const m_XK_F2 = 0xffbf
const m_XK_F20 = 0xffd1
const m_XK_F21 = 0xffd2
const m_XK_F22 = 0xffd3
const m_XK_F23 = 0xffd4
const m_XK_F24 = 0xffd5
const m_XK_F25 = 0xffd6
const m_XK_F26 = 0xffd7
const m_XK_F27 = 0xffd8
const m_XK_F28 = 0xffd9
const m_XK_F29 = 0xffda
const m_XK_F3 = 0xffc0
const m_XK_F30 = 0xffdb
const m_XK_F31 = 0xffdc
const m_XK_F32 = 0xffdd
const m_XK_F33 = 0xffde
const m_XK_F34 = 0xffdf
const m_XK_F35 = 0xffe0
const m_XK_F4 = 0xffc1
const m_XK_F5 = 0xffc2
const m_XK_F6 = 0xffc3
const m_XK_F7 = 0xffc4
const m_XK_F8 = 0xffc5
const m_XK_F9 = 0xffc6
const m_XK_FFrancSign = 0x10020a3
const m_XK_Fabovedot = 0x1001e1e
const m_XK_Farsi_0 = 0x10006f0
const m_XK_Farsi_1 = 0x10006f1
const m_XK_Farsi_2 = 0x10006f2
const m_XK_Farsi_3 = 0x10006f3
const m_XK_Farsi_4 = 0x10006f4
const m_XK_Farsi_5 = 0x10006f5
const m_XK_Farsi_6 = 0x10006f6
const m_XK_Farsi_7 = 0x10006f7
const m_XK_Farsi_8 = 0x10006f8
const m_XK_Farsi_9 = 0x10006f9
const m_XK_Farsi_yeh = 0x10006cc
const m_XK_Find = 0xff68
const m_XK_First_Virtual_Screen = 0xfed0
const m_XK_G = 0x0047
const m_XK_Gabovedot = 0x02d5
const m_XK_Gbreve = 0x02ab
const m_XK_Gcaron = 0x10001e6
const m_XK_Gcedilla = 0x03ab
const m_XK_Gcircumflex = 0x02d8
const m_XK_Georgian_an = 0x10010d0
const m_XK_Georgian_ban = 0x10010d1
const m_XK_Georgian_can = 0x10010ea
const m_XK_Georgian_char = 0x10010ed
const m_XK_Georgian_chin = 0x10010e9
const m_XK_Georgian_cil = 0x10010ec
const m_XK_Georgian_don = 0x10010d3
const m_XK_Georgian_en = 0x10010d4
const m_XK_Georgian_fi = 0x10010f6
const m_XK_Georgian_gan = 0x10010d2
const m_XK_Georgian_ghan = 0x10010e6
const m_XK_Georgian_hae = 0x10010f0
const m_XK_Georgian_har = 0x10010f4
const m_XK_Georgian_he = 0x10010f1
const m_XK_Georgian_hie = 0x10010f2
const m_XK_Georgian_hoe = 0x10010f5
const m_XK_Georgian_in = 0x10010d8
const m_XK_Georgian_jhan = 0x10010ef
const m_XK_Georgian_jil = 0x10010eb
const m_XK_Georgian_kan = 0x10010d9
const m_XK_Georgian_khar = 0x10010e5
const m_XK_Georgian_las = 0x10010da
const m_XK_Georgian_man = 0x10010db
const m_XK_Georgian_nar = 0x10010dc
const m_XK_Georgian_on = 0x10010dd
const m_XK_Georgian_par = 0x10010de
const m_XK_Georgian_phar = 0x10010e4
const m_XK_Georgian_qar = 0x10010e7
const m_XK_Georgian_rae = 0x10010e0
const m_XK_Georgian_san = 0x10010e1
const m_XK_Georgian_shin = 0x10010e8
const m_XK_Georgian_tan = 0x10010d7
const m_XK_Georgian_tar = 0x10010e2
const m_XK_Georgian_un = 0x10010e3
const m_XK_Georgian_vin = 0x10010d5
const m_XK_Georgian_we = 0x10010f3
const m_XK_Georgian_xan = 0x10010ee
const m_XK_Georgian_zen = 0x10010d6
const m_XK_Georgian_zhar = 0x10010df
const m_XK_Greek_ALPHA = 0x07c1
const m_XK_Greek_ALPHAaccent = 0x07a1
const m_XK_Greek_BETA = 0x07c2
const m_XK_Greek_CHI = 0x07d7
const m_XK_Greek_DELTA = 0x07c4
const m_XK_Greek_EPSILON = 0x07c5
const m_XK_Greek_EPSILONaccent = 0x07a2
const m_XK_Greek_ETA = 0x07c7
const m_XK_Greek_ETAaccent = 0x07a3
const m_XK_Greek_GAMMA = 0x07c3
const m_XK_Greek_IOTA = 0x07c9
const m_XK_Greek_IOTAaccent = 0x07a4
const m_XK_Greek_IOTAdiaeresis = 0x07a5
const m_XK_Greek_IOTAdieresis = 0x07a5
const m_XK_Greek_KAPPA = 0x07ca
const m_XK_Greek_LAMBDA = 0x07cb
const m_XK_Greek_LAMDA = 0x07cb
const m_XK_Greek_MU = 0x07cc
const m_XK_Greek_NU = 0x07cd
const m_XK_Greek_OMEGA = 0x07d9
const m_XK_Greek_OMEGAaccent = 0x07ab
const m_XK_Greek_OMICRON = 0x07cf
const m_XK_Greek_OMICRONaccent = 0x07a7
const m_XK_Greek_PHI = 0x07d6
const m_XK_Greek_PI = 0x07d0
const m_XK_Greek_PSI = 0x07d8
const m_XK_Greek_RHO = 0x07d1
const m_XK_Greek_SIGMA = 0x07d2
const m_XK_Greek_TAU = 0x07d4
const m_XK_Greek_THETA = 0x07c8
const m_XK_Greek_UPSILON = 0x07d5
const m_XK_Greek_UPSILONaccent = 0x07a8
const m_XK_Greek_UPSILONdieresis = 0x07a9
const m_XK_Greek_XI = 0x07ce
const m_XK_Greek_ZETA = 0x07c6
const m_XK_Greek_accentdieresis = 0x07ae
const m_XK_Greek_alpha = 0x07e1
const m_XK_Greek_alphaaccent = 0x07b1
const m_XK_Greek_beta = 0x07e2
const m_XK_Greek_chi = 0x07f7
const m_XK_Greek_delta = 0x07e4
const m_XK_Greek_epsilon = 0x07e5
const m_XK_Greek_epsilonaccent = 0x07b2
const m_XK_Greek_eta = 0x07e7
const m_XK_Greek_etaaccent = 0x07b3
const m_XK_Greek_finalsmallsigma = 0x07f3
const m_XK_Greek_gamma = 0x07e3
const m_XK_Greek_horizbar = 0x07af
const m_XK_Greek_iota = 0x07e9
const m_XK_Greek_iotaaccent = 0x07b4
const m_XK_Greek_iotaaccentdieresis = 0x07b6
const m_XK_Greek_iotadieresis = 0x07b5
const m_XK_Greek_kappa = 0x07ea
const m_XK_Greek_lambda = 0x07eb
const m_XK_Greek_lamda = 0x07eb
const m_XK_Greek_mu = 0x07ec
const m_XK_Greek_nu = 0x07ed
const m_XK_Greek_omega = 0x07f9
const m_XK_Greek_omegaaccent = 0x07bb
const m_XK_Greek_omicron = 0x07ef
const m_XK_Greek_omicronaccent = 0x07b7
const m_XK_Greek_phi = 0x07f6
const m_XK_Greek_pi = 0x07f0
const m_XK_Greek_psi = 0x07f8
const m_XK_Greek_rho = 0x07f1
const m_XK_Greek_sigma = 0x07f2
const m_XK_Greek_switch = 0xff7e
const m_XK_Greek_tau = 0x07f4
const m_XK_Greek_theta = 0x07e8
const m_XK_Greek_upsilon = 0x07f5
const m_XK_Greek_upsilonaccent = 0x07b8
const m_XK_Greek_upsilonaccentdieresis = 0x07ba
const m_XK_Greek_upsilondieresis = 0x07b9
const m_XK_Greek_xi = 0x07ee
const m_XK_Greek_zeta = 0x07e6
const m_XK_H = 0x0048
const m_XK_Hangul = 0xff31
const m_XK_Hangul_A = 0x0ebf
const m_XK_Hangul_AE = 0x0ec0
const m_XK_Hangul_AraeA = 0x0ef6
const m_XK_Hangul_AraeAE = 0x0ef7
const m_XK_Hangul_Banja = 0xff39
const m_XK_Hangul_Cieuc = 0x0eba
const m_XK_Hangul_Codeinput = 0xff37
const m_XK_Hangul_Dikeud = 0x0ea7
const m_XK_Hangul_E = 0x0ec4
const m_XK_Hangul_EO = 0x0ec3
const m_XK_Hangul_EU = 0x0ed1
const m_XK_Hangul_End = 0xff33
const m_XK_Hangul_Hanja = 0xff34
const m_XK_Hangul_Hieuh = 0x0ebe
const m_XK_Hangul_I = 0x0ed3
const m_XK_Hangul_Ieung = 0x0eb7
const m_XK_Hangul_J_Cieuc = 0x0eea
const m_XK_Hangul_J_Dikeud = 0x0eda
const m_XK_Hangul_J_Hieuh = 0x0eee
const m_XK_Hangul_J_Ieung = 0x0ee8
const m_XK_Hangul_J_Jieuj = 0x0ee9
const m_XK_Hangul_J_Khieuq = 0x0eeb
const m_XK_Hangul_J_Kiyeog = 0x0ed4
const m_XK_Hangul_J_KiyeogSios = 0x0ed6
const m_XK_Hangul_J_KkogjiDalrinIeung = 0x0ef9
const m_XK_Hangul_J_Mieum = 0x0ee3
const m_XK_Hangul_J_Nieun = 0x0ed7
const m_XK_Hangul_J_NieunHieuh = 0x0ed9
const m_XK_Hangul_J_NieunJieuj = 0x0ed8
const m_XK_Hangul_J_PanSios = 0x0ef8
const m_XK_Hangul_J_Phieuf = 0x0eed
const m_XK_Hangul_J_Pieub = 0x0ee4
const m_XK_Hangul_J_PieubSios = 0x0ee5
const m_XK_Hangul_J_Rieul = 0x0edb
const m_XK_Hangul_J_RieulHieuh = 0x0ee2
const m_XK_Hangul_J_RieulKiyeog = 0x0edc
const m_XK_Hangul_J_RieulMieum = 0x0edd
const m_XK_Hangul_J_RieulPhieuf = 0x0ee1
const m_XK_Hangul_J_RieulPieub = 0x0ede
const m_XK_Hangul_J_RieulSios = 0x0edf
const m_XK_Hangul_J_RieulTieut = 0x0ee0
const m_XK_Hangul_J_Sios = 0x0ee6
const m_XK_Hangul_J_SsangKiyeog = 0x0ed5
const m_XK_Hangul_J_SsangSios = 0x0ee7
const m_XK_Hangul_J_Tieut = 0x0eec
const m_XK_Hangul_J_YeorinHieuh = 0x0efa
const m_XK_Hangul_Jamo = 0xff35
const m_XK_Hangul_Jeonja = 0xff38
const m_XK_Hangul_Jieuj = 0x0eb8
const m_XK_Hangul_Khieuq = 0x0ebb
const m_XK_Hangul_Kiyeog = 0x0ea1
const m_XK_Hangul_KiyeogSios = 0x0ea3
const m_XK_Hangul_KkogjiDalrinIeung = 0x0ef3
const m_XK_Hangul_Mieum = 0x0eb1
const m_XK_Hangul_MultipleCandidate = 0xff3d
const m_XK_Hangul_Nieun = 0x0ea4
const m_XK_Hangul_NieunHieuh = 0x0ea6
const m_XK_Hangul_NieunJieuj = 0x0ea5
const m_XK_Hangul_O = 0x0ec7
const m_XK_Hangul_OE = 0x0eca
const m_XK_Hangul_PanSios = 0x0ef2
const m_XK_Hangul_Phieuf = 0x0ebd
const m_XK_Hangul_Pieub = 0x0eb2
const m_XK_Hangul_PieubSios = 0x0eb4
const m_XK_Hangul_PostHanja = 0xff3b
const m_XK_Hangul_PreHanja = 0xff3a
const m_XK_Hangul_PreviousCandidate = 0xff3e
const m_XK_Hangul_Rieul = 0x0ea9
const m_XK_Hangul_RieulHieuh = 0x0eb0
const m_XK_Hangul_RieulKiyeog = 0x0eaa
const m_XK_Hangul_RieulMieum = 0x0eab
const m_XK_Hangul_RieulPhieuf = 0x0eaf
const m_XK_Hangul_RieulPieub = 0x0eac
const m_XK_Hangul_RieulSios = 0x0ead
const m_XK_Hangul_RieulTieut = 0x0eae
const m_XK_Hangul_RieulYeorinHieuh = 0x0eef
const m_XK_Hangul_Romaja = 0xff36
const m_XK_Hangul_SingleCandidate = 0xff3c
const m_XK_Hangul_Sios = 0x0eb5
const m_XK_Hangul_Special = 0xff3f
const m_XK_Hangul_SsangDikeud = 0x0ea8
const m_XK_Hangul_SsangJieuj = 0x0eb9
const m_XK_Hangul_SsangKiyeog = 0x0ea2
const m_XK_Hangul_SsangPieub = 0x0eb3
const m_XK_Hangul_SsangSios = 0x0eb6
const m_XK_Hangul_Start = 0xff32
const m_XK_Hangul_SunkyeongeumMieum = 0x0ef0
const m_XK_Hangul_SunkyeongeumPhieuf = 0x0ef4
const m_XK_Hangul_SunkyeongeumPieub = 0x0ef1
const m_XK_Hangul_Tieut = 0x0ebc
const m_XK_Hangul_U = 0x0ecc
const m_XK_Hangul_WA = 0x0ec8
const m_XK_Hangul_WAE = 0x0ec9
const m_XK_Hangul_WE = 0x0ece
const m_XK_Hangul_WEO = 0x0ecd
const m_XK_Hangul_WI = 0x0ecf
const m_XK_Hangul_YA = 0x0ec1
const m_XK_Hangul_YAE = 0x0ec2
const m_XK_Hangul_YE = 0x0ec6
const m_XK_Hangul_YEO = 0x0ec5
const m_XK_Hangul_YI = 0x0ed2
const m_XK_Hangul_YO = 0x0ecb
const m_XK_Hangul_YU = 0x0ed0
const m_XK_Hangul_YeorinHieuh = 0x0ef5
const m_XK_Hangul_switch = 0xff7e
const m_XK_Hankaku = 0xff29
const m_XK_Hcircumflex = 0x02a6
const m_XK_Hebrew_switch = 0xff7e
const m_XK_Help = 0xff6a
const m_XK_Henkan = 0xff23
const m_XK_Henkan_Mode = 0xff23
const m_XK_Hiragana = 0xff25
const m_XK_Hiragana_Katakana = 0xff27
const m_XK_Home = 0xff50
const m_XK_Hstroke = 0x02a1
const m_XK_Hyper_L = 0xffed
const m_XK_Hyper_R = 0xffee
const m_XK_I = 0x0049
const m_XK_ISO_Center_Object = 0xfe33
const m_XK_ISO_Continuous_Underline = 0xfe30
const m_XK_ISO_Discontinuous_Underline = 0xfe31
const m_XK_ISO_Emphasize = 0xfe32
const m_XK_ISO_Enter = 0xfe34
const m_XK_ISO_Fast_Cursor_Down = 0xfe2f
const m_XK_ISO_Fast_Cursor_Left = 0xfe2c
const m_XK_ISO_Fast_Cursor_Right = 0xfe2d
const m_XK_ISO_Fast_Cursor_Up = 0xfe2e
const m_XK_ISO_First_Group = 0xfe0c
const m_XK_ISO_First_Group_Lock = 0xfe0d
const m_XK_ISO_Group_Latch = 0xfe06
const m_XK_ISO_Group_Lock = 0xfe07
const m_XK_ISO_Group_Shift = 0xff7e
const m_XK_ISO_Last_Group = 0xfe0e
const m_XK_ISO_Last_Group_Lock = 0xfe0f
const m_XK_ISO_Left_Tab = 0xfe20
const m_XK_ISO_Level2_Latch = 0xfe02
const m_XK_ISO_Level3_Latch = 0xfe04
const m_XK_ISO_Level3_Lock = 0xfe05
const m_XK_ISO_Level3_Shift = 0xfe03
const m_XK_ISO_Level5_Latch = 0xfe12
const m_XK_ISO_Level5_Lock = 0xfe13
const m_XK_ISO_Level5_Shift = 0xfe11
const m_XK_ISO_Lock = 0xfe01
const m_XK_ISO_Move_Line_Down = 0xfe22
const m_XK_ISO_Move_Line_Up = 0xfe21
const m_XK_ISO_Next_Group = 0xfe08
const m_XK_ISO_Next_Group_Lock = 0xfe09
const m_XK_ISO_Partial_Line_Down = 0xfe24
const m_XK_ISO_Partial_Line_Up = 0xfe23
const m_XK_ISO_Partial_Space_Left = 0xfe25
const m_XK_ISO_Partial_Space_Right = 0xfe26
const m_XK_ISO_Prev_Group = 0xfe0a
const m_XK_ISO_Prev_Group_Lock = 0xfe0b
const m_XK_ISO_Release_Both_Margins = 0xfe2b
const m_XK_ISO_Release_Margin_Left = 0xfe29
const m_XK_ISO_Release_Margin_Right = 0xfe2a
const m_XK_ISO_Set_Margin_Left = 0xfe27
const m_XK_ISO_Set_Margin_Right = 0xfe28
const m_XK_Iabovedot = 0x02a9
const m_XK_Iacute = 0x00cd
const m_XK_Ibelowdot = 0x1001eca
const m_XK_Ibreve = 0x100012c
const m_XK_Icircumflex = 0x00ce
const m_XK_Idiaeresis = 0x00cf
const m_XK_Igrave = 0x00cc
const m_XK_Ihook = 0x1001ec8
const m_XK_Imacron = 0x03cf
const m_XK_Insert = 0xff63
const m_XK_Iogonek = 0x03c7
const m_XK_Itilde = 0x03a5
const m_XK_J = 0x004a
const m_XK_Jcircumflex = 0x02ac
const m_XK_K = 0x004b
const m_XK_KP_0 = 0xffb0
const m_XK_KP_1 = 0xffb1
const m_XK_KP_2 = 0xffb2
const m_XK_KP_3 = 0xffb3
const m_XK_KP_4 = 0xffb4
const m_XK_KP_5 = 0xffb5
const m_XK_KP_6 = 0xffb6
const m_XK_KP_7 = 0xffb7
const m_XK_KP_8 = 0xffb8
const m_XK_KP_9 = 0xffb9
const m_XK_KP_Add = 0xffab
const m_XK_KP_Begin = 0xff9d
const m_XK_KP_Decimal = 0xffae
const m_XK_KP_Delete = 0xff9f
const m_XK_KP_Divide = 0xffaf
const m_XK_KP_Down = 0xff99
const m_XK_KP_End = 0xff9c
const m_XK_KP_Enter = 0xff8d
const m_XK_KP_Equal = 0xffbd
const m_XK_KP_F1 = 0xff91
const m_XK_KP_F2 = 0xff92
const m_XK_KP_F3 = 0xff93
const m_XK_KP_F4 = 0xff94
const m_XK_KP_Home = 0xff95
const m_XK_KP_Insert = 0xff9e
const m_XK_KP_Left = 0xff96
const m_XK_KP_Multiply = 0xffaa
const m_XK_KP_Next = 0xff9b
const m_XK_KP_Page_Down = 0xff9b
const m_XK_KP_Page_Up = 0xff9a
const m_XK_KP_Prior = 0xff9a
const m_XK_KP_Right = 0xff98
const m_XK_KP_Separator = 0xffac
const m_XK_KP_Space = 0xff80
const m_XK_KP_Subtract = 0xffad
const m_XK_KP_Tab = 0xff89
const m_XK_KP_Up = 0xff97
const m_XK_Kana_Lock = 0xff2d
const m_XK_Kana_Shift = 0xff2e
const m_XK_Kanji = 0xff21
const m_XK_Kanji_Bangou = 0xff37
const m_XK_Katakana = 0xff26
const m_XK_Kcedilla = 0x03d3
const m_XK_Korean_Won = 0x0eff
const m_XK_L = 0x004c
const m_XK_L1 = 0xffc8
const m_XK_L10 = 0xffd1
const m_XK_L2 = 0xffc9
const m_XK_L3 = 0xffca
const m_XK_L4 = 0xffcb
const m_XK_L5 = 0xffcc
const m_XK_L6 = 0xffcd
const m_XK_L7 = 0xffce
const m_XK_L8 = 0xffcf
const m_XK_L9 = 0xffd0
const m_XK_Lacute = 0x01c5
const m_XK_Last_Virtual_Screen = 0xfed4
const m_XK_Lbelowdot = 0x1001e36
const m_XK_Lcaron = 0x01a5
const m_XK_Lcedilla = 0x03a6
const m_XK_Left = 0xff51
const m_XK_Linefeed = 0xff0a
const m_XK_LiraSign = 0x10020a4
const m_XK_Lstroke = 0x01a3
const m_XK_M = 0x004d
const m_XK_Mabovedot = 0x1001e40
const m_XK_Macedonia_DSE = 0x06b5
const m_XK_Macedonia_GJE = 0x06b2
const m_XK_Macedonia_KJE = 0x06bc
const m_XK_Macedonia_dse = 0x06a5
const m_XK_Macedonia_gje = 0x06a2
const m_XK_Macedonia_kje = 0x06ac
const m_XK_Mae_Koho = 0xff3e
const m_XK_Massyo = 0xff2c
const m_XK_Menu = 0xff67
const m_XK_Meta_L = 0xffe7
const m_XK_Meta_R = 0xffe8
const m_XK_MillSign = 0x10020a5
const m_XK_Mode_switch = 0xff7e
const m_XK_MouseKeys_Accel_Enable = 0xfe77
const m_XK_MouseKeys_Enable = 0xfe76
const m_XK_Muhenkan = 0xff22
const m_XK_Multi_key = 0xff20
const m_XK_MultipleCandidate = 0xff3d
const m_XK_N = 0x004e
const m_XK_Nacute = 0x01d1
const m_XK_NairaSign = 0x10020a6
const m_XK_Ncaron = 0x01d2
const m_XK_Ncedilla = 0x03d1
const m_XK_NewSheqelSign = 0x10020aa
const m_XK_Next = 0xff56
const m_XK_Next_Virtual_Screen = 0xfed2
const m_XK_Ntilde = 0x00d1
const m_XK_Num_Lock = 0xff7f
const m_XK_O = 0x004f
const m_XK_OE = 0x13bc
const m_XK_Oacute = 0x00d3
const m_XK_Obarred = 0x100019f
const m_XK_Obelowdot = 0x1001ecc
const m_XK_Ocaron = 0x10001d1
const m_XK_Ocircumflex = 0x00d4
const m_XK_Ocircumflexacute = 0x1001ed0
const m_XK_Ocircumflexbelowdot = 0x1001ed8
const m_XK_Ocircumflexgrave = 0x1001ed2
const m_XK_Ocircumflexhook = 0x1001ed4
const m_XK_Ocircumflextilde = 0x1001ed6
const m_XK_Odiaeresis = 0x00d6
const m_XK_Odoubleacute = 0x01d5
const m_XK_Ograve = 0x00d2
const m_XK_Ohook = 0x1001ece
const m_XK_Ohorn = 0x10001a0
const m_XK_Ohornacute = 0x1001eda
const m_XK_Ohornbelowdot = 0x1001ee2
const m_XK_Ohorngrave = 0x1001edc
const m_XK_Ohornhook = 0x1001ede
const m_XK_Ohorntilde = 0x1001ee0
const m_XK_Omacron = 0x03d2
const m_XK_Ooblique = 0x00d8
const m_XK_Oslash = 0x00d8
const m_XK_Otilde = 0x00d5
const m_XK_Overlay1_Enable = 0xfe78
const m_XK_Overlay2_Enable = 0xfe79
const m_XK_P = 0x0050
const m_XK_Pabovedot = 0x1001e56
const m_XK_Page_Down = 0xff56
const m_XK_Page_Up = 0xff55
const m_XK_Pause = 0xff13
const m_XK_PesetaSign = 0x10020a7
const m_XK_Pointer_Accelerate = 0xfefa
const m_XK_Pointer_Button1 = 0xfee9
const m_XK_Pointer_Button2 = 0xfeea
const m_XK_Pointer_Button3 = 0xfeeb
const m_XK_Pointer_Button4 = 0xfeec
const m_XK_Pointer_Button5 = 0xfeed
const m_XK_Pointer_Button_Dflt = 0xfee8
const m_XK_Pointer_DblClick1 = 0xfeef
const m_XK_Pointer_DblClick2 = 0xfef0
const m_XK_Pointer_DblClick3 = 0xfef1
const m_XK_Pointer_DblClick4 = 0xfef2
const m_XK_Pointer_DblClick5 = 0xfef3
const m_XK_Pointer_DblClick_Dflt = 0xfeee
const m_XK_Pointer_DfltBtnNext = 0xfefb
const m_XK_Pointer_DfltBtnPrev = 0xfefc
const m_XK_Pointer_Down = 0xfee3
const m_XK_Pointer_DownLeft = 0xfee6
const m_XK_Pointer_DownRight = 0xfee7
const m_XK_Pointer_Drag1 = 0xfef5
const m_XK_Pointer_Drag2 = 0xfef6
const m_XK_Pointer_Drag3 = 0xfef7
const m_XK_Pointer_Drag4 = 0xfef8
const m_XK_Pointer_Drag5 = 0xfefd
const m_XK_Pointer_Drag_Dflt = 0xfef4
const m_XK_Pointer_EnableKeys = 0xfef9
const m_XK_Pointer_Left = 0xfee0
const m_XK_Pointer_Right = 0xfee1
const m_XK_Pointer_Up = 0xfee2
const m_XK_Pointer_UpLeft = 0xfee4
const m_XK_Pointer_UpRight = 0xfee5
const m_XK_Prev_Virtual_Screen = 0xfed1
const m_XK_PreviousCandidate = 0xff3e
const m_XK_Print = 0xff61
const m_XK_Prior = 0xff55
const m_XK_Q = 0x0051
const m_XK_R = 0x0052
const m_XK_R1 = 0xffd2
const m_XK_R10 = 0xffdb
const m_XK_R11 = 0xffdc
const m_XK_R12 = 0xffdd
const m_XK_R13 = 0xffde
const m_XK_R14 = 0xffdf
const m_XK_R15 = 0xffe0
const m_XK_R2 = 0xffd3
const m_XK_R3 = 0xffd4
const m_XK_R4 = 0xffd5
const m_XK_R5 = 0xffd6
const m_XK_R6 = 0xffd7
const m_XK_R7 = 0xffd8
const m_XK_R8 = 0xffd9
const m_XK_R9 = 0xffda
const m_XK_Racute = 0x01c0
const m_XK_Rcaron = 0x01d8
const m_XK_Rcedilla = 0x03a3
const m_XK_Redo = 0xff66
const m_XK_RepeatKeys_Enable = 0xfe72
const m_XK_Return = 0xff0d
const m_XK_Right = 0xff53
const m_XK_Romaji = 0xff24
const m_XK_RupeeSign = 0x10020a8
const m_XK_S = 0x0053
const m_XK_SCHWA = 0x100018f
const m_XK_Sabovedot = 0x1001e60
const m_XK_Sacute = 0x01a6
const m_XK_Scaron = 0x01a9
const m_XK_Scedilla = 0x01aa
const m_XK_Scircumflex = 0x02de
const m_XK_Scroll_Lock = 0xff14
const m_XK_Select = 0xff60
const m_XK_Serbian_DJE = 0x06b1
const m_XK_Serbian_DZE = 0x06bf
const m_XK_Serbian_JE = 0x06b8
const m_XK_Serbian_LJE = 0x06b9
const m_XK_Serbian_NJE = 0x06ba
const m_XK_Serbian_TSHE = 0x06bb
const m_XK_Serbian_dje = 0x06a1
const m_XK_Serbian_dze = 0x06af
const m_XK_Serbian_je = 0x06a8
const m_XK_Serbian_lje = 0x06a9
const m_XK_Serbian_nje = 0x06aa
const m_XK_Serbian_tshe = 0x06ab
const m_XK_Shift_L = 0xffe1
const m_XK_Shift_Lock = 0xffe6
const m_XK_Shift_R = 0xffe2
const m_XK_SingleCandidate = 0xff3c
const m_XK_Sinh_a = 0x1000d85
const m_XK_Sinh_aa = 0x1000d86
const m_XK_Sinh_aa2 = 0x1000dcf
const m_XK_Sinh_ae = 0x1000d87
const m_XK_Sinh_ae2 = 0x1000dd0
const m_XK_Sinh_aee = 0x1000d88
const m_XK_Sinh_aee2 = 0x1000dd1
const m_XK_Sinh_ai = 0x1000d93
const m_XK_Sinh_ai2 = 0x1000ddb
const m_XK_Sinh_al = 0x1000dca
const m_XK_Sinh_au = 0x1000d96
const m_XK_Sinh_au2 = 0x1000dde
const m_XK_Sinh_ba = 0x1000db6
const m_XK_Sinh_bha = 0x1000db7
const m_XK_Sinh_ca = 0x1000da0
const m_XK_Sinh_cha = 0x1000da1
const m_XK_Sinh_dda = 0x1000da9
const m_XK_Sinh_ddha = 0x1000daa
const m_XK_Sinh_dha = 0x1000daf
const m_XK_Sinh_dhha = 0x1000db0
const m_XK_Sinh_e = 0x1000d91
const m_XK_Sinh_e2 = 0x1000dd9
const m_XK_Sinh_ee = 0x1000d92
const m_XK_Sinh_ee2 = 0x1000dda
const m_XK_Sinh_fa = 0x1000dc6
const m_XK_Sinh_ga = 0x1000d9c
const m_XK_Sinh_gha = 0x1000d9d
const m_XK_Sinh_h2 = 0x1000d83
const m_XK_Sinh_ha = 0x1000dc4
const m_XK_Sinh_i = 0x1000d89
const m_XK_Sinh_i2 = 0x1000dd2
const m_XK_Sinh_ii = 0x1000d8a
const m_XK_Sinh_ii2 = 0x1000dd3
const m_XK_Sinh_ja = 0x1000da2
const m_XK_Sinh_jha = 0x1000da3
const m_XK_Sinh_jnya = 0x1000da5
const m_XK_Sinh_ka = 0x1000d9a
const m_XK_Sinh_kha = 0x1000d9b
const m_XK_Sinh_kunddaliya = 0x1000df4
const m_XK_Sinh_la = 0x1000dbd
const m_XK_Sinh_lla = 0x1000dc5
const m_XK_Sinh_lu = 0x1000d8f
const m_XK_Sinh_lu2 = 0x1000ddf
const m_XK_Sinh_luu = 0x1000d90
const m_XK_Sinh_luu2 = 0x1000df3
const m_XK_Sinh_ma = 0x1000db8
const m_XK_Sinh_mba = 0x1000db9
const m_XK_Sinh_na = 0x1000db1
const m_XK_Sinh_ndda = 0x1000dac
const m_XK_Sinh_ndha = 0x1000db3
const m_XK_Sinh_ng = 0x1000d82
const m_XK_Sinh_ng2 = 0x1000d9e
const m_XK_Sinh_nga = 0x1000d9f
const m_XK_Sinh_nja = 0x1000da6
const m_XK_Sinh_nna = 0x1000dab
const m_XK_Sinh_nya = 0x1000da4
const m_XK_Sinh_o = 0x1000d94
const m_XK_Sinh_o2 = 0x1000ddc
const m_XK_Sinh_oo = 0x1000d95
const m_XK_Sinh_oo2 = 0x1000ddd
const m_XK_Sinh_pa = 0x1000db4
const m_XK_Sinh_pha = 0x1000db5
const m_XK_Sinh_ra = 0x1000dbb
const m_XK_Sinh_ri = 0x1000d8d
const m_XK_Sinh_rii = 0x1000d8e
const m_XK_Sinh_ru2 = 0x1000dd8
const m_XK_Sinh_ruu2 = 0x1000df2
const m_XK_Sinh_sa = 0x1000dc3
const m_XK_Sinh_sha = 0x1000dc1
const m_XK_Sinh_ssha = 0x1000dc2
const m_XK_Sinh_tha = 0x1000dad
const m_XK_Sinh_thha = 0x1000dae
const m_XK_Sinh_tta = 0x1000da7
const m_XK_Sinh_ttha = 0x1000da8
const m_XK_Sinh_u = 0x1000d8b
const m_XK_Sinh_u2 = 0x1000dd4
const m_XK_Sinh_uu = 0x1000d8c
const m_XK_Sinh_uu2 = 0x1000dd6
const m_XK_Sinh_va = 0x1000dc0
const m_XK_Sinh_ya = 0x1000dba
const m_XK_SlowKeys_Enable = 0xfe73
const m_XK_StickyKeys_Enable = 0xfe75
const m_XK_Super_L = 0xffeb
const m_XK_Super_R = 0xffec
const m_XK_Sys_Req = 0xff15
const m_XK_T = 0x0054
const m_XK_THORN = 0x00de
const m_XK_Tab = 0xff09
const m_XK_Tabovedot = 0x1001e6a
const m_XK_Tcaron = 0x01ab
const m_XK_Tcedilla = 0x01de
const m_XK_Terminate_Server = 0xfed5
const m_XK_Thai_baht = 0x0ddf
const m_XK_Thai_bobaimai = 0x0dba
const m_XK_Thai_chochan = 0x0da8
const m_XK_Thai_chochang = 0x0daa
const m_XK_Thai_choching = 0x0da9
const m_XK_Thai_chochoe = 0x0dac
const m_XK_Thai_dochada = 0x0dae
const m_XK_Thai_dodek = 0x0db4
const m_XK_Thai_fofa = 0x0dbd
const m_XK_Thai_fofan = 0x0dbf
const m_XK_Thai_hohip = 0x0dcb
const m_XK_Thai_honokhuk = 0x0dce
const m_XK_Thai_khokhai = 0x0da2
const m_XK_Thai_khokhon = 0x0da5
const m_XK_Thai_khokhuat = 0x0da3
const m_XK_Thai_khokhwai = 0x0da4
const m_XK_Thai_khorakhang = 0x0da6
const m_XK_Thai_kokai = 0x0da1
const m_XK_Thai_lakkhangyao = 0x0de5
const m_XK_Thai_lekchet = 0x0df7
const m_XK_Thai_lekha = 0x0df5
const m_XK_Thai_lekhok = 0x0df6
const m_XK_Thai_lekkao = 0x0df9
const m_XK_Thai_leknung = 0x0df1
const m_XK_Thai_lekpaet = 0x0df8
const m_XK_Thai_leksam = 0x0df3
const m_XK_Thai_leksi = 0x0df4
const m_XK_Thai_leksong = 0x0df2
const m_XK_Thai_leksun = 0x0df0
const m_XK_Thai_lochula = 0x0dcc
const m_XK_Thai_loling = 0x0dc5
const m_XK_Thai_lu = 0x0dc6
const m_XK_Thai_maichattawa = 0x0deb
const m_XK_Thai_maiek = 0x0de8
const m_XK_Thai_maihanakat = 0x0dd1
const m_XK_Thai_maihanakat_maitho = 0x0dde
const m_XK_Thai_maitaikhu = 0x0de7
const m_XK_Thai_maitho = 0x0de9
const m_XK_Thai_maitri = 0x0dea
const m_XK_Thai_maiyamok = 0x0de6
const m_XK_Thai_moma = 0x0dc1
const m_XK_Thai_ngongu = 0x0da7
const m_XK_Thai_nikhahit = 0x0ded
const m_XK_Thai_nonen = 0x0db3
const m_XK_Thai_nonu = 0x0db9
const m_XK_Thai_oang = 0x0dcd
const m_XK_Thai_paiyannoi = 0x0dcf
const m_XK_Thai_phinthu = 0x0dda
const m_XK_Thai_phophan = 0x0dbe
const m_XK_Thai_phophung = 0x0dbc
const m_XK_Thai_phosamphao = 0x0dc0
const m_XK_Thai_popla = 0x0dbb
const m_XK_Thai_rorua = 0x0dc3
const m_XK_Thai_ru = 0x0dc4
const m_XK_Thai_saraa = 0x0dd0
const m_XK_Thai_saraaa = 0x0dd2
const m_XK_Thai_saraae = 0x0de1
const m_XK_Thai_saraaimaimalai = 0x0de4
const m_XK_Thai_saraaimaimuan = 0x0de3
const m_XK_Thai_saraam = 0x0dd3
const m_XK_Thai_sarae = 0x0de0
const m_XK_Thai_sarai = 0x0dd4
const m_XK_Thai_saraii = 0x0dd5
const m_XK_Thai_sarao = 0x0de2
const m_XK_Thai_sarau = 0x0dd8
const m_XK_Thai_saraue = 0x0dd6
const m_XK_Thai_sarauee = 0x0dd7
const m_XK_Thai_sarauu = 0x0dd9
const m_XK_Thai_sorusi = 0x0dc9
const m_XK_Thai_sosala = 0x0dc8
const m_XK_Thai_soso = 0x0dab
const m_XK_Thai_sosua = 0x0dca
const m_XK_Thai_thanthakhat = 0x0dec
const m_XK_Thai_thonangmontho = 0x0db1
const m_XK_Thai_thophuthao = 0x0db2
const m_XK_Thai_thothahan = 0x0db7
const m_XK_Thai_thothan = 0x0db0
const m_XK_Thai_thothong = 0x0db8
const m_XK_Thai_thothung = 0x0db6
const m_XK_Thai_topatak = 0x0daf
const m_XK_Thai_totao = 0x0db5
const m_XK_Thai_wowaen = 0x0dc7
const m_XK_Thai_yoyak = 0x0dc2
const m_XK_Thai_yoying = 0x0dad
const m_XK_Thorn = 0x00de
const m_XK_Touroku = 0xff2b
const m_XK_Tslash = 0x03ac
const m_XK_U = 0x0055
const m_XK_Uacute = 0x00da
const m_XK_Ubelowdot = 0x1001ee4
const m_XK_Ubreve = 0x02dd
const m_XK_Ucircumflex = 0x00db
const m_XK_Udiaeresis = 0x00dc
const m_XK_Udoubleacute = 0x01db
const m_XK_Ugrave = 0x00d9
const m_XK_Uhook = 0x1001ee6
const m_XK_Uhorn = 0x10001af
const m_XK_Uhornacute = 0x1001ee8
const m_XK_Uhornbelowdot = 0x1001ef0
const m_XK_Uhorngrave = 0x1001eea
const m_XK_Uhornhook = 0x1001eec
const m_XK_Uhorntilde = 0x1001eee
const m_XK_Ukrainian_GHE_WITH_UPTURN = 0x06bd
const m_XK_Ukrainian_I = 0x06b6
const m_XK_Ukrainian_IE = 0x06b4
const m_XK_Ukrainian_YI = 0x06b7
const m_XK_Ukrainian_ghe_with_upturn = 0x06ad
const m_XK_Ukrainian_i = 0x06a6
const m_XK_Ukrainian_ie = 0x06a4
const m_XK_Ukrainian_yi = 0x06a7
const m_XK_Ukranian_I = 0x06b6
const m_XK_Ukranian_JE = 0x06b4
const m_XK_Ukranian_YI = 0x06b7
const m_XK_Ukranian_i = 0x06a6
const m_XK_Ukranian_je = 0x06a4
const m_XK_Ukranian_yi = 0x06a7
const m_XK_Umacron = 0x03de
const m_XK_Undo = 0xff65
const m_XK_Uogonek = 0x03d9
const m_XK_Up = 0xff52
const m_XK_Uring = 0x01d9
const m_XK_Utilde = 0x03dd
const m_XK_V = 0x0056
const m_XK_VoidSymbol = 0xffffff
const m_XK_W = 0x0057
const m_XK_Wacute = 0x1001e82
const m_XK_Wcircumflex = 0x1000174
const m_XK_Wdiaeresis = 0x1001e84
const m_XK_Wgrave = 0x1001e80
const m_XK_WonSign = 0x10020a9
const m_XK_X = 0x0058
const m_XK_Xabovedot = 0x1001e8a
const m_XK_Y = 0x0059
const m_XK_Yacute = 0x00dd
const m_XK_Ybelowdot = 0x1001ef4
const m_XK_Ycircumflex = 0x1000176
const m_XK_Ydiaeresis = 0x13be
const m_XK_Ygrave = 0x1001ef2
const m_XK_Yhook = 0x1001ef6
const m_XK_Ytilde = 0x1001ef8
const m_XK_Z = 0x005a
const m_XK_Zabovedot = 0x01af
const m_XK_Zacute = 0x01ac
const m_XK_Zcaron = 0x01ae
const m_XK_Zen_Koho = 0xff3d
const m_XK_Zenkaku = 0xff28
const m_XK_Zenkaku_Hankaku = 0xff2a
const m_XK_Zstroke = 0x10001b5
const m_XK_a = 0x0061
const m_XK_aacute = 0x00e1
const m_XK_abelowdot = 0x1001ea1
const m_XK_abovedot = 0x01ff
const m_XK_abreve = 0x01e3
const m_XK_abreveacute = 0x1001eaf
const m_XK_abrevebelowdot = 0x1001eb7
const m_XK_abrevegrave = 0x1001eb1
const m_XK_abrevehook = 0x1001eb3
const m_XK_abrevetilde = 0x1001eb5
const m_XK_acircumflex = 0x00e2
const m_XK_acircumflexacute = 0x1001ea5
const m_XK_acircumflexbelowdot = 0x1001ead
const m_XK_acircumflexgrave = 0x1001ea7
const m_XK_acircumflexhook = 0x1001ea9
const m_XK_acircumflextilde = 0x1001eab
const m_XK_acute = 0x00b4
const m_XK_adiaeresis = 0x00e4
const m_XK_ae = 0x00e6
const m_XK_agrave = 0x00e0
const m_XK_ahook = 0x1001ea3
const m_XK_amacron = 0x03e0
const m_XK_ampersand = 0x0026
const m_XK_aogonek = 0x01b1
const m_XK_apostrophe = 0x0027
const m_XK_approxeq = 0x1002248
const m_XK_aring = 0x00e5
const m_XK_asciicircum = 0x005e
const m_XK_asciitilde = 0x007e
const m_XK_asterisk = 0x002a
const m_XK_at = 0x0040
const m_XK_atilde = 0x00e3
const m_XK_b = 0x0062
const m_XK_babovedot = 0x1001e03
const m_XK_backslash = 0x005c
const m_XK_bar = 0x007c
const m_XK_because = 0x1002235
const m_XK_braceleft = 0x007b
const m_XK_braceright = 0x007d
const m_XK_bracketleft = 0x005b
const m_XK_bracketright = 0x005d
const m_XK_braille_blank = 0x1002800
const m_XK_braille_dot_1 = 0xfff1
const m_XK_braille_dot_10 = 0xfffa
const m_XK_braille_dot_2 = 0xfff2
const m_XK_braille_dot_3 = 0xfff3
const m_XK_braille_dot_4 = 0xfff4
const m_XK_braille_dot_5 = 0xfff5
const m_XK_braille_dot_6 = 0xfff6
const m_XK_braille_dot_7 = 0xfff7
const m_XK_braille_dot_8 = 0xfff8
const m_XK_braille_dot_9 = 0xfff9
const m_XK_braille_dots_1 = 0x1002801
const m_XK_braille_dots_12 = 0x1002803
const m_XK_braille_dots_123 = 0x1002807
const m_XK_braille_dots_1234 = 0x100280f
const m_XK_braille_dots_12345 = 0x100281f
const m_XK_braille_dots_123456 = 0x100283f
const m_XK_braille_dots_1234567 = 0x100287f
const m_XK_braille_dots_12345678 = 0x10028ff
const m_XK_braille_dots_1234568 = 0x10028bf
const m_XK_braille_dots_123457 = 0x100285f
const m_XK_braille_dots_1234578 = 0x10028df
const m_XK_braille_dots_123458 = 0x100289f
const m_XK_braille_dots_12346 = 0x100282f
const m_XK_braille_dots_123467 = 0x100286f
const m_XK_braille_dots_1234678 = 0x10028ef
const m_XK_braille_dots_123468 = 0x10028af
const m_XK_braille_dots_12347 = 0x100284f
const m_XK_braille_dots_123478 = 0x10028cf
const m_XK_braille_dots_12348 = 0x100288f
const m_XK_braille_dots_1235 = 0x1002817
const m_XK_braille_dots_12356 = 0x1002837
const m_XK_braille_dots_123567 = 0x1002877
const m_XK_braille_dots_1235678 = 0x10028f7
const m_XK_braille_dots_123568 = 0x10028b7
const m_XK_braille_dots_12357 = 0x1002857
const m_XK_braille_dots_123578 = 0x10028d7
const m_XK_braille_dots_12358 = 0x1002897
const m_XK_braille_dots_1236 = 0x1002827
const m_XK_braille_dots_12367 = 0x1002867
const m_XK_braille_dots_123678 = 0x10028e7
const m_XK_braille_dots_12368 = 0x10028a7
const m_XK_braille_dots_1237 = 0x1002847
const m_XK_braille_dots_12378 = 0x10028c7
const m_XK_braille_dots_1238 = 0x1002887
const m_XK_braille_dots_124 = 0x100280b
const m_XK_braille_dots_1245 = 0x100281b
const m_XK_braille_dots_12456 = 0x100283b
const m_XK_braille_dots_124567 = 0x100287b
const m_XK_braille_dots_1245678 = 0x10028fb
const m_XK_braille_dots_124568 = 0x10028bb
const m_XK_braille_dots_12457 = 0x100285b
const m_XK_braille_dots_124578 = 0x10028db
const m_XK_braille_dots_12458 = 0x100289b
const m_XK_braille_dots_1246 = 0x100282b
const m_XK_braille_dots_12467 = 0x100286b
const m_XK_braille_dots_124678 = 0x10028eb
const m_XK_braille_dots_12468 = 0x10028ab
const m_XK_braille_dots_1247 = 0x100284b
const m_XK_braille_dots_12478 = 0x10028cb
const m_XK_braille_dots_1248 = 0x100288b
const m_XK_braille_dots_125 = 0x1002813
const m_XK_braille_dots_1256 = 0x1002833
const m_XK_braille_dots_12567 = 0x1002873
const m_XK_braille_dots_125678 = 0x10028f3
const m_XK_braille_dots_12568 = 0x10028b3
const m_XK_braille_dots_1257 = 0x1002853
const m_XK_braille_dots_12578 = 0x10028d3
const m_XK_braille_dots_1258 = 0x1002893
const m_XK_braille_dots_126 = 0x1002823
const m_XK_braille_dots_1267 = 0x1002863
const m_XK_braille_dots_12678 = 0x10028e3
const m_XK_braille_dots_1268 = 0x10028a3
const m_XK_braille_dots_127 = 0x1002843
const m_XK_braille_dots_1278 = 0x10028c3
const m_XK_braille_dots_128 = 0x1002883
const m_XK_braille_dots_13 = 0x1002805
const m_XK_braille_dots_134 = 0x100280d
const m_XK_braille_dots_1345 = 0x100281d
const m_XK_braille_dots_13456 = 0x100283d
const m_XK_braille_dots_134567 = 0x100287d
const m_XK_braille_dots_1345678 = 0x10028fd
const m_XK_braille_dots_134568 = 0x10028bd
const m_XK_braille_dots_13457 = 0x100285d
const m_XK_braille_dots_134578 = 0x10028dd
const m_XK_braille_dots_13458 = 0x100289d
const m_XK_braille_dots_1346 = 0x100282d
const m_XK_braille_dots_13467 = 0x100286d
const m_XK_braille_dots_134678 = 0x10028ed
const m_XK_braille_dots_13468 = 0x10028ad
const m_XK_braille_dots_1347 = 0x100284d
const m_XK_braille_dots_13478 = 0x10028cd
const m_XK_braille_dots_1348 = 0x100288d
const m_XK_braille_dots_135 = 0x1002815
const m_XK_braille_dots_1356 = 0x1002835
const m_XK_braille_dots_13567 = 0x1002875
const m_XK_braille_dots_135678 = 0x10028f5
const m_XK_braille_dots_13568 = 0x10028b5
const m_XK_braille_dots_1357 = 0x1002855
const m_XK_braille_dots_13578 = 0x10028d5
const m_XK_braille_dots_1358 = 0x1002895
const m_XK_braille_dots_136 = 0x1002825
const m_XK_braille_dots_1367 = 0x1002865
const m_XK_braille_dots_13678 = 0x10028e5
const m_XK_braille_dots_1368 = 0x10028a5
const m_XK_braille_dots_137 = 0x1002845
const m_XK_braille_dots_1378 = 0x10028c5
const m_XK_braille_dots_138 = 0x1002885
const m_XK_braille_dots_14 = 0x1002809
const m_XK_braille_dots_145 = 0x1002819
const m_XK_braille_dots_1456 = 0x1002839
const m_XK_braille_dots_14567 = 0x1002879
const m_XK_braille_dots_145678 = 0x10028f9
const m_XK_braille_dots_14568 = 0x10028b9
const m_XK_braille_dots_1457 = 0x1002859
const m_XK_braille_dots_14578 = 0x10028d9
const m_XK_braille_dots_1458 = 0x1002899
const m_XK_braille_dots_146 = 0x1002829
const m_XK_braille_dots_1467 = 0x1002869
const m_XK_braille_dots_14678 = 0x10028e9
const m_XK_braille_dots_1468 = 0x10028a9
const m_XK_braille_dots_147 = 0x1002849
const m_XK_braille_dots_1478 = 0x10028c9
const m_XK_braille_dots_148 = 0x1002889
const m_XK_braille_dots_15 = 0x1002811
const m_XK_braille_dots_156 = 0x1002831
const m_XK_braille_dots_1567 = 0x1002871
const m_XK_braille_dots_15678 = 0x10028f1
const m_XK_braille_dots_1568 = 0x10028b1
const m_XK_braille_dots_157 = 0x1002851
const m_XK_braille_dots_1578 = 0x10028d1
const m_XK_braille_dots_158 = 0x1002891
const m_XK_braille_dots_16 = 0x1002821
const m_XK_braille_dots_167 = 0x1002861
const m_XK_braille_dots_1678 = 0x10028e1
const m_XK_braille_dots_168 = 0x10028a1
const m_XK_braille_dots_17 = 0x1002841
const m_XK_braille_dots_178 = 0x10028c1
const m_XK_braille_dots_18 = 0x1002881
const m_XK_braille_dots_2 = 0x1002802
const m_XK_braille_dots_23 = 0x1002806
const m_XK_braille_dots_234 = 0x100280e
const m_XK_braille_dots_2345 = 0x100281e
const m_XK_braille_dots_23456 = 0x100283e
const m_XK_braille_dots_234567 = 0x100287e
const m_XK_braille_dots_2345678 = 0x10028fe
const m_XK_braille_dots_234568 = 0x10028be
const m_XK_braille_dots_23457 = 0x100285e
const m_XK_braille_dots_234578 = 0x10028de
const m_XK_braille_dots_23458 = 0x100289e
const m_XK_braille_dots_2346 = 0x100282e
const m_XK_braille_dots_23467 = 0x100286e
const m_XK_braille_dots_234678 = 0x10028ee
const m_XK_braille_dots_23468 = 0x10028ae
const m_XK_braille_dots_2347 = 0x100284e
const m_XK_braille_dots_23478 = 0x10028ce
const m_XK_braille_dots_2348 = 0x100288e
const m_XK_braille_dots_235 = 0x1002816
const m_XK_braille_dots_2356 = 0x1002836
const m_XK_braille_dots_23567 = 0x1002876
const m_XK_braille_dots_235678 = 0x10028f6
const m_XK_braille_dots_23568 = 0x10028b6
const m_XK_braille_dots_2357 = 0x1002856
const m_XK_braille_dots_23578 = 0x10028d6
const m_XK_braille_dots_2358 = 0x1002896
const m_XK_braille_dots_236 = 0x1002826
const m_XK_braille_dots_2367 = 0x1002866
const m_XK_braille_dots_23678 = 0x10028e6
const m_XK_braille_dots_2368 = 0x10028a6
const m_XK_braille_dots_237 = 0x1002846
const m_XK_braille_dots_2378 = 0x10028c6
const m_XK_braille_dots_238 = 0x1002886
const m_XK_braille_dots_24 = 0x100280a
const m_XK_braille_dots_245 = 0x100281a
const m_XK_braille_dots_2456 = 0x100283a
const m_XK_braille_dots_24567 = 0x100287a
const m_XK_braille_dots_245678 = 0x10028fa
const m_XK_braille_dots_24568 = 0x10028ba
const m_XK_braille_dots_2457 = 0x100285a
const m_XK_braille_dots_24578 = 0x10028da
const m_XK_braille_dots_2458 = 0x100289a
const m_XK_braille_dots_246 = 0x100282a
const m_XK_braille_dots_2467 = 0x100286a
const m_XK_braille_dots_24678 = 0x10028ea
const m_XK_braille_dots_2468 = 0x10028aa
const m_XK_braille_dots_247 = 0x100284a
const m_XK_braille_dots_2478 = 0x10028ca
const m_XK_braille_dots_248 = 0x100288a
const m_XK_braille_dots_25 = 0x1002812
const m_XK_braille_dots_256 = 0x1002832
const m_XK_braille_dots_2567 = 0x1002872
const m_XK_braille_dots_25678 = 0x10028f2
const m_XK_braille_dots_2568 = 0x10028b2
const m_XK_braille_dots_257 = 0x1002852
const m_XK_braille_dots_2578 = 0x10028d2
const m_XK_braille_dots_258 = 0x1002892
const m_XK_braille_dots_26 = 0x1002822
const m_XK_braille_dots_267 = 0x1002862
const m_XK_braille_dots_2678 = 0x10028e2
const m_XK_braille_dots_268 = 0x10028a2
const m_XK_braille_dots_27 = 0x1002842
const m_XK_braille_dots_278 = 0x10028c2
const m_XK_braille_dots_28 = 0x1002882
const m_XK_braille_dots_3 = 0x1002804
const m_XK_braille_dots_34 = 0x100280c
const m_XK_braille_dots_345 = 0x100281c
const m_XK_braille_dots_3456 = 0x100283c
const m_XK_braille_dots_34567 = 0x100287c
const m_XK_braille_dots_345678 = 0x10028fc
const m_XK_braille_dots_34568 = 0x10028bc
const m_XK_braille_dots_3457 = 0x100285c
const m_XK_braille_dots_34578 = 0x10028dc
const m_XK_braille_dots_3458 = 0x100289c
const m_XK_braille_dots_346 = 0x100282c
const m_XK_braille_dots_3467 = 0x100286c
const m_XK_braille_dots_34678 = 0x10028ec
const m_XK_braille_dots_3468 = 0x10028ac
const m_XK_braille_dots_347 = 0x100284c
const m_XK_braille_dots_3478 = 0x10028cc
const m_XK_braille_dots_348 = 0x100288c
const m_XK_braille_dots_35 = 0x1002814
const m_XK_braille_dots_356 = 0x1002834
const m_XK_braille_dots_3567 = 0x1002874
const m_XK_braille_dots_35678 = 0x10028f4
const m_XK_braille_dots_3568 = 0x10028b4
const m_XK_braille_dots_357 = 0x1002854
const m_XK_braille_dots_3578 = 0x10028d4
const m_XK_braille_dots_358 = 0x1002894
const m_XK_braille_dots_36 = 0x1002824
const m_XK_braille_dots_367 = 0x1002864
const m_XK_braille_dots_3678 = 0x10028e4
const m_XK_braille_dots_368 = 0x10028a4
const m_XK_braille_dots_37 = 0x1002844
const m_XK_braille_dots_378 = 0x10028c4
const m_XK_braille_dots_38 = 0x1002884
const m_XK_braille_dots_4 = 0x1002808
const m_XK_braille_dots_45 = 0x1002818
const m_XK_braille_dots_456 = 0x1002838
const m_XK_braille_dots_4567 = 0x1002878
const m_XK_braille_dots_45678 = 0x10028f8
const m_XK_braille_dots_4568 = 0x10028b8
const m_XK_braille_dots_457 = 0x1002858
const m_XK_braille_dots_4578 = 0x10028d8
const m_XK_braille_dots_458 = 0x1002898
const m_XK_braille_dots_46 = 0x1002828
const m_XK_braille_dots_467 = 0x1002868
const m_XK_braille_dots_4678 = 0x10028e8
const m_XK_braille_dots_468 = 0x10028a8
const m_XK_braille_dots_47 = 0x1002848
const m_XK_braille_dots_478 = 0x10028c8
const m_XK_braille_dots_48 = 0x1002888
const m_XK_braille_dots_5 = 0x1002810
const m_XK_braille_dots_56 = 0x1002830
const m_XK_braille_dots_567 = 0x1002870
const m_XK_braille_dots_5678 = 0x10028f0
const m_XK_braille_dots_568 = 0x10028b0
const m_XK_braille_dots_57 = 0x1002850
const m_XK_braille_dots_578 = 0x10028d0
const m_XK_braille_dots_58 = 0x1002890
const m_XK_braille_dots_6 = 0x1002820
const m_XK_braille_dots_67 = 0x1002860
const m_XK_braille_dots_678 = 0x10028e0
const m_XK_braille_dots_68 = 0x10028a0
const m_XK_braille_dots_7 = 0x1002840
const m_XK_braille_dots_78 = 0x10028c0
const m_XK_braille_dots_8 = 0x1002880
const m_XK_breve = 0x01a2
const m_XK_brokenbar = 0x00a6
const m_XK_c = 0x0063
const m_XK_c_h = 0xfea3
const m_XK_cabovedot = 0x02e5
const m_XK_cacute = 0x01e6
const m_XK_caron = 0x01b7
const m_XK_ccaron = 0x01e8
const m_XK_ccedilla = 0x00e7
const m_XK_ccircumflex = 0x02e6
const m_XK_cedilla = 0x00b8
const m_XK_cent = 0x00a2
const m_XK_ch = 0xfea0
const m_XK_colon = 0x003a
const m_XK_combining_acute = 0x1000301
const m_XK_combining_belowdot = 0x1000323
const m_XK_combining_grave = 0x1000300
const m_XK_combining_hook = 0x1000309
const m_XK_combining_tilde = 0x1000303
const m_XK_comma = 0x002c
const m_XK_containsas = 0x100220B
const m_XK_copyright = 0x00a9
const m_XK_cuberoot = 0x100221B
const m_XK_currency = 0x00a4
const m_XK_d = 0x0064
const m_XK_dabovedot = 0x1001e0b
const m_XK_dcaron = 0x01ef
const m_XK_dead_A = 0xfe81
const m_XK_dead_E = 0xfe83
const m_XK_dead_I = 0xfe85
const m_XK_dead_O = 0xfe87
const m_XK_dead_U = 0xfe89
const m_XK_dead_a = 0xfe80
const m_XK_dead_abovecomma = 0xfe64
const m_XK_dead_abovedot = 0xfe56
const m_XK_dead_abovereversedcomma = 0xfe65
const m_XK_dead_abovering = 0xfe58
const m_XK_dead_aboveverticalline = 0xfe91
const m_XK_dead_acute = 0xfe51
const m_XK_dead_belowbreve = 0xfe6b
const m_XK_dead_belowcircumflex = 0xfe69
const m_XK_dead_belowcomma = 0xfe6e
const m_XK_dead_belowdiaeresis = 0xfe6c
const m_XK_dead_belowdot = 0xfe60
const m_XK_dead_belowmacron = 0xfe68
const m_XK_dead_belowring = 0xfe67
const m_XK_dead_belowtilde = 0xfe6a
const m_XK_dead_belowverticalline = 0xfe92
const m_XK_dead_breve = 0xfe55
const m_XK_dead_capital_schwa = 0xfe8b
const m_XK_dead_caron = 0xfe5a
const m_XK_dead_cedilla = 0xfe5b
const m_XK_dead_circumflex = 0xfe52
const m_XK_dead_currency = 0xfe6f
const m_XK_dead_dasia = 0xfe65
const m_XK_dead_diaeresis = 0xfe57
const m_XK_dead_doubleacute = 0xfe59
const m_XK_dead_doublegrave = 0xfe66
const m_XK_dead_e = 0xfe82
const m_XK_dead_grave = 0xfe50
const m_XK_dead_greek = 0xfe8c
const m_XK_dead_hook = 0xfe61
const m_XK_dead_horn = 0xfe62
const m_XK_dead_i = 0xfe84
const m_XK_dead_invertedbreve = 0xfe6d
const m_XK_dead_iota = 0xfe5d
const m_XK_dead_longsolidusoverlay = 0xfe93
const m_XK_dead_lowline = 0xfe90
const m_XK_dead_macron = 0xfe54
const m_XK_dead_o = 0xfe86
const m_XK_dead_ogonek = 0xfe5c
const m_XK_dead_perispomeni = 0xfe53
const m_XK_dead_psili = 0xfe64
const m_XK_dead_semivoiced_sound = 0xfe5f
const m_XK_dead_small_schwa = 0xfe8a
const m_XK_dead_stroke = 0xfe63
const m_XK_dead_tilde = 0xfe53
const m_XK_dead_u = 0xfe88
const m_XK_dead_voiced_sound = 0xfe5e
const m_XK_degree = 0x00b0
const m_XK_diaeresis = 0x00a8
const m_XK_dintegral = 0x100222C
const m_XK_division = 0x00f7
const m_XK_dollar = 0x0024
const m_XK_doubleacute = 0x01bd
const m_XK_dstroke = 0x01f0
const m_XK_e = 0x0065
const m_XK_eabovedot = 0x03ec
const m_XK_eacute = 0x00e9
const m_XK_ebelowdot = 0x1001eb9
const m_XK_ecaron = 0x01ec
const m_XK_ecircumflex = 0x00ea
const m_XK_ecircumflexacute = 0x1001ebf
const m_XK_ecircumflexbelowdot = 0x1001ec7
const m_XK_ecircumflexgrave = 0x1001ec1
const m_XK_ecircumflexhook = 0x1001ec3
const m_XK_ecircumflextilde = 0x1001ec5
const m_XK_ediaeresis = 0x00eb
const m_XK_egrave = 0x00e8
const m_XK_ehook = 0x1001ebb
const m_XK_eightsubscript = 0x1002088
const m_XK_eightsuperior = 0x1002078
const m_XK_elementof = 0x1002208
const m_XK_emacron = 0x03ba
const m_XK_emptyset = 0x1002205
const m_XK_eng = 0x03bf
const m_XK_eogonek = 0x01ea
const m_XK_equal = 0x003d
const m_XK_eth = 0x00f0
const m_XK_etilde = 0x1001ebd
const m_XK_exclam = 0x0021
const m_XK_exclamdown = 0x00a1
const m_XK_ezh = 0x1000292
const m_XK_f = 0x0066
const m_XK_fabovedot = 0x1001e1f
const m_XK_fivesubscript = 0x1002085
const m_XK_fivesuperior = 0x1002075
const m_XK_foursubscript = 0x1002084
const m_XK_foursuperior = 0x1002074
const m_XK_fourthroot = 0x100221C
const m_XK_g = 0x0067
const m_XK_gabovedot = 0x02f5
const m_XK_gbreve = 0x02bb
const m_XK_gcaron = 0x10001e7
const m_XK_gcedilla = 0x03bb
const m_XK_gcircumflex = 0x02f8
const m_XK_grave = 0x0060
const m_XK_greater = 0x003e
const m_XK_guillemotleft = 0x00ab
const m_XK_guillemotright = 0x00bb
const m_XK_h = 0x0068
const m_XK_hcircumflex = 0x02b6
const m_XK_hebrew_aleph = 0x0ce0
const m_XK_hebrew_ayin = 0x0cf2
const m_XK_hebrew_bet = 0x0ce1
const m_XK_hebrew_beth = 0x0ce1
const m_XK_hebrew_chet = 0x0ce7
const m_XK_hebrew_dalet = 0x0ce3
const m_XK_hebrew_daleth = 0x0ce3
const m_XK_hebrew_doublelowline = 0x0cdf
const m_XK_hebrew_finalkaph = 0x0cea
const m_XK_hebrew_finalmem = 0x0ced
const m_XK_hebrew_finalnun = 0x0cef
const m_XK_hebrew_finalpe = 0x0cf3
const m_XK_hebrew_finalzade = 0x0cf5
const m_XK_hebrew_finalzadi = 0x0cf5
const m_XK_hebrew_gimel = 0x0ce2
const m_XK_hebrew_gimmel = 0x0ce2
const m_XK_hebrew_he = 0x0ce4
const m_XK_hebrew_het = 0x0ce7
const m_XK_hebrew_kaph = 0x0ceb
const m_XK_hebrew_kuf = 0x0cf7
const m_XK_hebrew_lamed = 0x0cec
const m_XK_hebrew_mem = 0x0cee
const m_XK_hebrew_nun = 0x0cf0
const m_XK_hebrew_pe = 0x0cf4
const m_XK_hebrew_qoph = 0x0cf7
const m_XK_hebrew_resh = 0x0cf8
const m_XK_hebrew_samech = 0x0cf1
const m_XK_hebrew_samekh = 0x0cf1
const m_XK_hebrew_shin = 0x0cf9
const m_XK_hebrew_taf = 0x0cfa
const m_XK_hebrew_taw = 0x0cfa
const m_XK_hebrew_tet = 0x0ce8
const m_XK_hebrew_teth = 0x0ce8
const m_XK_hebrew_waw = 0x0ce5
const m_XK_hebrew_yod = 0x0ce9
const m_XK_hebrew_zade = 0x0cf6
const m_XK_hebrew_zadi = 0x0cf6
const m_XK_hebrew_zain = 0x0ce6
const m_XK_hebrew_zayin = 0x0ce6
const m_XK_hstroke = 0x02b1
const m_XK_hyphen = 0x00ad
const m_XK_i = 0x0069
const m_XK_iacute = 0x00ed
const m_XK_ibelowdot = 0x1001ecb
const m_XK_ibreve = 0x100012d
const m_XK_icircumflex = 0x00ee
const m_XK_idiaeresis = 0x00ef
const m_XK_idotless = 0x02b9
const m_XK_igrave = 0x00ec
const m_XK_ihook = 0x1001ec9
const m_XK_imacron = 0x03ef
const m_XK_iogonek = 0x03e7
const m_XK_itilde = 0x03b5
const m_XK_j = 0x006a
const m_XK_jcircumflex = 0x02bc
const m_XK_k = 0x006b
const m_XK_kana_A = 0x04b1
const m_XK_kana_CHI = 0x04c1
const m_XK_kana_E = 0x04b4
const m_XK_kana_FU = 0x04cc
const m_XK_kana_HA = 0x04ca
const m_XK_kana_HE = 0x04cd
const m_XK_kana_HI = 0x04cb
const m_XK_kana_HO = 0x04ce
const m_XK_kana_HU = 0x04cc
const m_XK_kana_I = 0x04b2
const m_XK_kana_KA = 0x04b6
const m_XK_kana_KE = 0x04b9
const m_XK_kana_KI = 0x04b7
const m_XK_kana_KO = 0x04ba
const m_XK_kana_KU = 0x04b8
const m_XK_kana_MA = 0x04cf
const m_XK_kana_ME = 0x04d2
const m_XK_kana_MI = 0x04d0
const m_XK_kana_MO = 0x04d3
const m_XK_kana_MU = 0x04d1
const m_XK_kana_N = 0x04dd
const m_XK_kana_NA = 0x04c5
const m_XK_kana_NE = 0x04c8
const m_XK_kana_NI = 0x04c6
const m_XK_kana_NO = 0x04c9
const m_XK_kana_NU = 0x04c7
const m_XK_kana_O = 0x04b5
const m_XK_kana_RA = 0x04d7
const m_XK_kana_RE = 0x04da
const m_XK_kana_RI = 0x04d8
const m_XK_kana_RO = 0x04db
const m_XK_kana_RU = 0x04d9
const m_XK_kana_SA = 0x04bb
const m_XK_kana_SE = 0x04be
const m_XK_kana_SHI = 0x04bc
const m_XK_kana_SO = 0x04bf
const m_XK_kana_SU = 0x04bd
const m_XK_kana_TA = 0x04c0
const m_XK_kana_TE = 0x04c3
const m_XK_kana_TI = 0x04c1
const m_XK_kana_TO = 0x04c4
const m_XK_kana_TSU = 0x04c2
const m_XK_kana_TU = 0x04c2
const m_XK_kana_U = 0x04b3
const m_XK_kana_WA = 0x04dc
const m_XK_kana_WO = 0x04a6
const m_XK_kana_YA = 0x04d4
const m_XK_kana_YO = 0x04d6
const m_XK_kana_YU = 0x04d5
const m_XK_kana_a = 0x04a7
const m_XK_kana_closingbracket = 0x04a3
const m_XK_kana_comma = 0x04a4
const m_XK_kana_conjunctive = 0x04a5
const m_XK_kana_e = 0x04aa
const m_XK_kana_fullstop = 0x04a1
const m_XK_kana_i = 0x04a8
const m_XK_kana_middledot = 0x04a5
const m_XK_kana_o = 0x04ab
const m_XK_kana_openingbracket = 0x04a2
const m_XK_kana_switch = 0xff7e
const m_XK_kana_tsu = 0x04af
const m_XK_kana_tu = 0x04af
const m_XK_kana_u = 0x04a9
const m_XK_kana_ya = 0x04ac
const m_XK_kana_yo = 0x04ae
const m_XK_kana_yu = 0x04ad
const m_XK_kappa = 0x03a2
const m_XK_kcedilla = 0x03f3
const m_XK_kra = 0x03a2
const m_XK_l = 0x006c
const m_XK_lacute = 0x01e5
const m_XK_lbelowdot = 0x1001e37
const m_XK_lcaron = 0x01b5
const m_XK_lcedilla = 0x03b6
const m_XK_less = 0x003c
const m_XK_lstroke = 0x01b3
const m_XK_m = 0x006d
const m_XK_mabovedot = 0x1001e41
const m_XK_macron = 0x00af
const m_XK_masculine = 0x00ba
const m_XK_minus = 0x002d
const m_XK_mu = 0x00b5
const m_XK_multiply = 0x00d7
const m_XK_n = 0x006e
const m_XK_nacute = 0x01f1
const m_XK_ncaron = 0x01f2
const m_XK_ncedilla = 0x03f1
const m_XK_ninesubscript = 0x1002089
const m_XK_ninesuperior = 0x1002079
const m_XK_nobreakspace = 0x00a0
const m_XK_notapproxeq = 0x1002247
const m_XK_notelementof = 0x1002209
const m_XK_notidentical = 0x1002262
const m_XK_notsign = 0x00ac
const m_XK_ntilde = 0x00f1
const m_XK_numbersign = 0x0023
const m_XK_numerosign = 0x06b0
const m_XK_o = 0x006f
const m_XK_oacute = 0x00f3
const m_XK_obarred = 0x1000275
const m_XK_obelowdot = 0x1001ecd
const m_XK_ocaron = 0x10001d2
const m_XK_ocircumflex = 0x00f4
const m_XK_ocircumflexacute = 0x1001ed1
const m_XK_ocircumflexbelowdot = 0x1001ed9
const m_XK_ocircumflexgrave = 0x1001ed3
const m_XK_ocircumflexhook = 0x1001ed5
const m_XK_ocircumflextilde = 0x1001ed7
const m_XK_odiaeresis = 0x00f6
const m_XK_odoubleacute = 0x01f5
const m_XK_oe = 0x13bd
const m_XK_ogonek = 0x01b2
const m_XK_ograve = 0x00f2
const m_XK_ohook = 0x1001ecf
const m_XK_ohorn = 0x10001a1
const m_XK_ohornacute = 0x1001edb
const m_XK_ohornbelowdot = 0x1001ee3
const m_XK_ohorngrave = 0x1001edd
const m_XK_ohornhook = 0x1001edf
const m_XK_ohorntilde = 0x1001ee1
const m_XK_omacron = 0x03f2
const m_XK_onehalf = 0x00bd
const m_XK_onequarter = 0x00bc
const m_XK_onesubscript = 0x1002081
const m_XK_onesuperior = 0x00b9
const m_XK_ooblique = 0x00f8
const m_XK_ordfeminine = 0x00aa
const m_XK_oslash = 0x00f8
const m_XK_otilde = 0x00f5
const m_XK_overline = 0x047e
const m_XK_p = 0x0070
const m_XK_pabovedot = 0x1001e57
const m_XK_paragraph = 0x00b6
const m_XK_parenleft = 0x0028
const m_XK_parenright = 0x0029
const m_XK_partdifferential = 0x1002202
const m_XK_percent = 0x0025
const m_XK_period = 0x002e
const m_XK_periodcentered = 0x00b7
const m_XK_plus = 0x002b
const m_XK_plusminus = 0x00b1
const m_XK_prolongedsound = 0x04b0
const m_XK_q = 0x0071
const m_XK_question = 0x003f
const m_XK_questiondown = 0x00bf
const m_XK_quotedbl = 0x0022
const m_XK_quoteleft = 0x0060
const m_XK_quoteright = 0x0027
const m_XK_r = 0x0072
const m_XK_racute = 0x01e0
const m_XK_rcaron = 0x01f8
const m_XK_rcedilla = 0x03b3
const m_XK_registered = 0x00ae
const m_XK_s = 0x0073
const m_XK_sabovedot = 0x1001e61
const m_XK_sacute = 0x01b6
const m_XK_scaron = 0x01b9
const m_XK_scedilla = 0x01ba
const m_XK_schwa = 0x1000259
const m_XK_scircumflex = 0x02fe
const m_XK_script_switch = 0xff7e
const m_XK_section = 0x00a7
const m_XK_semicolon = 0x003b
const m_XK_semivoicedsound = 0x04df
const m_XK_sevensubscript = 0x1002087
const m_XK_sevensuperior = 0x1002077
const m_XK_sixsubscript = 0x1002086
const m_XK_sixsuperior = 0x1002076
const m_XK_slash = 0x002f
const m_XK_space = 0x0020
const m_XK_squareroot = 0x100221A
const m_XK_ssharp = 0x00df
const m_XK_sterling = 0x00a3
const m_XK_stricteq = 0x1002263
const m_XK_t = 0x0074
const m_XK_tabovedot = 0x1001e6b
const m_XK_tcaron = 0x01bb
const m_XK_tcedilla = 0x01fe
const m_XK_thorn = 0x00fe
const m_XK_threequarters = 0x00be
const m_XK_threesubscript = 0x1002083
const m_XK_threesuperior = 0x00b3
const m_XK_tintegral = 0x100222D
const m_XK_tslash = 0x03bc
const m_XK_twosubscript = 0x1002082
const m_XK_twosuperior = 0x00b2
const m_XK_u = 0x0075
const m_XK_uacute = 0x00fa
const m_XK_ubelowdot = 0x1001ee5
const m_XK_ubreve = 0x02fd
const m_XK_ucircumflex = 0x00fb
const m_XK_udiaeresis = 0x00fc
const m_XK_udoubleacute = 0x01fb
const m_XK_ugrave = 0x00f9
const m_XK_uhook = 0x1001ee7
const m_XK_uhorn = 0x10001b0
const m_XK_uhornacute = 0x1001ee9
const m_XK_uhornbelowdot = 0x1001ef1
const m_XK_uhorngrave = 0x1001eeb
const m_XK_uhornhook = 0x1001eed
const m_XK_uhorntilde = 0x1001eef
const m_XK_umacron = 0x03fe
const m_XK_underscore = 0x005f
const m_XK_uogonek = 0x03f9
const m_XK_uring = 0x01f9
const m_XK_utilde = 0x03fd
const m_XK_v = 0x0076
const m_XK_voicedsound = 0x04de
const m_XK_w = 0x0077
const m_XK_wacute = 0x1001e83
const m_XK_wcircumflex = 0x1000175
const m_XK_wdiaeresis = 0x1001e85
const m_XK_wgrave = 0x1001e81
const m_XK_x = 0x0078
const m_XK_xabovedot = 0x1001e8b
const m_XK_y = 0x0079
const m_XK_yacute = 0x00fd
const m_XK_ybelowdot = 0x1001ef5
const m_XK_ycircumflex = 0x1000177
const m_XK_ydiaeresis = 0x00ff
const m_XK_yen = 0x00a5
const m_XK_ygrave = 0x1001ef3
const m_XK_yhook = 0x1001ef7
const m_XK_ytilde = 0x1001ef9
const m_XK_z = 0x007a
const m_XK_zabovedot = 0x01bf
const m_XK_zacute = 0x01bc
const m_XK_zcaron = 0x01be
const m_XK_zerosubscript = 0x1002080
const m_XK_zerosuperior = 0x1002070
const m_XK_zstroke = 0x10001b6
const m_XLookupBoth = 4
const m_XLookupChars = 2
const m_XLookupKeySym = 3
const m_XLookupNone = 1
const m_XMD_H = 1
const m_XMUTEX_INITIALIZER = "PTHREAD_MUTEX_INITIALIZER"
const m_XNArea = "area"
const m_XNAreaNeeded = "areaNeeded"
const m_XNBackground = "background"
const m_XNBackgroundPixmap = "backgroundPixmap"
const m_XNBaseFontName = "baseFontName"
const m_XNClientWindow = "clientWindow"
const m_XNColormap = "colorMap"
const m_XNContextualDrawing = "contextualDrawing"
const m_XNCursor = "cursor"
const m_XNDefaultString = "defaultString"
const m_XNDestroyCallback = "destroyCallback"
const m_XNDirectionalDependentDrawing = "directionalDependentDrawing"
const m_XNFilterEvents = "filterEvents"
const m_XNFocusWindow = "focusWindow"
const m_XNFontInfo = "fontInfo"
const m_XNFontSet = "fontSet"
const m_XNForeground = "foreground"
const m_XNGeometryCallback = "geometryCallback"
const m_XNHotKey = "hotKey"
const m_XNHotKeyState = "hotKeyState"
const m_XNInputStyle = "inputStyle"
const m_XNLineSpace = "lineSpace"
const m_XNMissingCharSet = "missingCharSet"
const m_XNOMAutomatic = "omAutomatic"
const m_XNOrientation = "orientation"
const m_XNPreeditAttributes = "preeditAttributes"
const m_XNPreeditCaretCallback = "preeditCaretCallback"
const m_XNPreeditDoneCallback = "preeditDoneCallback"
const m_XNPreeditDrawCallback = "preeditDrawCallback"
const m_XNPreeditStartCallback = "preeditStartCallback"
const m_XNPreeditState = "preeditState"
const m_XNPreeditStateNotifyCallback = "preeditStateNotifyCallback"
const m_XNQueryICValuesList = "queryICValuesList"
const m_XNQueryIMValuesList = "queryIMValuesList"
const m_XNQueryInputStyle = "queryInputStyle"
const m_XNQueryOrientation = "queryOrientation"
const m_XNR6PreeditCallback = "r6PreeditCallback"
const m_XNRequiredCharSet = "requiredCharSet"
const m_XNResetState = "resetState"
const m_XNResourceClass = "resourceClass"
const m_XNResourceName = "resourceName"
const m_XNSeparatorofNestedList = "separatorofNestedList"
const m_XNSpotLocation = "spotLocation"
const m_XNStatusAttributes = "statusAttributes"
const m_XNStatusDoneCallback = "statusDoneCallback"
const m_XNStatusDrawCallback = "statusDrawCallback"
const m_XNStatusStartCallback = "statusStartCallback"
const m_XNStdColormap = "stdColorMap"
const m_XNStringConversion = "stringConversion"
const m_XNStringConversionCallback = "stringConversionCallback"
const m_XNVaNestedList = "XNVaNestedList"
const m_XNVisiblePosition = "visiblePosition"
const m_XNegative = 0x0010
const m_XTHREADS = 1
const m_XUSE_MTSAFE_API = 1
const m_XValue = 0x0001
const m_XYBitmap = 0
const m_XYPixmap = 1
const m_X_AllocColor = 84
const m_X_AllocColorCells = 86
const m_X_AllocColorPlanes = 87
const m_X_AllocNamedColor = 85
const m_X_AllowEvents = 35
const m_X_Bell = 104
const m_X_ChangeActivePointerGrab = 30
const m_X_ChangeGC = 56
const m_X_ChangeHosts = 109
const m_X_ChangeKeyboardControl = 102
const m_X_ChangeKeyboardMapping = 100
const m_X_ChangePointerControl = 105
const m_X_ChangeProperty = 18
const m_X_ChangeSaveSet = 6
const m_X_ChangeWindowAttributes = 2
const m_X_CirculateWindow = 13
const m_X_ClearArea = 61
const m_X_CloseFont = 46
const m_X_ConfigureWindow = 12
const m_X_ConvertSelection = 24
const m_X_CopyArea = 62
const m_X_CopyColormapAndFree = 80
const m_X_CopyGC = 57
const m_X_CopyPlane = 63
const m_X_CreateColormap = 78
const m_X_CreateCursor = 93
const m_X_CreateGC = 55
const m_X_CreateGlyphCursor = 94
const m_X_CreatePixmap = 53
const m_X_CreateWindow = 1
const m_X_DeleteProperty = 19
const m_X_DestroySubwindows = 5
const m_X_DestroyWindow = 4
const m_X_Error = 0
const m_X_FillPoly = 69
const m_X_ForceScreenSaver = 115
const m_X_FreeColormap = 79
const m_X_FreeColors = 88
const m_X_FreeCursor = 95
const m_X_FreeGC = 60
const m_X_FreePixmap = 54
const m_X_GetAtomName = 17
const m_X_GetFontPath = 52
const m_X_GetGeometry = 14
const m_X_GetImage = 73
const m_X_GetInputFocus = 43
const m_X_GetKeyboardControl = 103
const m_X_GetKeyboardMapping = 101
const m_X_GetModifierMapping = 119
const m_X_GetMotionEvents = 39
const m_X_GetPointerControl = 106
const m_X_GetPointerMapping = 117
const m_X_GetProperty = 20
const m_X_GetScreenSaver = 108
const m_X_GetSelectionOwner = 23
const m_X_GetWindowAttributes = 3
const m_X_GrabButton = 28
const m_X_GrabKey = 33
const m_X_GrabKeyboard = 31
const m_X_GrabPointer = 26
const m_X_GrabServer = 36
const m_X_HAVE_UTF8_STRING = 1
const m_X_ImageText16 = 77
const m_X_ImageText8 = 76
const m_X_InstallColormap = 81
const m_X_InternAtom = 16
const m_X_KillClient = 113
const m_X_ListExtensions = 99
const m_X_ListFonts = 49
const m_X_ListFontsWithInfo = 50
const m_X_ListHosts = 110
const m_X_ListInstalledColormaps = 83
const m_X_ListProperties = 21
const m_X_LookupColor = 92
const m_X_MapSubwindows = 9
const m_X_MapWindow = 8
const m_X_NoOperation = 127
const m_X_OpenFont = 45
const m_X_PROTOCOL = 11
const m_X_PROTOCOL_REVISION = 0
const m_X_PolyArc = 68
const m_X_PolyFillArc = 71
const m_X_PolyFillRectangle = 70
const m_X_PolyLine = 65
const m_X_PolyPoint = 64
const m_X_PolyRectangle = 67
const m_X_PolySegment = 66
const m_X_PolyText16 = 75
const m_X_PolyText8 = 74
const m_X_PutImage = 72
const m_X_QueryBestSize = 97
const m_X_QueryColors = 91
const m_X_QueryExtension = 98
const m_X_QueryFont = 47
const m_X_QueryKeymap = 44
const m_X_QueryPointer = 38
const m_X_QueryTextExtents = 48
const m_X_QueryTree = 15
const m_X_RecolorCursor = 96
const m_X_RenderAddGlyphs = 20
const m_X_RenderAddGlyphsFromPicture = 21
const m_X_RenderAddTraps = 32
const m_X_RenderChangePicture = 5
const m_X_RenderColorTrapezoids = 14
const m_X_RenderColorTriangles = 15
const m_X_RenderComposite = 8
const m_X_RenderCompositeGlyphs16 = 24
const m_X_RenderCompositeGlyphs32 = 25
const m_X_RenderCompositeGlyphs8 = 23
const m_X_RenderCreateAnimCursor = 31
const m_X_RenderCreateConicalGradient = 36
const m_X_RenderCreateCursor = 27
const m_X_RenderCreateGlyphSet = 17
const m_X_RenderCreateLinearGradient = 34
const m_X_RenderCreatePicture = 4
const m_X_RenderCreateRadialGradient = 35
const m_X_RenderCreateSolidFill = 33
const m_X_RenderFillRectangles = 26
const m_X_RenderFreeGlyphSet = 19
const m_X_RenderFreeGlyphs = 22
const m_X_RenderFreePicture = 7
const m_X_RenderQueryDithers = 3
const m_X_RenderQueryFilters = 29
const m_X_RenderQueryPictFormats = 1
const m_X_RenderQueryPictIndexValues = 2
const m_X_RenderQueryVersion = 0
const m_X_RenderReferenceGlyphSet = 18
const m_X_RenderScale = 9
const m_X_RenderSetPictureClipRectangles = 6
const m_X_RenderSetPictureFilter = 30
const m_X_RenderSetPictureTransform = 28
const m_X_RenderTrapezoids = 10
const m_X_RenderTriFan = 13
const m_X_RenderTriStrip = 12
const m_X_RenderTriangles = 11
const m_X_ReparentWindow = 7
const m_X_Reply = 1
const m_X_RotateProperties = 114
const m_X_SendEvent = 25
const m_X_SetAccessControl = 111
const m_X_SetClipRectangles = 59
const m_X_SetCloseDownMode = 112
const m_X_SetDashes = 58
const m_X_SetFontPath = 51
const m_X_SetInputFocus = 42
const m_X_SetModifierMapping = 118
const m_X_SetPointerMapping = 116
const m_X_SetScreenSaver = 107
const m_X_SetSelectionOwner = 22
const m_X_StoreColors = 89
const m_X_StoreNamedColor = 90
const m_X_TCP_PORT = 6000
const m_X_TranslateCoords = 40
const m_X_UngrabButton = 29
const m_X_UngrabKey = 34
const m_X_UngrabKeyboard = 32
const m_X_UngrabPointer = 27
const m_X_UngrabServer = 37
const m_X_UninstallColormap = 82
const m_X_UnmapSubwindows = 11
const m_X_UnmapWindow = 10
const m_X_WarpPointer = 41
const m_XftVersion = "XFT_VERSION"
const m_XlibSpecificationRelease = 6
const m_YNegative = 0x0020
const m_YSorted = 1
const m_YValue = 0x0002
const m_YXBanded = 3
const m_YXSorted = 2
const m_ZLNSPERBATCH = 1024
const m_ZPixmap = 2
const m_ZRCTSPERBATCH = 256
const m_ZoomState = 2
const m__CTYPE_A = 256
const m__CTYPE_B = 131072
const m__CTYPE_C = 512
const m__CTYPE_D = 1024
const m__CTYPE_G = 2048
const m__CTYPE_I = 524288
const m__CTYPE_L = 4096
const m__CTYPE_P = 8192
const m__CTYPE_Q = 2097152
const m__CTYPE_R = 262144
const m__CTYPE_S = 16384
const m__CTYPE_SW0 = 0x20000000
const m__CTYPE_SW1 = 0x40000000
const m__CTYPE_SW2 = 0x80000000
const m__CTYPE_SW3 = 0xc0000000
const m__CTYPE_SWM = 3758096384
const m__CTYPE_SWS = 30
const m__CTYPE_T = 1048576
const m__CTYPE_U = 32768
const m__CTYPE_X = 65536
const m__DARWIN_FEATURE_64_BIT_INODE = 1
const m__DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1
const m__DARWIN_FEATURE_UNIX_CONFORMANCE = 3
const m__FORTIFY_SOURCE = 2
const m__I386_SIGNAL_H_ = 1
const m__IOFBF = 0
const m__IOLBF = 1
const m__IONBF = 2
const m__LP64 = 1
const m__PTHREAD_COND_SIG_init = 0x3CB0B1BB
const m__PTHREAD_ERRORCHECK_MUTEX_SIG_init = 0x32AAABA1
const m__PTHREAD_FIRSTFIT_MUTEX_SIG_init = 0x32AAABA3
const m__PTHREAD_MUTEX_SIG_init = 0x32AAABA7
const m__PTHREAD_ONCE_SIG_init = 0x30B1BCBA
const m__PTHREAD_RECURSIVE_MUTEX_SIG_init = 0x32AAABA2
const m__PTHREAD_RWLOCK_SIG_init = 0x2DA8B3B4
const m__QUAD_HIGHWORD = 1
const m__QUAD_LOWWORD = 0
const m__RLIMIT_POSIX_FLAG = 0x1000
const m__RUNE_MAGIC_A = "RuneMagA"
const m__STRUCT_MCONTEXT = "_STRUCT_MCONTEXT64"
const m__WSTOPPED = 0177
const m__X11_XLIBINT_H_ = 1
const m__X86_INSTRUCTION_STATE_CACHELINE_SIZE = 64
const m__XBCOPYFUNC = "_Xbcopy"
const m__X_INLINE = "inline"
const m__X_RESTRICT_KYWD = "restrict"
const m__Xconst = "const"
const m___API_TO_BE_DEPRECATED = 100000
const m___API_TO_BE_DEPRECATED_DRIVERKIT = 100000
const m___API_TO_BE_DEPRECATED_IOS = 100000
const m___API_TO_BE_DEPRECATED_MACCATALYST = 100000
const m___API_TO_BE_DEPRECATED_MACOS = 100000
const m___API_TO_BE_DEPRECATED_TVOS = 100000
const m___API_TO_BE_DEPRECATED_VISIONOS = 100000
const m___API_TO_BE_DEPRECATED_WATCHOS = 100000
const m___APPLE_CC__ = 6000
const m___APPLE__ = 1
const m___ATOMIC_ACQUIRE = 2
const m___ATOMIC_ACQ_REL = 4
const m___ATOMIC_CONSUME = 1
const m___ATOMIC_RELAXED = 0
const m___ATOMIC_RELEASE = 3
const m___ATOMIC_SEQ_CST = 5
const m___BIGGEST_ALIGNMENT__ = 16
const m___BITINT_MAXWIDTH__ = 128
const m___BLOCKS__ = 1
const m___BOOL_WIDTH__ = 8
const m___BRIDGEOS_2_0 = 20000
const m___BRIDGEOS_3_0 = 30000
const m___BRIDGEOS_3_1 = 30100
const m___BRIDGEOS_3_4 = 30400
const m___BRIDGEOS_4_0 = 40000
const m___BRIDGEOS_4_1 = 40100
const m___BRIDGEOS_5_0 = 50000
const m___BRIDGEOS_5_1 = 50100
const m___BRIDGEOS_5_3 = 50300
const m___BRIDGEOS_6_0 = 60000
const m___BRIDGEOS_6_2 = 60200
const m___BRIDGEOS_6_4 = 60400
const m___BRIDGEOS_6_5 = 60500
const m___BRIDGEOS_6_6 = 60600
const m___BRIDGEOS_7_0 = 70000
const m___BRIDGEOS_7_1 = 70100
const m___BRIDGEOS_7_2 = 70200
const m___BRIDGEOS_7_3 = 70300
const m___BRIDGEOS_7_4 = 70400
const m___BRIDGEOS_7_6 = 70600
const m___BRIDGEOS_8_0 = 80000
const m___BRIDGEOS_8_1 = 80100
const m___BRIDGEOS_8_2 = 80200
const m___BRIDGEOS_8_3 = 80300
const m___BRIDGEOS_8_4 = 80400
const m___BYTE_ORDER__ = "__ORDER_LITTLE_ENDIAN__"
const m___CCGO__ = 1
const m___CHAR_BIT__ = 8
const m___CLANG_ATOMIC_BOOL_LOCK_FREE = 2
const m___CLANG_ATOMIC_CHAR16_T_LOCK_FREE = 2
const m___CLANG_ATOMIC_CHAR32_T_LOCK_FREE = 2
const m___CLANG_ATOMIC_CHAR_LOCK_FREE = 2
const m___CLANG_ATOMIC_INT_LOCK_FREE = 2
const m___CLANG_ATOMIC_LLONG_LOCK_FREE = 2
const m___CLANG_ATOMIC_LONG_LOCK_FREE = 2
const m___CLANG_ATOMIC_POINTER_LOCK_FREE = 2
const m___CLANG_ATOMIC_SHORT_LOCK_FREE = 2
const m___CLANG_ATOMIC_WCHAR_T_LOCK_FREE = 2
const m___CONSTANT_CFSTRINGS__ = 1
const m___DARWIN_64_BIT_INO_T = 1
const m___DARWIN_BIG_ENDIAN = 4321
const m___DARWIN_BYTE_ORDER = "__DARWIN_LITTLE_ENDIAN"
const m___DARWIN_CTYPE_TOP_inline = "__header_inline"
const m___DARWIN_CTYPE_inline = "__header_inline"
const m___DARWIN_C_ANSI = 010000
const m___DARWIN_C_FULL = 900000
const m___DARWIN_C_LEVEL = "__DARWIN_C_FULL"
const m___DARWIN_FD_SETSIZE = 1024
const m___DARWIN_LITTLE_ENDIAN = 1234
const m___DARWIN_NBBY = 8
const m___DARWIN_NON_CANCELABLE = 0
const m___DARWIN_NO_LONG_LONG = 0
const m___DARWIN_NSIG = 32
const m___DARWIN_ONLY_64_BIT_INO_T = 0
const m___DARWIN_ONLY_UNIX_CONFORMANCE = 1
const m___DARWIN_ONLY_VERS_1050 = 0
const m___DARWIN_PDP_ENDIAN = 3412
const m___DARWIN_SUF_1050 = "$1050"
const m___DARWIN_SUF_64_BIT_INO_T = "$INODE64"
const m___DARWIN_SUF_EXTSN = "$DARWIN_EXTSN"
const m___DARWIN_UNIX03 = 1
const m___DARWIN_VERS_1050 = 1
const m___DARWIN_WCHAR_MAX = "__WCHAR_MAX__"
const m___DBL_DECIMAL_DIG__ = 17
const m___DBL_DENORM_MIN__ = 4.9406564584124654e-324
const m___DBL_DIG__ = 15
const m___DBL_EPSILON__ = 2.2204460492503131e-16
const m___DBL_HAS_DENORM__ = 1
const m___DBL_HAS_INFINITY__ = 1
const m___DBL_HAS_QUIET_NAN__ = 1
const m___DBL_MANT_DIG__ = 53
const m___DBL_MAX_10_EXP__ = 308
const m___DBL_MAX_EXP__ = 1024
const m___DBL_MAX__ = 1.7976931348623157e+308
const m___DBL_MIN__ = 2.2250738585072014e-308
const m___DECIMAL_DIG__ = "__LDBL_DECIMAL_DIG__"
const m___DRIVERKIT_19_0 = 190000
const m___DRIVERKIT_20_0 = 200000
const m___DRIVERKIT_21_0 = 210000
const m___DRIVERKIT_22_0 = 220000
const m___DRIVERKIT_22_4 = 220400
const m___DRIVERKIT_22_5 = 220500
const m___DRIVERKIT_22_6 = 220600
const m___DRIVERKIT_23_0 = 230000
const m___DRIVERKIT_23_1 = 230100
const m___DRIVERKIT_23_2 = 230200
const m___DRIVERKIT_23_3 = 230300
const m___DRIVERKIT_23_4 = 230400
const m___DYNAMIC__ = 1
const m___ENABLE_LEGACY_MAC_AVAILABILITY = 1
const m___ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ = 140000
const m___ENVIRONMENT_OS_VERSION_MIN_REQUIRED__ = 140000
const m___FINITE_MATH_ONLY__ = 0
const m___FLT16_DECIMAL_DIG__ = 5
const m___FLT16_DENORM_MIN__ = 5.9604644775390625e-8
const m___FLT16_DIG__ = 3
const m___FLT16_EPSILON__ = 9.765625e-4
const m___FLT16_HAS_DENORM__ = 1
const m___FLT16_HAS_INFINITY__ = 1
const m___FLT16_HAS_QUIET_NAN__ = 1
const m___FLT16_MANT_DIG__ = 11
const m___FLT16_MAX_10_EXP__ = 4
const m___FLT16_MAX_EXP__ = 16
const m___FLT16_MAX__ = 6.5504e+4
const m___FLT16_MIN__ = 6.103515625e-5
const m___FLT_DECIMAL_DIG__ = 9
const m___FLT_DENORM_MIN__ = 1.40129846e-45
const m___FLT_DIG__ = 6
const m___FLT_EPSILON__ = 1.19209290e-7
const m___FLT_HAS_DENORM__ = 1
const m___FLT_HAS_INFINITY__ = 1
const m___FLT_HAS_QUIET_NAN__ = 1
const m___FLT_MANT_DIG__ = 24
const m___FLT_MAX_10_EXP__ = 38
const m___FLT_MAX_EXP__ = 128
const m___FLT_MAX__ = 3.40282347e+38
const m___FLT_MIN__ = 1.17549435e-38
const m___FLT_RADIX__ = 2
const m___FUNCTION__ = "__func__"
const m___FXSR__ = 1
const m___GCC_ASM_FLAG_OUTPUTS__ = 1
const m___GCC_ATOMIC_BOOL_LOCK_FREE = 2
const m___GCC_ATOMIC_CHAR16_T_LOCK_FREE = 2
const m___GCC_ATOMIC_CHAR32_T_LOCK_FREE = 2
const m___GCC_ATOMIC_CHAR_LOCK_FREE = 2
const m___GCC_ATOMIC_INT_LOCK_FREE = 2
const m___GCC_ATOMIC_LLONG_LOCK_FREE = 2
const m___GCC_ATOMIC_LONG_LOCK_FREE = 2
const m___GCC_ATOMIC_POINTER_LOCK_FREE = 2
const m___GCC_ATOMIC_SHORT_LOCK_FREE = 2
const m___GCC_ATOMIC_TEST_AND_SET_TRUEVAL = 1
const m___GCC_ATOMIC_WCHAR_T_LOCK_FREE = 2
const m___GCC_HAVE_DWARF2_CFI_ASM = 1
const m___GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = 1
const m___GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 = 1
const m___GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = 1
const m___GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = 1
const m___GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = 1
const m___GNUC_MINOR__ = 2
const m___GNUC_PATCHLEVEL__ = 1
const m___GNUC_STDC_INLINE__ = 1
const m___GNUC_VA_LIST = 1
const m___GNUC__ = 4
const m___GXX_ABI_VERSION = 1002
const m___INT16_FMTd__ = "hd"
const m___INT16_FMTi__ = "hi"
const m___INT16_MAX__ = 32767
const m___INT16_TYPE__ = "short"
const m___INT32_FMTd__ = "d"
const m___INT32_FMTi__ = "i"
const m___INT32_MAX__ = 2147483647
const m___INT32_TYPE__ = "int"
const m___INT64_C_SUFFIX__ = "LL"
const m___INT64_FMTd__ = "lld"
const m___INT64_FMTi__ = "lli"
const m___INT64_MAX__ = 9223372036854775807
const m___INT8_FMTd__ = "hhd"
const m___INT8_FMTi__ = "hhi"
const m___INT8_MAX__ = 127
const m___INTMAX_C_SUFFIX__ = "L"
const m___INTMAX_FMTd__ = "ld"
const m___INTMAX_FMTi__ = "li"
const m___INTMAX_MAX__ = 9223372036854775807
const m___INTMAX_WIDTH__ = 64
const m___INTPTR_FMTd__ = "ld"
const m___INTPTR_FMTi__ = "li"
const m___INTPTR_MAX__ = 9223372036854775807
const m___INTPTR_WIDTH__ = 64
const m___INT_FAST16_FMTd__ = "hd"
const m___INT_FAST16_FMTi__ = "hi"
const m___INT_FAST16_MAX__ = 32767
const m___INT_FAST16_TYPE__ = "short"
const m___INT_FAST16_WIDTH__ = 16
const m___INT_FAST32_FMTd__ = "d"
const m___INT_FAST32_FMTi__ = "i"
const m___INT_FAST32_MAX__ = 2147483647
const m___INT_FAST32_TYPE__ = "int"
const m___INT_FAST32_WIDTH__ = 32
const m___INT_FAST64_FMTd__ = "lld"
const m___INT_FAST64_FMTi__ = "lli"
const m___INT_FAST64_MAX__ = 9223372036854775807
const m___INT_FAST64_WIDTH__ = 64
const m___INT_FAST8_FMTd__ = "hhd"
const m___INT_FAST8_FMTi__ = "hhi"
const m___INT_FAST8_MAX__ = 127
const m___INT_FAST8_WIDTH__ = 8
const m___INT_LEAST16_FMTd__ = "hd"
const m___INT_LEAST16_FMTi__ = "hi"
const m___INT_LEAST16_MAX__ = 32767
const m___INT_LEAST16_TYPE__ = "short"
const m___INT_LEAST16_WIDTH__ = 16
const m___INT_LEAST32_FMTd__ = "d"
const m___INT_LEAST32_FMTi__ = "i"
const m___INT_LEAST32_MAX__ = 2147483647
const m___INT_LEAST32_TYPE__ = "int"
const m___INT_LEAST32_WIDTH__ = 32
const m___INT_LEAST64_FMTd__ = "lld"
const m___INT_LEAST64_FMTi__ = "lli"
const m___INT_LEAST64_MAX = "INT64_MAX"
const m___INT_LEAST64_MAX__ = 9223372036854775807
const m___INT_LEAST64_MIN = "INT64_MIN"
const m___INT_LEAST64_WIDTH__ = 64
const m___INT_LEAST8_FMTd__ = "hhd"
const m___INT_LEAST8_FMTi__ = "hhi"
const m___INT_LEAST8_MAX__ = 127
const m___INT_LEAST8_WIDTH__ = 8
const m___INT_MAX__ = 2147483647
const m___INT_WIDTH__ = 32
const m___IPHONE_10_0 = 100000
const m___IPHONE_10_1 = 100100
const m___IPHONE_10_2 = 100200
const m___IPHONE_10_3 = 100300
const m___IPHONE_11_0 = 110000
const m___IPHONE_11_1 = 110100
const m___IPHONE_11_2 = 110200
const m___IPHONE_11_3 = 110300
const m___IPHONE_11_4 = 110400
const m___IPHONE_12_0 = 120000
const m___IPHONE_12_1 = 120100
const m___IPHONE_12_2 = 120200
const m___IPHONE_12_3 = 120300
const m___IPHONE_12_4 = 120400
const m___IPHONE_13_0 = 130000
const m___IPHONE_13_1 = 130100
const m___IPHONE_13_2 = 130200
const m___IPHONE_13_3 = 130300
const m___IPHONE_13_4 = 130400
const m___IPHONE_13_5 = 130500
const m___IPHONE_13_6 = 130600
const m___IPHONE_13_7 = 130700
const m___IPHONE_14_0 = 140000
const m___IPHONE_14_1 = 140100
const m___IPHONE_14_2 = 140200
const m___IPHONE_14_3 = 140300
const m___IPHONE_14_4 = 140400
const m___IPHONE_14_5 = 140500
const m___IPHONE_14_6 = 140600
const m___IPHONE_14_7 = 140700
const m___IPHONE_14_8 = 140800
const m___IPHONE_15_0 = 150000
const m___IPHONE_15_1 = 150100
const m___IPHONE_15_2 = 150200
const m___IPHONE_15_3 = 150300
const m___IPHONE_15_4 = 150400
const m___IPHONE_15_5 = 150500
const m___IPHONE_15_6 = 150600
const m___IPHONE_15_7 = 150700
const m___IPHONE_15_8 = 150800
const m___IPHONE_16_0 = 160000
const m___IPHONE_16_1 = 160100
const m___IPHONE_16_2 = 160200
const m___IPHONE_16_3 = 160300
const m___IPHONE_16_4 = 160400
const m___IPHONE_16_5 = 160500
const m___IPHONE_16_6 = 160600
const m___IPHONE_16_7 = 160700
const m___IPHONE_17_0 = 170000
const m___IPHONE_17_1 = 170100
const m___IPHONE_17_2 = 170200
const m___IPHONE_17_3 = 170300
const m___IPHONE_17_4 = 170400
const m___IPHONE_2_0 = 20000
const m___IPHONE_2_1 = 20100
const m___IPHONE_2_2 = 20200
const m___IPHONE_3_0 = 30000
const m___IPHONE_3_1 = 30100
const m___IPHONE_3_2 = 30200
const m___IPHONE_4_0 = 40000
const m___IPHONE_4_1 = 40100
const m___IPHONE_4_2 = 40200
const m___IPHONE_4_3 = 40300
const m___IPHONE_5_0 = 50000
const m___IPHONE_5_1 = 50100
const m___IPHONE_6_0 = 60000
const m___IPHONE_6_1 = 60100
const m___IPHONE_7_0 = 70000
const m___IPHONE_7_1 = 70100
const m___IPHONE_8_0 = 80000
const m___IPHONE_8_1 = 80100
const m___IPHONE_8_2 = 80200
const m___IPHONE_8_3 = 80300
const m___IPHONE_8_4 = 80400
const m___IPHONE_9_0 = 90000
const m___IPHONE_9_1 = 90100
const m___IPHONE_9_2 = 90200
const m___IPHONE_9_3 = 90300
const m___IPHONE_COMPAT_VERSION = "__IPHONE_4_0"
const m___LAHF_SAHF__ = 1
const m___LASTBRANCH_MAX = 32
const m___LDBL_DECIMAL_DIG__ = 17
const m___LDBL_DENORM_MIN__ = 4.9406564584124654e-324
const m___LDBL_DIG__ = 15
const m___LDBL_EPSILON__ = 2.2204460492503131e-16
const m___LDBL_HAS_DENORM__ = 1
const m___LDBL_HAS_INFINITY__ = 1
const m___LDBL_HAS_QUIET_NAN__ = 1
const m___LDBL_MANT_DIG__ = 53
const m___LDBL_MAX_10_EXP__ = 308
const m___LDBL_MAX_EXP__ = 1024
const m___LDBL_MAX__ = 1.7976931348623157e+308
const m___LDBL_MIN__ = 2.2250738585072014e-308
const m___LITTLE_ENDIAN__ = 1
const m___LLONG_WIDTH__ = 64
const m___LONG_LONG_MAX__ = 9223372036854775807
const m___LONG_MAX__ = 9223372036854775807
const m___LONG_WIDTH__ = 64
const m___LP64__ = 1
const m___MACH__ = 1
const m___MAC_10_0 = 1000
const m___MAC_10_1 = 1010
const m___MAC_10_10 = 101000
const m___MAC_10_10_2 = 101002
const m___MAC_10_10_3 = 101003
const m___MAC_10_11 = 101100
const m___MAC_10_11_2 = 101102
const m___MAC_10_11_3 = 101103
const m___MAC_10_11_4 = 101104
const m___MAC_10_12 = 101200
const m___MAC_10_12_1 = 101201
const m___MAC_10_12_2 = 101202
const m___MAC_10_12_4 = 101204
const m___MAC_10_13 = 101300
const m___MAC_10_13_1 = 101301
const m___MAC_10_13_2 = 101302
const m___MAC_10_13_4 = 101304
const m___MAC_10_14 = 101400
const m___MAC_10_14_1 = 101401
const m___MAC_10_14_4 = 101404
const m___MAC_10_14_5 = 101405
const m___MAC_10_14_6 = 101406
const m___MAC_10_15 = 101500
const m___MAC_10_15_1 = 101501
const m___MAC_10_15_4 = 101504
const m___MAC_10_16 = 101600
const m___MAC_10_2 = 1020
const m___MAC_10_3 = 1030
const m___MAC_10_4 = 1040
const m___MAC_10_5 = 1050
const m___MAC_10_6 = 1060
const m___MAC_10_7 = 1070
const m___MAC_10_8 = 1080
const m___MAC_10_9 = 1090
const m___MAC_11_0 = 110000
const m___MAC_11_1 = 110100
const m___MAC_11_3 = 110300
const m___MAC_11_4 = 110400
const m___MAC_11_5 = 110500
const m___MAC_11_6 = 110600
const m___MAC_12_0 = 120000
const m___MAC_12_1 = 120100
const m___MAC_12_2 = 120200
const m___MAC_12_3 = 120300
const m___MAC_12_4 = 120400
const m___MAC_12_5 = 120500
const m___MAC_12_6 = 120600
const m___MAC_12_7 = 120700
const m___MAC_13_0 = 130000
const m___MAC_13_1 = 130100
const m___MAC_13_2 = 130200
const m___MAC_13_3 = 130300
const m___MAC_13_4 = 130400
const m___MAC_13_5 = 130500
const m___MAC_13_6 = 130600
const m___MAC_14_0 = 140000
const m___MAC_14_1 = 140100
const m___MAC_14_2 = 140200
const m___MAC_14_3 = 140300
const m___MAC_14_4 = 140400
const m___MAC_OS_X_VERSION_MAX_ALLOWED = "__MAC_14_4"
const m___MAC_OS_X_VERSION_MIN_REQUIRED = "__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__"
const m___MMX__ = 1
const m___NO_INLINE__ = 1
const m___NO_MATH_ERRNO__ = 1
const m___NO_MATH_INLINES = 1
const m___OBJC_BOOL_IS_BOOL = 0
const m___OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = 3
const m___OPENCL_MEMORY_SCOPE_DEVICE = 2
const m___OPENCL_MEMORY_SCOPE_SUB_GROUP = 4
const m___OPENCL_MEMORY_SCOPE_WORK_GROUP = 1
const m___OPENCL_MEMORY_SCOPE_WORK_ITEM = 0
const m___ORDER_BIG_ENDIAN__ = 4321
const m___ORDER_LITTLE_ENDIAN__ = 1234
const m___ORDER_PDP_ENDIAN__ = 3412
const m___PIC__ = 2
const m___POINTER_WIDTH__ = 64
const m___PRAGMA_REDEFINE_EXTNAME = 1
const m___PRETTY_FUNCTION__ = "__func__"
const m___PTHREAD_ATTR_SIZE__ = 56
const m___PTHREAD_CONDATTR_SIZE__ = 8
const m___PTHREAD_COND_SIZE__ = 40
const m___PTHREAD_MUTEXATTR_SIZE__ = 8
const m___PTHREAD_MUTEX_SIZE__ = 56
const m___PTHREAD_ONCE_SIZE__ = 8
const m___PTHREAD_RWLOCKATTR_SIZE__ = 16
const m___PTHREAD_RWLOCK_SIZE__ = 192
const m___PTHREAD_SIZE__ = 8176
const m___PTRDIFF_FMTd__ = "ld"
const m___PTRDIFF_FMTi__ = "li"
const m___PTRDIFF_MAX__ = 9223372036854775807
const m___PTRDIFF_WIDTH__ = 64
const m___SALC = 0x4000
const m___SAPP = 0x0100
const m___SCHAR_MAX__ = 127
const m___SCHED_PARAM_SIZE__ = 4
const m___SEG_FS = 1
const m___SEG_GS = 1
const m___SEOF = 0x0020
const m___SERR = 0x0040
const m___SHRT_MAX__ = 32767
const m___SHRT_WIDTH__ = 16
const m___SIGN = 0x8000
const m___SIG_ATOMIC_MAX__ = 2147483647
const m___SIG_ATOMIC_WIDTH__ = 32
const m___SIZEOF_DOUBLE__ = 8
const m___SIZEOF_FLOAT__ = 4
const m___SIZEOF_INT128__ = 16
const m___SIZEOF_INT__ = 4
const m___SIZEOF_LONG_DOUBLE__ = 8
const m___SIZEOF_LONG_LONG__ = 8
const m___SIZEOF_LONG__ = 8
const m___SIZEOF_POINTER__ = 8
const m___SIZEOF_PTRDIFF_T__ = 8
const m___SIZEOF_SHORT__ = 2
const m___SIZEOF_SIZE_T__ = 8
const m___SIZEOF_WCHAR_T__ = 4
const m___SIZEOF_WINT_T__ = 4
const m___SIZE_FMTX__ = "lX"
const m___SIZE_FMTo__ = "lo"
const m___SIZE_FMTu__ = "lu"
const m___SIZE_FMTx__ = "lx"
const m___SIZE_MAX__ = 18446744073709551615
const m___SIZE_WIDTH__ = 64
const m___SLBF = 0x0001
const m___SMBF = 0x0080
const m___SMOD = 0x2000
const m___SNBF = 0x0002
const m___SNPT = 0x0800
const m___SOFF = 0x1000
const m___SOPT = 0x0400
const m___SRD = 0x0004
const m___SRW = 0x0010
const m___SSE2_MATH__ = 1
const m___SSE2__ = 1
const m___SSE3__ = 1
const m___SSE4_1__ = 1
const m___SSE_MATH__ = 1
const m___SSE__ = 1
const m___SSP__ = 1
const m___SSSE3__ = 1
const m___SSTR = 0x0200
const m___STDC_HOSTED__ = 1
const m___STDC_NO_THREADS__ = 1
const m___STDC_UTF_16__ = 1
const m___STDC_UTF_32__ = 1
const m___STDC_VERSION__ = 201710
const m___STDC_WANT_LIB_EXT1__ = 1
const m___STDC__ = 1
const m___SWR = 0x0008
const m___TVOS_10_0 = 100000
const m___TVOS_10_0_1 = 100001
const m___TVOS_10_1 = 100100
const m___TVOS_10_2 = 100200
const m___TVOS_11_0 = 110000
const m___TVOS_11_1 = 110100
const m___TVOS_11_2 = 110200
const m___TVOS_11_3 = 110300
const m___TVOS_11_4 = 110400
const m___TVOS_12_0 = 120000
const m___TVOS_12_1 = 120100
const m___TVOS_12_2 = 120200
const m___TVOS_12_3 = 120300
const m___TVOS_12_4 = 120400
const m___TVOS_13_0 = 130000
const m___TVOS_13_2 = 130200
const m___TVOS_13_3 = 130300
const m___TVOS_13_4 = 130400
const m___TVOS_14_0 = 140000
const m___TVOS_14_1 = 140100
const m___TVOS_14_2 = 140200
const m___TVOS_14_3 = 140300
const m___TVOS_14_5 = 140500
const m___TVOS_14_6 = 140600
const m___TVOS_14_7 = 140700
const m___TVOS_15_0 = 150000
const m___TVOS_15_1 = 150100
const m___TVOS_15_2 = 150200
const m___TVOS_15_3 = 150300
const m___TVOS_15_4 = 150400
const m___TVOS_15_5 = 150500
const m___TVOS_15_6 = 150600
const m___TVOS_16_0 = 160000
const m___TVOS_16_1 = 160100
const m___TVOS_16_2 = 160200
const m___TVOS_16_3 = 160300
const m___TVOS_16_4 = 160400
const m___TVOS_16_5 = 160500
const m___TVOS_16_6 = 160600
const m___TVOS_17_0 = 170000
const m___TVOS_17_1 = 170100
const m___TVOS_17_2 = 170200
const m___TVOS_17_3 = 170300
const m___TVOS_17_4 = 170400
const m___TVOS_9_0 = 90000
const m___TVOS_9_1 = 90100
const m___TVOS_9_2 = 90200
const m___UINT16_FMTX__ = "hX"
const m___UINT16_FMTo__ = "ho"
const m___UINT16_FMTu__ = "hu"
const m___UINT16_FMTx__ = "hx"
const m___UINT16_MAX__ = 65535
const m___UINT32_C_SUFFIX__ = "U"
const m___UINT32_FMTX__ = "X"
const m___UINT32_FMTo__ = "o"
const m___UINT32_FMTu__ = "u"
const m___UINT32_FMTx__ = "x"
const m___UINT32_MAX__ = 4294967295
const m___UINT64_C_SUFFIX__ = "ULL"
const m___UINT64_FMTX__ = "llX"
const m___UINT64_FMTo__ = "llo"
const m___UINT64_FMTu__ = "llu"
const m___UINT64_FMTx__ = "llx"
const m___UINT64_MAX__ = "18446744073709551615U"
const m___UINT8_FMTX__ = "hhX"
const m___UINT8_FMTo__ = "hho"
const m___UINT8_FMTu__ = "hhu"
const m___UINT8_FMTx__ = "hhx"
const m___UINT8_MAX__ = 255
const m___UINTMAX_C_SUFFIX__ = "UL"
const m___UINTMAX_FMTX__ = "lX"
const m___UINTMAX_FMTo__ = "lo"
const m___UINTMAX_FMTu__ = "lu"
const m___UINTMAX_FMTx__ = "lx"
const m___UINTMAX_MAX__ = 18446744073709551615
const m___UINTMAX_WIDTH__ = 64
const m___UINTPTR_FMTX__ = "lX"
const m___UINTPTR_FMTo__ = "lo"
const m___UINTPTR_FMTu__ = "lu"
const m___UINTPTR_FMTx__ = "lx"
const m___UINTPTR_MAX__ = 18446744073709551615
const m___UINTPTR_WIDTH__ = 64
const m___UINT_FAST16_FMTX__ = "hX"
const m___UINT_FAST16_FMTo__ = "ho"
const m___UINT_FAST16_FMTu__ = "hu"
const m___UINT_FAST16_FMTx__ = "hx"
const m___UINT_FAST16_MAX__ = 65535
const m___UINT_FAST32_FMTX__ = "X"
const m___UINT_FAST32_FMTo__ = "o"
const m___UINT_FAST32_FMTu__ = "u"
const m___UINT_FAST32_FMTx__ = "x"
const m___UINT_FAST32_MAX__ = 4294967295
const m___UINT_FAST64_FMTX__ = "llX"
const m___UINT_FAST64_FMTo__ = "llo"
const m___UINT_FAST64_FMTu__ = "llu"
const m___UINT_FAST64_FMTx__ = "llx"
const m___UINT_FAST64_MAX__ = "18446744073709551615U"
const m___UINT_FAST8_FMTX__ = "hhX"
const m___UINT_FAST8_FMTo__ = "hho"
const m___UINT_FAST8_FMTu__ = "hhu"
const m___UINT_FAST8_FMTx__ = "hhx"
const m___UINT_FAST8_MAX__ = 255
const m___UINT_LEAST16_FMTX__ = "hX"
const m___UINT_LEAST16_FMTo__ = "ho"
const m___UINT_LEAST16_FMTu__ = "hu"
const m___UINT_LEAST16_FMTx__ = "hx"
const m___UINT_LEAST16_MAX__ = 65535
const m___UINT_LEAST32_FMTX__ = "X"
const m___UINT_LEAST32_FMTo__ = "o"
const m___UINT_LEAST32_FMTu__ = "u"
const m___UINT_LEAST32_FMTx__ = "x"
const m___UINT_LEAST32_MAX__ = 4294967295
const m___UINT_LEAST64_FMTX__ = "llX"
const m___UINT_LEAST64_FMTo__ = "llo"
const m___UINT_LEAST64_FMTu__ = "llu"
const m___UINT_LEAST64_FMTx__ = "llx"
const m___UINT_LEAST64_MAX = "UINT64_MAX"
const m___UINT_LEAST64_MAX__ = "18446744073709551615U"
const m___UINT_LEAST8_FMTX__ = "hhX"
const m___UINT_LEAST8_FMTo__ = "hho"
const m___UINT_LEAST8_FMTu__ = "hhu"
const m___UINT_LEAST8_FMTx__ = "hhx"
const m___UINT_LEAST8_MAX__ = 255
const m___USER_LABEL_PREFIX__ = "_"
const m___VERSION__ = "Apple LLVM 15.0.0 (clang-1500.3.9.4)"
const m___VISIONOS_1_0 = 10000
const m___VISIONOS_1_1 = 10100
const m___WATCHOS_10_0 = 100000
const m___WATCHOS_10_1 = 100100
const m___WATCHOS_10_2 = 100200
const m___WATCHOS_10_3 = 100300
const m___WATCHOS_10_4 = 100400
const m___WATCHOS_1_0 = 10000
const m___WATCHOS_2_0 = 20000
const m___WATCHOS_2_1 = 20100
const m___WATCHOS_2_2 = 20200
const m___WATCHOS_3_0 = 30000
const m___WATCHOS_3_1 = 30100
const m___WATCHOS_3_1_1 = 30101
const m___WATCHOS_3_2 = 30200
const m___WATCHOS_4_0 = 40000
const m___WATCHOS_4_1 = 40100
const m___WATCHOS_4_2 = 40200
const m___WATCHOS_4_3 = 40300
const m___WATCHOS_5_0 = 50000
const m___WATCHOS_5_1 = 50100
const m___WATCHOS_5_2 = 50200
const m___WATCHOS_5_3 = 50300
const m___WATCHOS_6_0 = 60000
const m___WATCHOS_6_1 = 60100
const m___WATCHOS_6_2 = 60200
const m___WATCHOS_7_0 = 70000
const m___WATCHOS_7_1 = 70100
const m___WATCHOS_7_2 = 70200
const m___WATCHOS_7_3 = 70300
const m___WATCHOS_7_4 = 70400
const m___WATCHOS_7_5 = 70500
const m___WATCHOS_7_6 = 70600
const m___WATCHOS_8_0 = 80000
const m___WATCHOS_8_1 = 80100
const m___WATCHOS_8_3 = 80300
const m___WATCHOS_8_4 = 80400
const m___WATCHOS_8_5 = 80500
const m___WATCHOS_8_6 = 80600
const m___WATCHOS_8_7 = 80700
const m___WATCHOS_8_8 = 80800
const m___WATCHOS_9_0 = 90000
const m___WATCHOS_9_1 = 90100
const m___WATCHOS_9_2 = 90200
const m___WATCHOS_9_3 = 90300
const m___WATCHOS_9_4 = 90400
const m___WATCHOS_9_5 = 90500
const m___WATCHOS_9_6 = 90600
const m___WCHAR_MAX__ = 2147483647
const m___WCHAR_TYPE__ = "int"
const m___WCHAR_WIDTH__ = 32
const m___WINT_MAX__ = 2147483647
const m___WINT_TYPE__ = "int"
const m___WINT_WIDTH__ = 32
const m___amd64 = 1
const m___amd64__ = 1
const m___apple_build_version__ = 15000309
const m___clang__ = 1
const m___clang_literal_encoding__ = "UTF-8"
const m___clang_major__ = 15
const m___clang_minor__ = 0
const m___clang_patchlevel__ = 0
const m___clang_version__ = "15.0.0 (clang-1500.3.9.4)"
const m___clang_wide_literal_encoding__ = "UTF-32"
const m___code_model_small__ = 1
const m___const = "const"
const m___core2 = 1
const m___core2__ = 1
const m___has_ptrcheck = 0
const m___has_safe_buffers = 0
const m___header_inline = "inline"
const m___llvm__ = 1
const m___nonnull = "_Nonnull"
const m___null_unspecified = "_Null_unspecified"
const m___nullable = "_Nullable"
const m___pic__ = 2
const m___restrict = "restrict"
const m___restrict_arr = "restrict"
const m___signed = "signed"
const m___tune_core2__ = 1
const m___volatile = "volatile"
const m___x86_64 = 1
const m___x86_64__ = 1
const m_ft_encoding_adobe_custom = "FT_ENCODING_ADOBE_CUSTOM"
const m_ft_encoding_adobe_expert = "FT_ENCODING_ADOBE_EXPERT"
const m_ft_encoding_adobe_standard = "FT_ENCODING_ADOBE_STANDARD"
const m_ft_encoding_apple_roman = "FT_ENCODING_APPLE_ROMAN"
const m_ft_encoding_big5 = "FT_ENCODING_BIG5"
const m_ft_encoding_gb2312 = "FT_ENCODING_PRC"
const m_ft_encoding_johab = "FT_ENCODING_JOHAB"
const m_ft_encoding_latin_1 = "FT_ENCODING_ADOBE_LATIN_1"
const m_ft_encoding_latin_2 = "FT_ENCODING_OLD_LATIN_2"
const m_ft_encoding_none = "FT_ENCODING_NONE"
const m_ft_encoding_sjis = "FT_ENCODING_SJIS"
const m_ft_encoding_symbol = "FT_ENCODING_MS_SYMBOL"
const m_ft_encoding_unicode = "FT_ENCODING_UNICODE"
const m_ft_encoding_wansung = "FT_ENCODING_WANSUNG"
const m_ft_fclose = "fclose"
const m_ft_fopen = "fopen"
const m_ft_fread = "fread"
const m_ft_fseek = "fseek"
const m_ft_ftell = "ftell"
const m_ft_getenv = "getenv"
const m_ft_glyph_format_bitmap = "FT_GLYPH_FORMAT_BITMAP"
const m_ft_glyph_format_composite = "FT_GLYPH_FORMAT_COMPOSITE"
const m_ft_glyph_format_none = "FT_GLYPH_FORMAT_NONE"
const m_ft_glyph_format_outline = "FT_GLYPH_FORMAT_OUTLINE"
const m_ft_glyph_format_plotter = "FT_GLYPH_FORMAT_PLOTTER"
const m_ft_jmp_buf = "jmp_buf"
const m_ft_kerning_default = "FT_KERNING_DEFAULT"
const m_ft_kerning_unfitted = "FT_KERNING_UNFITTED"
const m_ft_kerning_unscaled = "FT_KERNING_UNSCALED"
const m_ft_longjmp = "longjmp"
const m_ft_memchr = "memchr"
const m_ft_memcmp = "memcmp"
const m_ft_memcpy = "memcpy"
const m_ft_memmove = "memmove"
const m_ft_memset = "memset"
const m_ft_open_driver = "FT_OPEN_DRIVER"
const m_ft_open_memory = "FT_OPEN_MEMORY"
const m_ft_open_params = "FT_OPEN_PARAMS"
const m_ft_open_pathname = "FT_OPEN_PATHNAME"
const m_ft_open_stream = "FT_OPEN_STREAM"
const m_ft_outline_even_odd_fill = "FT_OUTLINE_EVEN_ODD_FILL"
const m_ft_outline_high_precision = "FT_OUTLINE_HIGH_PRECISION"
const m_ft_outline_ignore_dropouts = "FT_OUTLINE_IGNORE_DROPOUTS"
const m_ft_outline_none = "FT_OUTLINE_NONE"
const m_ft_outline_owner = "FT_OUTLINE_OWNER"
const m_ft_outline_reverse_fill = "FT_OUTLINE_REVERSE_FILL"
const m_ft_outline_single_pass = "FT_OUTLINE_SINGLE_PASS"
const m_ft_pixel_mode_grays = "FT_PIXEL_MODE_GRAY"
const m_ft_pixel_mode_mono = "FT_PIXEL_MODE_MONO"
const m_ft_pixel_mode_none = "FT_PIXEL_MODE_NONE"
const m_ft_pixel_mode_pal2 = "FT_PIXEL_MODE_GRAY2"
const m_ft_pixel_mode_pal4 = "FT_PIXEL_MODE_GRAY4"
const m_ft_ptrdiff_t = "ptrdiff_t"
const m_ft_qsort = "qsort"
const m_ft_raster_flag_aa = "FT_RASTER_FLAG_AA"
const m_ft_raster_flag_clip = "FT_RASTER_FLAG_CLIP"
const m_ft_raster_flag_default = "FT_RASTER_FLAG_DEFAULT"
const m_ft_raster_flag_direct = "FT_RASTER_FLAG_DIRECT"
const m_ft_render_mode_mono = "FT_RENDER_MODE_MONO"
const m_ft_render_mode_normal = "FT_RENDER_MODE_NORMAL"
const m_ft_scalloc = "calloc"
const m_ft_sfree = "free"
const m_ft_smalloc = "malloc"
const m_ft_sprintf = "sprintf"
const m_ft_srealloc = "realloc"
const m_ft_strcat = "strcat"
const m_ft_strcmp = "strcmp"
const m_ft_strcpy = "strcpy"
const m_ft_strlen = "strlen"
const m_ft_strncmp = "strncmp"
const m_ft_strncpy = "strncpy"
const m_ft_strrchr = "strrchr"
const m_ft_strstr = "strstr"
const m_ft_strtol = "strtol"
const m_ru_first = "ru_ixrss"
const m_ru_last = "ru_nivcsw"
const m_static_assert = "_Static_assert"
const m_stderr = "__stderrp"
const m_stdin = "__stdinp"
const m_stdout = "__stdoutp"
const m_sv_onstack = "sv_flags"
const m_sz_xAllocColorCellsReply = 32
const m_sz_xAllocColorCellsReq = 12
const m_sz_xAllocColorPlanesReply = 32
const m_sz_xAllocColorPlanesReq = 16
const m_sz_xAllocColorReply = 32
const m_sz_xAllocColorReq = 16
const m_sz_xAllocNamedColorReply = 32
const m_sz_xAllocNamedColorReq = 12
const m_sz_xAllowEventsReq = 8
const m_sz_xArc = 12
const m_sz_xBellReq = 4
const m_sz_xChangeActivePointerGrabReq = 16
const m_sz_xChangeGCReq = 12
const m_sz_xChangeHostsReq = 8
const m_sz_xChangeKeyboardControlReq = 8
const m_sz_xChangeKeyboardMappingReq = 8
const m_sz_xChangeModeReq = 4
const m_sz_xChangePointerControlReq = 12
const m_sz_xChangePropertyReq = 24
const m_sz_xChangeSaveSetReq = 8
const m_sz_xChangeWindowAttributesReq = 12
const m_sz_xCharInfo = 12
const m_sz_xCirculateWindowReq = 8
const m_sz_xClearAreaReq = 16
const m_sz_xColorItem = 12
const m_sz_xConfigureWindowReq = 12
const m_sz_xConnClientPrefix = 12
const m_sz_xConnSetup = 32
const m_sz_xConnSetupPrefix = 8
const m_sz_xConvertSelectionReq = 24
const m_sz_xCopyAreaReq = 28
const m_sz_xCopyColormapAndFreeReq = 12
const m_sz_xCopyGCReq = 16
const m_sz_xCopyPlaneReq = 32
const m_sz_xCreateColormapReq = 16
const m_sz_xCreateCursorReq = 32
const m_sz_xCreateGCReq = 16
const m_sz_xCreateGlyphCursorReq = 32
const m_sz_xCreatePixmapReq = 16
const m_sz_xCreateWindowReq = 32
const m_sz_xDeletePropertyReq = 12
const m_sz_xDepth = 8
const m_sz_xError = 32
const m_sz_xEvent = 32
const m_sz_xFillPolyReq = 16
const m_sz_xFontProp = 8
const m_sz_xForceScreenSaverReq = 4
const m_sz_xFreeColorsReq = 12
const m_sz_xGenericReply = 32
const m_sz_xGetAtomNameReply = 32
const m_sz_xGetFontPathReply = 32
const m_sz_xGetGeometryReply = 32
const m_sz_xGetImageReply = 32
const m_sz_xGetImageReq = 20
const m_sz_xGetInputFocusReply = 32
const m_sz_xGetKeyboardControlReply = 52
const m_sz_xGetKeyboardMappingReply = 32
const m_sz_xGetKeyboardMappingReq = 8
const m_sz_xGetModifierMappingReply = 32
const m_sz_xGetMotionEventsReply = 32
const m_sz_xGetMotionEventsReq = 16
const m_sz_xGetPointerControlReply = 32
const m_sz_xGetPointerMappingReply = 32
const m_sz_xGetPropertyReply = 32
const m_sz_xGetPropertyReq = 24
const m_sz_xGetScreenSaverReply = 32
const m_sz_xGetSelectionOwnerReply = 32
const m_sz_xGetWindowAttributesReply = 44
const m_sz_xGrabButtonReq = 24
const m_sz_xGrabKeyReq = 16
const m_sz_xGrabKeyboardReply = 32
const m_sz_xGrabKeyboardReq = 16
const m_sz_xGrabPointerReply = 32
const m_sz_xGrabPointerReq = 24
const m_sz_xHostEntry = 4
const m_sz_xImageText16Req = 16
const m_sz_xImageText8Req = 16
const m_sz_xImageTextReq = 16
const m_sz_xInternAtomReply = 32
const m_sz_xInternAtomReq = 8
const m_sz_xKeymapEvent = 32
const m_sz_xListExtensionsReply = 32
const m_sz_xListFontsReply = 32
const m_sz_xListFontsReq = 8
const m_sz_xListFontsWithInfoReply = 60
const m_sz_xListFontsWithInfoReq = 8
const m_sz_xListHostsReply = 32
const m_sz_xListHostsReq = 4
const m_sz_xListInstalledColormapsReply = 32
const m_sz_xListPropertiesReply = 32
const m_sz_xLookupColorReply = 32
const m_sz_xLookupColorReq = 12
const m_sz_xOpenFontReq = 12
const m_sz_xPixmapFormat = 8
const m_sz_xPoint = 4
const m_sz_xPolyArcReq = 12
const m_sz_xPolyFillArcReq = 12
const m_sz_xPolyFillRectangleReq = 12
const m_sz_xPolyLineReq = 12
const m_sz_xPolyPointReq = 12
const m_sz_xPolyRectangleReq = 12
const m_sz_xPolySegmentReq = 12
const m_sz_xPolyText16Req = 16
const m_sz_xPolyText8Req = 16
const m_sz_xPolyTextReq = 16
const m_sz_xPropIconSize = 24
const m_sz_xPutImageReq = 24
const m_sz_xQueryBestSizeReply = 32
const m_sz_xQueryBestSizeReq = 12
const m_sz_xQueryColorsReply = 32
const m_sz_xQueryColorsReq = 8
const m_sz_xQueryExtensionReply = 32
const m_sz_xQueryExtensionReq = 8
const m_sz_xQueryFontReply = 60
const m_sz_xQueryKeymapReply = 40
const m_sz_xQueryPointerReply = 32
const m_sz_xQueryTextExtentsReply = 32
const m_sz_xQueryTextExtentsReq = 8
const m_sz_xQueryTreeReply = 32
const m_sz_xRecolorCursorReq = 20
const m_sz_xRectangle = 8
const m_sz_xReparentWindowReq = 16
const m_sz_xReply = 32
const m_sz_xReq = 4
const m_sz_xResourceReq = 8
const m_sz_xRotatePropertiesReq = 12
const m_sz_xSegment = 8
const m_sz_xSendEventReq = 44
const m_sz_xSetAccessControlReq = 4
const m_sz_xSetClipRectanglesReq = 12
const m_sz_xSetCloseDownModeReq = 4
const m_sz_xSetDashesReq = 12
const m_sz_xSetFontPathReq = 8
const m_sz_xSetInputFocusReq = 12
const m_sz_xSetMappingReply = 32
const m_sz_xSetModifierMappingReply = 32
const m_sz_xSetModifierMappingReq = 4
const m_sz_xSetPointerMappingReply = 32
const m_sz_xSetPointerMappingReq = 4
const m_sz_xSetScreenSaverReq = 12
const m_sz_xSetSelectionOwnerReq = 16
const m_sz_xStoreColorsReq = 8
const m_sz_xStoreNamedColorReq = 16
const m_sz_xTextElt = 2
const m_sz_xTimecoord = 8
const m_sz_xTranslateCoordsReply = 32
const m_sz_xTranslateCoordsReq = 16
const m_sz_xUngrabButtonReq = 12
const m_sz_xUngrabKeyReq = 12
const m_sz_xVisualType = 24
const m_sz_xWarpPointerReq = 24
const m_sz_xWindowRoot = 40
const m_sz_xrgb = 8
const m_xFalse = 0
const m_xTrue = 1
const m_xfree = "free"
const m_xmalloc = "malloc"
const m_xthread_self = "pthread_self"

type t__builtin_va_list = uintptr

type t__predefined_size_t = uint64

type t__predefined_wchar_t = int32

type t__predefined_ptrdiff_t = int64

type t__int8_t = int8

type t__uint8_t = uint8

type t__int16_t = int16

type t__uint16_t = uint16

type t__int32_t = int32

type t__uint32_t = uint32

type t__int64_t = int64

type t__uint64_t = uint64

type t__darwin_intptr_t = int64

type t__darwin_natural_t = uint32

type t__darwin_ct_rune_t = int32

type t__mbstate_t = struct {
	F_mbstateL  [0]int64
	F__mbstate8 [128]int8
}

type t__darwin_mbstate_t = struct {
	F_mbstateL  [0]int64
	F__mbstate8 [128]int8
}

type t__darwin_ptrdiff_t = int64

type t__darwin_size_t = uint64

type t__darwin_va_list = uintptr

type t__darwin_wchar_t = int32

type t__darwin_rune_t = int32

type t__darwin_wint_t = int32

type t__darwin_clock_t = uint64

type t__darwin_socklen_t = uint32

type t__darwin_ssize_t = int64

type t__darwin_time_t = int64

type t__darwin_blkcnt_t = int64

type t__darwin_blksize_t = int32

type t__darwin_dev_t = int32

type t__darwin_fsblkcnt_t = uint32

type t__darwin_fsfilcnt_t = uint32

type t__darwin_gid_t = uint32

type t__darwin_id_t = uint32

type t__darwin_ino64_t = uint64

type t__darwin_ino_t = uint64

type t__darwin_mach_port_name_t = uint32

type t__darwin_mach_port_t = uint32

type t__darwin_mode_t = uint16

type t__darwin_off_t = int64

type t__darwin_pid_t = int32

type t__darwin_sigset_t = uint32

type t__darwin_suseconds_t = int32

type t__darwin_uid_t = uint32

type t__darwin_useconds_t = uint32

type t__darwin_uuid_t = [16]uint8

type t__darwin_uuid_string_t = [37]int8

type t__darwin_pthread_handler_rec = struct {
	F__routine uintptr
	F__arg     uintptr
	F__next    uintptr
}

type T_opaque_pthread_attr_t = struct {
	F__sig    int64
	F__opaque [56]int8
}

type T_opaque_pthread_cond_t = struct {
	F__sig    int64
	F__opaque [40]int8
}

type T_opaque_pthread_condattr_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type T_opaque_pthread_mutex_t = struct {
	F__sig    int64
	F__opaque [56]int8
}

type T_opaque_pthread_mutexattr_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type T_opaque_pthread_once_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type T_opaque_pthread_rwlock_t = struct {
	F__sig    int64
	F__opaque [192]int8
}

type T_opaque_pthread_rwlockattr_t = struct {
	F__sig    int64
	F__opaque [16]int8
}

type T_opaque_pthread_t = struct {
	F__sig           int64
	F__cleanup_stack uintptr
	F__opaque        [8176]int8
}

type t__darwin_pthread_attr_t = struct {
	F__sig    int64
	F__opaque [56]int8
}

type t__darwin_pthread_cond_t = struct {
	F__sig    int64
	F__opaque [40]int8
}

type t__darwin_pthread_condattr_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type t__darwin_pthread_key_t = uint64

type t__darwin_pthread_mutex_t = struct {
	F__sig    int64
	F__opaque [56]int8
}

type t__darwin_pthread_mutexattr_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type t__darwin_pthread_once_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type t__darwin_pthread_rwlock_t = struct {
	F__sig    int64
	F__opaque [192]int8
}

type t__darwin_pthread_rwlockattr_t = struct {
	F__sig    int64
	F__opaque [16]int8
}

type t__darwin_pthread_t = uintptr

type t__darwin_nl_item = int32

type t__darwin_wctrans_t = int32

type t__darwin_wctype_t = uint32

type Tint8_t = int8

type Tint16_t = int16

type Tint32_t = int32

type Tint64_t = int64

type Tu_int8_t = uint8

type Tu_int16_t = uint16

type Tu_int32_t = uint32

type Tu_int64_t = uint64

type Tregister_t = int64

type Tintptr_t = int64

type Tuintptr_t = uint64

type Tuser_addr_t = uint64

type Tuser_size_t = uint64

type Tuser_ssize_t = int64

type Tuser_long_t = int64

type Tuser_ulong_t = uint64

type Tuser_time_t = int64

type Tuser_off_t = int64

type Tsyscall_arg_t = uint64

type Tva_list = uintptr

type Tsize_t = uint64

type Tfpos_t = int64

type t__sbuf = struct {
	F_base uintptr
	F_size int32
}

type TFILE = struct {
	F_p       uintptr
	F_r       int32
	F_w       int32
	F_flags   int16
	F_file    int16
	F_bf      t__sbuf
	F_lbfsize int32
	F_cookie  uintptr
	F_close   uintptr
	F_read    uintptr
	F_seek    uintptr
	F_write   uintptr
	F_ub      t__sbuf
	F_extra   uintptr
	F_ur      int32
	F_ubuf    [3]uint8
	F_nbuf    [1]uint8
	F_lb      t__sbuf
	F_blksize int32
	F_offset  Tfpos_t
}

type t__sFILE = TFILE

type Toff_t = int64

type Tssize_t = int64

type Tidtype_t = int32

const _P_ALL = 0
const _P_PID = 1
const _P_PGID = 2

type Tpid_t = int32

type Tid_t = uint32

type Tsig_atomic_t = int32

type t__darwin_i386_thread_state = struct {
	F__eax    uint32
	F__ebx    uint32
	F__ecx    uint32
	F__edx    uint32
	F__edi    uint32
	F__esi    uint32
	F__ebp    uint32
	F__esp    uint32
	F__ss     uint32
	F__eflags uint32
	F__eip    uint32
	F__cs     uint32
	F__ds     uint32
	F__es     uint32
	F__fs     uint32
	F__gs     uint32
}

type t__darwin_fp_control = struct {
	F__ccgo0 uint16
}

type t__darwin_fp_control_t = struct {
	F__ccgo0 uint16
}

type t__darwin_fp_status = struct {
	F__ccgo0 uint16
}

type t__darwin_fp_status_t = struct {
	F__ccgo0 uint16
}

type t__darwin_mmst_reg = struct {
	F__mmst_reg  [10]int8
	F__mmst_rsrv [6]int8
}

type t__darwin_xmm_reg = struct {
	F__xmm_reg [16]int8
}

type t__darwin_ymm_reg = struct {
	F__ymm_reg [32]int8
}

type t__darwin_zmm_reg = struct {
	F__zmm_reg [64]int8
}

type t__darwin_opmask_reg = struct {
	F__opmask_reg [8]int8
}

type t__darwin_i386_float_state = struct {
	F__fpu_reserved  [2]int32
	F__fpu_fcw       t__darwin_fp_control
	F__fpu_fsw       t__darwin_fp_status
	F__fpu_ftw       t__uint8_t
	F__fpu_rsrv1     t__uint8_t
	F__fpu_fop       t__uint16_t
	F__fpu_ip        t__uint32_t
	F__fpu_cs        t__uint16_t
	F__fpu_rsrv2     t__uint16_t
	F__fpu_dp        t__uint32_t
	F__fpu_ds        t__uint16_t
	F__fpu_rsrv3     t__uint16_t
	F__fpu_mxcsr     t__uint32_t
	F__fpu_mxcsrmask t__uint32_t
	F__fpu_stmm0     t__darwin_mmst_reg
	F__fpu_stmm1     t__darwin_mmst_reg
	F__fpu_stmm2     t__darwin_mmst_reg
	F__fpu_stmm3     t__darwin_mmst_reg
	F__fpu_stmm4     t__darwin_mmst_reg
	F__fpu_stmm5     t__darwin_mmst_reg
	F__fpu_stmm6     t__darwin_mmst_reg
	F__fpu_stmm7     t__darwin_mmst_reg
	F__fpu_xmm0      t__darwin_xmm_reg
	F__fpu_xmm1      t__darwin_xmm_reg
	F__fpu_xmm2      t__darwin_xmm_reg
	F__fpu_xmm3      t__darwin_xmm_reg
	F__fpu_xmm4      t__darwin_xmm_reg
	F__fpu_xmm5      t__darwin_xmm_reg
	F__fpu_xmm6      t__darwin_xmm_reg
	F__fpu_xmm7      t__darwin_xmm_reg
	F__fpu_rsrv4     [224]int8
	F__fpu_reserved1 int32
}

type t__darwin_i386_avx_state = struct {
	F__fpu_reserved  [2]int32
	F__fpu_fcw       t__darwin_fp_control
	F__fpu_fsw       t__darwin_fp_status
	F__fpu_ftw       t__uint8_t
	F__fpu_rsrv1     t__uint8_t
	F__fpu_fop       t__uint16_t
	F__fpu_ip        t__uint32_t
	F__fpu_cs        t__uint16_t
	F__fpu_rsrv2     t__uint16_t
	F__fpu_dp        t__uint32_t
	F__fpu_ds        t__uint16_t
	F__fpu_rsrv3     t__uint16_t
	F__fpu_mxcsr     t__uint32_t
	F__fpu_mxcsrmask t__uint32_t
	F__fpu_stmm0     t__darwin_mmst_reg
	F__fpu_stmm1     t__darwin_mmst_reg
	F__fpu_stmm2     t__darwin_mmst_reg
	F__fpu_stmm3     t__darwin_mmst_reg
	F__fpu_stmm4     t__darwin_mmst_reg
	F__fpu_stmm5     t__darwin_mmst_reg
	F__fpu_stmm6     t__darwin_mmst_reg
	F__fpu_stmm7     t__darwin_mmst_reg
	F__fpu_xmm0      t__darwin_xmm_reg
	F__fpu_xmm1      t__darwin_xmm_reg
	F__fpu_xmm2      t__darwin_xmm_reg
	F__fpu_xmm3      t__darwin_xmm_reg
	F__fpu_xmm4      t__darwin_xmm_reg
	F__fpu_xmm5      t__darwin_xmm_reg
	F__fpu_xmm6      t__darwin_xmm_reg
	F__fpu_xmm7      t__darwin_xmm_reg
	F__fpu_rsrv4     [224]int8
	F__fpu_reserved1 int32
	F__avx_reserved1 [64]int8
	F__fpu_ymmh0     t__darwin_xmm_reg
	F__fpu_ymmh1     t__darwin_xmm_reg
	F__fpu_ymmh2     t__darwin_xmm_reg
	F__fpu_ymmh3     t__darwin_xmm_reg
	F__fpu_ymmh4     t__darwin_xmm_reg
	F__fpu_ymmh5     t__darwin_xmm_reg
	F__fpu_ymmh6     t__darwin_xmm_reg
	F__fpu_ymmh7     t__darwin_xmm_reg
}

type t__darwin_i386_avx512_state = struct {
	F__fpu_reserved  [2]int32
	F__fpu_fcw       t__darwin_fp_control
	F__fpu_fsw       t__darwin_fp_status
	F__fpu_ftw       t__uint8_t
	F__fpu_rsrv1     t__uint8_t
	F__fpu_fop       t__uint16_t
	F__fpu_ip        t__uint32_t
	F__fpu_cs        t__uint16_t
	F__fpu_rsrv2     t__uint16_t
	F__fpu_dp        t__uint32_t
	F__fpu_ds        t__uint16_t
	F__fpu_rsrv3     t__uint16_t
	F__fpu_mxcsr     t__uint32_t
	F__fpu_mxcsrmask t__uint32_t
	F__fpu_stmm0     t__darwin_mmst_reg
	F__fpu_stmm1     t__darwin_mmst_reg
	F__fpu_stmm2     t__darwin_mmst_reg
	F__fpu_stmm3     t__darwin_mmst_reg
	F__fpu_stmm4     t__darwin_mmst_reg
	F__fpu_stmm5     t__darwin_mmst_reg
	F__fpu_stmm6     t__darwin_mmst_reg
	F__fpu_stmm7     t__darwin_mmst_reg
	F__fpu_xmm0      t__darwin_xmm_reg
	F__fpu_xmm1      t__darwin_xmm_reg
	F__fpu_xmm2      t__darwin_xmm_reg
	F__fpu_xmm3      t__darwin_xmm_reg
	F__fpu_xmm4      t__darwin_xmm_reg
	F__fpu_xmm5      t__darwin_xmm_reg
	F__fpu_xmm6      t__darwin_xmm_reg
	F__fpu_xmm7      t__darwin_xmm_reg
	F__fpu_rsrv4     [224]int8
	F__fpu_reserved1 int32
	F__avx_reserved1 [64]int8
	F__fpu_ymmh0     t__darwin_xmm_reg
	F__fpu_ymmh1     t__darwin_xmm_reg
	F__fpu_ymmh2     t__darwin_xmm_reg
	F__fpu_ymmh3     t__darwin_xmm_reg
	F__fpu_ymmh4     t__darwin_xmm_reg
	F__fpu_ymmh5     t__darwin_xmm_reg
	F__fpu_ymmh6     t__darwin_xmm_reg
	F__fpu_ymmh7     t__darwin_xmm_reg
	F__fpu_k0        t__darwin_opmask_reg
	F__fpu_k1        t__darwin_opmask_reg
	F__fpu_k2        t__darwin_opmask_reg
	F__fpu_k3        t__darwin_opmask_reg
	F__fpu_k4        t__darwin_opmask_reg
	F__fpu_k5        t__darwin_opmask_reg
	F__fpu_k6        t__darwin_opmask_reg
	F__fpu_k7        t__darwin_opmask_reg
	F__fpu_zmmh0     t__darwin_ymm_reg
	F__fpu_zmmh1     t__darwin_ymm_reg
	F__fpu_zmmh2     t__darwin_ymm_reg
	F__fpu_zmmh3     t__darwin_ymm_reg
	F__fpu_zmmh4     t__darwin_ymm_reg
	F__fpu_zmmh5     t__darwin_ymm_reg
	F__fpu_zmmh6     t__darwin_ymm_reg
	F__fpu_zmmh7     t__darwin_ymm_reg
}

type t__darwin_i386_exception_state = struct {
	F__trapno     t__uint16_t
	F__cpu        t__uint16_t
	F__err        t__uint32_t
	F__faultvaddr t__uint32_t
}

type t__darwin_x86_debug_state32 = struct {
	F__dr0 uint32
	F__dr1 uint32
	F__dr2 uint32
	F__dr3 uint32
	F__dr4 uint32
	F__dr5 uint32
	F__dr6 uint32
	F__dr7 uint32
}

type t__x86_instruction_state = struct {
	F__insn_stream_valid_bytes int32
	F__insn_offset             int32
	F__out_of_synch            int32
	F__insn_bytes              [2380]t__uint8_t
	F__insn_cacheline          [64]t__uint8_t
}

type t__last_branch_record = struct {
	F__from_ip t__uint64_t
	F__to_ip   t__uint64_t
	F__ccgo16  uint32
}

type t__last_branch_state = struct {
	F__lbr_count int32
	F__ccgo4     uint32
	F__lbrs      [32]t__last_branch_record
}

type t__x86_pagein_state = struct {
	F__pagein_error int32
}

type t__darwin_x86_thread_state64 = struct {
	F__rax    t__uint64_t
	F__rbx    t__uint64_t
	F__rcx    t__uint64_t
	F__rdx    t__uint64_t
	F__rdi    t__uint64_t
	F__rsi    t__uint64_t
	F__rbp    t__uint64_t
	F__rsp    t__uint64_t
	F__r8     t__uint64_t
	F__r9     t__uint64_t
	F__r10    t__uint64_t
	F__r11    t__uint64_t
	F__r12    t__uint64_t
	F__r13    t__uint64_t
	F__r14    t__uint64_t
	F__r15    t__uint64_t
	F__rip    t__uint64_t
	F__rflags t__uint64_t
	F__cs     t__uint64_t
	F__fs     t__uint64_t
	F__gs     t__uint64_t
}

type t__darwin_x86_thread_full_state64 = struct {
	F__ss64   t__darwin_x86_thread_state64
	F__ds     t__uint64_t
	F__es     t__uint64_t
	F__ss     t__uint64_t
	F__gsbase t__uint64_t
}

type t__darwin_x86_float_state64 = struct {
	F__fpu_reserved  [2]int32
	F__fpu_fcw       t__darwin_fp_control
	F__fpu_fsw       t__darwin_fp_status
	F__fpu_ftw       t__uint8_t
	F__fpu_rsrv1     t__uint8_t
	F__fpu_fop       t__uint16_t
	F__fpu_ip        t__uint32_t
	F__fpu_cs        t__uint16_t
	F__fpu_rsrv2     t__uint16_t
	F__fpu_dp        t__uint32_t
	F__fpu_ds        t__uint16_t
	F__fpu_rsrv3     t__uint16_t
	F__fpu_mxcsr     t__uint32_t
	F__fpu_mxcsrmask t__uint32_t
	F__fpu_stmm0     t__darwin_mmst_reg
	F__fpu_stmm1     t__darwin_mmst_reg
	F__fpu_stmm2     t__darwin_mmst_reg
	F__fpu_stmm3     t__darwin_mmst_reg
	F__fpu_stmm4     t__darwin_mmst_reg
	F__fpu_stmm5     t__darwin_mmst_reg
	F__fpu_stmm6     t__darwin_mmst_reg
	F__fpu_stmm7     t__darwin_mmst_reg
	F__fpu_xmm0      t__darwin_xmm_reg
	F__fpu_xmm1      t__darwin_xmm_reg
	F__fpu_xmm2      t__darwin_xmm_reg
	F__fpu_xmm3      t__darwin_xmm_reg
	F__fpu_xmm4      t__darwin_xmm_reg
	F__fpu_xmm5      t__darwin_xmm_reg
	F__fpu_xmm6      t__darwin_xmm_reg
	F__fpu_xmm7      t__darwin_xmm_reg
	F__fpu_xmm8      t__darwin_xmm_reg
	F__fpu_xmm9      t__darwin_xmm_reg
	F__fpu_xmm10     t__darwin_xmm_reg
	F__fpu_xmm11     t__darwin_xmm_reg
	F__fpu_xmm12     t__darwin_xmm_reg
	F__fpu_xmm13     t__darwin_xmm_reg
	F__fpu_xmm14     t__darwin_xmm_reg
	F__fpu_xmm15     t__darwin_xmm_reg
	F__fpu_rsrv4     [96]int8
	F__fpu_reserved1 int32
}

type t__darwin_x86_avx_state64 = struct {
	F__fpu_reserved  [2]int32
	F__fpu_fcw       t__darwin_fp_control
	F__fpu_fsw       t__darwin_fp_status
	F__fpu_ftw       t__uint8_t
	F__fpu_rsrv1     t__uint8_t
	F__fpu_fop       t__uint16_t
	F__fpu_ip        t__uint32_t
	F__fpu_cs        t__uint16_t
	F__fpu_rsrv2     t__uint16_t
	F__fpu_dp        t__uint32_t
	F__fpu_ds        t__uint16_t
	F__fpu_rsrv3     t__uint16_t
	F__fpu_mxcsr     t__uint32_t
	F__fpu_mxcsrmask t__uint32_t
	F__fpu_stmm0     t__darwin_mmst_reg
	F__fpu_stmm1     t__darwin_mmst_reg
	F__fpu_stmm2     t__darwin_mmst_reg
	F__fpu_stmm3     t__darwin_mmst_reg
	F__fpu_stmm4     t__darwin_mmst_reg
	F__fpu_stmm5     t__darwin_mmst_reg
	F__fpu_stmm6     t__darwin_mmst_reg
	F__fpu_stmm7     t__darwin_mmst_reg
	F__fpu_xmm0      t__darwin_xmm_reg
	F__fpu_xmm1      t__darwin_xmm_reg
	F__fpu_xmm2      t__darwin_xmm_reg
	F__fpu_xmm3      t__darwin_xmm_reg
	F__fpu_xmm4      t__darwin_xmm_reg
	F__fpu_xmm5      t__darwin_xmm_reg
	F__fpu_xmm6      t__darwin_xmm_reg
	F__fpu_xmm7      t__darwin_xmm_reg
	F__fpu_xmm8      t__darwin_xmm_reg
	F__fpu_xmm9      t__darwin_xmm_reg
	F__fpu_xmm10     t__darwin_xmm_reg
	F__fpu_xmm11     t__darwin_xmm_reg
	F__fpu_xmm12     t__darwin_xmm_reg
	F__fpu_xmm13     t__darwin_xmm_reg
	F__fpu_xmm14     t__darwin_xmm_reg
	F__fpu_xmm15     t__darwin_xmm_reg
	F__fpu_rsrv4     [96]int8
	F__fpu_reserved1 int32
	F__avx_reserved1 [64]int8
	F__fpu_ymmh0     t__darwin_xmm_reg
	F__fpu_ymmh1     t__darwin_xmm_reg
	F__fpu_ymmh2     t__darwin_xmm_reg
	F__fpu_ymmh3     t__darwin_xmm_reg
	F__fpu_ymmh4     t__darwin_xmm_reg
	F__fpu_ymmh5     t__darwin_xmm_reg
	F__fpu_ymmh6     t__darwin_xmm_reg
	F__fpu_ymmh7     t__darwin_xmm_reg
	F__fpu_ymmh8     t__darwin_xmm_reg
	F__fpu_ymmh9     t__darwin_xmm_reg
	F__fpu_ymmh10    t__darwin_xmm_reg
	F__fpu_ymmh11    t__darwin_xmm_reg
	F__fpu_ymmh12    t__darwin_xmm_reg
	F__fpu_ymmh13    t__darwin_xmm_reg
	F__fpu_ymmh14    t__darwin_xmm_reg
	F__fpu_ymmh15    t__darwin_xmm_reg
}

type t__darwin_x86_avx512_state64 = struct {
	F__fpu_reserved  [2]int32
	F__fpu_fcw       t__darwin_fp_control
	F__fpu_fsw       t__darwin_fp_status
	F__fpu_ftw       t__uint8_t
	F__fpu_rsrv1     t__uint8_t
	F__fpu_fop       t__uint16_t
	F__fpu_ip        t__uint32_t
	F__fpu_cs        t__uint16_t
	F__fpu_rsrv2     t__uint16_t
	F__fpu_dp        t__uint32_t
	F__fpu_ds        t__uint16_t
	F__fpu_rsrv3     t__uint16_t
	F__fpu_mxcsr     t__uint32_t
	F__fpu_mxcsrmask t__uint32_t
	F__fpu_stmm0     t__darwin_mmst_reg
	F__fpu_stmm1     t__darwin_mmst_reg
	F__fpu_stmm2     t__darwin_mmst_reg
	F__fpu_stmm3     t__darwin_mmst_reg
	F__fpu_stmm4     t__darwin_mmst_reg
	F__fpu_stmm5     t__darwin_mmst_reg
	F__fpu_stmm6     t__darwin_mmst_reg
	F__fpu_stmm7     t__darwin_mmst_reg
	F__fpu_xmm0      t__darwin_xmm_reg
	F__fpu_xmm1      t__darwin_xmm_reg
	F__fpu_xmm2      t__darwin_xmm_reg
	F__fpu_xmm3      t__darwin_xmm_reg
	F__fpu_xmm4      t__darwin_xmm_reg
	F__fpu_xmm5      t__darwin_xmm_reg
	F__fpu_xmm6      t__darwin_xmm_reg
	F__fpu_xmm7      t__darwin_xmm_reg
	F__fpu_xmm8      t__darwin_xmm_reg
	F__fpu_xmm9      t__darwin_xmm_reg
	F__fpu_xmm10     t__darwin_xmm_reg
	F__fpu_xmm11     t__darwin_xmm_reg
	F__fpu_xmm12     t__darwin_xmm_reg
	F__fpu_xmm13     t__darwin_xmm_reg
	F__fpu_xmm14     t__darwin_xmm_reg
	F__fpu_xmm15     t__darwin_xmm_reg
	F__fpu_rsrv4     [96]int8
	F__fpu_reserved1 int32
	F__avx_reserved1 [64]int8
	F__fpu_ymmh0     t__darwin_xmm_reg
	F__fpu_ymmh1     t__darwin_xmm_reg
	F__fpu_ymmh2     t__darwin_xmm_reg
	F__fpu_ymmh3     t__darwin_xmm_reg
	F__fpu_ymmh4     t__darwin_xmm_reg
	F__fpu_ymmh5     t__darwin_xmm_reg
	F__fpu_ymmh6     t__darwin_xmm_reg
	F__fpu_ymmh7     t__darwin_xmm_reg
	F__fpu_ymmh8     t__darwin_xmm_reg
	F__fpu_ymmh9     t__darwin_xmm_reg
	F__fpu_ymmh10    t__darwin_xmm_reg
	F__fpu_ymmh11    t__darwin_xmm_reg
	F__fpu_ymmh12    t__darwin_xmm_reg
	F__fpu_ymmh13    t__darwin_xmm_reg
	F__fpu_ymmh14    t__darwin_xmm_reg
	F__fpu_ymmh15    t__darwin_xmm_reg
	F__fpu_k0        t__darwin_opmask_reg
	F__fpu_k1        t__darwin_opmask_reg
	F__fpu_k2        t__darwin_opmask_reg
	F__fpu_k3        t__darwin_opmask_reg
	F__fpu_k4        t__darwin_opmask_reg
	F__fpu_k5        t__darwin_opmask_reg
	F__fpu_k6        t__darwin_opmask_reg
	F__fpu_k7        t__darwin_opmask_reg
	F__fpu_zmmh0     t__darwin_ymm_reg
	F__fpu_zmmh1     t__darwin_ymm_reg
	F__fpu_zmmh2     t__darwin_ymm_reg
	F__fpu_zmmh3     t__darwin_ymm_reg
	F__fpu_zmmh4     t__darwin_ymm_reg
	F__fpu_zmmh5     t__darwin_ymm_reg
	F__fpu_zmmh6     t__darwin_ymm_reg
	F__fpu_zmmh7     t__darwin_ymm_reg
	F__fpu_zmmh8     t__darwin_ymm_reg
	F__fpu_zmmh9     t__darwin_ymm_reg
	F__fpu_zmmh10    t__darwin_ymm_reg
	F__fpu_zmmh11    t__darwin_ymm_reg
	F__fpu_zmmh12    t__darwin_ymm_reg
	F__fpu_zmmh13    t__darwin_ymm_reg
	F__fpu_zmmh14    t__darwin_ymm_reg
	F__fpu_zmmh15    t__darwin_ymm_reg
	F__fpu_zmm16     t__darwin_zmm_reg
	F__fpu_zmm17     t__darwin_zmm_reg
	F__fpu_zmm18     t__darwin_zmm_reg
	F__fpu_zmm19     t__darwin_zmm_reg
	F__fpu_zmm20     t__darwin_zmm_reg
	F__fpu_zmm21     t__darwin_zmm_reg
	F__fpu_zmm22     t__darwin_zmm_reg
	F__fpu_zmm23     t__darwin_zmm_reg
	F__fpu_zmm24     t__darwin_zmm_reg
	F__fpu_zmm25     t__darwin_zmm_reg
	F__fpu_zmm26     t__darwin_zmm_reg
	F__fpu_zmm27     t__darwin_zmm_reg
	F__fpu_zmm28     t__darwin_zmm_reg
	F__fpu_zmm29     t__darwin_zmm_reg
	F__fpu_zmm30     t__darwin_zmm_reg
	F__fpu_zmm31     t__darwin_zmm_reg
}

type t__darwin_x86_exception_state64 = struct {
	F__trapno     t__uint16_t
	F__cpu        t__uint16_t
	F__err        t__uint32_t
	F__faultvaddr t__uint64_t
}

type t__darwin_x86_debug_state64 = struct {
	F__dr0 t__uint64_t
	F__dr1 t__uint64_t
	F__dr2 t__uint64_t
	F__dr3 t__uint64_t
	F__dr4 t__uint64_t
	F__dr5 t__uint64_t
	F__dr6 t__uint64_t
	F__dr7 t__uint64_t
}

type t__darwin_x86_cpmu_state64 = struct {
	F__ctrs [16]t__uint64_t
}

type t__darwin_mcontext32 = struct {
	F__es t__darwin_i386_exception_state
	F__ss t__darwin_i386_thread_state
	F__fs t__darwin_i386_float_state
}

type t__darwin_mcontext_avx32 = struct {
	F__es t__darwin_i386_exception_state
	F__ss t__darwin_i386_thread_state
	F__fs t__darwin_i386_avx_state
}

type t__darwin_mcontext_avx512_32 = struct {
	F__es t__darwin_i386_exception_state
	F__ss t__darwin_i386_thread_state
	F__fs t__darwin_i386_avx512_state
}

type t__darwin_mcontext64 = struct {
	F__es t__darwin_x86_exception_state64
	F__ss t__darwin_x86_thread_state64
	F__fs t__darwin_x86_float_state64
}

type t__darwin_mcontext64_full = struct {
	F__es t__darwin_x86_exception_state64
	F__ss t__darwin_x86_thread_full_state64
	F__fs t__darwin_x86_float_state64
}

type t__darwin_mcontext_avx64 = struct {
	F__es t__darwin_x86_exception_state64
	F__ss t__darwin_x86_thread_state64
	F__fs t__darwin_x86_avx_state64
}

type t__darwin_mcontext_avx64_full = struct {
	F__es t__darwin_x86_exception_state64
	F__ss t__darwin_x86_thread_full_state64
	F__fs t__darwin_x86_avx_state64
}

type t__darwin_mcontext_avx512_64 = struct {
	F__es t__darwin_x86_exception_state64
	F__ss t__darwin_x86_thread_state64
	F__fs t__darwin_x86_avx512_state64
}

type t__darwin_mcontext_avx512_64_full = struct {
	F__es t__darwin_x86_exception_state64
	F__ss t__darwin_x86_thread_full_state64
	F__fs t__darwin_x86_avx512_state64
}

type Tmcontext_t = uintptr

type Tpthread_attr_t = struct {
	F__sig    int64
	F__opaque [56]int8
}

type t__darwin_sigaltstack = struct {
	Fss_sp    uintptr
	Fss_size  t__darwin_size_t
	Fss_flags int32
}

type Tstack_t = struct {
	Fss_sp    uintptr
	Fss_size  t__darwin_size_t
	Fss_flags int32
}

type t__darwin_ucontext = struct {
	Fuc_onstack  int32
	Fuc_sigmask  t__darwin_sigset_t
	Fuc_stack    t__darwin_sigaltstack
	Fuc_link     uintptr
	Fuc_mcsize   t__darwin_size_t
	Fuc_mcontext uintptr
}

type Tucontext_t = struct {
	Fuc_onstack  int32
	Fuc_sigmask  t__darwin_sigset_t
	Fuc_stack    t__darwin_sigaltstack
	Fuc_link     uintptr
	Fuc_mcsize   t__darwin_size_t
	Fuc_mcontext uintptr
}

type Tsigset_t = uint32

type Tuid_t = uint32

type Tsigval = struct {
	Fsival_ptr   [0]uintptr
	Fsival_int   int32
	F__ccgo_pad2 [4]byte
}

type Tsigevent = struct {
	Fsigev_notify            int32
	Fsigev_signo             int32
	Fsigev_value             Tsigval
	Fsigev_notify_function   uintptr
	Fsigev_notify_attributes uintptr
}

type Tsiginfo_t = struct {
	Fsi_signo  int32
	Fsi_errno  int32
	Fsi_code   int32
	Fsi_pid    Tpid_t
	Fsi_uid    Tuid_t
	Fsi_status int32
	Fsi_addr   uintptr
	Fsi_value  Tsigval
	Fsi_band   int64
	F__pad     [7]uint64
}

type t__siginfo = Tsiginfo_t

type t__sigaction_u = struct {
	F__sa_sigaction [0]uintptr
	F__sa_handler   uintptr
}

type t__sigaction = struct {
	F__sigaction_u t__sigaction_u
	Fsa_tramp      uintptr
	Fsa_mask       Tsigset_t
	Fsa_flags      int32
}

type Tsigaction = struct {
	F__sigaction_u t__sigaction_u
	Fsa_mask       Tsigset_t
	Fsa_flags      int32
}

type Tsig_t = uintptr

type Tsigvec = struct {
	Fsv_handler uintptr
	Fsv_mask    int32
	Fsv_flags   int32
}

type Tsigstack = struct {
	Fss_sp      uintptr
	Fss_onstack int32
}

type Tuint64_t = uint64

type Tint_least64_t = int64

type Tuint_least64_t = uint64

type Tint_fast64_t = int64

type Tuint_fast64_t = uint64

type Tuint32_t = uint32

type Tint_least32_t = int32

type Tuint_least32_t = uint32

type Tint_fast32_t = int32

type Tuint_fast32_t = uint32

type Tuint16_t = uint16

type Tint_least16_t = int16

type Tuint_least16_t = uint16

type Tint_fast16_t = int16

type Tuint_fast16_t = uint16

type Tuint8_t = uint8

type Tint_least8_t = int8

type Tuint_least8_t = uint8

type Tint_fast8_t = int8

type Tuint_fast8_t = uint8

type Tintmax_t = int64

type Tuintmax_t = uint64

type Ttimeval = struct {
	Ftv_sec  t__darwin_time_t
	Ftv_usec t__darwin_suseconds_t
}

type Trlim_t = uint64

type Trusage = struct {
	Fru_utime    Ttimeval
	Fru_stime    Ttimeval
	Fru_maxrss   int64
	Fru_ixrss    int64
	Fru_idrss    int64
	Fru_isrss    int64
	Fru_minflt   int64
	Fru_majflt   int64
	Fru_nswap    int64
	Fru_inblock  int64
	Fru_oublock  int64
	Fru_msgsnd   int64
	Fru_msgrcv   int64
	Fru_nsignals int64
	Fru_nvcsw    int64
	Fru_nivcsw   int64
}

type Trusage_info_t = uintptr

type Trusage_info_v0 = struct {
	Fri_uuid               [16]Tuint8_t
	Fri_user_time          Tuint64_t
	Fri_system_time        Tuint64_t
	Fri_pkg_idle_wkups     Tuint64_t
	Fri_interrupt_wkups    Tuint64_t
	Fri_pageins            Tuint64_t
	Fri_wired_size         Tuint64_t
	Fri_resident_size      Tuint64_t
	Fri_phys_footprint     Tuint64_t
	Fri_proc_start_abstime Tuint64_t
	Fri_proc_exit_abstime  Tuint64_t
}

type Trusage_info_v1 = struct {
	Fri_uuid                  [16]Tuint8_t
	Fri_user_time             Tuint64_t
	Fri_system_time           Tuint64_t
	Fri_pkg_idle_wkups        Tuint64_t
	Fri_interrupt_wkups       Tuint64_t
	Fri_pageins               Tuint64_t
	Fri_wired_size            Tuint64_t
	Fri_resident_size         Tuint64_t
	Fri_phys_footprint        Tuint64_t
	Fri_proc_start_abstime    Tuint64_t
	Fri_proc_exit_abstime     Tuint64_t
	Fri_child_user_time       Tuint64_t
	Fri_child_system_time     Tuint64_t
	Fri_child_pkg_idle_wkups  Tuint64_t
	Fri_child_interrupt_wkups Tuint64_t
	Fri_child_pageins         Tuint64_t
	Fri_child_elapsed_abstime Tuint64_t
}

type Trusage_info_v2 = struct {
	Fri_uuid                  [16]Tuint8_t
	Fri_user_time             Tuint64_t
	Fri_system_time           Tuint64_t
	Fri_pkg_idle_wkups        Tuint64_t
	Fri_interrupt_wkups       Tuint64_t
	Fri_pageins               Tuint64_t
	Fri_wired_size            Tuint64_t
	Fri_resident_size         Tuint64_t
	Fri_phys_footprint        Tuint64_t
	Fri_proc_start_abstime    Tuint64_t
	Fri_proc_exit_abstime     Tuint64_t
	Fri_child_user_time       Tuint64_t
	Fri_child_system_time     Tuint64_t
	Fri_child_pkg_idle_wkups  Tuint64_t
	Fri_child_interrupt_wkups Tuint64_t
	Fri_child_pageins         Tuint64_t
	Fri_child_elapsed_abstime Tuint64_t
	Fri_diskio_bytesread      Tuint64_t
	Fri_diskio_byteswritten   Tuint64_t
}

type Trusage_info_v3 = struct {
	Fri_uuid                          [16]Tuint8_t
	Fri_user_time                     Tuint64_t
	Fri_system_time                   Tuint64_t
	Fri_pkg_idle_wkups                Tuint64_t
	Fri_interrupt_wkups               Tuint64_t
	Fri_pageins                       Tuint64_t
	Fri_wired_size                    Tuint64_t
	Fri_resident_size                 Tuint64_t
	Fri_phys_footprint                Tuint64_t
	Fri_proc_start_abstime            Tuint64_t
	Fri_proc_exit_abstime             Tuint64_t
	Fri_child_user_time               Tuint64_t
	Fri_child_system_time             Tuint64_t
	Fri_child_pkg_idle_wkups          Tuint64_t
	Fri_child_interrupt_wkups         Tuint64_t
	Fri_child_pageins                 Tuint64_t
	Fri_child_elapsed_abstime         Tuint64_t
	Fri_diskio_bytesread              Tuint64_t
	Fri_diskio_byteswritten           Tuint64_t
	Fri_cpu_time_qos_default          Tuint64_t
	Fri_cpu_time_qos_maintenance      Tuint64_t
	Fri_cpu_time_qos_background       Tuint64_t
	Fri_cpu_time_qos_utility          Tuint64_t
	Fri_cpu_time_qos_legacy           Tuint64_t
	Fri_cpu_time_qos_user_initiated   Tuint64_t
	Fri_cpu_time_qos_user_interactive Tuint64_t
	Fri_billed_system_time            Tuint64_t
	Fri_serviced_system_time          Tuint64_t
}

type Trusage_info_v4 = struct {
	Fri_uuid                          [16]Tuint8_t
	Fri_user_time                     Tuint64_t
	Fri_system_time                   Tuint64_t
	Fri_pkg_idle_wkups                Tuint64_t
	Fri_interrupt_wkups               Tuint64_t
	Fri_pageins                       Tuint64_t
	Fri_wired_size                    Tuint64_t
	Fri_resident_size                 Tuint64_t
	Fri_phys_footprint                Tuint64_t
	Fri_proc_start_abstime            Tuint64_t
	Fri_proc_exit_abstime             Tuint64_t
	Fri_child_user_time               Tuint64_t
	Fri_child_system_time             Tuint64_t
	Fri_child_pkg_idle_wkups          Tuint64_t
	Fri_child_interrupt_wkups         Tuint64_t
	Fri_child_pageins                 Tuint64_t
	Fri_child_elapsed_abstime         Tuint64_t
	Fri_diskio_bytesread              Tuint64_t
	Fri_diskio_byteswritten           Tuint64_t
	Fri_cpu_time_qos_default          Tuint64_t
	Fri_cpu_time_qos_maintenance      Tuint64_t
	Fri_cpu_time_qos_background       Tuint64_t
	Fri_cpu_time_qos_utility          Tuint64_t
	Fri_cpu_time_qos_legacy           Tuint64_t
	Fri_cpu_time_qos_user_initiated   Tuint64_t
	Fri_cpu_time_qos_user_interactive Tuint64_t
	Fri_billed_system_time            Tuint64_t
	Fri_serviced_system_time          Tuint64_t
	Fri_logical_writes                Tuint64_t
	Fri_lifetime_max_phys_footprint   Tuint64_t
	Fri_instructions                  Tuint64_t
	Fri_cycles                        Tuint64_t
	Fri_billed_energy                 Tuint64_t
	Fri_serviced_energy               Tuint64_t
	Fri_interval_max_phys_footprint   Tuint64_t
	Fri_runnable_time                 Tuint64_t
}

type Trusage_info_v5 = struct {
	Fri_uuid                          [16]Tuint8_t
	Fri_user_time                     Tuint64_t
	Fri_system_time                   Tuint64_t
	Fri_pkg_idle_wkups                Tuint64_t
	Fri_interrupt_wkups               Tuint64_t
	Fri_pageins                       Tuint64_t
	Fri_wired_size                    Tuint64_t
	Fri_resident_size                 Tuint64_t
	Fri_phys_footprint                Tuint64_t
	Fri_proc_start_abstime            Tuint64_t
	Fri_proc_exit_abstime             Tuint64_t
	Fri_child_user_time               Tuint64_t
	Fri_child_system_time             Tuint64_t
	Fri_child_pkg_idle_wkups          Tuint64_t
	Fri_child_interrupt_wkups         Tuint64_t
	Fri_child_pageins                 Tuint64_t
	Fri_child_elapsed_abstime         Tuint64_t
	Fri_diskio_bytesread              Tuint64_t
	Fri_diskio_byteswritten           Tuint64_t
	Fri_cpu_time_qos_default          Tuint64_t
	Fri_cpu_time_qos_maintenance      Tuint64_t
	Fri_cpu_time_qos_background       Tuint64_t
	Fri_cpu_time_qos_utility          Tuint64_t
	Fri_cpu_time_qos_legacy           Tuint64_t
	Fri_cpu_time_qos_user_initiated   Tuint64_t
	Fri_cpu_time_qos_user_interactive Tuint64_t
	Fri_billed_system_time            Tuint64_t
	Fri_serviced_system_time          Tuint64_t
	Fri_logical_writes                Tuint64_t
	Fri_lifetime_max_phys_footprint   Tuint64_t
	Fri_instructions                  Tuint64_t
	Fri_cycles                        Tuint64_t
	Fri_billed_energy                 Tuint64_t
	Fri_serviced_energy               Tuint64_t
	Fri_interval_max_phys_footprint   Tuint64_t
	Fri_runnable_time                 Tuint64_t
	Fri_flags                         Tuint64_t
}

type Trusage_info_v6 = struct {
	Fri_uuid                          [16]Tuint8_t
	Fri_user_time                     Tuint64_t
	Fri_system_time                   Tuint64_t
	Fri_pkg_idle_wkups                Tuint64_t
	Fri_interrupt_wkups               Tuint64_t
	Fri_pageins                       Tuint64_t
	Fri_wired_size                    Tuint64_t
	Fri_resident_size                 Tuint64_t
	Fri_phys_footprint                Tuint64_t
	Fri_proc_start_abstime            Tuint64_t
	Fri_proc_exit_abstime             Tuint64_t
	Fri_child_user_time               Tuint64_t
	Fri_child_system_time             Tuint64_t
	Fri_child_pkg_idle_wkups          Tuint64_t
	Fri_child_interrupt_wkups         Tuint64_t
	Fri_child_pageins                 Tuint64_t
	Fri_child_elapsed_abstime         Tuint64_t
	Fri_diskio_bytesread              Tuint64_t
	Fri_diskio_byteswritten           Tuint64_t
	Fri_cpu_time_qos_default          Tuint64_t
	Fri_cpu_time_qos_maintenance      Tuint64_t
	Fri_cpu_time_qos_background       Tuint64_t
	Fri_cpu_time_qos_utility          Tuint64_t
	Fri_cpu_time_qos_legacy           Tuint64_t
	Fri_cpu_time_qos_user_initiated   Tuint64_t
	Fri_cpu_time_qos_user_interactive Tuint64_t
	Fri_billed_system_time            Tuint64_t
	Fri_serviced_system_time          Tuint64_t
	Fri_logical_writes                Tuint64_t
	Fri_lifetime_max_phys_footprint   Tuint64_t
	Fri_instructions                  Tuint64_t
	Fri_cycles                        Tuint64_t
	Fri_billed_energy                 Tuint64_t
	Fri_serviced_energy               Tuint64_t
	Fri_interval_max_phys_footprint   Tuint64_t
	Fri_runnable_time                 Tuint64_t
	Fri_flags                         Tuint64_t
	Fri_user_ptime                    Tuint64_t
	Fri_system_ptime                  Tuint64_t
	Fri_pinstructions                 Tuint64_t
	Fri_pcycles                       Tuint64_t
	Fri_energy_nj                     Tuint64_t
	Fri_penergy_nj                    Tuint64_t
	Fri_secure_time_in_system         Tuint64_t
	Fri_secure_ptime_in_system        Tuint64_t
	Fri_reserved                      [12]Tuint64_t
}

type Trusage_info_current = struct {
	Fri_uuid                          [16]Tuint8_t
	Fri_user_time                     Tuint64_t
	Fri_system_time                   Tuint64_t
	Fri_pkg_idle_wkups                Tuint64_t
	Fri_interrupt_wkups               Tuint64_t
	Fri_pageins                       Tuint64_t
	Fri_wired_size                    Tuint64_t
	Fri_resident_size                 Tuint64_t
	Fri_phys_footprint                Tuint64_t
	Fri_proc_start_abstime            Tuint64_t
	Fri_proc_exit_abstime             Tuint64_t
	Fri_child_user_time               Tuint64_t
	Fri_child_system_time             Tuint64_t
	Fri_child_pkg_idle_wkups          Tuint64_t
	Fri_child_interrupt_wkups         Tuint64_t
	Fri_child_pageins                 Tuint64_t
	Fri_child_elapsed_abstime         Tuint64_t
	Fri_diskio_bytesread              Tuint64_t
	Fri_diskio_byteswritten           Tuint64_t
	Fri_cpu_time_qos_default          Tuint64_t
	Fri_cpu_time_qos_maintenance      Tuint64_t
	Fri_cpu_time_qos_background       Tuint64_t
	Fri_cpu_time_qos_utility          Tuint64_t
	Fri_cpu_time_qos_legacy           Tuint64_t
	Fri_cpu_time_qos_user_initiated   Tuint64_t
	Fri_cpu_time_qos_user_interactive Tuint64_t
	Fri_billed_system_time            Tuint64_t
	Fri_serviced_system_time          Tuint64_t
	Fri_logical_writes                Tuint64_t
	Fri_lifetime_max_phys_footprint   Tuint64_t
	Fri_instructions                  Tuint64_t
	Fri_cycles                        Tuint64_t
	Fri_billed_energy                 Tuint64_t
	Fri_serviced_energy               Tuint64_t
	Fri_interval_max_phys_footprint   Tuint64_t
	Fri_runnable_time                 Tuint64_t
	Fri_flags                         Tuint64_t
	Fri_user_ptime                    Tuint64_t
	Fri_system_ptime                  Tuint64_t
	Fri_pinstructions                 Tuint64_t
	Fri_pcycles                       Tuint64_t
	Fri_energy_nj                     Tuint64_t
	Fri_penergy_nj                    Tuint64_t
	Fri_secure_time_in_system         Tuint64_t
	Fri_secure_ptime_in_system        Tuint64_t
	Fri_reserved                      [12]Tuint64_t
}

type Trlimit = struct {
	Frlim_cur Trlim_t
	Frlim_max Trlim_t
}

type Tproc_rlimit_control_wakeupmon = struct {
	Fwm_flags Tuint32_t
	Fwm_rate  Tint32_t
}

type Twait = struct {
	Fw_T [0]struct {
		F__ccgo0 uint32
	}
	Fw_S [0]struct {
		F__ccgo0 uint32
	}
	Fw_status int32
}

type Tct_rune_t = int32

type Trune_t = int32

type Twchar_t = int32

type Tdiv_t = struct {
	Fquot int32
	Frem  int32
}

type Tldiv_t = struct {
	Fquot int64
	Frem  int64
}

type Tlldiv_t = struct {
	Fquot int64
	Frem  int64
}

type Tmalloc_type_id_t = uint64

type Tdev_t = int32

type Tmode_t = uint16

type Trsize_t = uint64

type Terrno_t = int32

type Twint_t = int32

type T_RuneEntry = struct {
	F__min   t__darwin_rune_t
	F__max   t__darwin_rune_t
	F__map   t__darwin_rune_t
	F__types uintptr
}

type T_RuneRange = struct {
	F__nranges int32
	F__ranges  uintptr
}

type T_RuneCharClass = struct {
	F__name [14]int8
	F__mask t__uint32_t
}

type T_RuneLocale = struct {
	F__magic        [8]int8
	F__encoding     [32]int8
	F__sgetrune     uintptr
	F__sputrune     uintptr
	F__invalid_rune t__darwin_rune_t
	F__runetype     [256]t__uint32_t
	F__maplower     [256]t__darwin_rune_t
	F__mapupper     [256]t__darwin_rune_t
	F__runetype_ext T_RuneRange
	F__maplower_ext T_RuneRange
	F__mapupper_ext T_RuneRange
	F__variable     uintptr
	F__variable_len int32
	F__ncharclasses int32
	F__charclasses  uintptr
}

type Tu_char = uint8

type Tu_short = uint16

type Tu_int = uint32

type Tu_long = uint64

type Tushort = uint16

type Tuint = uint32

type Tu_quad_t = uint64

type Tquad_t = int64

type Tqaddr_t = uintptr

type Tcaddr_t = uintptr

type Tdaddr_t = int32

type Tfixpt_t = uint32

type Tblkcnt_t = int64

type Tblksize_t = int32

type Tgid_t = uint32

type Tin_addr_t = uint32

type Tin_port_t = uint16

type Tino_t = uint64

type Tino64_t = uint64

type Tkey_t = int32

type Tnlink_t = uint16

type Tsegsz_t = int32

type Tswblk_t = int32

type Tclock_t = uint64

type Ttime_t = int64

type Tuseconds_t = uint32

type Tsuseconds_t = int32

type Tfd_set = struct {
	Ffds_bits [32]t__int32_t
}

type Tfd_mask = int32

type Tpthread_cond_t = struct {
	F__sig    int64
	F__opaque [40]int8
}

type Tpthread_condattr_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type Tpthread_mutex_t = struct {
	F__sig    int64
	F__opaque [56]int8
}

type Tpthread_mutexattr_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type Tpthread_once_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type Tpthread_rwlock_t = struct {
	F__sig    int64
	F__opaque [192]int8
}

type Tpthread_rwlockattr_t = struct {
	F__sig    int64
	F__opaque [16]int8
}

type Tpthread_t = uintptr

type Tpthread_key_t = uint64

type Tfsblkcnt_t = uint32

type Tfsfilcnt_t = uint32

type TXID = uint64

type TMask = uint64

type TAtom = uint64

type TVisualID = uint64

type TTime = uint64

type TWindow = uint64

type TDrawable = uint64

type TFont = uint64

type TPixmap = uint64

type TCursor = uint64

type TColormap = uint64

type TGContext = uint64

type TKeySym = uint64

type TKeyCode = uint8

type Tptrdiff_t = int64

type Tmax_align_t = float64

type TXPointer = uintptr

type TXExtData = struct {
	Fnumber       int32
	Fnext         uintptr
	Ffree_private uintptr
	Fprivate_data TXPointer
}

type T_XExtData = TXExtData

type TXExtCodes = struct {
	Fextension    int32
	Fmajor_opcode int32
	Ffirst_event  int32
	Ffirst_error  int32
}

type TXPixmapFormatValues = struct {
	Fdepth          int32
	Fbits_per_pixel int32
	Fscanline_pad   int32
}

type TXGCValues = struct {
	Ffunction           int32
	Fplane_mask         uint64
	Fforeground         uint64
	Fbackground         uint64
	Fline_width         int32
	Fline_style         int32
	Fcap_style          int32
	Fjoin_style         int32
	Ffill_style         int32
	Ffill_rule          int32
	Farc_mode           int32
	Ftile               TPixmap
	Fstipple            TPixmap
	Fts_x_origin        int32
	Fts_y_origin        int32
	Ffont               TFont
	Fsubwindow_mode     int32
	Fgraphics_exposures int32
	Fclip_x_origin      int32
	Fclip_y_origin      int32
	Fclip_mask          TPixmap
	Fdash_offset        int32
	Fdashes             int8
}

type TGC = uintptr

type T_XGC = struct {
	Fext_data uintptr
	Fgid      TGContext
	Frects    int32
	Fdashes   int32
	Fdirty    uint64
	Fvalues   TXGCValues
}

type TVisual = struct {
	Fext_data     uintptr
	Fvisualid     TVisualID
	Fclass        int32
	Fred_mask     uint64
	Fgreen_mask   uint64
	Fblue_mask    uint64
	Fbits_per_rgb int32
	Fmap_entries  int32
}

type TDepth = struct {
	Fdepth    int32
	Fnvisuals int32
	Fvisuals  uintptr
}

type T_XDisplay = struct {
	Fext_data            uintptr
	Ffree_funcs          uintptr
	Ffd                  int32
	Fconn_checker        int32
	Fproto_major_version int32
	Fproto_minor_version int32
	Fvendor              uintptr
	Fresource_base       TXID
	Fresource_mask       TXID
	Fresource_id         TXID
	Fresource_shift      int32
	Fresource_alloc      uintptr
	Fbyte_order          int32
	Fbitmap_unit         int32
	Fbitmap_pad          int32
	Fbitmap_bit_order    int32
	Fnformats            int32
	Fpixmap_format       uintptr
	Fvnumber             int32
	Frelease             int32
	Fhead                uintptr
	Ftail                uintptr
	Fqlen                int32
	Flast_request_read   uint64
	Frequest             uint64
	Flast_req            uintptr
	Fbuffer              uintptr
	Fbufptr              uintptr
	Fbufmax              uintptr
	Fmax_request_size    uint32
	Fdb                  uintptr
	Fsynchandler         uintptr
	Fdisplay_name        uintptr
	Fdefault_screen      int32
	Fnscreens            int32
	Fscreens             uintptr
	Fmotion_buffer       uint64
	Fflags               uint64
	Fmin_keycode         int32
	Fmax_keycode         int32
	Fkeysyms             uintptr
	Fmodifiermap         uintptr
	Fkeysyms_per_keycode int32
	Fxdefaults           uintptr
	Fscratch_buffer      uintptr
	Fscratch_length      uint64
	Fext_number          int32
	Fext_procs           uintptr
	Fevent_vec           [128]uintptr
	Fwire_vec            [128]uintptr
	Flock_meaning        TKeySym
	Flock                uintptr
	Fasync_handlers      uintptr
	Fbigreq_size         uint64
	Flock_fns            uintptr
	Fidlist_alloc        uintptr
	Fkey_bindings        uintptr
	Fcursor_font         TFont
	Fatoms               uintptr
	Fmode_switch         uint32
	Fnum_lock            uint32
	Fcontext_db          uintptr
	Ferror_vec           uintptr
	Fcms                 struct {
		FdefaultCCCs            TXPointer
		FclientCmaps            TXPointer
		FperVisualIntensityMaps TXPointer
	}
	Fim_filters             uintptr
	Fqfree                  uintptr
	Fnext_event_serial_num  uint64
	Fflushes                uintptr
	Fim_fd_info             uintptr
	Fim_fd_length           int32
	Fconn_watchers          uintptr
	Fwatcher_count          int32
	Ffiledes                TXPointer
	Fsavedsynchandler       uintptr
	Fresource_max           TXID
	Fxcmisc_opcode          int32
	Fxkb_info               uintptr
	Ftrans_conn             uintptr
	Fxcb                    uintptr
	Fnext_cookie            uint32
	Fgeneric_event_vec      [128]uintptr
	Fgeneric_event_copy_vec [128]uintptr
	Fcookiejar              uintptr
	Ferror_threads          uintptr
	Fexit_handler           TXIOErrorExitHandler
	Fexit_handler_data      uintptr
	Fin_ifevent             TCARD32
	Fifevent_thread         Txthread_t
}

type TScreen = struct {
	Fext_data        uintptr
	Fdisplay         uintptr
	Froot            TWindow
	Fwidth           int32
	Fheight          int32
	Fmwidth          int32
	Fmheight         int32
	Fndepths         int32
	Fdepths          uintptr
	Froot_depth      int32
	Froot_visual     uintptr
	Fdefault_gc      TGC
	Fcmap            TColormap
	Fwhite_pixel     uint64
	Fblack_pixel     uint64
	Fmax_maps        int32
	Fmin_maps        int32
	Fbacking_store   int32
	Fsave_unders     int32
	Froot_input_mask int64
}

type TScreenFormat = struct {
	Fext_data       uintptr
	Fdepth          int32
	Fbits_per_pixel int32
	Fscanline_pad   int32
}

type TXSetWindowAttributes = struct {
	Fbackground_pixmap     TPixmap
	Fbackground_pixel      uint64
	Fborder_pixmap         TPixmap
	Fborder_pixel          uint64
	Fbit_gravity           int32
	Fwin_gravity           int32
	Fbacking_store         int32
	Fbacking_planes        uint64
	Fbacking_pixel         uint64
	Fsave_under            int32
	Fevent_mask            int64
	Fdo_not_propagate_mask int64
	Foverride_redirect     int32
	Fcolormap              TColormap
	Fcursor                TCursor
}

type TXWindowAttributes = struct {
	Fx                     int32
	Fy                     int32
	Fwidth                 int32
	Fheight                int32
	Fborder_width          int32
	Fdepth                 int32
	Fvisual                uintptr
	Froot                  TWindow
	Fclass                 int32
	Fbit_gravity           int32
	Fwin_gravity           int32
	Fbacking_store         int32
	Fbacking_planes        uint64
	Fbacking_pixel         uint64
	Fsave_under            int32
	Fcolormap              TColormap
	Fmap_installed         int32
	Fmap_state             int32
	Fall_event_masks       int64
	Fyour_event_mask       int64
	Fdo_not_propagate_mask int64
	Foverride_redirect     int32
	Fscreen                uintptr
}

type TXHostAddress = struct {
	Ffamily  int32
	Flength  int32
	Faddress uintptr
}

type TXServerInterpretedAddress = struct {
	Ftypelength  int32
	Fvaluelength int32
	Ftype1       uintptr
	Fvalue       uintptr
}

type TXImage = struct {
	Fwidth            int32
	Fheight           int32
	Fxoffset          int32
	Fformat           int32
	Fdata             uintptr
	Fbyte_order       int32
	Fbitmap_unit      int32
	Fbitmap_bit_order int32
	Fbitmap_pad       int32
	Fdepth            int32
	Fbytes_per_line   int32
	Fbits_per_pixel   int32
	Fred_mask         uint64
	Fgreen_mask       uint64
	Fblue_mask        uint64
	Fobdata           TXPointer
	Ff                Tfuncs
}

type T_XImage = TXImage

type TXWindowChanges = struct {
	Fx            int32
	Fy            int32
	Fwidth        int32
	Fheight       int32
	Fborder_width int32
	Fsibling      TWindow
	Fstack_mode   int32
}

type TXColor = struct {
	Fpixel uint64
	Fred   uint16
	Fgreen uint16
	Fblue  uint16
	Fflags int8
	Fpad   int8
}

type TXSegment = struct {
	Fx1 int16
	Fy1 int16
	Fx2 int16
	Fy2 int16
}

type TXPoint = struct {
	Fx int16
	Fy int16
}

type TXRectangle = struct {
	Fx      int16
	Fy      int16
	Fwidth  uint16
	Fheight uint16
}

type TXArc = struct {
	Fx      int16
	Fy      int16
	Fwidth  uint16
	Fheight uint16
	Fangle1 int16
	Fangle2 int16
}

type TXKeyboardControl = struct {
	Fkey_click_percent int32
	Fbell_percent      int32
	Fbell_pitch        int32
	Fbell_duration     int32
	Fled               int32
	Fled_mode          int32
	Fkey               int32
	Fauto_repeat_mode  int32
}

type TXKeyboardState = struct {
	Fkey_click_percent  int32
	Fbell_percent       int32
	Fbell_pitch         uint32
	Fbell_duration      uint32
	Fled_mask           uint64
	Fglobal_auto_repeat int32
	Fauto_repeats       [32]int8
}

type TXTimeCoord = struct {
	Ftime TTime
	Fx    int16
	Fy    int16
}

type TXModifierKeymap = struct {
	Fmax_keypermod int32
	Fmodifiermap   uintptr
}

type TDisplay = struct {
	Fext_data            uintptr
	Ffree_funcs          uintptr
	Ffd                  int32
	Fconn_checker        int32
	Fproto_major_version int32
	Fproto_minor_version int32
	Fvendor              uintptr
	Fresource_base       TXID
	Fresource_mask       TXID
	Fresource_id         TXID
	Fresource_shift      int32
	Fresource_alloc      uintptr
	Fbyte_order          int32
	Fbitmap_unit         int32
	Fbitmap_pad          int32
	Fbitmap_bit_order    int32
	Fnformats            int32
	Fpixmap_format       uintptr
	Fvnumber             int32
	Frelease             int32
	Fhead                uintptr
	Ftail                uintptr
	Fqlen                int32
	Flast_request_read   uint64
	Frequest             uint64
	Flast_req            uintptr
	Fbuffer              uintptr
	Fbufptr              uintptr
	Fbufmax              uintptr
	Fmax_request_size    uint32
	Fdb                  uintptr
	Fsynchandler         uintptr
	Fdisplay_name        uintptr
	Fdefault_screen      int32
	Fnscreens            int32
	Fscreens             uintptr
	Fmotion_buffer       uint64
	Fflags               uint64
	Fmin_keycode         int32
	Fmax_keycode         int32
	Fkeysyms             uintptr
	Fmodifiermap         uintptr
	Fkeysyms_per_keycode int32
	Fxdefaults           uintptr
	Fscratch_buffer      uintptr
	Fscratch_length      uint64
	Fext_number          int32
	Fext_procs           uintptr
	Fevent_vec           [128]uintptr
	Fwire_vec            [128]uintptr
	Flock_meaning        TKeySym
	Flock                uintptr
	Fasync_handlers      uintptr
	Fbigreq_size         uint64
	Flock_fns            uintptr
	Fidlist_alloc        uintptr
	Fkey_bindings        uintptr
	Fcursor_font         TFont
	Fatoms               uintptr
	Fmode_switch         uint32
	Fnum_lock            uint32
	Fcontext_db          uintptr
	Ferror_vec           uintptr
	Fcms                 struct {
		FdefaultCCCs            TXPointer
		FclientCmaps            TXPointer
		FperVisualIntensityMaps TXPointer
	}
	Fim_filters             uintptr
	Fqfree                  uintptr
	Fnext_event_serial_num  uint64
	Fflushes                uintptr
	Fim_fd_info             uintptr
	Fim_fd_length           int32
	Fconn_watchers          uintptr
	Fwatcher_count          int32
	Ffiledes                TXPointer
	Fsavedsynchandler       uintptr
	Fresource_max           TXID
	Fxcmisc_opcode          int32
	Fxkb_info               uintptr
	Ftrans_conn             uintptr
	Fxcb                    uintptr
	Fnext_cookie            uint32
	Fgeneric_event_vec      [128]uintptr
	Fgeneric_event_copy_vec [128]uintptr
	Fcookiejar              uintptr
	Ferror_threads          uintptr
	Fexit_handler           TXIOErrorExitHandler
	Fexit_handler_data      uintptr
	Fin_ifevent             TCARD32
	Fifevent_thread         Txthread_t
}

type T_XPrivDisplay = uintptr

type TXKeyEvent = struct {
	Ftype1       int32
	Fserial      uint64
	Fsend_event  int32
	Fdisplay     uintptr
	Fwindow      TWindow
	Froot        TWindow
	Fsubwindow   TWindow
	Ftime        TTime
	Fx           int32
	Fy           int32
	Fx_root      int32
	Fy_root      int32
	Fstate       uint32
	Fkeycode     uint32
	Fsame_screen int32
}

type TXKeyPressedEvent = struct {
	Ftype1       int32
	Fserial      uint64
	Fsend_event  int32
	Fdisplay     uintptr
	Fwindow      TWindow
	Froot        TWindow
	Fsubwindow   TWindow
	Ftime        TTime
	Fx           int32
	Fy           int32
	Fx_root      int32
	Fy_root      int32
	Fstate       uint32
	Fkeycode     uint32
	Fsame_screen int32
}

type TXKeyReleasedEvent = struct {
	Ftype1       int32
	Fserial      uint64
	Fsend_event  int32
	Fdisplay     uintptr
	Fwindow      TWindow
	Froot        TWindow
	Fsubwindow   TWindow
	Ftime        TTime
	Fx           int32
	Fy           int32
	Fx_root      int32
	Fy_root      int32
	Fstate       uint32
	Fkeycode     uint32
	Fsame_screen int32
}

type TXButtonEvent = struct {
	Ftype1       int32
	Fserial      uint64
	Fsend_event  int32
	Fdisplay     uintptr
	Fwindow      TWindow
	Froot        TWindow
	Fsubwindow   TWindow
	Ftime        TTime
	Fx           int32
	Fy           int32
	Fx_root      int32
	Fy_root      int32
	Fstate       uint32
	Fbutton      uint32
	Fsame_screen int32
}

type TXButtonPressedEvent = struct {
	Ftype1       int32
	Fserial      uint64
	Fsend_event  int32
	Fdisplay     uintptr
	Fwindow      TWindow
	Froot        TWindow
	Fsubwindow   TWindow
	Ftime        TTime
	Fx           int32
	Fy           int32
	Fx_root      int32
	Fy_root      int32
	Fstate       uint32
	Fbutton      uint32
	Fsame_screen int32
}

type TXButtonReleasedEvent = struct {
	Ftype1       int32
	Fserial      uint64
	Fsend_event  int32
	Fdisplay     uintptr
	Fwindow      TWindow
	Froot        TWindow
	Fsubwindow   TWindow
	Ftime        TTime
	Fx           int32
	Fy           int32
	Fx_root      int32
	Fy_root      int32
	Fstate       uint32
	Fbutton      uint32
	Fsame_screen int32
}

type TXMotionEvent = struct {
	Ftype1       int32
	Fserial      uint64
	Fsend_event  int32
	Fdisplay     uintptr
	Fwindow      TWindow
	Froot        TWindow
	Fsubwindow   TWindow
	Ftime        TTime
	Fx           int32
	Fy           int32
	Fx_root      int32
	Fy_root      int32
	Fstate       uint32
	Fis_hint     int8
	Fsame_screen int32
}

type TXPointerMovedEvent = struct {
	Ftype1       int32
	Fserial      uint64
	Fsend_event  int32
	Fdisplay     uintptr
	Fwindow      TWindow
	Froot        TWindow
	Fsubwindow   TWindow
	Ftime        TTime
	Fx           int32
	Fy           int32
	Fx_root      int32
	Fy_root      int32
	Fstate       uint32
	Fis_hint     int8
	Fsame_screen int32
}

type TXCrossingEvent = struct {
	Ftype1       int32
	Fserial      uint64
	Fsend_event  int32
	Fdisplay     uintptr
	Fwindow      TWindow
	Froot        TWindow
	Fsubwindow   TWindow
	Ftime        TTime
	Fx           int32
	Fy           int32
	Fx_root      int32
	Fy_root      int32
	Fmode        int32
	Fdetail      int32
	Fsame_screen int32
	Ffocus       int32
	Fstate       uint32
}

type TXEnterWindowEvent = struct {
	Ftype1       int32
	Fserial      uint64
	Fsend_event  int32
	Fdisplay     uintptr
	Fwindow      TWindow
	Froot        TWindow
	Fsubwindow   TWindow
	Ftime        TTime
	Fx           int32
	Fy           int32
	Fx_root      int32
	Fy_root      int32
	Fmode        int32
	Fdetail      int32
	Fsame_screen int32
	Ffocus       int32
	Fstate       uint32
}

type TXLeaveWindowEvent = struct {
	Ftype1       int32
	Fserial      uint64
	Fsend_event  int32
	Fdisplay     uintptr
	Fwindow      TWindow
	Froot        TWindow
	Fsubwindow   TWindow
	Ftime        TTime
	Fx           int32
	Fy           int32
	Fx_root      int32
	Fy_root      int32
	Fmode        int32
	Fdetail      int32
	Fsame_screen int32
	Ffocus       int32
	Fstate       uint32
}

type TXFocusChangeEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fwindow     TWindow
	Fmode       int32
	Fdetail     int32
}

type TXFocusInEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fwindow     TWindow
	Fmode       int32
	Fdetail     int32
}

type TXFocusOutEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fwindow     TWindow
	Fmode       int32
	Fdetail     int32
}

type TXKeymapEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fwindow     TWindow
	Fkey_vector [32]int8
}

type TXExposeEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fwindow     TWindow
	Fx          int32
	Fy          int32
	Fwidth      int32
	Fheight     int32
	Fcount      int32
}

type TXGraphicsExposeEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fdrawable   TDrawable
	Fx          int32
	Fy          int32
	Fwidth      int32
	Fheight     int32
	Fcount      int32
	Fmajor_code int32
	Fminor_code int32
}

type TXNoExposeEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fdrawable   TDrawable
	Fmajor_code int32
	Fminor_code int32
}

type TXVisibilityEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fwindow     TWindow
	Fstate      int32
}

type TXCreateWindowEvent = struct {
	Ftype1             int32
	Fserial            uint64
	Fsend_event        int32
	Fdisplay           uintptr
	Fparent            TWindow
	Fwindow            TWindow
	Fx                 int32
	Fy                 int32
	Fwidth             int32
	Fheight            int32
	Fborder_width      int32
	Foverride_redirect int32
}

type TXDestroyWindowEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fevent      TWindow
	Fwindow     TWindow
}

type TXUnmapEvent = struct {
	Ftype1          int32
	Fserial         uint64
	Fsend_event     int32
	Fdisplay        uintptr
	Fevent          TWindow
	Fwindow         TWindow
	Ffrom_configure int32
}

type TXMapEvent = struct {
	Ftype1             int32
	Fserial            uint64
	Fsend_event        int32
	Fdisplay           uintptr
	Fevent             TWindow
	Fwindow            TWindow
	Foverride_redirect int32
}

type TXMapRequestEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fparent     TWindow
	Fwindow     TWindow
}

type TXReparentEvent = struct {
	Ftype1             int32
	Fserial            uint64
	Fsend_event        int32
	Fdisplay           uintptr
	Fevent             TWindow
	Fwindow            TWindow
	Fparent            TWindow
	Fx                 int32
	Fy                 int32
	Foverride_redirect int32
}

type TXConfigureEvent = struct {
	Ftype1             int32
	Fserial            uint64
	Fsend_event        int32
	Fdisplay           uintptr
	Fevent             TWindow
	Fwindow            TWindow
	Fx                 int32
	Fy                 int32
	Fwidth             int32
	Fheight            int32
	Fborder_width      int32
	Fabove             TWindow
	Foverride_redirect int32
}

type TXGravityEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fevent      TWindow
	Fwindow     TWindow
	Fx          int32
	Fy          int32
}

type TXResizeRequestEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fwindow     TWindow
	Fwidth      int32
	Fheight     int32
}

type TXConfigureRequestEvent = struct {
	Ftype1        int32
	Fserial       uint64
	Fsend_event   int32
	Fdisplay      uintptr
	Fparent       TWindow
	Fwindow       TWindow
	Fx            int32
	Fy            int32
	Fwidth        int32
	Fheight       int32
	Fborder_width int32
	Fabove        TWindow
	Fdetail       int32
	Fvalue_mask   uint64
}

type TXCirculateEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fevent      TWindow
	Fwindow     TWindow
	Fplace      int32
}

type TXCirculateRequestEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fparent     TWindow
	Fwindow     TWindow
	Fplace      int32
}

type TXPropertyEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fwindow     TWindow
	Fatom       TAtom
	Ftime       TTime
	Fstate      int32
}

type TXSelectionClearEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fwindow     TWindow
	Fselection  TAtom
	Ftime       TTime
}

type TXSelectionRequestEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fowner      TWindow
	Frequestor  TWindow
	Fselection  TAtom
	Ftarget     TAtom
	Fproperty   TAtom
	Ftime       TTime
}

type TXSelectionEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Frequestor  TWindow
	Fselection  TAtom
	Ftarget     TAtom
	Fproperty   TAtom
	Ftime       TTime
}

type TXColormapEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fwindow     TWindow
	Fcolormap   TColormap
	Fnew1       int32
	Fstate      int32
}

type TXClientMessageEvent = struct {
	Ftype1        int32
	Fserial       uint64
	Fsend_event   int32
	Fdisplay      uintptr
	Fwindow       TWindow
	Fmessage_type TAtom
	Fformat       int32
	Fdata         struct {
		Fs           [0][10]int16
		Fl           [0][5]int64
		Fb           [20]int8
		F__ccgo_pad3 [20]byte
	}
}

type TXMappingEvent = struct {
	Ftype1         int32
	Fserial        uint64
	Fsend_event    int32
	Fdisplay       uintptr
	Fwindow        TWindow
	Frequest       int32
	Ffirst_keycode int32
	Fcount         int32
}

type TXErrorEvent = struct {
	Ftype1        int32
	Fdisplay      uintptr
	Fresourceid   TXID
	Fserial       uint64
	Ferror_code   uint8
	Frequest_code uint8
	Fminor_code   uint8
}

type TXAnyEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fwindow     TWindow
}

type TXGenericEvent = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fextension  int32
	Fevtype     int32
}

type TXGenericEventCookie = struct {
	Ftype1      int32
	Fserial     uint64
	Fsend_event int32
	Fdisplay    uintptr
	Fextension  int32
	Fevtype     int32
	Fcookie     uint32
	Fdata       uintptr
}

type TXEvent = struct {
	Fxany              [0]TXAnyEvent
	Fxkey              [0]TXKeyEvent
	Fxbutton           [0]TXButtonEvent
	Fxmotion           [0]TXMotionEvent
	Fxcrossing         [0]TXCrossingEvent
	Fxfocus            [0]TXFocusChangeEvent
	Fxexpose           [0]TXExposeEvent
	Fxgraphicsexpose   [0]TXGraphicsExposeEvent
	Fxnoexpose         [0]TXNoExposeEvent
	Fxvisibility       [0]TXVisibilityEvent
	Fxcreatewindow     [0]TXCreateWindowEvent
	Fxdestroywindow    [0]TXDestroyWindowEvent
	Fxunmap            [0]TXUnmapEvent
	Fxmap              [0]TXMapEvent
	Fxmaprequest       [0]TXMapRequestEvent
	Fxreparent         [0]TXReparentEvent
	Fxconfigure        [0]TXConfigureEvent
	Fxgravity          [0]TXGravityEvent
	Fxresizerequest    [0]TXResizeRequestEvent
	Fxconfigurerequest [0]TXConfigureRequestEvent
	Fxcirculate        [0]TXCirculateEvent
	Fxcirculaterequest [0]TXCirculateRequestEvent
	Fxproperty         [0]TXPropertyEvent
	Fxselectionclear   [0]TXSelectionClearEvent
	Fxselectionrequest [0]TXSelectionRequestEvent
	Fxselection        [0]TXSelectionEvent
	Fxcolormap         [0]TXColormapEvent
	Fxclient           [0]TXClientMessageEvent
	Fxmapping          [0]TXMappingEvent
	Fxerror            [0]TXErrorEvent
	Fxkeymap           [0]TXKeymapEvent
	Fxgeneric          [0]TXGenericEvent
	Fxcookie           [0]TXGenericEventCookie
	Fpad               [0][24]int64
	Ftype1             int32
	F__ccgo_pad35      [188]byte
}

type T_XEvent = TXEvent

type TXCharStruct = struct {
	Flbearing   int16
	Frbearing   int16
	Fwidth      int16
	Fascent     int16
	Fdescent    int16
	Fattributes uint16
}

type TXFontProp = struct {
	Fname   TAtom
	Fcard32 uint64
}

type TXFontStruct = struct {
	Fext_data          uintptr
	Ffid               TFont
	Fdirection         uint32
	Fmin_char_or_byte2 uint32
	Fmax_char_or_byte2 uint32
	Fmin_byte1         uint32
	Fmax_byte1         uint32
	Fall_chars_exist   int32
	Fdefault_char      uint32
	Fn_properties      int32
	Fproperties        uintptr
	Fmin_bounds        TXCharStruct
	Fmax_bounds        TXCharStruct
	Fper_char          uintptr
	Fascent            int32
	Fdescent           int32
}

type TXTextItem = struct {
	Fchars  uintptr
	Fnchars int32
	Fdelta  int32
	Ffont   TFont
}

type TXChar2b = struct {
	Fbyte1 uint8
	Fbyte2 uint8
}

type TXTextItem16 = struct {
	Fchars  uintptr
	Fnchars int32
	Fdelta  int32
	Ffont   TFont
}

type TXEDataObject = struct {
	Fgc            [0]TGC
	Fvisual        [0]uintptr
	Fscreen        [0]uintptr
	Fpixmap_format [0]uintptr
	Ffont          [0]uintptr
	Fdisplay       uintptr
}

type TXFontSetExtents = struct {
	Fmax_ink_extent     TXRectangle
	Fmax_logical_extent TXRectangle
}

type TXOM = uintptr

type TXOC = uintptr

type TXFontSet = uintptr

type TXmbTextItem = struct {
	Fchars    uintptr
	Fnchars   int32
	Fdelta    int32
	Ffont_set TXFontSet
}

type TXwcTextItem = struct {
	Fchars    uintptr
	Fnchars   int32
	Fdelta    int32
	Ffont_set TXFontSet
}

type TXOMCharSetList = struct {
	Fcharset_count int32
	Fcharset_list  uintptr
}

type TXOrientation = int32

const _XOMOrientation_LTR_TTB = 0
const _XOMOrientation_RTL_TTB = 1
const _XOMOrientation_TTB_LTR = 2
const _XOMOrientation_TTB_RTL = 3
const _XOMOrientation_Context = 4

type TXOMOrientation = struct {
	Fnum_orientation int32
	Forientation     uintptr
}

type TXOMFontInfo = struct {
	Fnum_font         int32
	Ffont_struct_list uintptr
	Ffont_name_list   uintptr
}

type TXIM = uintptr

type TXIC = uintptr

type TXIMProc = uintptr

type TXICProc = uintptr

type TXIDProc = uintptr

type TXIMStyle = uint64

type TXIMStyles = struct {
	Fcount_styles     uint16
	Fsupported_styles uintptr
}

type TXVaNestedList = uintptr

type TXIMCallback = struct {
	Fclient_data TXPointer
	Fcallback    TXIMProc
}

type TXICCallback = struct {
	Fclient_data TXPointer
	Fcallback    TXICProc
}

type TXIMFeedback = uint64

type TXIMText = struct {
	Flength            uint16
	Ffeedback          uintptr
	Fencoding_is_wchar int32
	Fstring1           struct {
		Fwide_char  [0]uintptr
		Fmulti_byte uintptr
	}
}

type T_XIMText = TXIMText

type TXIMPreeditState = uint64

type TXIMPreeditStateNotifyCallbackStruct = struct {
	Fstate TXIMPreeditState
}

type T_XIMPreeditStateNotifyCallbackStruct = TXIMPreeditStateNotifyCallbackStruct

type TXIMResetState = uint64

type TXIMStringConversionFeedback = uint64

type TXIMStringConversionText = struct {
	Flength            uint16
	Ffeedback          uintptr
	Fencoding_is_wchar int32
	Fstring1           struct {
		Fwcs [0]uintptr
		Fmbs uintptr
	}
}

type T_XIMStringConversionText = TXIMStringConversionText

type TXIMStringConversionPosition = uint16

type TXIMStringConversionType = uint16

type TXIMStringConversionOperation = uint16

type TXIMCaretDirection = int32

const _XIMForwardChar = 0
const _XIMBackwardChar = 1
const _XIMForwardWord = 2
const _XIMBackwardWord = 3
const _XIMCaretUp = 4
const _XIMCaretDown = 5
const _XIMNextLine = 6
const _XIMPreviousLine = 7
const _XIMLineStart = 8
const _XIMLineEnd = 9
const _XIMAbsolutePosition = 10
const _XIMDontChange = 11

type TXIMStringConversionCallbackStruct = struct {
	Fposition  TXIMStringConversionPosition
	Fdirection TXIMCaretDirection
	Foperation TXIMStringConversionOperation
	Ffactor    uint16
	Ftext      uintptr
}

type T_XIMStringConversionCallbackStruct = TXIMStringConversionCallbackStruct

type TXIMPreeditDrawCallbackStruct = struct {
	Fcaret      int32
	Fchg_first  int32
	Fchg_length int32
	Ftext       uintptr
}

type T_XIMPreeditDrawCallbackStruct = TXIMPreeditDrawCallbackStruct

type TXIMCaretStyle = int32

const _XIMIsInvisible = 0
const _XIMIsPrimary = 1
const _XIMIsSecondary = 2

type TXIMPreeditCaretCallbackStruct = struct {
	Fposition  int32
	Fdirection TXIMCaretDirection
	Fstyle     TXIMCaretStyle
}

type T_XIMPreeditCaretCallbackStruct = TXIMPreeditCaretCallbackStruct

type TXIMStatusDataType = int32

const _XIMTextType = 0
const _XIMBitmapType = 1

type TXIMStatusDrawCallbackStruct = struct {
	Ftype1 TXIMStatusDataType
	Fdata  struct {
		Fbitmap [0]TPixmap
		Ftext   uintptr
	}
}

type T_XIMStatusDrawCallbackStruct = TXIMStatusDrawCallbackStruct

type TXIMHotKeyTrigger = struct {
	Fkeysym        TKeySym
	Fmodifier      int32
	Fmodifier_mask int32
}

type T_XIMHotKeyTrigger = TXIMHotKeyTrigger

type TXIMHotKeyTriggers = struct {
	Fnum_hot_key int32
	Fkey         uintptr
}

type T_XIMHotKeyTriggers = TXIMHotKeyTriggers

type TXIMHotKeyState = uint64

type TXIMValuesList = struct {
	Fcount_values     uint16
	Fsupported_values uintptr
}

type TXErrorHandler = uintptr

type TXIOErrorHandler = uintptr

type TXIOErrorExitHandler = uintptr

type TXConnectionWatchProc = uintptr

type TXSizeHints = struct {
	Fflags      int64
	Fx          int32
	Fy          int32
	Fwidth      int32
	Fheight     int32
	Fmin_width  int32
	Fmin_height int32
	Fmax_width  int32
	Fmax_height int32
	Fwidth_inc  int32
	Fheight_inc int32
	Fmin_aspect struct {
		Fx int32
		Fy int32
	}
	Fmax_aspect struct {
		Fx int32
		Fy int32
	}
	Fbase_width  int32
	Fbase_height int32
	Fwin_gravity int32
}

type TXWMHints = struct {
	Fflags         int64
	Finput         int32
	Finitial_state int32
	Ficon_pixmap   TPixmap
	Ficon_window   TWindow
	Ficon_x        int32
	Ficon_y        int32
	Ficon_mask     TPixmap
	Fwindow_group  TXID
}

type TXTextProperty = struct {
	Fvalue    uintptr
	Fencoding TAtom
	Fformat   int32
	Fnitems   uint64
}

type TXICCEncodingStyle = int32

const _XStringStyle = 0
const _XCompoundTextStyle = 1
const _XTextStyle = 2
const _XStdICCTextStyle = 3
const _XUTF8StringStyle = 4

type TXIconSize = struct {
	Fmin_width  int32
	Fmin_height int32
	Fmax_width  int32
	Fmax_height int32
	Fwidth_inc  int32
	Fheight_inc int32
}

type TXClassHint = struct {
	Fres_name  uintptr
	Fres_class uintptr
}

type TXComposeStatus = struct {
	Fcompose_ptr   TXPointer
	Fchars_matched int32
}

type T_XComposeStatus = TXComposeStatus

type TRegion = uintptr

type TXVisualInfo = struct {
	Fvisual        uintptr
	Fvisualid      TVisualID
	Fscreen        int32
	Fdepth         int32
	Fclass         int32
	Fred_mask      uint64
	Fgreen_mask    uint64
	Fblue_mask     uint64
	Fcolormap_size int32
	Fbits_per_rgb  int32
}

type TXStandardColormap = struct {
	Fcolormap   TColormap
	Fred_max    uint64
	Fred_mult   uint64
	Fgreen_max  uint64
	Fgreen_mult uint64
	Fblue_max   uint64
	Fblue_mult  uint64
	Fbase_pixel uint64
	Fvisualid   TVisualID
	Fkillid     TXID
}

type TXContext = int32

type TINT64 = int64

type TINT32 = int32

type TINT16 = int16

type TINT8 = int8

type TCARD64 = uint64

type TCARD32 = uint32

type TCARD16 = uint16

type TCARD8 = uint8

type TBITS32 = uint32

type TBITS16 = uint16

type TBYTE = uint8

type TBOOL = uint8

type TxSegment = struct {
	Fx1 TINT16
	Fy1 TINT16
	Fx2 TINT16
	Fy2 TINT16
}

type T_xSegment = TxSegment

type TxPoint = struct {
	Fx TINT16
	Fy TINT16
}

type T_xPoint = TxPoint

type TxRectangle = struct {
	Fx      TINT16
	Fy      TINT16
	Fwidth  TCARD16
	Fheight TCARD16
}

type T_xRectangle = TxRectangle

type TxArc = struct {
	Fx      TINT16
	Fy      TINT16
	Fwidth  TCARD16
	Fheight TCARD16
	Fangle1 TINT16
	Fangle2 TINT16
}

type T_xArc = TxArc

type TKeyButMask = uint16

type TxConnClientPrefix = struct {
	FbyteOrder        TCARD8
	Fpad              TBYTE
	FmajorVersion     TCARD16
	FminorVersion     TCARD16
	FnbytesAuthProto  TCARD16
	FnbytesAuthString TCARD16
	Fpad2             TCARD16
}

type TxConnSetupPrefix = struct {
	Fsuccess      TCARD8
	FlengthReason TBYTE
	FmajorVersion TCARD16
	FminorVersion TCARD16
	Flength       TCARD16
}

type TxConnSetup = struct {
	Frelease            TCARD32
	FridBase            TCARD32
	FridMask            TCARD32
	FmotionBufferSize   TCARD32
	FnbytesVendor       TCARD16
	FmaxRequestSize     TCARD16
	FnumRoots           TCARD8
	FnumFormats         TCARD8
	FimageByteOrder     TCARD8
	FbitmapBitOrder     TCARD8
	FbitmapScanlineUnit TCARD8
	FbitmapScanlinePad  TCARD8
	FminKeyCode         TCARD8
	FmaxKeyCode         TCARD8
	Fpad2               TCARD32
}

type TxPixmapFormat = struct {
	Fdepth        TCARD8
	FbitsPerPixel TCARD8
	FscanLinePad  TCARD8
	Fpad1         TCARD8
	Fpad2         TCARD32
}

type TxDepth = struct {
	Fdepth    TCARD8
	Fpad1     TCARD8
	FnVisuals TCARD16
	Fpad2     TCARD32
}

type TxVisualType = struct {
	FvisualID        TCARD32
	Fclass           TCARD8
	FbitsPerRGB      TCARD8
	FcolormapEntries TCARD16
	FredMask         TCARD32
	FgreenMask       TCARD32
	FblueMask        TCARD32
	Fpad             TCARD32
}

type TxWindowRoot = struct {
	FwindowId         TCARD32
	FdefaultColormap  TCARD32
	FwhitePixel       TCARD32
	FblackPixel       TCARD32
	FcurrentInputMask TCARD32
	FpixWidth         TCARD16
	FpixHeight        TCARD16
	FmmWidth          TCARD16
	FmmHeight         TCARD16
	FminInstalledMaps TCARD16
	FmaxInstalledMaps TCARD16
	FrootVisualID     TCARD32
	FbackingStore     TCARD8
	FsaveUnders       TBOOL
	FrootDepth        TCARD8
	FnDepths          TCARD8
}

type TxTimecoord = struct {
	Ftime TCARD32
	Fx    TINT16
	Fy    TINT16
}

type TxHostEntry = struct {
	Ffamily TCARD8
	Fpad    TBYTE
	Flength TCARD16
}

type TxCharInfo = struct {
	FleftSideBearing  TINT16
	FrightSideBearing TINT16
	FcharacterWidth   TINT16
	Fascent           TINT16
	Fdescent          TINT16
	Fattributes       TCARD16
}

type TxFontProp = struct {
	Fname  TCARD32
	Fvalue TCARD32
}

type TxTextElt = struct {
	Flen1  TCARD8
	Fdelta TINT8
}

type TxColorItem = struct {
	Fpixel TCARD32
	Fred   TCARD16
	Fgreen TCARD16
	Fblue  TCARD16
	Fflags TCARD8
	Fpad   TCARD8
}

type Txrgb = struct {
	Fred   TCARD16
	Fgreen TCARD16
	Fblue  TCARD16
	Fpad   TCARD16
}

type TKEYCODE = uint8

type TxGenericReply = struct {
	Ftype1          TBYTE
	Fdata1          TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fdata00         TCARD32
	Fdata01         TCARD32
	Fdata02         TCARD32
	Fdata03         TCARD32
	Fdata04         TCARD32
	Fdata05         TCARD32
}

type TxGetWindowAttributesReply = struct {
	Ftype1              TBYTE
	FbackingStore       TCARD8
	FsequenceNumber     TCARD16
	Flength             TCARD32
	FvisualID           TCARD32
	Fclass              TCARD16
	FbitGravity         TCARD8
	FwinGravity         TCARD8
	FbackingBitPlanes   TCARD32
	FbackingPixel       TCARD32
	FsaveUnder          TBOOL
	FmapInstalled       TBOOL
	FmapState           TCARD8
	Foverride           TBOOL
	Fcolormap           TCARD32
	FallEventMasks      TCARD32
	FyourEventMask      TCARD32
	FdoNotPropagateMask TCARD16
	Fpad                TCARD16
}

type TxGetGeometryReply = struct {
	Ftype1          TBYTE
	Fdepth          TCARD8
	FsequenceNumber TCARD16
	Flength         TCARD32
	Froot           TCARD32
	Fx              TINT16
	Fy              TINT16
	Fwidth          TCARD16
	Fheight         TCARD16
	FborderWidth    TCARD16
	Fpad1           TCARD16
	Fpad2           TCARD32
	Fpad3           TCARD32
}

type TxQueryTreeReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	Froot           TCARD32
	Fparent         TCARD32
	FnChildren      TCARD16
	Fpad2           TCARD16
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
}

type TxInternAtomReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fatom           TCARD32
	Fpad2           TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
}

type TxGetAtomNameReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	FnameLength     TCARD16
	Fpad2           TCARD16
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxGetPropertyReply = struct {
	Ftype1          TBYTE
	Fformat         TCARD8
	FsequenceNumber TCARD16
	Flength         TCARD32
	FpropertyType   TCARD32
	FbytesAfter     TCARD32
	FnItems         TCARD32
	Fpad1           TCARD32
	Fpad2           TCARD32
	Fpad3           TCARD32
}

type TxListPropertiesReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	FnProperties    TCARD16
	Fpad2           TCARD16
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxGetSelectionOwnerReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fowner          TCARD32
	Fpad2           TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
}

type TxGrabPointerReply = struct {
	Ftype1          TBYTE
	Fstatus         TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fpad1           TCARD32
	Fpad2           TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
}

type TxGrabKeyboardReply = struct {
	Ftype1          TBYTE
	Fstatus         TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fpad1           TCARD32
	Fpad2           TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
}

type TxQueryPointerReply = struct {
	Ftype1          TBYTE
	FsameScreen     TBOOL
	FsequenceNumber TCARD16
	Flength         TCARD32
	Froot           TCARD32
	Fchild          TCARD32
	FrootX          TINT16
	FrootY          TINT16
	FwinX           TINT16
	FwinY           TINT16
	Fmask           TCARD16
	Fpad1           TCARD16
	Fpad            TCARD32
}

type TxGetMotionEventsReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	FnEvents        TCARD32
	Fpad2           TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
}

type TxTranslateCoordsReply = struct {
	Ftype1          TBYTE
	FsameScreen     TBOOL
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fchild          TCARD32
	FdstX           TINT16
	FdstY           TINT16
	Fpad2           TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
}

type TxGetInputFocusReply = struct {
	Ftype1          TBYTE
	FrevertTo       TCARD8
	FsequenceNumber TCARD16
	Flength         TCARD32
	Ffocus          TCARD32
	Fpad1           TCARD32
	Fpad2           TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
}

type TxQueryKeymapReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fmap1           [32]TBYTE
}

type TxQueryFontReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	FminBounds      TxCharInfo
	Fwalign1        TCARD32
	FmaxBounds      TxCharInfo
	Fwalign2        TCARD32
	FminCharOrByte2 TCARD16
	FmaxCharOrByte2 TCARD16
	FdefaultChar    TCARD16
	FnFontProps     TCARD16
	FdrawDirection  TCARD8
	FminByte1       TCARD8
	FmaxByte1       TCARD8
	FallCharsExist  TBOOL
	FfontAscent     TINT16
	FfontDescent    TINT16
	FnCharInfos     TCARD32
}

type T_xQueryFontReply = TxQueryFontReply

type TxQueryTextExtentsReply = struct {
	Ftype1          TBYTE
	FdrawDirection  TCARD8
	FsequenceNumber TCARD16
	Flength         TCARD32
	FfontAscent     TINT16
	FfontDescent    TINT16
	FoverallAscent  TINT16
	FoverallDescent TINT16
	FoverallWidth   TINT32
	FoverallLeft    TINT32
	FoverallRight   TINT32
	Fpad            TCARD32
}

type TxListFontsReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	FnFonts         TCARD16
	Fpad2           TCARD16
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxListFontsWithInfoReply = struct {
	Ftype1          TBYTE
	FnameLength     TCARD8
	FsequenceNumber TCARD16
	Flength         TCARD32
	FminBounds      TxCharInfo
	Fwalign1        TCARD32
	FmaxBounds      TxCharInfo
	Fwalign2        TCARD32
	FminCharOrByte2 TCARD16
	FmaxCharOrByte2 TCARD16
	FdefaultChar    TCARD16
	FnFontProps     TCARD16
	FdrawDirection  TCARD8
	FminByte1       TCARD8
	FmaxByte1       TCARD8
	FallCharsExist  TBOOL
	FfontAscent     TINT16
	FfontDescent    TINT16
	FnReplies       TCARD32
}

type TxGetFontPathReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	FnPaths         TCARD16
	Fpad2           TCARD16
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxGetImageReply = struct {
	Ftype1          TBYTE
	Fdepth          TCARD8
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fvisual         TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxListInstalledColormapsReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	FnColormaps     TCARD16
	Fpad2           TCARD16
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxAllocColorReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fred            TCARD16
	Fgreen          TCARD16
	Fblue           TCARD16
	Fpad2           TCARD16
	Fpixel          TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
}

type TxAllocNamedColorReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fpixel          TCARD32
	FexactRed       TCARD16
	FexactGreen     TCARD16
	FexactBlue      TCARD16
	FscreenRed      TCARD16
	FscreenGreen    TCARD16
	FscreenBlue     TCARD16
	Fpad2           TCARD32
	Fpad3           TCARD32
}

type TxAllocColorCellsReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	FnPixels        TCARD16
	FnMasks         TCARD16
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxAllocColorPlanesReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	FnPixels        TCARD16
	Fpad2           TCARD16
	FredMask        TCARD32
	FgreenMask      TCARD32
	FblueMask       TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
}

type TxQueryColorsReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	FnColors        TCARD16
	Fpad2           TCARD16
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxLookupColorReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	FexactRed       TCARD16
	FexactGreen     TCARD16
	FexactBlue      TCARD16
	FscreenRed      TCARD16
	FscreenGreen    TCARD16
	FscreenBlue     TCARD16
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
}

type TxQueryBestSizeReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fwidth          TCARD16
	Fheight         TCARD16
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxQueryExtensionReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fpresent        TBOOL
	Fmajor_opcode   TCARD8
	Ffirst_event    TCARD8
	Ffirst_error    TCARD8
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxListExtensionsReply = struct {
	Ftype1          TBYTE
	FnExtensions    TCARD8
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fpad2           TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxSetMappingReply = struct {
	Ftype1          TBYTE
	Fsuccess        TCARD8
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fpad2           TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxSetPointerMappingReply = struct {
	Ftype1          TBYTE
	Fsuccess        TCARD8
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fpad2           TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxSetModifierMappingReply = struct {
	Ftype1          TBYTE
	Fsuccess        TCARD8
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fpad2           TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxGetPointerMappingReply = struct {
	Ftype1          TBYTE
	FnElts          TCARD8
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fpad2           TCARD32
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxGetKeyboardMappingReply = struct {
	Ftype1             TBYTE
	FkeySymsPerKeyCode TCARD8
	FsequenceNumber    TCARD16
	Flength            TCARD32
	Fpad2              TCARD32
	Fpad3              TCARD32
	Fpad4              TCARD32
	Fpad5              TCARD32
	Fpad6              TCARD32
	Fpad7              TCARD32
}

type TxGetModifierMappingReply = struct {
	Ftype1             TBYTE
	FnumKeyPerModifier TCARD8
	FsequenceNumber    TCARD16
	Flength            TCARD32
	Fpad1              TCARD32
	Fpad2              TCARD32
	Fpad3              TCARD32
	Fpad4              TCARD32
	Fpad5              TCARD32
	Fpad6              TCARD32
}

type TxGetKeyboardControlReply = struct {
	Ftype1            TBYTE
	FglobalAutoRepeat TBOOL
	FsequenceNumber   TCARD16
	Flength           TCARD32
	FledMask          TCARD32
	FkeyClickPercent  TCARD8
	FbellPercent      TCARD8
	FbellPitch        TCARD16
	FbellDuration     TCARD16
	Fpad              TCARD16
	Fmap1             [32]TBYTE
}

type TxGetPointerControlReply = struct {
	Ftype1            TBYTE
	Fpad1             TBYTE
	FsequenceNumber   TCARD16
	Flength           TCARD32
	FaccelNumerator   TCARD16
	FaccelDenominator TCARD16
	Fthreshold        TCARD16
	Fpad2             TCARD16
	Fpad3             TCARD32
	Fpad4             TCARD32
	Fpad5             TCARD32
	Fpad6             TCARD32
}

type TxGetScreenSaverReply = struct {
	Ftype1          TBYTE
	Fpad1           TBYTE
	FsequenceNumber TCARD16
	Flength         TCARD32
	Ftimeout        TCARD16
	Finterval       TCARD16
	FpreferBlanking TBOOL
	FallowExposures TBOOL
	Fpad2           TCARD16
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
}

type TxListHostsReply = struct {
	Ftype1          TBYTE
	Fenabled        TBOOL
	FsequenceNumber TCARD16
	Flength         TCARD32
	FnHosts         TCARD16
	Fpad1           TCARD16
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxError = struct {
	Ftype1          TBYTE
	FerrorCode      TBYTE
	FsequenceNumber TCARD16
	FresourceID     TCARD32
	FminorCode      TCARD16
	FmajorCode      TCARD8
	Fpad1           TBYTE
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxEvent = struct {
	Fu struct {
		FkeyButtonPointer [0]struct {
			Fpad00      TCARD32
			Ftime       TCARD32
			Froot       TCARD32
			Fevent      TCARD32
			Fchild      TCARD32
			FrootX      TINT16
			FrootY      TINT16
			FeventX     TINT16
			FeventY     TINT16
			Fstate      TKeyButMask
			FsameScreen TBOOL
			Fpad1       TBYTE
		}
		FenterLeave [0]struct {
			Fpad00  TCARD32
			Ftime   TCARD32
			Froot   TCARD32
			Fevent  TCARD32
			Fchild  TCARD32
			FrootX  TINT16
			FrootY  TINT16
			FeventX TINT16
			FeventY TINT16
			Fstate  TKeyButMask
			Fmode   TBYTE
			Fflags  TBYTE
		}
		Ffocus [0]struct {
			Fpad00  TCARD32
			Fwindow TCARD32
			Fmode   TBYTE
			Fpad1   TBYTE
			Fpad2   TBYTE
			Fpad3   TBYTE
		}
		Fexpose [0]struct {
			Fpad00  TCARD32
			Fwindow TCARD32
			Fx      TCARD16
			Fy      TCARD16
			Fwidth  TCARD16
			Fheight TCARD16
			Fcount  TCARD16
			Fpad2   TCARD16
		}
		FgraphicsExposure [0]struct {
			Fpad00      TCARD32
			Fdrawable   TCARD32
			Fx          TCARD16
			Fy          TCARD16
			Fwidth      TCARD16
			Fheight     TCARD16
			FminorEvent TCARD16
			Fcount      TCARD16
			FmajorEvent TBYTE
			Fpad1       TBYTE
			Fpad2       TBYTE
			Fpad3       TBYTE
		}
		FnoExposure [0]struct {
			Fpad00      TCARD32
			Fdrawable   TCARD32
			FminorEvent TCARD16
			FmajorEvent TBYTE
			Fbpad       TBYTE
		}
		Fvisibility [0]struct {
			Fpad00  TCARD32
			Fwindow TCARD32
			Fstate  TCARD8
			Fpad1   TBYTE
			Fpad2   TBYTE
			Fpad3   TBYTE
		}
		FcreateNotify [0]struct {
			Fpad00       TCARD32
			Fparent      TCARD32
			Fwindow      TCARD32
			Fx           TINT16
			Fy           TINT16
			Fwidth       TCARD16
			Fheight      TCARD16
			FborderWidth TCARD16
			Foverride    TBOOL
			Fbpad        TBYTE
		}
		FdestroyNotify [0]struct {
			Fpad00  TCARD32
			Fevent  TCARD32
			Fwindow TCARD32
		}
		FunmapNotify [0]struct {
			Fpad00         TCARD32
			Fevent         TCARD32
			Fwindow        TCARD32
			FfromConfigure TBOOL
			Fpad1          TBYTE
			Fpad2          TBYTE
			Fpad3          TBYTE
		}
		FmapNotify [0]struct {
			Fpad00    TCARD32
			Fevent    TCARD32
			Fwindow   TCARD32
			Foverride TBOOL
			Fpad1     TBYTE
			Fpad2     TBYTE
			Fpad3     TBYTE
		}
		FmapRequest [0]struct {
			Fpad00  TCARD32
			Fparent TCARD32
			Fwindow TCARD32
		}
		Freparent [0]struct {
			Fpad00    TCARD32
			Fevent    TCARD32
			Fwindow   TCARD32
			Fparent   TCARD32
			Fx        TINT16
			Fy        TINT16
			Foverride TBOOL
			Fpad1     TBYTE
			Fpad2     TBYTE
			Fpad3     TBYTE
		}
		FconfigureNotify [0]struct {
			Fpad00        TCARD32
			Fevent        TCARD32
			Fwindow       TCARD32
			FaboveSibling TCARD32
			Fx            TINT16
			Fy            TINT16
			Fwidth        TCARD16
			Fheight       TCARD16
			FborderWidth  TCARD16
			Foverride     TBOOL
			Fbpad         TBYTE
		}
		FconfigureRequest [0]struct {
			Fpad00       TCARD32
			Fparent      TCARD32
			Fwindow      TCARD32
			Fsibling     TCARD32
			Fx           TINT16
			Fy           TINT16
			Fwidth       TCARD16
			Fheight      TCARD16
			FborderWidth TCARD16
			FvalueMask   TCARD16
			Fpad1        TCARD32
		}
		Fgravity [0]struct {
			Fpad00  TCARD32
			Fevent  TCARD32
			Fwindow TCARD32
			Fx      TINT16
			Fy      TINT16
			Fpad1   TCARD32
			Fpad2   TCARD32
			Fpad3   TCARD32
			Fpad4   TCARD32
		}
		FresizeRequest [0]struct {
			Fpad00  TCARD32
			Fwindow TCARD32
			Fwidth  TCARD16
			Fheight TCARD16
		}
		Fcirculate [0]struct {
			Fpad00  TCARD32
			Fevent  TCARD32
			Fwindow TCARD32
			Fparent TCARD32
			Fplace  TBYTE
			Fpad1   TBYTE
			Fpad2   TBYTE
			Fpad3   TBYTE
		}
		Fproperty [0]struct {
			Fpad00  TCARD32
			Fwindow TCARD32
			Fatom   TCARD32
			Ftime   TCARD32
			Fstate  TBYTE
			Fpad1   TBYTE
			Fpad2   TCARD16
		}
		FselectionClear [0]struct {
			Fpad00  TCARD32
			Ftime   TCARD32
			Fwindow TCARD32
			Fatom   TCARD32
		}
		FselectionRequest [0]struct {
			Fpad00     TCARD32
			Ftime      TCARD32
			Fowner     TCARD32
			Frequestor TCARD32
			Fselection TCARD32
			Ftarget    TCARD32
			Fproperty  TCARD32
		}
		FselectionNotify [0]struct {
			Fpad00     TCARD32
			Ftime      TCARD32
			Frequestor TCARD32
			Fselection TCARD32
			Ftarget    TCARD32
			Fproperty  TCARD32
		}
		Fcolormap [0]struct {
			Fpad00    TCARD32
			Fwindow   TCARD32
			Fcolormap TCARD32
			Fnew1     TBOOL
			Fstate    TBYTE
			Fpad1     TBYTE
			Fpad2     TBYTE
		}
		FmappingNotify [0]struct {
			Fpad00        TCARD32
			Frequest      TCARD8
			FfirstKeyCode TCARD8
			Fcount        TCARD8
			Fpad1         TBYTE
		}
		FclientMessage [0]struct {
			Fpad00  TCARD32
			Fwindow TCARD32
			Fu      struct {
				Fs [0]struct {
					Ftype1   TCARD32
					Fshorts0 TINT16
					Fshorts1 TINT16
					Fshorts2 TINT16
					Fshorts3 TINT16
					Fshorts4 TINT16
					Fshorts5 TINT16
					Fshorts6 TINT16
					Fshorts7 TINT16
					Fshorts8 TINT16
					Fshorts9 TINT16
				}
				Fb [0]struct {
					Ftype1 TCARD32
					Fbytes [20]TINT8
				}
				Fl struct {
					Ftype1  TCARD32
					Flongs0 TINT32
					Flongs1 TINT32
					Flongs2 TINT32
					Flongs3 TINT32
					Flongs4 TINT32
				}
			}
		}
		Fu struct {
			Ftype1          TBYTE
			Fdetail         TBYTE
			FsequenceNumber TCARD16
		}
		F__ccgo_pad26 [28]byte
	}
}

type T_xEvent = TxEvent

type TxGenericEvent = struct {
	Ftype1          TBYTE
	Fextension      TCARD8
	FsequenceNumber TCARD16
	Flength         TCARD32
	Fevtype         TCARD16
	Fpad2           TCARD16
	Fpad3           TCARD32
	Fpad4           TCARD32
	Fpad5           TCARD32
	Fpad6           TCARD32
	Fpad7           TCARD32
}

type TxKeymapEvent = struct {
	Ftype1 TBYTE
	Fmap1  [31]TBYTE
}

type TxReply = struct {
	Fgeom               [0]TxGetGeometryReply
	Ftree               [0]TxQueryTreeReply
	Fatom               [0]TxInternAtomReply
	FatomName           [0]TxGetAtomNameReply
	Fproperty           [0]TxGetPropertyReply
	FlistProperties     [0]TxListPropertiesReply
	Fselection          [0]TxGetSelectionOwnerReply
	FgrabPointer        [0]TxGrabPointerReply
	FgrabKeyboard       [0]TxGrabKeyboardReply
	Fpointer            [0]TxQueryPointerReply
	FmotionEvents       [0]TxGetMotionEventsReply
	Fcoords             [0]TxTranslateCoordsReply
	FinputFocus         [0]TxGetInputFocusReply
	FtextExtents        [0]TxQueryTextExtentsReply
	Ffonts              [0]TxListFontsReply
	FfontPath           [0]TxGetFontPathReply
	Fimage              [0]TxGetImageReply
	Fcolormaps          [0]TxListInstalledColormapsReply
	FallocColor         [0]TxAllocColorReply
	FallocNamedColor    [0]TxAllocNamedColorReply
	FcolorCells         [0]TxAllocColorCellsReply
	FcolorPlanes        [0]TxAllocColorPlanesReply
	Fcolors             [0]TxQueryColorsReply
	FlookupColor        [0]TxLookupColorReply
	FbestSize           [0]TxQueryBestSizeReply
	Fextension          [0]TxQueryExtensionReply
	Fextensions         [0]TxListExtensionsReply
	FsetModifierMapping [0]TxSetModifierMappingReply
	FgetModifierMapping [0]TxGetModifierMappingReply
	FsetPointerMapping  [0]TxSetPointerMappingReply
	FgetKeyboardMapping [0]TxGetKeyboardMappingReply
	FgetPointerMapping  [0]TxGetPointerMappingReply
	FpointerControl     [0]TxGetPointerControlReply
	FscreenSaver        [0]TxGetScreenSaverReply
	Fhosts              [0]TxListHostsReply
	Ferror1             [0]TxError
	Fevent              [0]TxEvent
	Fgeneric            TxGenericReply
}

type TxReq = struct {
	FreqType TCARD8
	Fdata    TCARD8
	Flength  TCARD16
}

type T_xReq = TxReq

type TxResourceReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	Fid      TCARD32
}

type TxCreateWindowReq = struct {
	FreqType     TCARD8
	Fdepth       TCARD8
	Flength      TCARD16
	Fwid         TCARD32
	Fparent      TCARD32
	Fx           TINT16
	Fy           TINT16
	Fwidth       TCARD16
	Fheight      TCARD16
	FborderWidth TCARD16
	Fclass       TCARD16
	Fvisual      TCARD32
	Fmask        TCARD32
}

type TxChangeWindowAttributesReq = struct {
	FreqType   TCARD8
	Fpad       TBYTE
	Flength    TCARD16
	Fwindow    TCARD32
	FvalueMask TCARD32
}

type TxChangeSaveSetReq = struct {
	FreqType TCARD8
	Fmode    TBYTE
	Flength  TCARD16
	Fwindow  TCARD32
}

type TxReparentWindowReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	Fwindow  TCARD32
	Fparent  TCARD32
	Fx       TINT16
	Fy       TINT16
}

type TxConfigureWindowReq = struct {
	FreqType TCARD8
	Fpad     TCARD8
	Flength  TCARD16
	Fwindow  TCARD32
	Fmask    TCARD16
	Fpad2    TCARD16
}

type TxCirculateWindowReq = struct {
	FreqType   TCARD8
	Fdirection TCARD8
	Flength    TCARD16
	Fwindow    TCARD32
}

type TxInternAtomReq = struct {
	FreqType      TCARD8
	FonlyIfExists TBOOL
	Flength       TCARD16
	Fnbytes       TCARD16
	Fpad          TCARD16
}

type TxChangePropertyReq = struct {
	FreqType  TCARD8
	Fmode     TCARD8
	Flength   TCARD16
	Fwindow   TCARD32
	Fproperty TCARD32
	Ftype1    TCARD32
	Fformat   TCARD8
	Fpad      [3]TBYTE
	FnUnits   TCARD32
}

type TxDeletePropertyReq = struct {
	FreqType  TCARD8
	Fpad      TBYTE
	Flength   TCARD16
	Fwindow   TCARD32
	Fproperty TCARD32
}

type TxGetPropertyReq = struct {
	FreqType    TCARD8
	Fdelete1    TBOOL
	Flength     TCARD16
	Fwindow     TCARD32
	Fproperty   TCARD32
	Ftype1      TCARD32
	FlongOffset TCARD32
	FlongLength TCARD32
}

type TxSetSelectionOwnerReq = struct {
	FreqType   TCARD8
	Fpad       TBYTE
	Flength    TCARD16
	Fwindow    TCARD32
	Fselection TCARD32
	Ftime      TCARD32
}

type TxConvertSelectionReq = struct {
	FreqType   TCARD8
	Fpad       TBYTE
	Flength    TCARD16
	Frequestor TCARD32
	Fselection TCARD32
	Ftarget    TCARD32
	Fproperty  TCARD32
	Ftime      TCARD32
}

type TxSendEventReq = struct {
	FreqType     TCARD8
	Fpropagate   TBOOL
	Flength      TCARD16
	Fdestination TCARD32
	FeventMask   TCARD32
	Fevent       TxEvent
}

type TxGrabPointerReq = struct {
	FreqType      TCARD8
	FownerEvents  TBOOL
	Flength       TCARD16
	FgrabWindow   TCARD32
	FeventMask    TCARD16
	FpointerMode  TBYTE
	FkeyboardMode TBYTE
	FconfineTo    TCARD32
	Fcursor       TCARD32
	Ftime         TCARD32
}

type TxGrabButtonReq = struct {
	FreqType      TCARD8
	FownerEvents  TBOOL
	Flength       TCARD16
	FgrabWindow   TCARD32
	FeventMask    TCARD16
	FpointerMode  TBYTE
	FkeyboardMode TBYTE
	FconfineTo    TCARD32
	Fcursor       TCARD32
	Fbutton       TCARD8
	Fpad          TBYTE
	Fmodifiers    TCARD16
}

type TxUngrabButtonReq = struct {
	FreqType    TCARD8
	Fbutton     TCARD8
	Flength     TCARD16
	FgrabWindow TCARD32
	Fmodifiers  TCARD16
	Fpad        TCARD16
}

type TxChangeActivePointerGrabReq = struct {
	FreqType   TCARD8
	Fpad       TBYTE
	Flength    TCARD16
	Fcursor    TCARD32
	Ftime      TCARD32
	FeventMask TCARD16
	Fpad2      TCARD16
}

type TxGrabKeyboardReq = struct {
	FreqType      TCARD8
	FownerEvents  TBOOL
	Flength       TCARD16
	FgrabWindow   TCARD32
	Ftime         TCARD32
	FpointerMode  TBYTE
	FkeyboardMode TBYTE
	Fpad          TCARD16
}

type TxGrabKeyReq = struct {
	FreqType      TCARD8
	FownerEvents  TBOOL
	Flength       TCARD16
	FgrabWindow   TCARD32
	Fmodifiers    TCARD16
	Fkey          TCARD8
	FpointerMode  TBYTE
	FkeyboardMode TBYTE
	Fpad1         TBYTE
	Fpad2         TBYTE
	Fpad3         TBYTE
}

type TxUngrabKeyReq = struct {
	FreqType    TCARD8
	Fkey        TCARD8
	Flength     TCARD16
	FgrabWindow TCARD32
	Fmodifiers  TCARD16
	Fpad        TCARD16
}

type TxAllowEventsReq = struct {
	FreqType TCARD8
	Fmode    TCARD8
	Flength  TCARD16
	Ftime    TCARD32
}

type TxGetMotionEventsReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	Fwindow  TCARD32
	Fstart   TCARD32
	Fstop    TCARD32
}

type TxTranslateCoordsReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	FsrcWid  TCARD32
	FdstWid  TCARD32
	FsrcX    TINT16
	FsrcY    TINT16
}

type TxWarpPointerReq = struct {
	FreqType   TCARD8
	Fpad       TBYTE
	Flength    TCARD16
	FsrcWid    TCARD32
	FdstWid    TCARD32
	FsrcX      TINT16
	FsrcY      TINT16
	FsrcWidth  TCARD16
	FsrcHeight TCARD16
	FdstX      TINT16
	FdstY      TINT16
}

type TxSetInputFocusReq = struct {
	FreqType  TCARD8
	FrevertTo TCARD8
	Flength   TCARD16
	Ffocus    TCARD32
	Ftime     TCARD32
}

type TxOpenFontReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	Ffid     TCARD32
	Fnbytes  TCARD16
	Fpad1    TBYTE
	Fpad2    TBYTE
}

type TxQueryTextExtentsReq = struct {
	FreqType   TCARD8
	FoddLength TBOOL
	Flength    TCARD16
	Ffid       TCARD32
}

type TxListFontsReq = struct {
	FreqType  TCARD8
	Fpad      TBYTE
	Flength   TCARD16
	FmaxNames TCARD16
	Fnbytes   TCARD16
}

type TxListFontsWithInfoReq = struct {
	FreqType  TCARD8
	Fpad      TBYTE
	Flength   TCARD16
	FmaxNames TCARD16
	Fnbytes   TCARD16
}

type TxSetFontPathReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	FnFonts  TCARD16
	Fpad1    TBYTE
	Fpad2    TBYTE
}

type TxCreatePixmapReq = struct {
	FreqType  TCARD8
	Fdepth    TCARD8
	Flength   TCARD16
	Fpid      TCARD32
	Fdrawable TCARD32
	Fwidth    TCARD16
	Fheight   TCARD16
}

type TxCreateGCReq = struct {
	FreqType  TCARD8
	Fpad      TBYTE
	Flength   TCARD16
	Fgc       TCARD32
	Fdrawable TCARD32
	Fmask     TCARD32
}

type TxChangeGCReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	Fgc      TCARD32
	Fmask    TCARD32
}

type TxCopyGCReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	FsrcGC   TCARD32
	FdstGC   TCARD32
	Fmask    TCARD32
}

type TxSetDashesReq = struct {
	FreqType    TCARD8
	Fpad        TBYTE
	Flength     TCARD16
	Fgc         TCARD32
	FdashOffset TCARD16
	FnDashes    TCARD16
}

type TxSetClipRectanglesReq = struct {
	FreqType  TCARD8
	Fordering TBYTE
	Flength   TCARD16
	Fgc       TCARD32
	FxOrigin  TINT16
	FyOrigin  TINT16
}

type TxClearAreaReq = struct {
	FreqType   TCARD8
	Fexposures TBOOL
	Flength    TCARD16
	Fwindow    TCARD32
	Fx         TINT16
	Fy         TINT16
	Fwidth     TCARD16
	Fheight    TCARD16
}

type TxCopyAreaReq = struct {
	FreqType     TCARD8
	Fpad         TBYTE
	Flength      TCARD16
	FsrcDrawable TCARD32
	FdstDrawable TCARD32
	Fgc          TCARD32
	FsrcX        TINT16
	FsrcY        TINT16
	FdstX        TINT16
	FdstY        TINT16
	Fwidth       TCARD16
	Fheight      TCARD16
}

type TxCopyPlaneReq = struct {
	FreqType     TCARD8
	Fpad         TBYTE
	Flength      TCARD16
	FsrcDrawable TCARD32
	FdstDrawable TCARD32
	Fgc          TCARD32
	FsrcX        TINT16
	FsrcY        TINT16
	FdstX        TINT16
	FdstY        TINT16
	Fwidth       TCARD16
	Fheight      TCARD16
	FbitPlane    TCARD32
}

type TxPolyPointReq = struct {
	FreqType   TCARD8
	FcoordMode TBYTE
	Flength    TCARD16
	Fdrawable  TCARD32
	Fgc        TCARD32
}

type TxPolyLineReq = struct {
	FreqType   TCARD8
	FcoordMode TBYTE
	Flength    TCARD16
	Fdrawable  TCARD32
	Fgc        TCARD32
}

type TxPolySegmentReq = struct {
	FreqType  TCARD8
	Fpad      TBYTE
	Flength   TCARD16
	Fdrawable TCARD32
	Fgc       TCARD32
}

type TxPolyArcReq = struct {
	FreqType  TCARD8
	Fpad      TBYTE
	Flength   TCARD16
	Fdrawable TCARD32
	Fgc       TCARD32
}

type TxPolyRectangleReq = struct {
	FreqType  TCARD8
	Fpad      TBYTE
	Flength   TCARD16
	Fdrawable TCARD32
	Fgc       TCARD32
}

type TxPolyFillRectangleReq = struct {
	FreqType  TCARD8
	Fpad      TBYTE
	Flength   TCARD16
	Fdrawable TCARD32
	Fgc       TCARD32
}

type TxPolyFillArcReq = struct {
	FreqType  TCARD8
	Fpad      TBYTE
	Flength   TCARD16
	Fdrawable TCARD32
	Fgc       TCARD32
}

type TxFillPolyReq = struct {
	FreqType   TCARD8
	Fpad       TBYTE
	Flength    TCARD16
	Fdrawable  TCARD32
	Fgc        TCARD32
	Fshape     TBYTE
	FcoordMode TBYTE
	Fpad1      TCARD16
}

type T_FillPolyReq = TxFillPolyReq

type TxPutImageReq = struct {
	FreqType  TCARD8
	Fformat   TCARD8
	Flength   TCARD16
	Fdrawable TCARD32
	Fgc       TCARD32
	Fwidth    TCARD16
	Fheight   TCARD16
	FdstX     TINT16
	FdstY     TINT16
	FleftPad  TCARD8
	Fdepth    TCARD8
	Fpad      TCARD16
}

type T_PutImageReq = TxPutImageReq

type TxGetImageReq = struct {
	FreqType   TCARD8
	Fformat    TCARD8
	Flength    TCARD16
	Fdrawable  TCARD32
	Fx         TINT16
	Fy         TINT16
	Fwidth     TCARD16
	Fheight    TCARD16
	FplaneMask TCARD32
}

type TxPolyTextReq = struct {
	FreqType  TCARD8
	Fpad      TCARD8
	Flength   TCARD16
	Fdrawable TCARD32
	Fgc       TCARD32
	Fx        TINT16
	Fy        TINT16
}

type TxPolyText8Req = struct {
	FreqType  TCARD8
	Fpad      TCARD8
	Flength   TCARD16
	Fdrawable TCARD32
	Fgc       TCARD32
	Fx        TINT16
	Fy        TINT16
}

type TxPolyText16Req = struct {
	FreqType  TCARD8
	Fpad      TCARD8
	Flength   TCARD16
	Fdrawable TCARD32
	Fgc       TCARD32
	Fx        TINT16
	Fy        TINT16
}

type TxImageTextReq = struct {
	FreqType  TCARD8
	FnChars   TBYTE
	Flength   TCARD16
	Fdrawable TCARD32
	Fgc       TCARD32
	Fx        TINT16
	Fy        TINT16
}

type TxImageText8Req = struct {
	FreqType  TCARD8
	FnChars   TBYTE
	Flength   TCARD16
	Fdrawable TCARD32
	Fgc       TCARD32
	Fx        TINT16
	Fy        TINT16
}

type TxImageText16Req = struct {
	FreqType  TCARD8
	FnChars   TBYTE
	Flength   TCARD16
	Fdrawable TCARD32
	Fgc       TCARD32
	Fx        TINT16
	Fy        TINT16
}

type TxCreateColormapReq = struct {
	FreqType TCARD8
	Falloc   TBYTE
	Flength  TCARD16
	Fmid     TCARD32
	Fwindow  TCARD32
	Fvisual  TCARD32
}

type TxCopyColormapAndFreeReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	Fmid     TCARD32
	FsrcCmap TCARD32
}

type TxAllocColorReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	Fcmap    TCARD32
	Fred     TCARD16
	Fgreen   TCARD16
	Fblue    TCARD16
	Fpad2    TCARD16
}

type TxAllocNamedColorReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	Fcmap    TCARD32
	Fnbytes  TCARD16
	Fpad1    TBYTE
	Fpad2    TBYTE
}

type TxAllocColorCellsReq = struct {
	FreqType    TCARD8
	Fcontiguous TBOOL
	Flength     TCARD16
	Fcmap       TCARD32
	Fcolors     TCARD16
	Fplanes     TCARD16
}

type TxAllocColorPlanesReq = struct {
	FreqType    TCARD8
	Fcontiguous TBOOL
	Flength     TCARD16
	Fcmap       TCARD32
	Fcolors     TCARD16
	Fred        TCARD16
	Fgreen      TCARD16
	Fblue       TCARD16
}

type TxFreeColorsReq = struct {
	FreqType   TCARD8
	Fpad       TBYTE
	Flength    TCARD16
	Fcmap      TCARD32
	FplaneMask TCARD32
}

type TxStoreColorsReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	Fcmap    TCARD32
}

type TxStoreNamedColorReq = struct {
	FreqType TCARD8
	Fflags   TCARD8
	Flength  TCARD16
	Fcmap    TCARD32
	Fpixel   TCARD32
	Fnbytes  TCARD16
	Fpad1    TBYTE
	Fpad2    TBYTE
}

type TxQueryColorsReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	Fcmap    TCARD32
}

type TxLookupColorReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	Fcmap    TCARD32
	Fnbytes  TCARD16
	Fpad1    TBYTE
	Fpad2    TBYTE
}

type TxCreateCursorReq = struct {
	FreqType   TCARD8
	Fpad       TBYTE
	Flength    TCARD16
	Fcid       TCARD32
	Fsource    TCARD32
	Fmask      TCARD32
	FforeRed   TCARD16
	FforeGreen TCARD16
	FforeBlue  TCARD16
	FbackRed   TCARD16
	FbackGreen TCARD16
	FbackBlue  TCARD16
	Fx         TCARD16
	Fy         TCARD16
}

type TxCreateGlyphCursorReq = struct {
	FreqType    TCARD8
	Fpad        TBYTE
	Flength     TCARD16
	Fcid        TCARD32
	Fsource     TCARD32
	Fmask       TCARD32
	FsourceChar TCARD16
	FmaskChar   TCARD16
	FforeRed    TCARD16
	FforeGreen  TCARD16
	FforeBlue   TCARD16
	FbackRed    TCARD16
	FbackGreen  TCARD16
	FbackBlue   TCARD16
}

type TxRecolorCursorReq = struct {
	FreqType   TCARD8
	Fpad       TBYTE
	Flength    TCARD16
	Fcursor    TCARD32
	FforeRed   TCARD16
	FforeGreen TCARD16
	FforeBlue  TCARD16
	FbackRed   TCARD16
	FbackGreen TCARD16
	FbackBlue  TCARD16
}

type TxQueryBestSizeReq = struct {
	FreqType  TCARD8
	Fclass    TCARD8
	Flength   TCARD16
	Fdrawable TCARD32
	Fwidth    TCARD16
	Fheight   TCARD16
}

type TxQueryExtensionReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	Fnbytes  TCARD16
	Fpad1    TBYTE
	Fpad2    TBYTE
}

type TxSetModifierMappingReq = struct {
	FreqType           TCARD8
	FnumKeyPerModifier TCARD8
	Flength            TCARD16
}

type TxSetPointerMappingReq = struct {
	FreqType TCARD8
	FnElts   TCARD8
	Flength  TCARD16
}

type TxGetKeyboardMappingReq = struct {
	FreqType      TCARD8
	Fpad          TBYTE
	Flength       TCARD16
	FfirstKeyCode TCARD8
	Fcount        TCARD8
	Fpad1         TCARD16
}

type TxChangeKeyboardMappingReq = struct {
	FreqType           TCARD8
	FkeyCodes          TCARD8
	Flength            TCARD16
	FfirstKeyCode      TCARD8
	FkeySymsPerKeyCode TCARD8
	Fpad1              TCARD16
}

type TxChangeKeyboardControlReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
	Fmask    TCARD32
}

type TxBellReq = struct {
	FreqType TCARD8
	Fpercent TINT8
	Flength  TCARD16
}

type TxChangePointerControlReq = struct {
	FreqType    TCARD8
	Fpad        TBYTE
	Flength     TCARD16
	FaccelNum   TINT16
	FaccelDenum TINT16
	Fthreshold  TINT16
	FdoAccel    TBOOL
	FdoThresh   TBOOL
}

type TxSetScreenSaverReq = struct {
	FreqType     TCARD8
	Fpad         TBYTE
	Flength      TCARD16
	Ftimeout     TINT16
	Finterval    TINT16
	FpreferBlank TBYTE
	FallowExpose TBYTE
	Fpad2        TCARD16
}

type TxChangeHostsReq = struct {
	FreqType    TCARD8
	Fmode       TBYTE
	Flength     TCARD16
	FhostFamily TCARD8
	Fpad        TBYTE
	FhostLength TCARD16
}

type TxListHostsReq = struct {
	FreqType TCARD8
	Fpad     TBYTE
	Flength  TCARD16
}

type TxChangeModeReq = struct {
	FreqType TCARD8
	Fmode    TBYTE
	Flength  TCARD16
}

type TxSetAccessControlReq = struct {
	FreqType TCARD8
	Fmode    TBYTE
	Flength  TCARD16
}

type TxSetCloseDownModeReq = struct {
	FreqType TCARD8
	Fmode    TBYTE
	Flength  TCARD16
}

type TxForceScreenSaverReq = struct {
	FreqType TCARD8
	Fmode    TBYTE
	Flength  TCARD16
}

type TxRotatePropertiesReq = struct {
	FreqType    TCARD8
	Fpad        TBYTE
	Flength     TCARD16
	Fwindow     TCARD32
	FnAtoms     TCARD16
	FnPositions TINT16
}

type Tsched_param = struct {
	Fsched_priority int32
	F__opaque       [4]int8
}

type Ttimespec = struct {
	Ftv_sec  t__darwin_time_t
	Ftv_nsec int64
}

type Ttm = struct {
	Ftm_sec    int32
	Ftm_min    int32
	Ftm_hour   int32
	Ftm_mday   int32
	Ftm_mon    int32
	Ftm_year   int32
	Ftm_wday   int32
	Ftm_yday   int32
	Ftm_isdst  int32
	Ftm_gmtoff int64
	Ftm_zone   uintptr
} //TODO "timezone" // time.h:103:13:

type Tclockid_t = int32

const __CLOCK_REALTIME = 0
const __CLOCK_MONOTONIC = 6
const __CLOCK_MONOTONIC_RAW = 4
const __CLOCK_MONOTONIC_RAW_APPROX = 5
const __CLOCK_UPTIME_RAW = 8
const __CLOCK_UPTIME_RAW_APPROX = 9
const __CLOCK_PROCESS_CPUTIME_ID = 12
const __CLOCK_THREAD_CPUTIME_ID = 16
const _QOS_CLASS_USER_INTERACTIVE = 33
const _QOS_CLASS_USER_INITIATED = 25
const _QOS_CLASS_DEFAULT = 21
const _QOS_CLASS_UTILITY = 17
const _QOS_CLASS_BACKGROUND = 9
const _QOS_CLASS_UNSPECIFIED = 0

type Tqos_class_t = uint32

type Tpthread_override_t = uintptr

type Tmach_port_t = uint32

type Tpthread_jit_write_callback_t = uintptr

type Txthread_t = uintptr

type Txthread_key_t = uint64

type Txcondition_rec = struct {
	F__sig    int64
	F__opaque [40]int8
}

type Txmutex_rec = struct {
	F__sig    int64
	F__opaque [56]int8
}

type Txcondition_t = uintptr

type Txmutex_t = uintptr

type T_XQEvent = struct {
	Fnext        uintptr
	Fevent       TXEvent
	Fqserial_num uint64
}

type T_XSQEvent = T_XQEvent

type TLockInfoPtr = uintptr

type T_XLockPtrs = struct {
	Flock_display   uintptr
	Funlock_display uintptr
}

type T_XAsyncHandler = struct {
	Fnext    uintptr
	Fhandler uintptr
	Fdata    TXPointer
}

type T_XInternalAsync = T_XAsyncHandler

type T_XAsyncErrorState = struct {
	Fmin_sequence_number uint64
	Fmax_sequence_number uint64
	Ferror_code          uint8
	Fmajor_opcode        uint8
	Fminor_opcode        uint16
	Flast_error_received uint8
	Ferror_count         int32
}

type T_XAsyncEState = T_XAsyncErrorState

type TFreeFuncType = uintptr

type TFreeModmapType = uintptr

type T_XFreeFuncRec = struct {
	Fatoms         TFreeFuncType
	Fmodifiermap   TFreeModmapType
	Fkey_bindings  TFreeFuncType
	Fcontext_db    TFreeFuncType
	FdefaultCCCs   TFreeFuncType
	FclientCmaps   TFreeFuncType
	FintensityMaps TFreeFuncType
	Fim_filters    TFreeFuncType
	Fxkb           TFreeFuncType
}

type T_XFreeFuncs = T_XFreeFuncRec

type TCreateGCType = uintptr

type TCopyGCType = uintptr

type TFlushGCType = uintptr

type TFreeGCType = uintptr

type TCreateFontType = uintptr

type TFreeFontType = uintptr

type TCloseDisplayType = uintptr

type TErrorType = uintptr

type TErrorStringType = uintptr

type TPrintErrorType = uintptr

type TBeforeFlushType = uintptr

type T_XExtension = struct {
	Fnext          uintptr
	Fcodes         TXExtCodes
	Fcreate_GC     TCreateGCType
	Fcopy_GC       TCopyGCType
	Fflush_GC      TFlushGCType
	Ffree_GC       TFreeGCType
	Fcreate_Font   TCreateFontType
	Ffree_Font     TFreeFontType
	Fclose_display TCloseDisplayType
	Ferror1        TErrorType
	Ferror_string  TErrorStringType
	Fname          uintptr
	Ferror_values  TPrintErrorType
	Fbefore_flush  TBeforeFlushType
	Fnext_flush    uintptr
}

type T_XExten = T_XExtension

type T_XInternalConnectionProc = uintptr

type T_XConnectionInfo = struct {
	Ffd            int32
	Fread_callback T_XInternalConnectionProc
	Fcall_data     TXPointer
	Fwatch_data    uintptr
	Fnext          uintptr
}

type T_XConnWatchInfo = struct {
	Ffn          TXConnectionWatchProc
	Fclient_data TXPointer
	Fnext        uintptr
}

type t__gnuc_va_list = uintptr

type Tjmp_buf = [37]int32

type Tsigjmp_buf = [38]int32

type TFT_Int16 = int16

type TFT_UInt16 = uint16

type TFT_Int32 = int32

type TFT_UInt32 = uint32

type TFT_Fast = int32

type TFT_UFast = uint32

type TFT_Int64 = int64

type TFT_UInt64 = uint64

type TFT_Memory = uintptr

type TFT_MemoryRec_ = struct {
	Fuser    uintptr
	Falloc   TFT_Alloc_Func
	Ffree    TFT_Free_Func
	Frealloc TFT_Realloc_Func
}

type TFT_Alloc_Func = uintptr

type TFT_Free_Func = uintptr

type TFT_Realloc_Func = uintptr

type TFT_Stream = uintptr

type TFT_StreamRec_ = struct {
	Fbase       uintptr
	Fsize       uint64
	Fpos        uint64
	Fdescriptor TFT_StreamDesc
	Fpathname   TFT_StreamDesc
	Fread       TFT_Stream_IoFunc
	Fclose1     TFT_Stream_CloseFunc
	Fmemory     TFT_Memory
	Fcursor     uintptr
	Flimit      uintptr
}

type TFT_StreamDesc = struct {
	Fpointer [0]uintptr
	Fvalue   int64
}

type TFT_StreamDesc_ = TFT_StreamDesc

type TFT_Stream_IoFunc = uintptr

type TFT_Stream_CloseFunc = uintptr

type TFT_StreamRec = struct {
	Fbase       uintptr
	Fsize       uint64
	Fpos        uint64
	Fdescriptor TFT_StreamDesc
	Fpathname   TFT_StreamDesc
	Fread       TFT_Stream_IoFunc
	Fclose1     TFT_Stream_CloseFunc
	Fmemory     TFT_Memory
	Fcursor     uintptr
	Flimit      uintptr
}

type TFT_Pos = int64

type TFT_Vector = struct {
	Fx TFT_Pos
	Fy TFT_Pos
}

type TFT_Vector_ = TFT_Vector

type TFT_BBox = struct {
	FxMin TFT_Pos
	FyMin TFT_Pos
	FxMax TFT_Pos
	FyMax TFT_Pos
}

type TFT_BBox_ = TFT_BBox

type TFT_Pixel_Mode = int32

type _FT_Pixel_Mode_ = int32

const _FT_PIXEL_MODE_NONE = 0
const _FT_PIXEL_MODE_MONO = 1
const _FT_PIXEL_MODE_GRAY = 2
const _FT_PIXEL_MODE_GRAY2 = 3
const _FT_PIXEL_MODE_GRAY4 = 4
const _FT_PIXEL_MODE_LCD = 5
const _FT_PIXEL_MODE_LCD_V = 6
const _FT_PIXEL_MODE_BGRA = 7
const _FT_PIXEL_MODE_MAX = 8

type TFT_Bitmap = struct {
	Frows         uint32
	Fwidth        uint32
	Fpitch        int32
	Fbuffer       uintptr
	Fnum_grays    uint16
	Fpixel_mode   uint8
	Fpalette_mode uint8
	Fpalette      uintptr
}

type TFT_Bitmap_ = TFT_Bitmap

type TFT_Outline = struct {
	Fn_contours int16
	Fn_points   int16
	Fpoints     uintptr
	Ftags       uintptr
	Fcontours   uintptr
	Fflags      int32
}

type TFT_Outline_ = TFT_Outline

type TFT_Outline_MoveToFunc = uintptr

type TFT_Outline_LineToFunc = uintptr

type TFT_Outline_ConicToFunc = uintptr

type TFT_Outline_CubicToFunc = uintptr

type TFT_Outline_Funcs = struct {
	Fmove_to  TFT_Outline_MoveToFunc
	Fline_to  TFT_Outline_LineToFunc
	Fconic_to TFT_Outline_ConicToFunc
	Fcubic_to TFT_Outline_CubicToFunc
	Fshift    int32
	Fdelta    TFT_Pos
}

type TFT_Outline_Funcs_ = TFT_Outline_Funcs

type TFT_Glyph_Format = int32

type _FT_Glyph_Format_ = int32

const _FT_GLYPH_FORMAT_NONE = 0
const _FT_GLYPH_FORMAT_COMPOSITE = 1668246896
const _FT_GLYPH_FORMAT_BITMAP = 1651078259
const _FT_GLYPH_FORMAT_OUTLINE = 1869968492
const _FT_GLYPH_FORMAT_PLOTTER = 1886154612

type TFT_Raster = uintptr

type TFT_Span = struct {
	Fx        int16
	Flen1     uint16
	Fcoverage uint8
}

type TFT_Span_ = TFT_Span

type TFT_SpanFunc = uintptr

type TFT_Raster_BitTest_Func = uintptr

type TFT_Raster_BitSet_Func = uintptr

type TFT_Raster_Params = struct {
	Ftarget      uintptr
	Fsource      uintptr
	Fflags       int32
	Fgray_spans  TFT_SpanFunc
	Fblack_spans TFT_SpanFunc
	Fbit_test    TFT_Raster_BitTest_Func
	Fbit_set     TFT_Raster_BitSet_Func
	Fuser        uintptr
	Fclip_box    TFT_BBox
}

type TFT_Raster_Params_ = TFT_Raster_Params

type TFT_Raster_NewFunc = uintptr

type TFT_Raster_DoneFunc = uintptr

type TFT_Raster_ResetFunc = uintptr

type TFT_Raster_SetModeFunc = uintptr

type TFT_Raster_RenderFunc = uintptr

type TFT_Raster_Funcs = struct {
	Fglyph_format    TFT_Glyph_Format
	Fraster_new      TFT_Raster_NewFunc
	Fraster_reset    TFT_Raster_ResetFunc
	Fraster_set_mode TFT_Raster_SetModeFunc
	Fraster_render   TFT_Raster_RenderFunc
	Fraster_done     TFT_Raster_DoneFunc
}

type TFT_Raster_Funcs_ = TFT_Raster_Funcs

type TFT_Bool = uint8

type TFT_FWord = int16

type TFT_UFWord = uint16

type TFT_Char = int8

type TFT_Byte = uint8

type TFT_Bytes = uintptr

type TFT_Tag = uint32

type TFT_String = int8

type TFT_Short = int16

type TFT_UShort = uint16

type TFT_Int = int32

type TFT_UInt = uint32

type TFT_Long = int64

type TFT_ULong = uint64

type TFT_F2Dot14 = int16

type TFT_F26Dot6 = int64

type TFT_Fixed = int64

type TFT_Error = int32

type TFT_Pointer = uintptr

type TFT_Offset = uint64

type TFT_PtrDist = int64

type TFT_UnitVector = struct {
	Fx TFT_F2Dot14
	Fy TFT_F2Dot14
}

type TFT_UnitVector_ = TFT_UnitVector

type TFT_Matrix = struct {
	Fxx TFT_Fixed
	Fxy TFT_Fixed
	Fyx TFT_Fixed
	Fyy TFT_Fixed
}

type TFT_Matrix_ = TFT_Matrix

type TFT_Data = struct {
	Fpointer uintptr
	Flength  TFT_Int
}

type TFT_Data_ = TFT_Data

type TFT_Generic_Finalizer = uintptr

type TFT_Generic = struct {
	Fdata      uintptr
	Ffinalizer TFT_Generic_Finalizer
}

type TFT_Generic_ = TFT_Generic

type TFT_ListNode = uintptr

type TFT_ListNodeRec_ = struct {
	Fprev TFT_ListNode
	Fnext TFT_ListNode
	Fdata uintptr
}

type TFT_List = uintptr

type TFT_ListRec_ = struct {
	Fhead TFT_ListNode
	Ftail TFT_ListNode
}

type TFT_ListNodeRec = struct {
	Fprev TFT_ListNode
	Fnext TFT_ListNode
	Fdata uintptr
}

type TFT_ListRec = struct {
	Fhead TFT_ListNode
	Ftail TFT_ListNode
}

const _FT_Mod_Err_Base = 0
const _FT_Mod_Err_Autofit = 0
const _FT_Mod_Err_BDF = 0
const _FT_Mod_Err_Bzip2 = 0
const _FT_Mod_Err_Cache = 0
const _FT_Mod_Err_CFF = 0
const _FT_Mod_Err_CID = 0
const _FT_Mod_Err_Gzip = 0
const _FT_Mod_Err_LZW = 0
const _FT_Mod_Err_OTvalid = 0
const _FT_Mod_Err_PCF = 0
const _FT_Mod_Err_PFR = 0
const _FT_Mod_Err_PSaux = 0
const _FT_Mod_Err_PShinter = 0
const _FT_Mod_Err_PSnames = 0
const _FT_Mod_Err_Raster = 0
const _FT_Mod_Err_SFNT = 0
const _FT_Mod_Err_Smooth = 0
const _FT_Mod_Err_TrueType = 0
const _FT_Mod_Err_Type1 = 0
const _FT_Mod_Err_Type42 = 0
const _FT_Mod_Err_Winfonts = 0
const _FT_Mod_Err_GXvalid = 0
const _FT_Mod_Err_Max = 1
const _FT_Err_Ok = 0
const _FT_Err_Cannot_Open_Resource = 1
const _FT_Err_Unknown_File_Format = 2
const _FT_Err_Invalid_File_Format = 3
const _FT_Err_Invalid_Version = 4
const _FT_Err_Lower_Module_Version = 5
const _FT_Err_Invalid_Argument = 6
const _FT_Err_Unimplemented_Feature = 7
const _FT_Err_Invalid_Table = 8
const _FT_Err_Invalid_Offset = 9
const _FT_Err_Array_Too_Large = 10
const _FT_Err_Missing_Module = 11
const _FT_Err_Missing_Property = 12
const _FT_Err_Invalid_Glyph_Index = 16
const _FT_Err_Invalid_Character_Code = 17
const _FT_Err_Invalid_Glyph_Format = 18
const _FT_Err_Cannot_Render_Glyph = 19
const _FT_Err_Invalid_Outline = 20
const _FT_Err_Invalid_Composite = 21
const _FT_Err_Too_Many_Hints = 22
const _FT_Err_Invalid_Pixel_Size = 23
const _FT_Err_Invalid_Handle = 32
const _FT_Err_Invalid_Library_Handle = 33
const _FT_Err_Invalid_Driver_Handle = 34
const _FT_Err_Invalid_Face_Handle = 35
const _FT_Err_Invalid_Size_Handle = 36
const _FT_Err_Invalid_Slot_Handle = 37
const _FT_Err_Invalid_CharMap_Handle = 38
const _FT_Err_Invalid_Cache_Handle = 39
const _FT_Err_Invalid_Stream_Handle = 40
const _FT_Err_Too_Many_Drivers = 48
const _FT_Err_Too_Many_Extensions = 49
const _FT_Err_Out_Of_Memory = 64
const _FT_Err_Unlisted_Object = 65
const _FT_Err_Cannot_Open_Stream = 81
const _FT_Err_Invalid_Stream_Seek = 82
const _FT_Err_Invalid_Stream_Skip = 83
const _FT_Err_Invalid_Stream_Read = 84
const _FT_Err_Invalid_Stream_Operation = 85
const _FT_Err_Invalid_Frame_Operation = 86
const _FT_Err_Nested_Frame_Access = 87
const _FT_Err_Invalid_Frame_Read = 88
const _FT_Err_Raster_Uninitialized = 96
const _FT_Err_Raster_Corrupted = 97
const _FT_Err_Raster_Overflow = 98
const _FT_Err_Raster_Negative_Height = 99
const _FT_Err_Too_Many_Caches = 112
const _FT_Err_Invalid_Opcode = 128
const _FT_Err_Too_Few_Arguments = 129
const _FT_Err_Stack_Overflow = 130
const _FT_Err_Code_Overflow = 131
const _FT_Err_Bad_Argument = 132
const _FT_Err_Divide_By_Zero = 133
const _FT_Err_Invalid_Reference = 134
const _FT_Err_Debug_OpCode = 135
const _FT_Err_ENDF_In_Exec_Stream = 136
const _FT_Err_Nested_DEFS = 137
const _FT_Err_Invalid_CodeRange = 138
const _FT_Err_Execution_Too_Long = 139
const _FT_Err_Too_Many_Function_Defs = 140
const _FT_Err_Too_Many_Instruction_Defs = 141
const _FT_Err_Table_Missing = 142
const _FT_Err_Horiz_Header_Missing = 143
const _FT_Err_Locations_Missing = 144
const _FT_Err_Name_Table_Missing = 145
const _FT_Err_CMap_Table_Missing = 146
const _FT_Err_Hmtx_Table_Missing = 147
const _FT_Err_Post_Table_Missing = 148
const _FT_Err_Invalid_Horiz_Metrics = 149
const _FT_Err_Invalid_CharMap_Format = 150
const _FT_Err_Invalid_PPem = 151
const _FT_Err_Invalid_Vert_Metrics = 152
const _FT_Err_Could_Not_Find_Context = 153
const _FT_Err_Invalid_Post_Table_Format = 154
const _FT_Err_Invalid_Post_Table = 155
const _FT_Err_DEF_In_Glyf_Bytecode = 156
const _FT_Err_Missing_Bitmap = 157
const _FT_Err_Syntax_Error = 160
const _FT_Err_Stack_Underflow = 161
const _FT_Err_Ignore = 162
const _FT_Err_No_Unicode_Glyph_Name = 163
const _FT_Err_Glyph_Too_Big = 164
const _FT_Err_Missing_Startfont_Field = 176
const _FT_Err_Missing_Font_Field = 177
const _FT_Err_Missing_Size_Field = 178
const _FT_Err_Missing_Fontboundingbox_Field = 179
const _FT_Err_Missing_Chars_Field = 180
const _FT_Err_Missing_Startchar_Field = 181
const _FT_Err_Missing_Encoding_Field = 182
const _FT_Err_Missing_Bbx_Field = 183
const _FT_Err_Bbx_Too_Big = 184
const _FT_Err_Corrupted_Font_Header = 185
const _FT_Err_Corrupted_Font_Glyphs = 186
const _FT_Err_Max = 187

type TFT_Glyph_Metrics = struct {
	Fwidth        TFT_Pos
	Fheight       TFT_Pos
	FhoriBearingX TFT_Pos
	FhoriBearingY TFT_Pos
	FhoriAdvance  TFT_Pos
	FvertBearingX TFT_Pos
	FvertBearingY TFT_Pos
	FvertAdvance  TFT_Pos
}

type TFT_Glyph_Metrics_ = TFT_Glyph_Metrics

type TFT_Bitmap_Size = struct {
	Fheight TFT_Short
	Fwidth  TFT_Short
	Fsize   TFT_Pos
	Fx_ppem TFT_Pos
	Fy_ppem TFT_Pos
}

type TFT_Bitmap_Size_ = TFT_Bitmap_Size

type TFT_Library = uintptr

type TFT_Module = uintptr

type TFT_Driver = uintptr

type TFT_Renderer = uintptr

type TFT_Face = uintptr

type TFT_FaceRec_ = struct {
	Fnum_faces           TFT_Long
	Fface_index          TFT_Long
	Fface_flags          TFT_Long
	Fstyle_flags         TFT_Long
	Fnum_glyphs          TFT_Long
	Ffamily_name         uintptr
	Fstyle_name          uintptr
	Fnum_fixed_sizes     TFT_Int
	Favailable_sizes     uintptr
	Fnum_charmaps        TFT_Int
	Fcharmaps            uintptr
	Fgeneric             TFT_Generic
	Fbbox                TFT_BBox
	Funits_per_EM        TFT_UShort
	Fascender            TFT_Short
	Fdescender           TFT_Short
	Fheight              TFT_Short
	Fmax_advance_width   TFT_Short
	Fmax_advance_height  TFT_Short
	Funderline_position  TFT_Short
	Funderline_thickness TFT_Short
	Fglyph               TFT_GlyphSlot
	Fsize                TFT_Size
	Fcharmap             TFT_CharMap
	Fdriver              TFT_Driver
	Fmemory              TFT_Memory
	Fstream              TFT_Stream
	Fsizes_list          TFT_ListRec
	Fautohint            TFT_Generic
	Fextensions          uintptr
	Finternal            TFT_Face_Internal
}

type TFT_Size = uintptr

type TFT_SizeRec_ = struct {
	Fface     TFT_Face
	Fgeneric  TFT_Generic
	Fmetrics  TFT_Size_Metrics
	Finternal TFT_Size_Internal
}

type TFT_GlyphSlot = uintptr

type TFT_GlyphSlotRec_ = struct {
	Flibrary           TFT_Library
	Fface              TFT_Face
	Fnext              TFT_GlyphSlot
	Fglyph_index       TFT_UInt
	Fgeneric           TFT_Generic
	Fmetrics           TFT_Glyph_Metrics
	FlinearHoriAdvance TFT_Fixed
	FlinearVertAdvance TFT_Fixed
	Fadvance           TFT_Vector
	Fformat            TFT_Glyph_Format
	Fbitmap            TFT_Bitmap
	Fbitmap_left       TFT_Int
	Fbitmap_top        TFT_Int
	Foutline           TFT_Outline
	Fnum_subglyphs     TFT_UInt
	Fsubglyphs         TFT_SubGlyph
	Fcontrol_data      uintptr
	Fcontrol_len       int64
	Flsb_delta         TFT_Pos
	Frsb_delta         TFT_Pos
	Fother             uintptr
	Finternal          TFT_Slot_Internal
}

type TFT_CharMap = uintptr

type TFT_CharMapRec_ = struct {
	Fface        TFT_Face
	Fencoding    TFT_Encoding
	Fplatform_id TFT_UShort
	Fencoding_id TFT_UShort
}

type _FT_Encoding_ = int32

const _FT_ENCODING_NONE = 0
const _FT_ENCODING_MS_SYMBOL = 1937337698
const _FT_ENCODING_UNICODE = 1970170211
const _FT_ENCODING_SJIS = 1936353651
const _FT_ENCODING_PRC = 1734484000
const _FT_ENCODING_BIG5 = 1651074869
const _FT_ENCODING_WANSUNG = 2002873971
const _FT_ENCODING_JOHAB = 1785686113
const _FT_ENCODING_GB2312 = 1734484000
const _FT_ENCODING_MS_SJIS = 1936353651
const _FT_ENCODING_MS_GB2312 = 1734484000
const _FT_ENCODING_MS_BIG5 = 1651074869
const _FT_ENCODING_MS_WANSUNG = 2002873971
const _FT_ENCODING_MS_JOHAB = 1785686113
const _FT_ENCODING_ADOBE_STANDARD = 1094995778
const _FT_ENCODING_ADOBE_EXPERT = 1094992453
const _FT_ENCODING_ADOBE_CUSTOM = 1094992451
const _FT_ENCODING_ADOBE_LATIN_1 = 1818326065
const _FT_ENCODING_OLD_LATIN_2 = 1818326066
const _FT_ENCODING_APPLE_ROMAN = 1634889070

type TFT_Encoding = int32

type TFT_CharMapRec = struct {
	Fface        TFT_Face
	Fencoding    TFT_Encoding
	Fplatform_id TFT_UShort
	Fencoding_id TFT_UShort
}

type TFT_Face_Internal = uintptr

type TFT_FaceRec = struct {
	Fnum_faces           TFT_Long
	Fface_index          TFT_Long
	Fface_flags          TFT_Long
	Fstyle_flags         TFT_Long
	Fnum_glyphs          TFT_Long
	Ffamily_name         uintptr
	Fstyle_name          uintptr
	Fnum_fixed_sizes     TFT_Int
	Favailable_sizes     uintptr
	Fnum_charmaps        TFT_Int
	Fcharmaps            uintptr
	Fgeneric             TFT_Generic
	Fbbox                TFT_BBox
	Funits_per_EM        TFT_UShort
	Fascender            TFT_Short
	Fdescender           TFT_Short
	Fheight              TFT_Short
	Fmax_advance_width   TFT_Short
	Fmax_advance_height  TFT_Short
	Funderline_position  TFT_Short
	Funderline_thickness TFT_Short
	Fglyph               TFT_GlyphSlot
	Fsize                TFT_Size
	Fcharmap             TFT_CharMap
	Fdriver              TFT_Driver
	Fmemory              TFT_Memory
	Fstream              TFT_Stream
	Fsizes_list          TFT_ListRec
	Fautohint            TFT_Generic
	Fextensions          uintptr
	Finternal            TFT_Face_Internal
}

type TFT_Size_Internal = uintptr

type TFT_Size_Metrics = struct {
	Fx_ppem      TFT_UShort
	Fy_ppem      TFT_UShort
	Fx_scale     TFT_Fixed
	Fy_scale     TFT_Fixed
	Fascender    TFT_Pos
	Fdescender   TFT_Pos
	Fheight      TFT_Pos
	Fmax_advance TFT_Pos
}

type TFT_Size_Metrics_ = TFT_Size_Metrics

type TFT_SizeRec = struct {
	Fface     TFT_Face
	Fgeneric  TFT_Generic
	Fmetrics  TFT_Size_Metrics
	Finternal TFT_Size_Internal
}

type TFT_SubGlyph = uintptr

type TFT_Slot_Internal = uintptr

type TFT_GlyphSlotRec = struct {
	Flibrary           TFT_Library
	Fface              TFT_Face
	Fnext              TFT_GlyphSlot
	Fglyph_index       TFT_UInt
	Fgeneric           TFT_Generic
	Fmetrics           TFT_Glyph_Metrics
	FlinearHoriAdvance TFT_Fixed
	FlinearVertAdvance TFT_Fixed
	Fadvance           TFT_Vector
	Fformat            TFT_Glyph_Format
	Fbitmap            TFT_Bitmap
	Fbitmap_left       TFT_Int
	Fbitmap_top        TFT_Int
	Foutline           TFT_Outline
	Fnum_subglyphs     TFT_UInt
	Fsubglyphs         TFT_SubGlyph
	Fcontrol_data      uintptr
	Fcontrol_len       int64
	Flsb_delta         TFT_Pos
	Frsb_delta         TFT_Pos
	Fother             uintptr
	Finternal          TFT_Slot_Internal
}

type TFT_Parameter = struct {
	Ftag  TFT_ULong
	Fdata TFT_Pointer
}

type TFT_Parameter_ = TFT_Parameter

type TFT_Open_Args = struct {
	Fflags       TFT_UInt
	Fmemory_base uintptr
	Fmemory_size TFT_Long
	Fpathname    uintptr
	Fstream      TFT_Stream
	Fdriver      TFT_Module
	Fnum_params  TFT_Int
	Fparams      uintptr
}

type TFT_Open_Args_ = TFT_Open_Args

type TFT_Size_Request_Type = int32

type _FT_Size_Request_Type_ = int32

const _FT_SIZE_REQUEST_TYPE_NOMINAL = 0
const _FT_SIZE_REQUEST_TYPE_REAL_DIM = 1
const _FT_SIZE_REQUEST_TYPE_BBOX = 2
const _FT_SIZE_REQUEST_TYPE_CELL = 3
const _FT_SIZE_REQUEST_TYPE_SCALES = 4
const _FT_SIZE_REQUEST_TYPE_MAX = 5

type TFT_Size_RequestRec = struct {
	Ftype1          TFT_Size_Request_Type
	Fwidth          TFT_Long
	Fheight         TFT_Long
	FhoriResolution TFT_UInt
	FvertResolution TFT_UInt
}

type TFT_Size_RequestRec_ = TFT_Size_RequestRec

type TFT_Size_Request = uintptr

type TFT_Render_Mode = int32

type _FT_Render_Mode_ = int32

const _FT_RENDER_MODE_NORMAL = 0
const _FT_RENDER_MODE_LIGHT = 1
const _FT_RENDER_MODE_MONO = 2
const _FT_RENDER_MODE_LCD = 3
const _FT_RENDER_MODE_LCD_V = 4
const _FT_RENDER_MODE_MAX = 5

type TFT_Kerning_Mode = int32

type _FT_Kerning_Mode_ = int32

const _FT_KERNING_DEFAULT = 0
const _FT_KERNING_UNFITTED = 1
const _FT_KERNING_UNSCALED = 2

type TFT_LayerIterator = struct {
	Fnum_layers TFT_UInt
	Flayer      TFT_UInt
	Fp          uintptr
}

type TFT_LayerIterator_ = TFT_LayerIterator

type Tostat = struct {
	Fst_dev       t__uint16_t
	Fst_ino       Tino_t
	Fst_mode      Tmode_t
	Fst_nlink     Tnlink_t
	Fst_uid       t__uint16_t
	Fst_gid       t__uint16_t
	Fst_rdev      t__uint16_t
	Fst_size      t__int32_t
	Fst_atimespec Ttimespec
	Fst_mtimespec Ttimespec
	Fst_ctimespec Ttimespec
	Fst_blksize   t__int32_t
	Fst_blocks    t__int32_t
	Fst_flags     t__uint32_t
	Fst_gen       t__uint32_t
}

type Tstat = struct {
	Fst_dev           Tdev_t
	Fst_mode          Tmode_t
	Fst_nlink         Tnlink_t
	Fst_ino           t__darwin_ino64_t
	Fst_uid           Tuid_t
	Fst_gid           Tgid_t
	Fst_rdev          Tdev_t
	Fst_atimespec     Ttimespec
	Fst_mtimespec     Ttimespec
	Fst_ctimespec     Ttimespec
	Fst_birthtimespec Ttimespec
	Fst_size          Toff_t
	Fst_blocks        Tblkcnt_t
	Fst_blksize       Tblksize_t
	Fst_flags         t__uint32_t
	Fst_gen           t__uint32_t
	Fst_lspare        t__int32_t
	Fst_qspare        [2]t__int64_t
}

type Tstat64 = struct {
	Fst_dev           Tdev_t
	Fst_mode          Tmode_t
	Fst_nlink         Tnlink_t
	Fst_ino           t__darwin_ino64_t
	Fst_uid           Tuid_t
	Fst_gid           Tgid_t
	Fst_rdev          Tdev_t
	Fst_atimespec     Ttimespec
	Fst_mtimespec     Ttimespec
	Fst_ctimespec     Ttimespec
	Fst_birthtimespec Ttimespec
	Fst_size          Toff_t
	Fst_blocks        Tblkcnt_t
	Fst_blksize       Tblksize_t
	Fst_flags         t__uint32_t
	Fst_gen           t__uint32_t
	Fst_lspare        t__int32_t
	Fst_qspare        [2]t__int64_t
}

type Tfilesec_t = uintptr

type TFcChar8 = uint8

type TFcChar16 = uint16

type TFcChar32 = uint32

type TFcBool = int32

type TFcType = int32

type __FcType = int32

const _FcTypeUnknown = -1
const _FcTypeVoid = 0
const _FcTypeInteger = 1
const _FcTypeDouble = 2
const _FcTypeString = 3
const _FcTypeBool = 4
const _FcTypeMatrix = 5
const _FcTypeCharSet = 6
const _FcTypeFTFace = 7
const _FcTypeLangSet = 8
const _FcTypeRange = 9

type TFcMatrix = struct {
	Fxx float64
	Fxy float64
	Fyx float64
	Fyy float64
}

type T_FcMatrix = TFcMatrix

type TFcObjectType = struct {
	Fobject uintptr
	Ftype1  TFcType
}

type T_FcObjectType = TFcObjectType

type TFcConstant = struct {
	Fname   uintptr
	Fobject uintptr
	Fvalue  int32
}

type T_FcConstant = TFcConstant

type TFcResult = int32

type __FcResult = int32

const _FcResultMatch = 0
const _FcResultNoMatch = 1
const _FcResultTypeMismatch = 2
const _FcResultNoId = 3
const _FcResultOutOfMemory = 4

type TFcValueBinding = int32

type __FcValueBinding = int32

const _FcValueBindingWeak = 0
const _FcValueBindingStrong = 1
const _FcValueBindingSame = 2
const _FcValueBindingEnd = 2147483647

type TFcPatternIter = struct {
	Fdummy1 uintptr
	Fdummy2 uintptr
}

type T_FcPatternIter = TFcPatternIter

type TFcValue = struct {
	Ftype1 TFcType
	Fu     struct {
		Fi [0]int32
		Fb [0]TFcBool
		Fd [0]float64
		Fm [0]uintptr
		Fc [0]uintptr
		Ff [0]uintptr
		Fl [0]uintptr
		Fr [0]uintptr
		Fs uintptr
	}
}

type T_FcValue = TFcValue

type TFcFontSet = struct {
	Fnfont int32
	Fsfont int32
	Ffonts uintptr
}

type T_FcFontSet = TFcFontSet

type TFcObjectSet = struct {
	Fnobject int32
	Fsobject int32
	Fobjects uintptr
}

type T_FcObjectSet = TFcObjectSet

type TFcMatchKind = int32

type __FcMatchKind = int32

const _FcMatchPattern = 0
const _FcMatchFont = 1
const _FcMatchScan = 2
const _FcMatchKindEnd = 3
const _FcMatchKindBegin = 0

type TFcLangResult = int32

type __FcLangResult = int32

const _FcLangEqual = 0
const _FcLangDifferentCountry = 1
const _FcLangDifferentTerritory = 1
const _FcLangDifferentLang = 2

type TFcSetName = int32

type __FcSetName = int32

const _FcSetSystem = 0
const _FcSetApplication = 1

type TFcConfigFileInfoIter = struct {
	Fdummy1 uintptr
	Fdummy2 uintptr
	Fdummy3 uintptr
}

type T_FcConfigFileInfoIter = TFcConfigFileInfoIter

type TFcEndian = int32

const _FcEndianBig = 0
const _FcEndianLittle = 1

type Tpointer = uintptr

type TClientPtr = uintptr

type TFontPtr = uintptr

type TFSID = uint64

type TAccContext = uint64

type TOSTimePtr = uintptr

type TBlockHandlerProcPtr = uintptr

type TGlyph = uint64

type TGlyphSet = uint64

type TPicture = uint64

type TPictFormat = uint64

type TXRenderDirectFormat = struct {
	Fred       int16
	FredMask   int16
	Fgreen     int16
	FgreenMask int16
	Fblue      int16
	FblueMask  int16
	Falpha     int16
	FalphaMask int16
}

type TXRenderPictFormat = struct {
	Fid       TPictFormat
	Ftype1    int32
	Fdepth    int32
	Fdirect   TXRenderDirectFormat
	Fcolormap TColormap
}

type TXRenderPictureAttributes = struct {
	Frepeat             int32
	Falpha_map          TPicture
	Falpha_x_origin     int32
	Falpha_y_origin     int32
	Fclip_x_origin      int32
	Fclip_y_origin      int32
	Fclip_mask          TPixmap
	Fgraphics_exposures int32
	Fsubwindow_mode     int32
	Fpoly_edge          int32
	Fpoly_mode          int32
	Fdither             TAtom
	Fcomponent_alpha    int32
}

type T_XRenderPictureAttributes = TXRenderPictureAttributes

type TXRenderColor = struct {
	Fred   uint16
	Fgreen uint16
	Fblue  uint16
	Falpha uint16
}

type TXGlyphInfo = struct {
	Fwidth  uint16
	Fheight uint16
	Fx      int16
	Fy      int16
	FxOff   int16
	FyOff   int16
}

type T_XGlyphInfo = TXGlyphInfo

type TXGlyphElt8 = struct {
	Fglyphset TGlyphSet
	Fchars    uintptr
	Fnchars   int32
	FxOff     int32
	FyOff     int32
}

type T_XGlyphElt8 = TXGlyphElt8

type TXGlyphElt16 = struct {
	Fglyphset TGlyphSet
	Fchars    uintptr
	Fnchars   int32
	FxOff     int32
	FyOff     int32
}

type T_XGlyphElt16 = TXGlyphElt16

type TXGlyphElt32 = struct {
	Fglyphset TGlyphSet
	Fchars    uintptr
	Fnchars   int32
	FxOff     int32
	FyOff     int32
}

type T_XGlyphElt32 = TXGlyphElt32

type TXDouble = float64

type TXPointDouble = struct {
	Fx TXDouble
	Fy TXDouble
}

type T_XPointDouble = TXPointDouble

type TXFixed = int32

type TXPointFixed = struct {
	Fx TXFixed
	Fy TXFixed
}

type T_XPointFixed = TXPointFixed

type TXLineFixed = struct {
	Fp1 TXPointFixed
	Fp2 TXPointFixed
}

type T_XLineFixed = TXLineFixed

type TXTriangle = struct {
	Fp1 TXPointFixed
	Fp2 TXPointFixed
	Fp3 TXPointFixed
}

type T_XTriangle = TXTriangle

type TXCircle = struct {
	Fx      TXFixed
	Fy      TXFixed
	Fradius TXFixed
}

type T_XCircle = TXCircle

type TXTrapezoid = struct {
	Ftop    TXFixed
	Fbottom TXFixed
	Fleft   TXLineFixed
	Fright  TXLineFixed
}

type T_XTrapezoid = TXTrapezoid

type TXTransform = struct {
	Fmatrix [3][3]TXFixed
}

type T_XTransform = TXTransform

type TXFilters = struct {
	Fnfilter int32
	Ffilter  uintptr
	Fnalias  int32
	Falias   uintptr
}

type T_XFilters = TXFilters

type TXIndexValue = struct {
	Fpixel uint64
	Fred   uint16
	Fgreen uint16
	Fblue  uint16
	Falpha uint16
}

type T_XIndexValue = TXIndexValue

type TXAnimCursor = struct {
	Fcursor TCursor
	Fdelay  uint64
}

type T_XAnimCursor = TXAnimCursor

type TXSpanFix = struct {
	Fleft  TXFixed
	Fright TXFixed
	Fy     TXFixed
}

type T_XSpanFix = TXSpanFix

type TXTrap = struct {
	Ftop    TXSpanFix
	Fbottom TXSpanFix
}

type T_XTrap = TXTrap

type TXLinearGradient = struct {
	Fp1 TXPointFixed
	Fp2 TXPointFixed
}

type T_XLinearGradient = TXLinearGradient

type TXRadialGradient = struct {
	Finner TXCircle
	Fouter TXCircle
}

type T_XRadialGradient = TXRadialGradient

type TXConicalGradient = struct {
	Fcenter TXPointFixed
	Fangle  TXFixed
}

type T_XConicalGradient = TXConicalGradient

type TXftFontInfo = struct {
	Fhash       TFcChar32
	Ffile       uintptr
	Fxsize      TFT_F26Dot6
	Fysize      TFT_F26Dot6
	Fantialias  TFcBool
	Fembolden   TFcBool
	Fcolor      TFcBool
	Frgba       int32
	Flcd_filter int32
	Fmatrix     TFT_Matrix
	Ftransform  TFcBool
	Fload_flags TFT_Int
	Frender     TFcBool
	Fspacing    int32
	Fminspace   TFcBool
	Fchar_width int32
}

type T_XftFontInfo = TXftFontInfo

type TXftFont = struct {
	Fascent            int32
	Fdescent           int32
	Fheight            int32
	Fmax_advance_width int32
	Fcharset           uintptr
	Fpattern           uintptr
}

type T_XftFont = TXftFont

type TXftDraw = struct {
	Fdpy            uintptr
	Fscreen         int32
	Fbits_per_pixel uint32
	Fdepth          uint32
	Fdrawable       TDrawable
	Fvisual         uintptr
	Fcolormap       TColormap
	Fclip_type      TXftClipType
	Fclip           TXftClip
	Fsubwindow_mode int32
	Frender         struct {
		Fpict TPicture
	}
	Fcore struct {
		Fgc         TGC
		Fuse_pixmap int32
	}
}

type T_XftDraw = TXftDraw

type __XftClipType = int32

const _XftClipTypeNone = 0
const _XftClipTypeRegion = 1
const _XftClipTypeRectangles = 2

type TXftColor = struct {
	Fpixel uint64
	Fcolor TXRenderColor
}

type T_XftColor = TXftColor

type TXftCharSpec = struct {
	Fucs4 TFcChar32
	Fx    int16
	Fy    int16
}

type T_XftCharSpec = TXftCharSpec

type TXftCharFontSpec = struct {
	Ffont uintptr
	Fucs4 TFcChar32
	Fx    int16
	Fy    int16
}

type T_XftCharFontSpec = TXftCharFontSpec

type TXftGlyphSpec = struct {
	Fglyph TFT_UInt
	Fx     int16
	Fy     int16
}

type T_XftGlyphSpec = TXftGlyphSpec

type TXftGlyphFontSpec = struct {
	Ffont  uintptr
	Fglyph TFT_UInt
	Fx     int16
	Fy     int16
}

type T_XftGlyphFontSpec = TXftGlyphFontSpec

type TXftMatcher = struct {
	Fobject  uintptr
	Fcompare uintptr
}

type T_XftMatcher = TXftMatcher

type TXftSymbolic = struct {
	Fname  uintptr
	Fvalue int32
}

type T_XftSymbolic = TXftSymbolic

type TXftGlyph = struct {
	Fmetrics      TXGlyphInfo
	Fbitmap       uintptr
	Fglyph_memory uint64
	Fpicture      TPicture
}

type T_XftGlyph = TXftGlyph

type TXftGlyphUsage = struct {
	Fcontents TXftGlyph
	Fnewer    TFT_UInt
	Folder    TFT_UInt
}

type T_XftGlyphUsage = TXftGlyphUsage

type TXftUcsHash = struct {
	Fucs4  TFcChar32
	Fglyph TFT_UInt
}

type T_XftUcsHash = TXftUcsHash

type TXftFtFile = struct {
	Fnext   uintptr
	Fref    int32
	Ffile   uintptr
	Fid     int32
	Fxsize  TFT_F26Dot6
	Fysize  TFT_F26Dot6
	Fmatrix TFT_Matrix
	Flock   int32
	Fface   TFT_Face
}

type T_XftFtFile = TXftFtFile

type TXftFontInt = struct {
	Fpublic           TXftFont
	Fnext             uintptr
	Fhash_next        uintptr
	Finfo             TXftFontInfo
	Fref              int32
	Fglyphs           uintptr
	Fnum_glyphs       TFT_UInt
	Fhash_table       uintptr
	Fhash_value       int32
	Frehash_value     int32
	Fglyphset         TGlyphSet
	Fformat           uintptr
	Fglyph_memory     uint64
	Fmax_glyph_memory uint64
	Fsizeof_glyph     uint32
	Fnewest           TFT_UInt
	Ftotal_inuse      TFT_UInt
	Ftrack_mem_usage  TFcBool
	Fuse_free_glyphs  TFcBool
}

type T_XftFontInt = TXftFontInt

type TXftClipType = int32

type TXftClipRect = struct {
	FxOrigin int32
	FyOrigin int32
	Fn       int32
}

type T_XftClipRect = TXftClipRect

type TXftClip = struct {
	Fregion [0]TRegion
	Frect   uintptr
}

type T_XftClip = TXftClip

type TXftSolidColor = struct {
	Fcolor  TXRenderColor
	Fscreen int32
	Fpict   TPicture
}

type T_XftSolidColor = TXftSolidColor

type TXftDisplayInfo = struct {
	Fnext             uintptr
	Fdisplay          uintptr
	Fcodes            uintptr
	Fdefaults         uintptr
	FhasRender        TFcBool
	FhasSolid         TFcBool
	Ffonts            uintptr
	FsolidFormat      uintptr
	Fglyph_memory     uint64
	Fmax_glyph_memory uint64
	Ftrack_mem_usage  TFcBool
	Fuse_free_glyphs  TFcBool
	Fnum_unref_fonts  int32
	Fmax_unref_fonts  int32
	Fcolors           [16]TXftSolidColor
	FfontHash         [127]uintptr
}

type T_XftDisplayInfo = TXftDisplayInfo

type TXFT_MEM_KIND = int32

const _XFT_MEM_DRAW = 0
const _XFT_MEM_FONT = 1
const _XFT_MEM_FILE = 2
const _XFT_MEM_GLYPH = 3
const _XFT_MEM_NUM = 4

/* xftxlfd.c */
func XXftColorAllocName(tls *libc.TLS, dpy uintptr, visual uintptr, cmap TColormap, name uintptr, result uintptr) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* exact at bp+16 */ TXColor
	var _ /* screen at bp+0 */ TXColor
	if !(libx11.XXAllocNamedColor(tls, dpy, cmap, name, bp, bp+16) != 0) {
		/* XXX stick standard colormap stuff here */
		return m_False
	}
	(*TXftColor)(unsafe.Pointer(result)).Fpixel = (*(*TXColor)(unsafe.Pointer(bp))).Fpixel
	(*TXftColor)(unsafe.Pointer(result)).Fcolor.Fred = (*(*TXColor)(unsafe.Pointer(bp + 16))).Fred
	(*TXftColor)(unsafe.Pointer(result)).Fcolor.Fgreen = (*(*TXColor)(unsafe.Pointer(bp + 16))).Fgreen
	(*TXftColor)(unsafe.Pointer(result)).Fcolor.Fblue = (*(*TXColor)(unsafe.Pointer(bp + 16))).Fblue
	(*TXftColor)(unsafe.Pointer(result)).Fcolor.Falpha = uint16(0xffff)
	return int32(m_True)
}

func _maskbase(tls *libc.TLS, m uint64) (r int16) {
	var i int16
	_ = i
	if !(m != 0) {
		return 0
	}
	i = 0
	for !(m&libc.Uint64FromInt32(1) != 0) {
		m >>= uint64(1)
		i++
	}
	return i
}

func _masklen(tls *libc.TLS, m uint64) (r int16) {
	var y uint64
	_ = y
	y = m >> int32(1) & uint64(033333333333)
	y = m - y - y>>int32(1)&uint64(033333333333)
	return int16((y + y>>libc.Int32FromInt32(3)) & libc.Uint64FromUint32(030707070707) % libc.Uint64FromInt32(077))
}

func XXftColorAllocValue(tls *libc.TLS, dpy uintptr, visual uintptr, cmap TColormap, color uintptr, result uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var blue_len, blue_shift, green_len, green_shift, red_len, red_shift int32
	var _ /* xcolor at bp+0 */ TXColor
	_, _, _, _, _, _ = blue_len, blue_shift, green_len, green_shift, red_len, red_shift
	if (*TVisual)(unsafe.Pointer(visual)).Fclass == int32(m_TrueColor) {
		red_shift = int32(_maskbase(tls, (*TVisual)(unsafe.Pointer(visual)).Fred_mask))
		red_len = int32(_masklen(tls, (*TVisual)(unsafe.Pointer(visual)).Fred_mask))
		green_shift = int32(_maskbase(tls, (*TVisual)(unsafe.Pointer(visual)).Fgreen_mask))
		green_len = int32(_masklen(tls, (*TVisual)(unsafe.Pointer(visual)).Fgreen_mask))
		blue_shift = int32(_maskbase(tls, (*TVisual)(unsafe.Pointer(visual)).Fblue_mask))
		blue_len = int32(_masklen(tls, (*TVisual)(unsafe.Pointer(visual)).Fblue_mask))
		(*TXftColor)(unsafe.Pointer(result)).Fpixel = uint64(int32((*TXRenderColor)(unsafe.Pointer(color)).Fred)>>(libc.Int32FromInt32(16)-red_len)<<red_shift | int32((*TXRenderColor)(unsafe.Pointer(color)).Fgreen)>>(libc.Int32FromInt32(16)-green_len)<<green_shift | int32((*TXRenderColor)(unsafe.Pointer(color)).Fblue)>>(libc.Int32FromInt32(16)-blue_len)<<blue_shift)
	} else {
		(*(*TXColor)(unsafe.Pointer(bp))).Fred = (*TXRenderColor)(unsafe.Pointer(color)).Fred
		(*(*TXColor)(unsafe.Pointer(bp))).Fgreen = (*TXRenderColor)(unsafe.Pointer(color)).Fgreen
		(*(*TXColor)(unsafe.Pointer(bp))).Fblue = (*TXRenderColor)(unsafe.Pointer(color)).Fblue
		if !(libx11.XXAllocColor(tls, dpy, cmap, bp) != 0) {
			return m_False
		}
		(*TXftColor)(unsafe.Pointer(result)).Fpixel = (*(*TXColor)(unsafe.Pointer(bp))).Fpixel
	}
	(*TXftColor)(unsafe.Pointer(result)).Fcolor.Fred = (*TXRenderColor)(unsafe.Pointer(color)).Fred
	(*TXftColor)(unsafe.Pointer(result)).Fcolor.Fgreen = (*TXRenderColor)(unsafe.Pointer(color)).Fgreen
	(*TXftColor)(unsafe.Pointer(result)).Fcolor.Fblue = (*TXRenderColor)(unsafe.Pointer(color)).Fblue
	(*TXftColor)(unsafe.Pointer(result)).Fcolor.Falpha = (*TXRenderColor)(unsafe.Pointer(color)).Falpha
	return int32(m_True)
}

func XXftColorFree(tls *libc.TLS, dpy uintptr, visual uintptr, cmap TColormap, color uintptr) {
	if (*TVisual)(unsafe.Pointer(visual)).Fclass != int32(m_TrueColor) {
		libx11.XXFreeColors(tls, dpy, cmap, color, int32(1), uint64(0))
	}
}

type Tfuncs = struct {
	Fcreate_image  uintptr
	Fdestroy_image uintptr
	Fget_pixel     uintptr
	Fput_pixel     uintptr
	Fsub_image     uintptr
	Fadd_pixel     uintptr
}

const m_NUM_LOCAL = 1024

/* xftxlfd.c */
func XXftRectCore(tls *libc.TLS, draw uintptr, color uintptr, x int32, y int32, width uint32, height uint32) {
	if int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Falpha) >= int32(0x8000) {
		libx11.XXSetForeground(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, (*TXftColor)(unsafe.Pointer(color)).Fpixel)
		libx11.XXFillRectangle(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, x, y, width, height)
	}
}

/*
 * Use the core protocol to draw the glyphs
 */

func __XftSharpGlyphMono(tls *libc.TLS, draw uintptr, glyph uintptr, x int32, y int32) {
	var bits, bitsMask uint8
	var height, lenspan, stride, w, width, xspan, v1 int32
	var src, srcLine, v2, v3, v4 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = bits, bitsMask, height, lenspan, src, srcLine, stride, w, width, xspan, v1, v2, v3, v4
	srcLine = (*TXftGlyph)(unsafe.Pointer(glyph)).Fbitmap
	width = int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fwidth)
	stride = (width + int32(31)) & ^libc.Int32FromInt32(31) >> int32(3)
	height = int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fheight)
	x -= int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fx)
	y -= int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fy)
	for {
		v1 = height
		height--
		if !(v1 != 0) {
			break
		}
		src = srcLine
		srcLine += uintptr(stride)
		w = width
		bitsMask = uint8(0x80) /* FreeType is always MSB first */
		v2 = src
		src++
		bits = *(*uint8)(unsafe.Pointer(v2))
		xspan = x
		for w != 0 {
			if int32(bits)&int32(bitsMask) != 0 {
				lenspan = 0
				for cond := true; cond; cond = int32(bits)&int32(bitsMask) != 0 {
					lenspan++
					if lenspan == w {
						break
					}
					bitsMask = uint8(int32(bitsMask) >> int32(1))
					if !(bitsMask != 0) {
						v3 = src
						src++
						bits = *(*uint8)(unsafe.Pointer(v3))
						bitsMask = uint8(0x80)
					}
				}
				libx11.XXFillRectangle(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, xspan, y, uint32(lenspan), uint32(1))
				xspan += lenspan
				w -= lenspan
			} else {
				for cond := true; cond; cond = !(int32(bits)&int32(bitsMask) != 0) {
					w--
					xspan++
					if !(w != 0) {
						break
					}
					bitsMask = uint8(int32(bitsMask) >> int32(1))
					if !(bitsMask != 0) {
						v4 = src
						src++
						bits = *(*uint8)(unsafe.Pointer(v4))
						bitsMask = uint8(0x80)
					}
				}
			}
		}
		y++
	}
}

// C documentation
//
//	/*
//	 * Draw solid color text from an anti-aliased bitmap.  This is a
//	 * fallback for cases where a particular drawable has no AA code
//	 */
func __XftSharpGlyphGray(tls *libc.TLS, draw uintptr, glyph uintptr, x int32, y int32) {
	var bits uint8
	var height, lenspan, stride, w, width, xspan, v1 int32
	var src, srcLine, v2, v3, v4 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _ = bits, height, lenspan, src, srcLine, stride, w, width, xspan, v1, v2, v3, v4
	srcLine = (*TXftGlyph)(unsafe.Pointer(glyph)).Fbitmap
	width = int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fwidth)
	stride = (width + int32(3)) & ^libc.Int32FromInt32(3)
	height = int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fheight)
	x -= int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fx)
	y -= int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fy)
	for {
		v1 = height
		height--
		if !(v1 != 0) {
			break
		}
		src = srcLine
		srcLine += uintptr(stride)
		w = width
		v2 = src
		src++
		bits = *(*uint8)(unsafe.Pointer(v2))
		xspan = x
		for w != 0 {
			if int32(bits) >= int32(0x80) {
				lenspan = 0
				for cond := true; cond; cond = int32(bits) >= int32(0x80) {
					lenspan++
					if lenspan == w {
						break
					}
					v3 = src
					src++
					bits = *(*uint8)(unsafe.Pointer(v3))
				}
				libx11.XXFillRectangle(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, xspan, y, uint32(lenspan), uint32(1))
				xspan += lenspan
				w -= lenspan
			} else {
				for cond := true; cond; cond = int32(bits) < int32(0x80) {
					w--
					xspan++
					if !(w != 0) {
						break
					}
					v4 = src
					src++
					bits = *(*uint8)(unsafe.Pointer(v4))
				}
			}
		}
		y++
	}
}

func __XftSharpGlyphRgba(tls *libc.TLS, draw uintptr, glyph uintptr, x int32, y int32) {
	var bits TCARD32
	var height, lenspan, stride, w, width, xspan, v1 int32
	var src, srcLine, v2, v3, v4 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _ = bits, height, lenspan, src, srcLine, stride, w, width, xspan, v1, v2, v3, v4
	srcLine = (*TXftGlyph)(unsafe.Pointer(glyph)).Fbitmap
	width = int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fwidth)
	stride = (width + int32(3)) & ^libc.Int32FromInt32(3)
	height = int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fheight)
	x -= int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fx)
	y -= int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fy)
	for {
		v1 = height
		height--
		if !(v1 != 0) {
			break
		}
		src = srcLine
		srcLine += uintptr(stride) * 4
		w = width
		v2 = src
		src += 4
		bits = *(*TCARD32)(unsafe.Pointer(v2))
		xspan = x
		for w != 0 {
			if bits >= uint32(0x80000000) {
				lenspan = 0
				for cond := true; cond; cond = bits >= uint32(0x80000000) {
					lenspan++
					if lenspan == w {
						break
					}
					v3 = src
					src += 4
					bits = *(*TCARD32)(unsafe.Pointer(v3))
				}
				libx11.XXFillRectangle(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, xspan, y, uint32(lenspan), uint32(1))
				xspan += lenspan
				w -= lenspan
			} else {
				for cond := true; cond; cond = bits < uint32(0x80000000) {
					w--
					xspan++
					if !(w != 0) {
						break
					}
					v4 = src
					src += 4
					bits = *(*TCARD32)(unsafe.Pointer(v4))
				}
			}
		}
		y++
	}
}

type TXftSharpGlyph = uintptr

func __XftSharpGlyphFind(tls *libc.TLS, draw uintptr, public uintptr) (r TXftSharpGlyph) {
	var font uintptr
	_ = font
	font = public
	if !((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fantialias != 0) {
		return __ccgo_fp(__XftSharpGlyphMono)
	} else {
		switch (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Frgba {
		case int32(m_FC_RGBA_RGB):
			fallthrough
		case int32(m_FC_RGBA_BGR):
			fallthrough
		case int32(m_FC_RGBA_VRGB):
			fallthrough
		case int32(m_FC_RGBA_VBGR):
			return __ccgo_fp(__XftSharpGlyphRgba)
		default:
			return __ccgo_fp(__XftSharpGlyphGray)
		}
	}
	return r
}

/*
 * Draw glyphs to a target that supports anti-aliasing
 */

/*
 * Primitives for converting between RGB values and TrueColor pixels
 */

func __XftExamineBitfield(tls *libc.TLS, mask uint64, shift uintptr, len1 uintptr) {
	var l, s int32
	_, _ = l, s
	s = 0
	for mask&uint64(1) == uint64(0) {
		mask >>= uint64(1)
		s++
	}
	l = 0
	for mask&uint64(1) == uint64(1) {
		mask >>= uint64(1)
		l++
	}
	*(*int32)(unsafe.Pointer(shift)) = s
	*(*int32)(unsafe.Pointer(len1)) = l
}

func __XftGetField(tls *libc.TLS, l_pixel uint64, shift int32, len1 int32) (r TCARD32) {
	var pixel TCARD32
	_ = pixel
	pixel = uint32(l_pixel)
	pixel = pixel & uint32((libc.Int32FromInt32(1)<<len1-libc.Int32FromInt32(1))<<shift)
	pixel = pixel << (int32(32) - (shift + len1)) >> int32(24)
	for len1 < int32(8) {
		pixel |= pixel >> len1
		len1 <<= int32(1)
	}
	return pixel
}

func __XftPutField(tls *libc.TLS, pixel TCARD32, shift int32, len1 int32) (r uint64) {
	var l_pixel uint64
	_ = l_pixel
	l_pixel = uint64(pixel)
	shift = shift - (int32(8) - len1)
	if len1 <= int32(8) {
		l_pixel = l_pixel & uint64((libc.Int32FromInt32(1)<<len1-libc.Int32FromInt32(1))<<(libc.Int32FromInt32(8)-len1))
	}
	if shift < 0 {
		l_pixel >>= uint64(-shift)
	} else {
		l_pixel <<= uint64(shift)
	}
	return l_pixel
}

// C documentation
//
//	/*
//	 * This is used when doing XftCharFontSpec/XftGlyphFontSpec where
//	 * some of the fonts are bitmaps and some are anti-aliased to handle
//	 * the bitmap portions
//	 */
func __XftSmoothGlyphMono(tls *libc.TLS, image uintptr, xftg uintptr, x int32, y int32, color uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var bits, bitsMask uint8
	var height, stride, w, width, xspan, v1, v3 int32
	var pixel uint64
	var src, srcLine, v2, v4 uintptr
	var _ /* b_len at bp+20 */ int32
	var _ /* b_shift at bp+16 */ int32
	var _ /* g_len at bp+12 */ int32
	var _ /* g_shift at bp+8 */ int32
	var _ /* r_len at bp+4 */ int32
	var _ /* r_shift at bp+0 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = bits, bitsMask, height, pixel, src, srcLine, stride, w, width, xspan, v1, v2, v3, v4
	srcLine = (*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap
	width = int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fwidth)
	stride = (width + int32(31)) & ^libc.Int32FromInt32(31) >> int32(3)
	height = int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fheight)
	__XftExamineBitfield(tls, (*TXImage)(unsafe.Pointer(image)).Fred_mask, bp, bp+4)
	__XftExamineBitfield(tls, (*TXImage)(unsafe.Pointer(image)).Fgreen_mask, bp+8, bp+12)
	__XftExamineBitfield(tls, (*TXImage)(unsafe.Pointer(image)).Fblue_mask, bp+16, bp+20)
	pixel = __XftPutField(tls, uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fred)>>int32(8)), *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4))) | __XftPutField(tls, uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fgreen)>>int32(8)), *(*int32)(unsafe.Pointer(bp + 8)), *(*int32)(unsafe.Pointer(bp + 12))) | __XftPutField(tls, uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fblue)>>int32(8)), *(*int32)(unsafe.Pointer(bp + 16)), *(*int32)(unsafe.Pointer(bp + 20)))
	x -= int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fx)
	y -= int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fy)
	for {
		v1 = height
		height--
		if !(v1 != 0) {
			break
		}
		src = srcLine
		srcLine += uintptr(stride)
		w = width
		bitsMask = uint8(0x80) /* FreeType is always MSB first */
		v2 = src
		src++
		bits = *(*uint8)(unsafe.Pointer(v2))
		xspan = x
		for {
			v3 = w
			w--
			if !(v3 != 0) {
				break
			}
			if int32(bits)&int32(bitsMask) != 0 {
				(*(*func(*libc.TLS, uintptr, int32, int32, uint64) int32)(unsafe.Pointer(&struct{ uintptr }{(*TXImage)(unsafe.Pointer(image)).Ff.Fput_pixel})))(tls, image, xspan, y, pixel)
			}
			bitsMask = uint8(int32(bitsMask) >> int32(1))
			if !(bitsMask != 0) {
				v4 = src
				src++
				bits = *(*uint8)(unsafe.Pointer(v4))
				bitsMask = uint8(0x80)
			}
			xspan++
		}
		y++
	}
}

/*
 * As simple anti-aliasing is likely to be common, there are three
 * optimized versions for the usual true color pixel formats (888, 565, 555).
 * Other formats are handled by the general case
 */

/*
 * There are two ways of handling alpha -- either as a single unified value or
 * a separate value for each component, hence each macro must have two
 * versions.  The unified alpha version has a 'U' at the end of the name,
 * the component version has a 'C'.  Similarly, functions which deal with
 * this difference will have two versions using the same convention.
 */

func _fbOver24(tls *libc.TLS, x TCARD32, y TCARD32) (r TCARD32) {
	var a, t TCARD16
	var m, n, o TCARD32
	_, _, _, _, _ = a, m, n, o, t
	a = uint16(^x >> libc.Int32FromInt32(24))
	t = uint16(0)
	t = uint16(int32(uint16(uint8(y>>libc.Int32FromInt32(0))))*int32(a) + libc.Int32FromInt32(0x80))
	t = uint16(int32(uint16((int32(t)>>libc.Int32FromInt32(8)+int32(t))>>libc.Int32FromInt32(8))) + int32(uint16(uint8(x>>libc.Int32FromInt32(0)))))
	m = uint32(uint8(int32(t)|(libc.Int32FromInt32(0)-int32(t)>>libc.Int32FromInt32(8)))) << libc.Int32FromInt32(0)
	t = uint16(int32(uint16(uint8(y>>libc.Int32FromInt32(8))))*int32(a) + libc.Int32FromInt32(0x80))
	t = uint16(int32(uint16((int32(t)>>libc.Int32FromInt32(8)+int32(t))>>libc.Int32FromInt32(8))) + int32(uint16(uint8(x>>libc.Int32FromInt32(8)))))
	n = uint32(uint8(int32(t)|(libc.Int32FromInt32(0)-int32(t)>>libc.Int32FromInt32(8)))) << libc.Int32FromInt32(8)
	t = uint16(int32(uint16(uint8(y>>libc.Int32FromInt32(16))))*int32(a) + libc.Int32FromInt32(0x80))
	t = uint16(int32(uint16((int32(t)>>libc.Int32FromInt32(8)+int32(t))>>libc.Int32FromInt32(8))) + int32(uint16(uint8(x>>libc.Int32FromInt32(16)))))
	o = uint32(uint8(int32(t)|(libc.Int32FromInt32(0)-int32(t)>>libc.Int32FromInt32(8)))) << libc.Int32FromInt32(16)
	return m | n | o
}

func _fbIn(tls *libc.TLS, x TCARD32, y TCARD8) (r TCARD32) {
	var a, t TCARD16
	var m, n, o, p TCARD32
	_, _, _, _, _, _ = a, m, n, o, p, t
	a = uint16(y)
	t = uint16(int32(uint16(uint8(x>>libc.Int32FromInt32(0))))*int32(a) + libc.Int32FromInt32(0x80))
	m = uint32((int32(t)>>libc.Int32FromInt32(8)+int32(t))>>libc.Int32FromInt32(8)) << 0
	t = uint16(int32(uint16(uint8(x>>libc.Int32FromInt32(8))))*int32(a) + libc.Int32FromInt32(0x80))
	n = uint32((int32(t)>>libc.Int32FromInt32(8)+int32(t))>>libc.Int32FromInt32(8)) << int32(8)
	t = uint16(int32(uint16(uint8(x>>libc.Int32FromInt32(16))))*int32(a) + libc.Int32FromInt32(0x80))
	o = uint32((int32(t)>>libc.Int32FromInt32(8)+int32(t))>>libc.Int32FromInt32(8)) << int32(16)
	t = uint16(int32(uint16(uint8(x>>libc.Int32FromInt32(24))))*int32(a) + libc.Int32FromInt32(0x80))
	p = uint32((int32(t)>>libc.Int32FromInt32(8)+int32(t))>>libc.Int32FromInt32(8)) << int32(24)
	return m | n | o | p
}

func __XftSmoothGlyphGray8888(tls *libc.TLS, image uintptr, xftg uintptr, x int32, y int32, color uintptr) {
	var b, d, g, r, src, srca TCARD32
	var dst, dstLine, mask, maskLine, v3 uintptr
	var dstStride, height, maskStride, w, width, v1, v2 int32
	var m TCARD8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = b, d, dst, dstLine, dstStride, g, height, m, mask, maskLine, maskStride, r, src, srca, w, width, v1, v2, v3
	srca = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Falpha) >> int32(8))
	/* This handles only RGB and BGR */
	g = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fgreen) & libc.Int32FromInt32(0xff00))
	if (*TXImage)(unsafe.Pointer(image)).Fred_mask == uint64(0xff0000) {
		r = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fred) & int32(0xff00) << int32(8))
		b = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fblue) >> int32(8))
	} else {
		r = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fred) >> int32(8))
		b = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fblue) & int32(0xff00) << int32(8))
	}
	src = srca<<libc.Int32FromInt32(24) | r | g | b
	width = int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fwidth)
	height = int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fheight)
	x -= int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fx)
	y -= int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fy)
	dstLine = (*TXImage)(unsafe.Pointer(image)).Fdata + uintptr((*TXImage)(unsafe.Pointer(image)).Fbytes_per_line*y) + uintptr(x<<libc.Int32FromInt32(2))
	dstStride = (*TXImage)(unsafe.Pointer(image)).Fbytes_per_line >> int32(2)
	maskLine = (*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap
	maskStride = (width + int32(3)) & ^libc.Int32FromInt32(3)
	for {
		v1 = height
		height--
		if !(v1 != 0) {
			break
		}
		dst = dstLine
		dstLine += uintptr(dstStride) * 4
		mask = maskLine
		maskLine += uintptr(maskStride)
		w = width
		for {
			v2 = w
			w--
			if !(v2 != 0) {
				break
			}
			v3 = mask
			mask++
			m = *(*TCARD8)(unsafe.Pointer(v3))
			if int32(m) == int32(0xff) {
				if srca == uint32(0xff) {
					*(*TCARD32)(unsafe.Pointer(dst)) = src
				} else {
					*(*TCARD32)(unsafe.Pointer(dst)) = _fbOver24(tls, src, *(*TCARD32)(unsafe.Pointer(dst)))
				}
			} else {
				if m != 0 {
					d = _fbIn(tls, src, m)
					*(*TCARD32)(unsafe.Pointer(dst)) = _fbOver24(tls, d, *(*TCARD32)(unsafe.Pointer(dst)))
				}
			}
			dst += 4
		}
	}
}

func __XftSmoothGlyphGray565(tls *libc.TLS, image uintptr, xftg uintptr, x int32, y int32, color uintptr) {
	var b, d, g, r, src, srca TCARD32
	var dst, dstLine, mask, maskLine, v3 uintptr
	var dstStride, height, maskStride, w, width, v1, v2 int32
	var m TCARD8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = b, d, dst, dstLine, dstStride, g, height, m, mask, maskLine, maskStride, r, src, srca, w, width, v1, v2, v3
	srca = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Falpha) >> int32(8))
	/* This handles only RGB and BGR */
	g = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fgreen) & libc.Int32FromInt32(0xff00))
	if (*TXImage)(unsafe.Pointer(image)).Fred_mask == uint64(0xf800) {
		r = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fred) & int32(0xff00) << int32(8))
		b = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fblue) >> int32(8))
	} else {
		r = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fred) >> int32(8))
		b = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fblue) & int32(0xff00) << int32(8))
	}
	src = srca<<libc.Int32FromInt32(24) | r | g | b
	width = int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fwidth)
	height = int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fheight)
	x -= int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fx)
	y -= int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fy)
	dstLine = (*TXImage)(unsafe.Pointer(image)).Fdata + uintptr((*TXImage)(unsafe.Pointer(image)).Fbytes_per_line*y) + uintptr(x<<libc.Int32FromInt32(1))
	dstStride = (*TXImage)(unsafe.Pointer(image)).Fbytes_per_line >> int32(1)
	maskLine = (*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap
	maskStride = (width + int32(3)) & ^libc.Int32FromInt32(3)
	for {
		v1 = height
		height--
		if !(v1 != 0) {
			break
		}
		dst = dstLine
		dstLine += uintptr(dstStride) * 2
		mask = maskLine
		maskLine += uintptr(maskStride)
		w = width
		for {
			v2 = w
			w--
			if !(v2 != 0) {
				break
			}
			v3 = mask
			mask++
			m = *(*TCARD8)(unsafe.Pointer(v3))
			if int32(m) == int32(0xff) {
				if srca == uint32(0xff) {
					d = src
				} else {
					d = uint32(*(*TCARD16)(unsafe.Pointer(dst)))
					d = _fbOver24(tls, src, d<<libc.Int32FromInt32(3)&libc.Uint32FromInt32(0xf8)|d>>libc.Int32FromInt32(2)&libc.Uint32FromInt32(0x7)|(d<<libc.Int32FromInt32(5)&libc.Uint32FromInt32(0xfc00)|d>>libc.Int32FromInt32(1)&libc.Uint32FromInt32(0x300))|(d<<libc.Int32FromInt32(8)&libc.Uint32FromInt32(0xf80000)|d<<libc.Int32FromInt32(3)&libc.Uint32FromInt32(0x70000)))
				}
				*(*TCARD16)(unsafe.Pointer(dst)) = uint16(d>>libc.Int32FromInt32(3)&libc.Uint32FromInt32(0x001f) | d>>libc.Int32FromInt32(5)&libc.Uint32FromInt32(0x07e0) | d>>libc.Int32FromInt32(8)&libc.Uint32FromInt32(0xf800))
			} else {
				if m != 0 {
					d = uint32(*(*TCARD16)(unsafe.Pointer(dst)))
					d = _fbOver24(tls, _fbIn(tls, src, m), d<<libc.Int32FromInt32(3)&libc.Uint32FromInt32(0xf8)|d>>libc.Int32FromInt32(2)&libc.Uint32FromInt32(0x7)|(d<<libc.Int32FromInt32(5)&libc.Uint32FromInt32(0xfc00)|d>>libc.Int32FromInt32(1)&libc.Uint32FromInt32(0x300))|(d<<libc.Int32FromInt32(8)&libc.Uint32FromInt32(0xf80000)|d<<libc.Int32FromInt32(3)&libc.Uint32FromInt32(0x70000)))
					*(*TCARD16)(unsafe.Pointer(dst)) = uint16(d>>libc.Int32FromInt32(3)&libc.Uint32FromInt32(0x001f) | d>>libc.Int32FromInt32(5)&libc.Uint32FromInt32(0x07e0) | d>>libc.Int32FromInt32(8)&libc.Uint32FromInt32(0xf800))
				}
			}
			dst += 2
		}
	}
}

func __XftSmoothGlyphGray555(tls *libc.TLS, image uintptr, xftg uintptr, x int32, y int32, color uintptr) {
	var b, d, g, r, src, srca TCARD32
	var dst, dstLine, mask, maskLine, v3 uintptr
	var dstStride, height, maskStride, w, width, v1, v2 int32
	var m TCARD8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = b, d, dst, dstLine, dstStride, g, height, m, mask, maskLine, maskStride, r, src, srca, w, width, v1, v2, v3
	srca = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Falpha) >> int32(8))
	/* This handles only RGB and BGR */
	g = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fgreen) & libc.Int32FromInt32(0xff00))
	if (*TXImage)(unsafe.Pointer(image)).Fred_mask == uint64(0xf800) {
		r = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fred) & int32(0xff00) << int32(8))
		b = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fblue) >> int32(8))
	} else {
		r = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fred) >> int32(8))
		b = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fblue) & int32(0xff00) << int32(8))
	}
	src = srca<<libc.Int32FromInt32(24) | r | g | b
	width = int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fwidth)
	height = int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fheight)
	x -= int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fx)
	y -= int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fy)
	dstLine = (*TXImage)(unsafe.Pointer(image)).Fdata + uintptr((*TXImage)(unsafe.Pointer(image)).Fbytes_per_line*y) + uintptr(x<<libc.Int32FromInt32(1))
	dstStride = (*TXImage)(unsafe.Pointer(image)).Fbytes_per_line >> int32(1)
	maskLine = (*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap
	maskStride = (width + int32(3)) & ^libc.Int32FromInt32(3)
	for {
		v1 = height
		height--
		if !(v1 != 0) {
			break
		}
		dst = dstLine
		dstLine += uintptr(dstStride) * 2
		mask = maskLine
		maskLine += uintptr(maskStride)
		w = width
		for {
			v2 = w
			w--
			if !(v2 != 0) {
				break
			}
			v3 = mask
			mask++
			m = *(*TCARD8)(unsafe.Pointer(v3))
			if int32(m) == int32(0xff) {
				if srca == uint32(0xff) {
					d = src
				} else {
					d = uint32(*(*TCARD16)(unsafe.Pointer(dst)))
					d = _fbOver24(tls, src, d<<libc.Int32FromInt32(3)&libc.Uint32FromInt32(0xf8)|d>>libc.Int32FromInt32(2)&libc.Uint32FromInt32(0x7)|(d<<libc.Int32FromInt32(6)&libc.Uint32FromInt32(0xf800)|d>>libc.Int32FromInt32(0)&libc.Uint32FromInt32(0x300))|(d<<libc.Int32FromInt32(9)&libc.Uint32FromInt32(0xf80000)|d<<libc.Int32FromInt32(4)&libc.Uint32FromInt32(0x70000)))
				}
				*(*TCARD16)(unsafe.Pointer(dst)) = uint16(d>>libc.Int32FromInt32(3)&libc.Uint32FromInt32(0x001f) | d>>libc.Int32FromInt32(6)&libc.Uint32FromInt32(0x03e0) | d>>libc.Int32FromInt32(7)&libc.Uint32FromInt32(0x7c00))
			} else {
				if m != 0 {
					d = uint32(*(*TCARD16)(unsafe.Pointer(dst)))
					d = _fbOver24(tls, _fbIn(tls, src, m), d<<libc.Int32FromInt32(3)&libc.Uint32FromInt32(0xf8)|d>>libc.Int32FromInt32(2)&libc.Uint32FromInt32(0x7)|(d<<libc.Int32FromInt32(6)&libc.Uint32FromInt32(0xf800)|d>>libc.Int32FromInt32(0)&libc.Uint32FromInt32(0x300))|(d<<libc.Int32FromInt32(9)&libc.Uint32FromInt32(0xf80000)|d<<libc.Int32FromInt32(4)&libc.Uint32FromInt32(0x70000)))
					*(*TCARD16)(unsafe.Pointer(dst)) = uint16(d>>libc.Int32FromInt32(3)&libc.Uint32FromInt32(0x001f) | d>>libc.Int32FromInt32(6)&libc.Uint32FromInt32(0x03e0) | d>>libc.Int32FromInt32(7)&libc.Uint32FromInt32(0x7c00))
				}
			}
			dst += 2
		}
	}
}

func __XftSmoothGlyphGray(tls *libc.TLS, image uintptr, xftg uintptr, x int32, y int32, color uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var d, src, srca TCARD32
	var height, maskStride, tx, w, width, v1, v2 int32
	var m TCARD8
	var mask, maskLine, v3 uintptr
	var pixel uint64
	var _ /* b_len at bp+20 */ int32
	var _ /* b_shift at bp+16 */ int32
	var _ /* g_len at bp+12 */ int32
	var _ /* g_shift at bp+8 */ int32
	var _ /* r_len at bp+4 */ int32
	var _ /* r_shift at bp+0 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = d, height, m, mask, maskLine, maskStride, pixel, src, srca, tx, w, width, v1, v2, v3
	srca = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Falpha) >> int32(8))
	src = srca<<libc.Int32FromInt32(24) | uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fred)&libc.Int32FromInt32(0xff00)<<libc.Int32FromInt32(8)) | uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fgreen)&libc.Int32FromInt32(0xff00)) | uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fblue)>>libc.Int32FromInt32(8))
	x -= int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fx)
	y -= int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fy)
	width = int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fwidth)
	height = int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fheight)
	maskLine = (*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap
	maskStride = (width + int32(3)) & ^libc.Int32FromInt32(3)
	__XftExamineBitfield(tls, (*TXImage)(unsafe.Pointer(image)).Fred_mask, bp, bp+4)
	__XftExamineBitfield(tls, (*TXImage)(unsafe.Pointer(image)).Fgreen_mask, bp+8, bp+12)
	__XftExamineBitfield(tls, (*TXImage)(unsafe.Pointer(image)).Fblue_mask, bp+16, bp+20)
	for {
		v1 = height
		height--
		if !(v1 != 0) {
			break
		}
		mask = maskLine
		maskLine += uintptr(maskStride)
		w = width
		tx = x
		for {
			v2 = w
			w--
			if !(v2 != 0) {
				break
			}
			v3 = mask
			mask++
			m = *(*TCARD8)(unsafe.Pointer(v3))
			if int32(m) == int32(0xff) {
				if srca == uint32(0xff) {
					d = src
				} else {
					pixel = (*(*func(*libc.TLS, uintptr, int32, int32) uint64)(unsafe.Pointer(&struct{ uintptr }{(*TXImage)(unsafe.Pointer(image)).Ff.Fget_pixel})))(tls, image, tx, y)
					d = __XftGetField(tls, pixel, *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)))<<libc.Int32FromInt32(16) | __XftGetField(tls, pixel, *(*int32)(unsafe.Pointer(bp + 8)), *(*int32)(unsafe.Pointer(bp + 12)))<<libc.Int32FromInt32(8) | __XftGetField(tls, pixel, *(*int32)(unsafe.Pointer(bp + 16)), *(*int32)(unsafe.Pointer(bp + 20)))
					d = _fbOver24(tls, src, d)
				}
				pixel = __XftPutField(tls, d>>libc.Int32FromInt32(16)&uint32(0xff), *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4))) | __XftPutField(tls, d>>libc.Int32FromInt32(8)&uint32(0xff), *(*int32)(unsafe.Pointer(bp + 8)), *(*int32)(unsafe.Pointer(bp + 12))) | __XftPutField(tls, d&uint32(0xff), *(*int32)(unsafe.Pointer(bp + 16)), *(*int32)(unsafe.Pointer(bp + 20)))
				(*(*func(*libc.TLS, uintptr, int32, int32, uint64) int32)(unsafe.Pointer(&struct{ uintptr }{(*TXImage)(unsafe.Pointer(image)).Ff.Fput_pixel})))(tls, image, tx, y, pixel)
			} else {
				if m != 0 {
					pixel = (*(*func(*libc.TLS, uintptr, int32, int32) uint64)(unsafe.Pointer(&struct{ uintptr }{(*TXImage)(unsafe.Pointer(image)).Ff.Fget_pixel})))(tls, image, tx, y)
					d = __XftGetField(tls, pixel, *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)))<<libc.Int32FromInt32(16) | __XftGetField(tls, pixel, *(*int32)(unsafe.Pointer(bp + 8)), *(*int32)(unsafe.Pointer(bp + 12)))<<libc.Int32FromInt32(8) | __XftGetField(tls, pixel, *(*int32)(unsafe.Pointer(bp + 16)), *(*int32)(unsafe.Pointer(bp + 20)))
					d = _fbOver24(tls, _fbIn(tls, src, m), d)
					pixel = __XftPutField(tls, d>>libc.Int32FromInt32(16)&uint32(0xff), *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4))) | __XftPutField(tls, d>>libc.Int32FromInt32(8)&uint32(0xff), *(*int32)(unsafe.Pointer(bp + 8)), *(*int32)(unsafe.Pointer(bp + 12))) | __XftPutField(tls, d&uint32(0xff), *(*int32)(unsafe.Pointer(bp + 16)), *(*int32)(unsafe.Pointer(bp + 20)))
					(*(*func(*libc.TLS, uintptr, int32, int32, uint64) int32)(unsafe.Pointer(&struct{ uintptr }{(*TXImage)(unsafe.Pointer(image)).Ff.Fput_pixel})))(tls, image, tx, y, pixel)
				}
			}
			tx++
		}
		y++
	}
}

func __XftSmoothGlyphRgba(tls *libc.TLS, image uintptr, xftg uintptr, x int32, y int32, color uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var __a, __a1, __a2 TCARD16
	var __i, __i1, __i2, __t, __t1, __t2, __ta, __ta1, __ta2, d, m, ma, n, o, src, srca TCARD32
	var height, tx, w, width, v1, v2 int32
	var mask, v3 uintptr
	var pixel uint64
	var _ /* b_len at bp+20 */ int32
	var _ /* b_shift at bp+16 */ int32
	var _ /* g_len at bp+12 */ int32
	var _ /* g_shift at bp+8 */ int32
	var _ /* r_len at bp+4 */ int32
	var _ /* r_shift at bp+0 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = __a, __a1, __a2, __i, __i1, __i2, __t, __t1, __t2, __ta, __ta1, __ta2, d, height, m, ma, mask, n, o, pixel, src, srca, tx, w, width, v1, v2, v3
	srca = uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Falpha) >> int32(8))
	src = srca<<libc.Int32FromInt32(24) | uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fred)&libc.Int32FromInt32(0xff00)<<libc.Int32FromInt32(8)) | uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fgreen)&libc.Int32FromInt32(0xff00)) | uint32(int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Fblue)>>libc.Int32FromInt32(8))
	x -= int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fx)
	y -= int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fy)
	width = int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fwidth)
	height = int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fheight)
	mask = (*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap
	__XftExamineBitfield(tls, (*TXImage)(unsafe.Pointer(image)).Fred_mask, bp, bp+4)
	__XftExamineBitfield(tls, (*TXImage)(unsafe.Pointer(image)).Fgreen_mask, bp+8, bp+12)
	__XftExamineBitfield(tls, (*TXImage)(unsafe.Pointer(image)).Fblue_mask, bp+16, bp+20)
	for {
		v1 = height
		height--
		if !(v1 != 0) {
			break
		}
		w = width
		tx = x
		for {
			v2 = w
			w--
			if !(v2 != 0) {
				break
			}
			v3 = mask
			mask += 4
			ma = *(*TCARD32)(unsafe.Pointer(v3))
			if ma == uint32(0xffffffff) {
				if srca == uint32(0xff) {
					d = src
				} else {
					pixel = (*(*func(*libc.TLS, uintptr, int32, int32) uint64)(unsafe.Pointer(&struct{ uintptr }{(*TXImage)(unsafe.Pointer(image)).Ff.Fget_pixel})))(tls, image, tx, y)
					d = __XftGetField(tls, pixel, *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)))<<libc.Int32FromInt32(16) | __XftGetField(tls, pixel, *(*int32)(unsafe.Pointer(bp + 8)), *(*int32)(unsafe.Pointer(bp + 12)))<<libc.Int32FromInt32(8) | __XftGetField(tls, pixel, *(*int32)(unsafe.Pointer(bp + 16)), *(*int32)(unsafe.Pointer(bp + 20)))
					d = _fbOver24(tls, src, d)
				}
				pixel = __XftPutField(tls, d>>libc.Int32FromInt32(16)&uint32(0xff), *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4))) | __XftPutField(tls, d>>libc.Int32FromInt32(8)&uint32(0xff), *(*int32)(unsafe.Pointer(bp + 8)), *(*int32)(unsafe.Pointer(bp + 12))) | __XftPutField(tls, d&uint32(0xff), *(*int32)(unsafe.Pointer(bp + 16)), *(*int32)(unsafe.Pointer(bp + 20)))
				(*(*func(*libc.TLS, uintptr, int32, int32, uint64) int32)(unsafe.Pointer(&struct{ uintptr }{(*TXImage)(unsafe.Pointer(image)).Ff.Fput_pixel})))(tls, image, tx, y, pixel)
			} else {
				if ma != 0 {
					pixel = (*(*func(*libc.TLS, uintptr, int32, int32) uint64)(unsafe.Pointer(&struct{ uintptr }{(*TXImage)(unsafe.Pointer(image)).Ff.Fget_pixel})))(tls, image, tx, y)
					d = __XftGetField(tls, pixel, *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)))<<libc.Int32FromInt32(16) | __XftGetField(tls, pixel, *(*int32)(unsafe.Pointer(bp + 8)), *(*int32)(unsafe.Pointer(bp + 12)))<<libc.Int32FromInt32(8) | __XftGetField(tls, pixel, *(*int32)(unsafe.Pointer(bp + 16)), *(*int32)(unsafe.Pointer(bp + 20)))
					__a = uint16(uint8(ma >> libc.Int32FromInt32(0)))
					__i = uint32(int32(uint16(uint8(src>>libc.Int32FromInt32(0))))*int32(__a) + libc.Int32FromInt32(0x80))
					__t = (__i>>libc.Int32FromInt32(8) + __i) >> libc.Int32FromInt32(8)
					__i = srca*uint32(__a) + libc.Uint32FromInt32(0x80)
					__ta = uint32(uint8(^((__i>>libc.Int32FromInt32(8) + __i) >> libc.Int32FromInt32(8))))
					__i = uint32(uint16(uint8(d>>libc.Int32FromInt32(0))))*__ta + libc.Uint32FromInt32(0x80)
					__t = __t + (__i>>libc.Int32FromInt32(8)+__i)>>libc.Int32FromInt32(8)
					__t = uint32(uint8(__t | -(__t >> libc.Int32FromInt32(8))))
					m = __t << 0
					__a1 = uint16(uint8(ma >> libc.Int32FromInt32(8)))
					__i1 = uint32(int32(uint16(uint8(src>>libc.Int32FromInt32(8))))*int32(__a1) + libc.Int32FromInt32(0x80))
					__t1 = (__i1>>libc.Int32FromInt32(8) + __i1) >> libc.Int32FromInt32(8)
					__i1 = srca*uint32(__a1) + libc.Uint32FromInt32(0x80)
					__ta1 = uint32(uint8(^((__i1>>libc.Int32FromInt32(8) + __i1) >> libc.Int32FromInt32(8))))
					__i1 = uint32(uint16(uint8(d>>libc.Int32FromInt32(8))))*__ta1 + libc.Uint32FromInt32(0x80)
					__t1 = __t1 + (__i1>>libc.Int32FromInt32(8)+__i1)>>libc.Int32FromInt32(8)
					__t1 = uint32(uint8(__t1 | -(__t1 >> libc.Int32FromInt32(8))))
					n = __t1 << int32(8)
					__a2 = uint16(uint8(ma >> libc.Int32FromInt32(16)))
					__i2 = uint32(int32(uint16(uint8(src>>libc.Int32FromInt32(16))))*int32(__a2) + libc.Int32FromInt32(0x80))
					__t2 = (__i2>>libc.Int32FromInt32(8) + __i2) >> libc.Int32FromInt32(8)
					__i2 = srca*uint32(__a2) + libc.Uint32FromInt32(0x80)
					__ta2 = uint32(uint8(^((__i2>>libc.Int32FromInt32(8) + __i2) >> libc.Int32FromInt32(8))))
					__i2 = uint32(uint16(uint8(d>>libc.Int32FromInt32(16))))*__ta2 + libc.Uint32FromInt32(0x80)
					__t2 = __t2 + (__i2>>libc.Int32FromInt32(8)+__i2)>>libc.Int32FromInt32(8)
					__t2 = uint32(uint8(__t2 | -(__t2 >> libc.Int32FromInt32(8))))
					o = __t2 << int32(16)
					d = m | n | o
					pixel = __XftPutField(tls, d>>libc.Int32FromInt32(16)&uint32(0xff), *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4))) | __XftPutField(tls, d>>libc.Int32FromInt32(8)&uint32(0xff), *(*int32)(unsafe.Pointer(bp + 8)), *(*int32)(unsafe.Pointer(bp + 12))) | __XftPutField(tls, d&uint32(0xff), *(*int32)(unsafe.Pointer(bp + 16)), *(*int32)(unsafe.Pointer(bp + 20)))
					(*(*func(*libc.TLS, uintptr, int32, int32, uint64) int32)(unsafe.Pointer(&struct{ uintptr }{(*TXImage)(unsafe.Pointer(image)).Ff.Fput_pixel})))(tls, image, tx, y, pixel)
				}
			}
			tx++
		}
		y++
	}
}

func __XftSmoothGlyphPossible(tls *libc.TLS, draw uintptr) (r TFcBool) {
	if !((*TXftDraw)(unsafe.Pointer(draw)).Fvisual != 0) {
		return m_FcFalse
	}
	if (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fclass != int32(m_TrueColor) {
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

type TXftSmoothGlyph = uintptr

func __XftSmoothGlyphFind(tls *libc.TLS, draw uintptr, public uintptr) (r TXftSmoothGlyph) {
	var font uintptr
	_ = font
	font = public
	if !((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fantialias != 0) {
		return __ccgo_fp(__XftSmoothGlyphMono)
	} else {
		switch (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Frgba {
		case int32(m_FC_RGBA_RGB):
			fallthrough
		case int32(m_FC_RGBA_BGR):
			fallthrough
		case int32(m_FC_RGBA_VRGB):
			fallthrough
		case int32(m_FC_RGBA_VBGR):
			return __ccgo_fp(__XftSmoothGlyphRgba)
		default:
			switch XXftDrawBitsPerPixel(tls, draw) {
			case uint32(32):
				if (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fred_mask == uint64(0xff0000) && (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fgreen_mask == uint64(0x00ff00) && (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fblue_mask == uint64(0x0000ff) || (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fred_mask == uint64(0x0000ff) && (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fgreen_mask == uint64(0x00ff00) && (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fblue_mask == uint64(0xff0000) {
					return __ccgo_fp(__XftSmoothGlyphGray8888)
				}
			case uint32(16):
				if (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fred_mask == uint64(0xf800) && (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fgreen_mask == uint64(0x07e0) && (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fblue_mask == uint64(0x001f) || (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fred_mask == uint64(0x001f) && (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fgreen_mask == uint64(0x07e0) && (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fblue_mask == uint64(0xf800) {
					return __ccgo_fp(__XftSmoothGlyphGray565)
				}
				if (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fred_mask == uint64(0x7c00) && (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fgreen_mask == uint64(0x03e0) && (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fblue_mask == uint64(0x001f) || (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fred_mask == uint64(0x001f) && (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fgreen_mask == uint64(0x03e0) && (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fblue_mask == uint64(0x7c00) {
					return __ccgo_fp(__XftSmoothGlyphGray555)
				}
			default:
				break
			}
			return __ccgo_fp(__XftSmoothGlyphGray)
		}
	}
	return r
}

func __XftGlyphDefault(tls *libc.TLS, dpy uintptr, public uintptr) (r uintptr) {
	bp := tls.Alloc(1040)
	defer tls.Free(1040)
	var font uintptr
	var glyphs_loaded TFcBool
	var _ /* missing at bp+0 */ [256]TFT_UInt
	var _ /* nmissing at bp+1024 */ int32
	_, _ = font, glyphs_loaded
	font = public
	glyphs_loaded = m_FcFalse
	if XXftFontCheckGlyph(tls, dpy, public, int32(m_FcTrue), uint32(0), bp, bp+1024) != 0 {
		glyphs_loaded = int32(m_FcTrue)
	}
	if *(*int32)(unsafe.Pointer(bp + 1024)) != 0 {
		XXftFontLoadGlyphs(tls, dpy, public, glyphs_loaded, bp, *(*int32)(unsafe.Pointer(bp + 1024)))
	}
	return *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs))
}

func _XftGetImageErrorHandler(tls *libc.TLS, dpy uintptr, error_event uintptr) (r int32) {
	return 0
}

func XXftGlyphCore(tls *libc.TLS, draw uintptr, color uintptr, public uintptr, x int32, y int32, glyphs uintptr, nglyphs int32) {
	bp := tls.Alloc(1168)
	defer tls.Free(1168)
	var depth, v3 uint32
	var dpy, font, g, image, xftg, v10, v11, v2, v6, v7 uintptr
	var gc TGC
	var glyph TFT_UInt
	var glyphs_loaded TFcBool
	var n, ox, oy, v1, v5, v9 int32
	var pix TPixmap
	var prev_error TXErrorHandler
	var sharp TXftSharpGlyph
	var smooth TXftSmoothGlyph
	var v12, v4, v8 bool
	var _ /* gcv at bp+1040 */ TXGCValues
	var _ /* gi at bp+1028 */ TXGlyphInfo
	var _ /* missing at bp+0 */ [256]TFT_UInt
	var _ /* nmissing at bp+1024 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = depth, dpy, font, g, gc, glyph, glyphs_loaded, image, n, ox, oy, pix, prev_error, sharp, smooth, xftg, v1, v10, v11, v12, v2, v3, v4, v5, v6, v7, v8, v9
	dpy = (*TXftDraw)(unsafe.Pointer(draw)).Fdpy
	font = public
	/*
	 * Load missing glyphs
	 */
	g = glyphs
	n = nglyphs
	*(*int32)(unsafe.Pointer(bp + 1024)) = 0
	glyphs_loaded = m_FcFalse
	for {
		v1 = n
		n--
		if !(v1 != 0) {
			break
		}
		v2 = g
		g += 4
		if XXftFontCheckGlyph(tls, dpy, public, int32(m_FcTrue), *(*TFT_UInt)(unsafe.Pointer(v2)), bp, bp+1024) != 0 {
			glyphs_loaded = int32(m_FcTrue)
		}
	}
	if *(*int32)(unsafe.Pointer(bp + 1024)) != 0 {
		XXftFontLoadGlyphs(tls, dpy, public, int32(m_FcTrue), bp, *(*int32)(unsafe.Pointer(bp + 1024)))
	}
	g = glyphs
	n = nglyphs
	if ((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fantialias != 0 || int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Falpha) != int32(0xffff)) && __XftSmoothGlyphPossible(tls, draw) != 0 {
		smooth = __XftSmoothGlyphFind(tls, draw, public)
		XXftGlyphExtents(tls, dpy, public, glyphs, nglyphs, bp+1028)
		if !((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fwidth != 0) || !((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fheight != 0) {
			goto bail1
		}
		ox = x - int32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fx)
		oy = y - int32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fy)
		/*
		 * Try to get bits directly from the drawable; if that fails,
		 * use a temporary pixmap.  When it does fail, assume it
		 * will probably fail for a while and keep using temporary
		 * pixmaps for a while to avoid double round trips.
		 */
		if (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fuse_pixmap == 0 {
			prev_error = libx11.XXSetErrorHandler(tls, __ccgo_fp(_XftGetImageErrorHandler))
			image = libx11.XXGetImage(tls, dpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, ox, oy, uint32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fwidth), uint32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fheight), uint64(^libc.Int64FromInt64(0)), int32(m_ZPixmap))
			libx11.XXSetErrorHandler(tls, prev_error)
			if !(image != 0) {
				(*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fuse_pixmap = int32(m_XFT_ASSUME_PIXMAP)
			}
		} else {
			(*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fuse_pixmap--
			image = libc.UintptrFromInt32(0)
		}
		if v4 = !(image != 0); v4 {
			v3 = XXftDrawDepth(tls, draw)
			depth = v3
		}
		if v4 && v3 != 0 {
			pix = libx11.XXCreatePixmap(tls, dpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, uint32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fwidth), uint32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fheight), depth)
			(*(*TXGCValues)(unsafe.Pointer(bp + 1040))).Fgraphics_exposures = m_False
			gc = libx11.XXCreateGC(tls, dpy, pix, uint64(libc.Int64FromInt64(1)<<libc.Int32FromInt32(16)), bp+1040)
			libx11.XXCopyArea(tls, dpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, pix, gc, ox, oy, uint32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fwidth), uint32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fheight), 0, 0)
			libx11.XXFreeGC(tls, dpy, gc)
			image = libx11.XXGetImage(tls, dpy, pix, 0, 0, uint32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fwidth), uint32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fheight), uint64(^libc.Int64FromInt64(0)), int32(m_ZPixmap))
			libx11.XXFreePixmap(tls, dpy, pix)
		}
		if !(image != 0) {
			goto bail1
		}
		(*TXImage)(unsafe.Pointer(image)).Fred_mask = (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fred_mask
		(*TXImage)(unsafe.Pointer(image)).Fgreen_mask = (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fgreen_mask
		(*TXImage)(unsafe.Pointer(image)).Fblue_mask = (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fblue_mask
		if (*TXImage)(unsafe.Pointer(image)).Fbyte_order != XXftNativeByteOrder(tls) {
			XXftSwapImage(tls, image)
		}
		for {
			v5 = n
			n--
			if !(v5 != 0) {
				break
			}
			v6 = g
			g += 4
			glyph = *(*TFT_UInt)(unsafe.Pointer(v6))
			if v8 = glyph >= (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs; !v8 {
				v7 = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(glyph)*8))
				xftg = v7
			}
			if v8 || !(v7 != 0) {
				xftg = __XftGlyphDefault(tls, dpy, public)
			}
			if xftg != 0 {
				(*(*func(*libc.TLS, uintptr, uintptr, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{smooth})))(tls, image, xftg, x-ox, y-oy, color)
				x += int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FxOff)
				y += int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FyOff)
			}
		}
		if (*TXImage)(unsafe.Pointer(image)).Fbyte_order != XXftNativeByteOrder(tls) {
			XXftSwapImage(tls, image)
		}
		libx11.XXPutImage(tls, dpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, image, 0, 0, ox, oy, uint32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fwidth), uint32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fheight))
		(*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*TXImage)(unsafe.Pointer(image)).Ff.Fdestroy_image})))(tls, image)
	} else {
		sharp = __XftSharpGlyphFind(tls, draw, public)
		for {
			v9 = n
			n--
			if !(v9 != 0) {
				break
			}
			v10 = g
			g += 4
			glyph = *(*TFT_UInt)(unsafe.Pointer(v10))
			if v12 = glyph >= (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs; !v12 {
				v11 = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(glyph)*8))
				xftg = v11
			}
			if v12 || !(v11 != 0) {
				xftg = __XftGlyphDefault(tls, dpy, public)
			}
			if xftg != 0 {
				(*(*func(*libc.TLS, uintptr, uintptr, int32, int32))(unsafe.Pointer(&struct{ uintptr }{sharp})))(tls, draw, xftg, x, y)
				x += int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FxOff)
				y += int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FyOff)
			}
		}
	}
	goto bail1
bail1:
	;
	if glyphs_loaded != 0 {
		X_XftFontManageMemory(tls, dpy, public)
	}
}

func XXftGlyphSpecCore(tls *libc.TLS, draw uintptr, color uintptr, public uintptr, glyphs uintptr, nglyphs int32) {
	bp := tls.Alloc(1168)
	defer tls.Free(1168)
	var depth, v5 uint32
	var dpy, font, image, xftg, v11, v8 uintptr
	var g_x1, g_x2, g_y1, g_y2, height, i, width, x1, x2, y1, y2, v1, v2, v3 int32
	var gc TGC
	var glyph, glyph1 TFT_UInt
	var glyphs_loaded TFcBool
	var pix TPixmap
	var prev_error TXErrorHandler
	var sharp TXftSharpGlyph
	var smooth TXftSmoothGlyph
	var v12, v6, v9 bool
	var _ /* gcv at bp+1040 */ TXGCValues
	var _ /* gi at bp+1028 */ TXGlyphInfo
	var _ /* missing at bp+0 */ [256]TFT_UInt
	var _ /* nmissing at bp+1024 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = depth, dpy, font, g_x1, g_x2, g_y1, g_y2, gc, glyph, glyph1, glyphs_loaded, height, i, image, pix, prev_error, sharp, smooth, width, x1, x2, xftg, y1, y2, v1, v11, v12, v2, v3, v5, v6, v8, v9
	dpy = (*TXftDraw)(unsafe.Pointer(draw)).Fdpy
	font = public
	/*
	 * Load missing glyphs
	 */
	glyphs_loaded = m_FcFalse
	v3 = libc.Int32FromInt32(0)
	y2 = v3
	v2 = v3
	x2 = v2
	v1 = v2
	y1 = v1
	x1 = v1
	i = 0
	for {
		if !(i < nglyphs) {
			break
		}
		*(*int32)(unsafe.Pointer(bp + 1024)) = 0
		if XXftFontCheckGlyph(tls, dpy, public, int32(m_FcTrue), (*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fglyph, bp, bp+1024) != 0 {
			glyphs_loaded = int32(m_FcTrue)
		}
		if *(*int32)(unsafe.Pointer(bp + 1024)) != 0 {
			XXftFontLoadGlyphs(tls, dpy, public, int32(m_FcTrue), bp, *(*int32)(unsafe.Pointer(bp + 1024)))
		}
		XXftGlyphExtents(tls, dpy, public, glyphs+uintptr(i)*8, int32(1), bp+1028)
		g_x1 = int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fx) - int32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fx)
		g_y1 = int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fy) - int32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fy)
		g_x2 = g_x1 + int32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fwidth)
		g_y2 = g_y1 + int32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fheight)
		if i != 0 {
			if g_x1 < x1 {
				x1 = g_x1
			}
			if g_y1 < y1 {
				y1 = g_y1
			}
			if g_x2 > x2 {
				x2 = g_x2
			}
			if g_y2 > y2 {
				y2 = g_y2
			}
		} else {
			x1 = g_x1
			y1 = g_y1
			x2 = g_x2
			y2 = g_y2
		}
		goto _4
	_4:
		;
		i++
	}
	if x1 == x2 || y1 == y2 {
		goto bail1
	}
	if ((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fantialias != 0 || int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Falpha) != int32(0xffff)) && __XftSmoothGlyphPossible(tls, draw) != 0 {
		width = x2 - x1
		height = y2 - y1
		smooth = __XftSmoothGlyphFind(tls, draw, public)
		/*
		 * Try to get bits directly from the drawable; if that fails,
		 * use a temporary pixmap.  When it does fail, assume it
		 * will probably fail for a while and keep using temporary
		 * pixmaps for a while to avoid double round trips.
		 */
		if (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fuse_pixmap == 0 {
			prev_error = libx11.XXSetErrorHandler(tls, __ccgo_fp(_XftGetImageErrorHandler))
			image = libx11.XXGetImage(tls, dpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, x1, y1, uint32(width), uint32(height), uint64(^libc.Int64FromInt64(0)), int32(m_ZPixmap))
			libx11.XXSetErrorHandler(tls, prev_error)
			if !(image != 0) {
				(*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fuse_pixmap = int32(m_XFT_ASSUME_PIXMAP)
			}
		} else {
			(*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fuse_pixmap--
			image = libc.UintptrFromInt32(0)
		}
		if v6 = !(image != 0); v6 {
			v5 = XXftDrawDepth(tls, draw)
			depth = v5
		}
		if v6 && v5 != 0 {
			pix = libx11.XXCreatePixmap(tls, dpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, uint32(width), uint32(height), depth)
			(*(*TXGCValues)(unsafe.Pointer(bp + 1040))).Fgraphics_exposures = m_False
			gc = libx11.XXCreateGC(tls, dpy, pix, uint64(libc.Int64FromInt64(1)<<libc.Int32FromInt32(16)), bp+1040)
			libx11.XXCopyArea(tls, dpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, pix, gc, x1, y1, uint32(width), uint32(height), 0, 0)
			libx11.XXFreeGC(tls, dpy, gc)
			image = libx11.XXGetImage(tls, dpy, pix, 0, 0, uint32(width), uint32(height), uint64(^libc.Int64FromInt64(0)), int32(m_ZPixmap))
			libx11.XXFreePixmap(tls, dpy, pix)
		}
		if !(image != 0) {
			goto bail1
		}
		(*TXImage)(unsafe.Pointer(image)).Fred_mask = (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fred_mask
		(*TXImage)(unsafe.Pointer(image)).Fgreen_mask = (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fgreen_mask
		(*TXImage)(unsafe.Pointer(image)).Fblue_mask = (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fblue_mask
		if (*TXImage)(unsafe.Pointer(image)).Fbyte_order != XXftNativeByteOrder(tls) {
			XXftSwapImage(tls, image)
		}
		i = 0
		for {
			if !(i < nglyphs) {
				break
			}
			glyph = (*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fglyph
			if v9 = glyph >= (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs; !v9 {
				v8 = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(glyph)*8))
				xftg = v8
			}
			if v9 || !(v8 != 0) {
				xftg = __XftGlyphDefault(tls, dpy, public)
			}
			if xftg != 0 {
				(*(*func(*libc.TLS, uintptr, uintptr, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{smooth})))(tls, image, xftg, int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fx)-x1, int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fy)-y1, color)
			}
			goto _7
		_7:
			;
			i++
		}
		if (*TXImage)(unsafe.Pointer(image)).Fbyte_order != XXftNativeByteOrder(tls) {
			XXftSwapImage(tls, image)
		}
		libx11.XXPutImage(tls, dpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, image, 0, 0, x1, y1, uint32(width), uint32(height))
		(*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*TXImage)(unsafe.Pointer(image)).Ff.Fdestroy_image})))(tls, image)
	} else {
		sharp = __XftSharpGlyphFind(tls, draw, public)
		i = 0
		for {
			if !(i < nglyphs) {
				break
			}
			glyph1 = (*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fglyph
			if v12 = glyph1 >= (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs; !v12 {
				v11 = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(glyph1)*8))
				xftg = v11
			}
			if v12 || !(v11 != 0) {
				xftg = __XftGlyphDefault(tls, dpy, public)
			}
			if xftg != 0 {
				(*(*func(*libc.TLS, uintptr, uintptr, int32, int32))(unsafe.Pointer(&struct{ uintptr }{sharp})))(tls, draw, xftg, int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fx), int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fy))
			}
			goto _10
		_10:
			;
			i++
		}
	}
	goto bail1
bail1:
	;
	if glyphs_loaded != 0 {
		X_XftFontManageMemory(tls, dpy, public)
	}
}

func XXftGlyphFontSpecCore(tls *libc.TLS, draw uintptr, color uintptr, glyphs uintptr, nglyphs int32) {
	bp := tls.Alloc(1168)
	defer tls.Free(1168)
	var depth, v6 uint32
	var dpy, font, font1, image, public, public1, public2, xftg, v12, v9 uintptr
	var g_x1, g_x2, g_y1, g_y2, height, i, width, x1, x2, y1, y2, v1, v2, v3 int32
	var gc TGC
	var glyph, glyph1 TFT_UInt
	var glyphs_loaded TFcBool
	var pix TPixmap
	var prev_error TXErrorHandler
	var sharp TXftSharpGlyph
	var smooth TXftSmoothGlyph
	var t int16
	var v10, v13, v7 bool
	var _ /* gcv at bp+1040 */ TXGCValues
	var _ /* gi at bp+1028 */ TXGlyphInfo
	var _ /* missing at bp+0 */ [256]TFT_UInt
	var _ /* nmissing at bp+1024 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = depth, dpy, font, font1, g_x1, g_x2, g_y1, g_y2, gc, glyph, glyph1, glyphs_loaded, height, i, image, pix, prev_error, public, public1, public2, sharp, smooth, t, width, x1, x2, xftg, y1, y2, v1, v10, v12, v13, v2, v3, v6, v7, v9
	dpy = (*TXftDraw)(unsafe.Pointer(draw)).Fdpy
	/*
	 * Load missing glyphs
	 */
	glyphs_loaded = m_FcFalse
	v3 = libc.Int32FromInt32(0)
	y2 = v3
	v2 = v3
	x2 = v2
	v1 = v2
	y1 = v1
	x1 = v1
	i = 0
	for {
		if !(i < nglyphs) {
			break
		}
		public = (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont
		*(*int32)(unsafe.Pointer(bp + 1024)) = 0
		if XXftFontCheckGlyph(tls, dpy, public, int32(m_FcTrue), (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fglyph, bp, bp+1024) != 0 {
			glyphs_loaded = int32(m_FcTrue)
		}
		if *(*int32)(unsafe.Pointer(bp + 1024)) != 0 {
			XXftFontLoadGlyphs(tls, dpy, public, int32(m_FcTrue), bp, *(*int32)(unsafe.Pointer(bp + 1024)))
		}
		XXftGlyphExtents(tls, dpy, public, glyphs+uintptr(i)*16+8, int32(1), bp+1028)
		g_x1 = int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fx) - int32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fx)
		g_y1 = int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fy) - int32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fy)
		g_x2 = g_x1 + int32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fwidth)
		g_y2 = g_y1 + int32((*(*TXGlyphInfo)(unsafe.Pointer(bp + 1028))).Fheight)
		if i != 0 {
			if g_x1 < x1 {
				if g_x1 < 0 {
					/* do nothing if the given glyphs are out of range */
					t = int16((*TXftFont)(unsafe.Pointer((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i-int32(1))*16))).Ffont)).Fmax_advance_width + int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i-int32(1))*16))).Fx))
					if int32(t) < 0 && int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i-int32(1))*16))).Fx) > 0 {
						goto bail1
					}
				}
				x1 = g_x1
			}
			if g_y1 < y1 {
				y1 = g_y1
			}
			if g_x2 > x2 {
				x2 = g_x2
			}
			if g_y2 > y2 {
				y2 = g_y2
			}
		} else {
			x1 = g_x1
			y1 = g_y1
			x2 = g_x2
			y2 = g_y2
		}
		goto _4
	_4:
		;
		i++
	}
	if x1 == x2 || y1 == y2 {
		goto bail1
	}
	i = 0
	for {
		if !(i < nglyphs) {
			break
		}
		if (*TXftFontInt)(unsafe.Pointer((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont)).Finfo.Fantialias != 0 {
			break
		}
		goto _5
	_5:
		;
		i++
	}
	if (i != nglyphs || int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Falpha) != int32(0xffff)) && __XftSmoothGlyphPossible(tls, draw) != 0 {
		width = x2 - x1
		height = y2 - y1
		/*
		 * Try to get bits directly from the drawable; if that fails,
		 * use a temporary pixmap.  When it does fail, assume it
		 * will probably fail for a while and keep using temporary
		 * pixmaps for a while to avoid double round trips.
		 */
		if (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fuse_pixmap == 0 {
			prev_error = libx11.XXSetErrorHandler(tls, __ccgo_fp(_XftGetImageErrorHandler))
			image = libx11.XXGetImage(tls, dpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, x1, y1, uint32(width), uint32(height), uint64(^libc.Int64FromInt64(0)), int32(m_ZPixmap))
			libx11.XXSetErrorHandler(tls, prev_error)
			if !(image != 0) {
				(*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fuse_pixmap = int32(m_XFT_ASSUME_PIXMAP)
			}
		} else {
			(*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fuse_pixmap--
			image = libc.UintptrFromInt32(0)
		}
		if v7 = !(image != 0); v7 {
			v6 = XXftDrawDepth(tls, draw)
			depth = v6
		}
		if v7 && v6 != 0 {
			pix = libx11.XXCreatePixmap(tls, dpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, uint32(width), uint32(height), depth)
			(*(*TXGCValues)(unsafe.Pointer(bp + 1040))).Fgraphics_exposures = m_False
			gc = libx11.XXCreateGC(tls, dpy, pix, uint64(libc.Int64FromInt64(1)<<libc.Int32FromInt32(16)), bp+1040)
			libx11.XXCopyArea(tls, dpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, pix, gc, x1, y1, uint32(width), uint32(height), 0, 0)
			libx11.XXFreeGC(tls, dpy, gc)
			image = libx11.XXGetImage(tls, dpy, pix, 0, 0, uint32(width), uint32(height), uint64(^libc.Int64FromInt64(0)), int32(m_ZPixmap))
			libx11.XXFreePixmap(tls, dpy, pix)
		}
		if !(image != 0) {
			goto bail1
		}
		(*TXImage)(unsafe.Pointer(image)).Fred_mask = (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fred_mask
		(*TXImage)(unsafe.Pointer(image)).Fgreen_mask = (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fgreen_mask
		(*TXImage)(unsafe.Pointer(image)).Fblue_mask = (*TVisual)(unsafe.Pointer((*TXftDraw)(unsafe.Pointer(draw)).Fvisual)).Fblue_mask
		if (*TXImage)(unsafe.Pointer(image)).Fbyte_order != XXftNativeByteOrder(tls) {
			XXftSwapImage(tls, image)
		}
		i = 0
		for {
			if !(i < nglyphs) {
				break
			}
			public1 = (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont
			font = public1
			smooth = __XftSmoothGlyphFind(tls, draw, public1)
			glyph = (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fglyph
			if v10 = glyph >= (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs; !v10 {
				v9 = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(glyph)*8))
				xftg = v9
			}
			if v10 || !(v9 != 0) {
				xftg = __XftGlyphDefault(tls, dpy, public1)
			}
			if xftg != 0 {
				(*(*func(*libc.TLS, uintptr, uintptr, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{smooth})))(tls, image, xftg, int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fx)-x1, int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fy)-y1, color)
			}
			goto _8
		_8:
			;
			i++
		}
		if (*TXImage)(unsafe.Pointer(image)).Fbyte_order != XXftNativeByteOrder(tls) {
			XXftSwapImage(tls, image)
		}
		libx11.XXPutImage(tls, dpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, image, 0, 0, x1, y1, uint32(width), uint32(height))
		(*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*TXImage)(unsafe.Pointer(image)).Ff.Fdestroy_image})))(tls, image)
	} else {
		i = 0
		for {
			if !(i < nglyphs) {
				break
			}
			public2 = (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont
			font1 = public2
			sharp = __XftSharpGlyphFind(tls, draw, public2)
			glyph1 = (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fglyph
			if v13 = glyph1 >= (*TXftFontInt)(unsafe.Pointer(font1)).Fnum_glyphs; !v13 {
				v12 = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font1)).Fglyphs + uintptr(glyph1)*8))
				xftg = v12
			}
			if v13 || !(v12 != 0) {
				xftg = __XftGlyphDefault(tls, dpy, public2)
			}
			if xftg != 0 {
				(*(*func(*libc.TLS, uintptr, uintptr, int32, int32))(unsafe.Pointer(&struct{ uintptr }{sharp})))(tls, draw, xftg, int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fx), int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fy))
			}
			goto _11
		_11:
			;
			i++
		}
	}
	goto bail1
bail1:
	;
	if glyphs_loaded != 0 {
		i = 0
		for {
			if !(i < nglyphs) {
				break
			}
			X_XftFontManageMemory(tls, dpy, (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont)
			goto _14
		_14:
			;
			i++
		}
	}
}

/* xftxlfd.c */
func XXftDebug(tls *libc.TLS) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e uintptr
	_ = e
	if !(_initialized != 0) {
		_initialized = int32(1)
		e = libc.Xgetenv(tls, __ccgo_ts)
		if e != 0 {
			libc.Xprintf(tls, __ccgo_ts+10, libc.VaList(bp+8, e))
			_debug = libc.Xatoi(tls, e)
			if _debug <= 0 {
				_debug = int32(1)
			}
		}
	}
	return _debug
}

var _initialized int32

var _debug int32

func __XftCloseDisplay(tls *libc.TLS, dpy uintptr, codes uintptr) (r int32) {
	var info, prev, v2 uintptr
	_, _, _ = info, prev, v2
	info = X_XftDisplayInfoGet(tls, dpy, m_FcFalse)
	if !(info != 0) {
		return 0
	}
	/*
	 * Get rid of any dangling unreferenced fonts
	 */
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_unref_fonts = 0
	XXftFontManageMemory(tls, dpy)
	/*
	 * Clean up the default values
	 */
	if (*TXftDisplayInfo)(unsafe.Pointer(info)).Fdefaults != 0 {
		libfontconfig.XFcPatternDestroy(tls, (*TXftDisplayInfo)(unsafe.Pointer(info)).Fdefaults)
	}
	/*
	 * Unhook from the global list
	 */
	prev = uintptr(unsafe.Pointer(&X_XftDisplayInfo))
	for {
		v2 = *(*uintptr)(unsafe.Pointer(prev))
		info = v2
		if !(v2 != 0) {
			break
		}
		if (*TXftDisplayInfo)(unsafe.Pointer(info)).Fdisplay == dpy {
			break
		}
		goto _1
	_1:
		;
		prev = *(*uintptr)(unsafe.Pointer(prev))
	}
	if info != libc.UintptrFromInt32(0) {
		*(*uintptr)(unsafe.Pointer(prev)) = (*TXftDisplayInfo)(unsafe.Pointer(info)).Fnext
	}
	libc.Xfree(tls, info)
	return 0
}

func X_XftDisplayInfoGet(tls *libc.TLS, dpy uintptr, createIfNecessary TFcBool) (r uintptr) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var format, info, prev, visual, v2, v3, v5 uintptr
	var i int32
	var _ /* error_base at bp+44 */ int32
	var _ /* event_base at bp+40 */ int32
	var _ /* major at bp+48 */ int32
	var _ /* minor at bp+52 */ int32
	var _ /* pf at bp+0 */ TXRenderPictFormat
	_, _, _, _, _, _, _, _ = format, i, info, prev, visual, v2, v3, v5
	prev = uintptr(unsafe.Pointer(&X_XftDisplayInfo))
	for {
		v2 = *(*uintptr)(unsafe.Pointer(prev))
		info = v2
		if !(v2 != 0) {
			break
		}
		if (*TXftDisplayInfo)(unsafe.Pointer(info)).Fdisplay == dpy {
			/*
			 * MRU the list
			 */
			if prev != uintptr(unsafe.Pointer(&X_XftDisplayInfo)) {
				*(*uintptr)(unsafe.Pointer(prev)) = (*TXftDisplayInfo)(unsafe.Pointer(info)).Fnext
				(*TXftDisplayInfo)(unsafe.Pointer(info)).Fnext = X_XftDisplayInfo
				X_XftDisplayInfo = info
			}
			return info
		}
		goto _1
	_1:
		;
		prev = *(*uintptr)(unsafe.Pointer(prev))
	}
	if !(createIfNecessary != 0) {
		return libc.UintptrFromInt32(0)
	}
	info = libc.Xmalloc(tls, uint64(1488))
	if !(info != 0) {
		goto bail0
	}
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Fcodes = libx11.XXAddExtension(tls, dpy)
	if !((*TXftDisplayInfo)(unsafe.Pointer(info)).Fcodes != 0) {
		goto bail1
	}
	libx11.XXESetCloseDisplay(tls, dpy, (*TXExtCodes)(unsafe.Pointer((*TXftDisplayInfo)(unsafe.Pointer(info)).Fcodes)).Fextension, __ccgo_fp(__XftCloseDisplay))
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Fdisplay = dpy
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Fdefaults = libc.UintptrFromInt32(0)
	(*TXftDisplayInfo)(unsafe.Pointer(info)).FsolidFormat = libc.UintptrFromInt32(0)
	(*TXftDisplayInfo)(unsafe.Pointer(info)).FhasRender = libc.BoolInt32(libxrender.XXRenderQueryExtension(tls, dpy, bp+40, bp+44) != 0 && libxrender.XXRenderFindVisualFormat(tls, dpy, (*TScreen)(unsafe.Pointer((*struct {
		Fext_data            uintptr
		Fprivate1            uintptr
		Ffd                  int32
		Fprivate2            int32
		Fproto_major_version int32
		Fproto_minor_version int32
		Fvendor              uintptr
		Fprivate3            TXID
		Fprivate4            TXID
		Fprivate5            TXID
		Fprivate6            int32
		Fresource_alloc      uintptr
		Fbyte_order          int32
		Fbitmap_unit         int32
		Fbitmap_pad          int32
		Fbitmap_bit_order    int32
		Fnformats            int32
		Fpixmap_format       uintptr
		Fprivate8            int32
		Frelease             int32
		Fprivate9            uintptr
		Fprivate10           uintptr
		Fqlen                int32
		Flast_request_read   uint64
		Frequest             uint64
		Fprivate11           TXPointer
		Fprivate12           TXPointer
		Fprivate13           TXPointer
		Fprivate14           TXPointer
		Fmax_request_size    uint32
		Fdb                  uintptr
		Fprivate15           uintptr
		Fdisplay_name        uintptr
		Fdefault_screen      int32
		Fnscreens            int32
		Fscreens             uintptr
		Fmotion_buffer       uint64
		Fprivate16           uint64
		Fmin_keycode         int32
		Fmax_keycode         int32
		Fprivate17           TXPointer
		Fprivate18           TXPointer
		Fprivate19           int32
		Fxdefaults           uintptr
	})(unsafe.Pointer(dpy)).Fscreens+uintptr((*struct {
		Fext_data            uintptr
		Fprivate1            uintptr
		Ffd                  int32
		Fprivate2            int32
		Fproto_major_version int32
		Fproto_minor_version int32
		Fvendor              uintptr
		Fprivate3            TXID
		Fprivate4            TXID
		Fprivate5            TXID
		Fprivate6            int32
		Fresource_alloc      uintptr
		Fbyte_order          int32
		Fbitmap_unit         int32
		Fbitmap_pad          int32
		Fbitmap_bit_order    int32
		Fnformats            int32
		Fpixmap_format       uintptr
		Fprivate8            int32
		Frelease             int32
		Fprivate9            uintptr
		Fprivate10           uintptr
		Fqlen                int32
		Flast_request_read   uint64
		Frequest             uint64
		Fprivate11           TXPointer
		Fprivate12           TXPointer
		Fprivate13           TXPointer
		Fprivate14           TXPointer
		Fmax_request_size    uint32
		Fdb                  uintptr
		Fprivate15           uintptr
		Fdisplay_name        uintptr
		Fdefault_screen      int32
		Fnscreens            int32
		Fscreens             uintptr
		Fmotion_buffer       uint64
		Fprivate16           uint64
		Fmin_keycode         int32
		Fmax_keycode         int32
		Fprivate17           TXPointer
		Fprivate18           TXPointer
		Fprivate19           int32
		Fxdefaults           uintptr
	})(unsafe.Pointer(dpy)).Fdefault_screen)*128)).Froot_visual) != libc.UintptrFromInt32(0))
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Fuse_free_glyphs = int32(m_FcTrue)
	if (*TXftDisplayInfo)(unsafe.Pointer(info)).FhasRender != 0 {
		libxrender.XXRenderQueryVersion(tls, dpy, bp+48, bp+52)
		if *(*int32)(unsafe.Pointer(bp + 48)) < 0 || *(*int32)(unsafe.Pointer(bp + 48)) == 0 && *(*int32)(unsafe.Pointer(bp + 52)) <= int32(2) {
			(*TXftDisplayInfo)(unsafe.Pointer(info)).Fuse_free_glyphs = m_FcFalse
		}
		(*TXftDisplayInfo)(unsafe.Pointer(info)).FhasSolid = m_FcFalse
		if *(*int32)(unsafe.Pointer(bp + 48)) > 0 || *(*int32)(unsafe.Pointer(bp + 48)) == 0 && *(*int32)(unsafe.Pointer(bp + 52)) >= int32(10) {
			(*TXftDisplayInfo)(unsafe.Pointer(info)).FhasSolid = int32(m_FcTrue)
		}
		(*(*TXRenderPictFormat)(unsafe.Pointer(bp))).Ftype1 = int32(m_PictTypeDirect)
		(*(*TXRenderPictFormat)(unsafe.Pointer(bp))).Fdepth = int32(32)
		(*(*TXRenderPictFormat)(unsafe.Pointer(bp))).Fdirect.FredMask = int16(0xff)
		(*(*TXRenderPictFormat)(unsafe.Pointer(bp))).Fdirect.FgreenMask = int16(0xff)
		(*(*TXRenderPictFormat)(unsafe.Pointer(bp))).Fdirect.FblueMask = int16(0xff)
		(*(*TXRenderPictFormat)(unsafe.Pointer(bp))).Fdirect.FalphaMask = int16(0xff)
		(*TXftDisplayInfo)(unsafe.Pointer(info)).FsolidFormat = libxrender.XXRenderFindFormat(tls, dpy, uint64(libc.Int32FromInt32(1)<<libc.Int32FromInt32(1)|libc.Int32FromInt32(1)<<libc.Int32FromInt32(2)|libc.Int32FromInt32(1)<<libc.Int32FromInt32(4)|libc.Int32FromInt32(1)<<libc.Int32FromInt32(6)|libc.Int32FromInt32(1)<<libc.Int32FromInt32(8)|libc.Int32FromInt32(1)<<libc.Int32FromInt32(10)), bp, 0)
	}
	if XXftDebug(tls)&int32(m_XFT_DBG_RENDER) != 0 {
		visual = (*TScreen)(unsafe.Pointer((*struct {
			Fext_data            uintptr
			Fprivate1            uintptr
			Ffd                  int32
			Fprivate2            int32
			Fproto_major_version int32
			Fproto_minor_version int32
			Fvendor              uintptr
			Fprivate3            TXID
			Fprivate4            TXID
			Fprivate5            TXID
			Fprivate6            int32
			Fresource_alloc      uintptr
			Fbyte_order          int32
			Fbitmap_unit         int32
			Fbitmap_pad          int32
			Fbitmap_bit_order    int32
			Fnformats            int32
			Fpixmap_format       uintptr
			Fprivate8            int32
			Frelease             int32
			Fprivate9            uintptr
			Fprivate10           uintptr
			Fqlen                int32
			Flast_request_read   uint64
			Frequest             uint64
			Fprivate11           TXPointer
			Fprivate12           TXPointer
			Fprivate13           TXPointer
			Fprivate14           TXPointer
			Fmax_request_size    uint32
			Fdb                  uintptr
			Fprivate15           uintptr
			Fdisplay_name        uintptr
			Fdefault_screen      int32
			Fnscreens            int32
			Fscreens             uintptr
			Fmotion_buffer       uint64
			Fprivate16           uint64
			Fmin_keycode         int32
			Fmax_keycode         int32
			Fprivate17           TXPointer
			Fprivate18           TXPointer
			Fprivate19           int32
			Fxdefaults           uintptr
		})(unsafe.Pointer(dpy)).Fscreens + uintptr((*struct {
			Fext_data            uintptr
			Fprivate1            uintptr
			Ffd                  int32
			Fprivate2            int32
			Fproto_major_version int32
			Fproto_minor_version int32
			Fvendor              uintptr
			Fprivate3            TXID
			Fprivate4            TXID
			Fprivate5            TXID
			Fprivate6            int32
			Fresource_alloc      uintptr
			Fbyte_order          int32
			Fbitmap_unit         int32
			Fbitmap_pad          int32
			Fbitmap_bit_order    int32
			Fnformats            int32
			Fpixmap_format       uintptr
			Fprivate8            int32
			Frelease             int32
			Fprivate9            uintptr
			Fprivate10           uintptr
			Fqlen                int32
			Flast_request_read   uint64
			Frequest             uint64
			Fprivate11           TXPointer
			Fprivate12           TXPointer
			Fprivate13           TXPointer
			Fprivate14           TXPointer
			Fmax_request_size    uint32
			Fdb                  uintptr
			Fprivate15           uintptr
			Fdisplay_name        uintptr
			Fdefault_screen      int32
			Fnscreens            int32
			Fscreens             uintptr
			Fmotion_buffer       uint64
			Fprivate16           uint64
			Fmin_keycode         int32
			Fmax_keycode         int32
			Fprivate17           TXPointer
			Fprivate18           TXPointer
			Fprivate19           int32
			Fxdefaults           uintptr
		})(unsafe.Pointer(dpy)).Fdefault_screen)*128)).Froot_visual
		format = libxrender.XXRenderFindVisualFormat(tls, dpy, visual)
		libc.Xprintf(tls, __ccgo_ts+24, libc.VaList(bp+64, int32((*TVisual)(unsafe.Pointer(visual)).Fvisualid)))
		if format != 0 {
			if (*TXRenderPictFormat)(unsafe.Pointer(format)).Ftype1 == int32(m_PictTypeDirect) {
				libc.Xprintf(tls, __ccgo_ts+63, libc.VaList(bp+64, int32((*TXRenderPictFormat)(unsafe.Pointer(format)).Fdirect.Falpha), int32((*TXRenderPictFormat)(unsafe.Pointer(format)).Fdirect.Fred), int32((*TXRenderPictFormat)(unsafe.Pointer(format)).Fdirect.Fgreen), int32((*TXRenderPictFormat)(unsafe.Pointer(format)).Fdirect.Fblue)))
			} else {
				libc.Xprintf(tls, __ccgo_ts+83, 0)
			}
		} else {
			libc.Xprintf(tls, __ccgo_ts+99, 0)
		}
		if (*TXftDisplayInfo)(unsafe.Pointer(info)).FhasRender != 0 {
			v3 = __ccgo_ts + 136
		} else {
			v3 = __ccgo_ts + 141
		}
		libc.Xprintf(tls, __ccgo_ts+147, libc.VaList(bp+64, v3))
	}
	i = 0
	for {
		if !(i < int32(m_XFT_NUM_SOLID_COLOR)) {
			break
		}
		(*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fscreen = -int32(1)
		(*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fpict = uint64(0)
		goto _4
	_4:
		;
		i++
	}
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Ffonts = libc.UintptrFromInt32(0)
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Fnext = X_XftDisplayInfo
	X_XftDisplayInfo = info
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Fglyph_memory = uint64(0)
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_glyph_memory = uint64(XXftDefaultGetInteger(tls, dpy, __ccgo_ts+201, 0, libc.Int32FromInt32(4)*libc.Int32FromInt32(1024)*libc.Int32FromInt32(1024)))
	if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
		libc.Xprintf(tls, __ccgo_ts+216, libc.VaList(bp+64, (*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_glyph_memory))
	}
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Fnum_unref_fonts = 0
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_unref_fonts = XXftDefaultGetInteger(tls, dpy, __ccgo_ts+245, 0, int32(m_XFT_DPY_MAX_UNREF_FONTS))
	if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
		libc.Xprintf(tls, __ccgo_ts+259, libc.VaList(bp+64, (*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_unref_fonts))
	}
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Ftrack_mem_usage = m_FcFalse
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Ftrack_mem_usage = XXftDefaultGetBool(tls, dpy, __ccgo_ts+287, 0, m_FcFalse)
	if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
		if (*TXftDisplayInfo)(unsafe.Pointer(info)).Ftrack_mem_usage != 0 {
			v5 = __ccgo_ts + 301
		} else {
			v5 = __ccgo_ts + 306
		}
		libc.Xprintf(tls, __ccgo_ts+312, libc.VaList(bp+64, v5))
	}
	libc.X__builtin___memset_chk(tls, info+472, int32('\000'), libc.Uint64FromInt64(8)*libc.Uint64FromInt32(m_XFT_NUM_FONT_HASH), uint64(libc.X__builtin_object_size(tls, info+472, 0)))
	return info
	goto bail1
bail1:
	;
	libc.Xfree(tls, info)
	goto bail0
bail0:
	;
	if XXftDebug(tls)&int32(m_XFT_DBG_RENDER) != 0 {
		libc.Xprintf(tls, __ccgo_ts+340, 0)
	}
	return libc.UintptrFromInt32(0)
}

/*
 * Reduce memory usage in X server
 */

func __XftDisplayValidateMemory(tls *libc.TLS, info uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var font, public uintptr
	var glyph_memory uint64
	_, _, _ = font, glyph_memory, public
	glyph_memory = uint64(0)
	public = (*TXftDisplayInfo)(unsafe.Pointer(info)).Ffonts
	for {
		if !(public != 0) {
			break
		}
		font = public
		glyph_memory += (*TXftFontInt)(unsafe.Pointer(font)).Fglyph_memory
		goto _1
	_1:
		;
		public = (*TXftFontInt)(unsafe.Pointer(font)).Fnext
	}
	if glyph_memory != (*TXftDisplayInfo)(unsafe.Pointer(info)).Fglyph_memory {
		libc.Xprintf(tls, __ccgo_ts+393, libc.VaList(bp+8, (*TXftDisplayInfo)(unsafe.Pointer(info)).Fglyph_memory, glyph_memory))
	}
}

func X_XftDisplayManageMemory(tls *libc.TLS, dpy uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var font, info, public uintptr
	var glyph_memory uint64
	_, _, _, _ = font, glyph_memory, info, public
	info = X_XftDisplayInfoGet(tls, dpy, m_False)
	if !(info != 0) || !((*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_glyph_memory != 0) {
		return
	}
	if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
		if (*TXftDisplayInfo)(unsafe.Pointer(info)).Fglyph_memory > (*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_glyph_memory {
			libc.Xprintf(tls, __ccgo_ts+455, libc.VaList(bp+8, (*TXftDisplayInfo)(unsafe.Pointer(info)).Fglyph_memory, (*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_glyph_memory))
		}
		__XftDisplayValidateMemory(tls, info)
	}
	for (*TXftDisplayInfo)(unsafe.Pointer(info)).Fglyph_memory > (*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_glyph_memory {
		glyph_memory = uint64(libc.Xrand(tls)) % (*TXftDisplayInfo)(unsafe.Pointer(info)).Fglyph_memory
		public = (*TXftDisplayInfo)(unsafe.Pointer(info)).Ffonts
		for public != 0 {
			font = public
			if (*TXftFontInt)(unsafe.Pointer(font)).Fglyph_memory > glyph_memory {
				X_XftFontUncacheGlyph(tls, dpy, public)
				break
			}
			public = (*TXftFontInt)(unsafe.Pointer(font)).Fnext
			glyph_memory -= (*TXftFontInt)(unsafe.Pointer(font)).Fglyph_memory
		}
	}
	if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
		__XftDisplayValidateMemory(tls, info)
	}
}

func XXftDefaultHasRender(tls *libc.TLS, dpy uintptr) (r int32) {
	var info uintptr
	_ = info
	info = X_XftDisplayInfoGet(tls, dpy, int32(m_True))
	if !(info != 0) {
		return m_False
	}
	return (*TXftDisplayInfo)(unsafe.Pointer(info)).FhasRender
}

func XXftDefaultSet(tls *libc.TLS, dpy uintptr, defaults uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var info, v1 uintptr
	_, _ = info, v1
	info = X_XftDisplayInfoGet(tls, dpy, int32(m_True))
	if !(info != 0) {
		return m_False
	}
	if (*TXftDisplayInfo)(unsafe.Pointer(info)).Fdefaults != 0 {
		libfontconfig.XFcPatternDestroy(tls, (*TXftDisplayInfo)(unsafe.Pointer(info)).Fdefaults)
	}
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Fdefaults = defaults
	if !((*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_glyph_memory != 0) {
		(*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_glyph_memory = uint64(libc.Int32FromInt32(4) * libc.Int32FromInt32(1024) * libc.Int32FromInt32(1024))
	}
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_glyph_memory = uint64(XXftDefaultGetInteger(tls, dpy, __ccgo_ts+201, 0, int32((*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_glyph_memory)))
	if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
		libc.Xprintf(tls, __ccgo_ts+493, libc.VaList(bp+8, (*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_glyph_memory))
	}
	if !((*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_unref_fonts != 0) {
		(*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_unref_fonts = int32(m_XFT_DPY_MAX_UNREF_FONTS)
	}
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_unref_fonts = XXftDefaultGetInteger(tls, dpy, __ccgo_ts+245, 0, (*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_unref_fonts)
	if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
		libc.Xprintf(tls, __ccgo_ts+522, libc.VaList(bp+8, (*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_unref_fonts))
	}
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Ftrack_mem_usage = XXftDefaultGetBool(tls, dpy, __ccgo_ts+287, 0, (*TXftDisplayInfo)(unsafe.Pointer(info)).Ftrack_mem_usage)
	if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
		if (*TXftDisplayInfo)(unsafe.Pointer(info)).Ftrack_mem_usage != 0 {
			v1 = __ccgo_ts + 301
		} else {
			v1 = __ccgo_ts + 306
		}
		libc.Xprintf(tls, __ccgo_ts+550, libc.VaList(bp+8, v1))
	}
	return int32(m_True)
}

func XXftDefaultParseBool(tls *libc.TLS, v uintptr) (r int32) {
	var c0, c1 int8
	var v1, v10, v12, v16, v18, v19, v21, v5, v7, v8 int32
	var v14, v3 t__darwin_ct_rune_t
	var v15, v4 uint64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c0, c1, v1, v10, v12, v14, v15, v16, v18, v19, v21, v3, v4, v5, v7, v8
	c0 = *(*int8)(unsafe.Pointer(v))
	v3 = int32(c0)
	v4 = uint64(0x00008000)
	v8 = libc.BoolInt32(v3 & ^libc.Int32FromInt32(0x7F) == 0)
	goto _9
_9:
	if v8 != 0 {
		v7 = libc.BoolInt32(!!(uint64(*(*t__uint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&libc.X_DefaultRuneLocale)) + 60 + uintptr(v3)*4)))&v4 != 0))
	} else {
		v7 = libc.BoolInt32(!!(libc.X__maskrune(tls, v3, v4) != 0))
	}
	v5 = v7
	goto _6
_6:
	v1 = v5
	goto _2
_2:
	if v1 != 0 {
		v10 = libc.X__tolower(tls, int32(c0))
		goto _11
	_11:
		c0 = int8(v10)
	}
	if int32(c0) == int32('t') || int32(c0) == int32('y') || int32(c0) == int32('1') {
		return int32(1)
	}
	if int32(c0) == int32('f') || int32(c0) == int32('n') || int32(c0) == int32('0') {
		return 0
	}
	if int32(c0) == int32('o') {
		c1 = *(*int8)(unsafe.Pointer(v + 1))
		v14 = int32(c1)
		v15 = uint64(0x00008000)
		v19 = libc.BoolInt32(v14 & ^libc.Int32FromInt32(0x7F) == 0)
		goto _20
	_20:
		if v19 != 0 {
			v18 = libc.BoolInt32(!!(uint64(*(*t__uint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&libc.X_DefaultRuneLocale)) + 60 + uintptr(v14)*4)))&v15 != 0))
		} else {
			v18 = libc.BoolInt32(!!(libc.X__maskrune(tls, v14, v15) != 0))
		}
		v16 = v18
		goto _17
	_17:
		v12 = v16
		goto _13
	_13:
		if v12 != 0 {
			v21 = libc.X__tolower(tls, int32(c1))
			goto _22
		_22:
			c1 = int8(v21)
		}
		if int32(c1) == int32('n') {
			return int32(1)
		}
		if int32(c1) == int32('f') {
			return 0
		}
	}
	return -int32(1)
}

func __XftDefaultInitBool(tls *libc.TLS, dpy uintptr, pat uintptr, option uintptr) (r int32) {
	var i, v1 int32
	var v uintptr
	var v2 bool
	_, _, _, _ = i, v, v1, v2
	v = libx11.XXGetDefault(tls, dpy, __ccgo_ts+578, option)
	if v2 = v != 0; v2 {
		v1 = XXftDefaultParseBool(tls, v)
		i = v1
	}
	if v2 && v1 >= 0 {
		return libfontconfig.XFcPatternAddBool(tls, pat, option, libc.BoolInt32(i != 0))
	}
	return int32(m_True)
}

func __XftDefaultInitDouble(tls *libc.TLS, dpy uintptr, pat uintptr, option uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var d float64
	var v uintptr
	var _ /* e at bp+0 */ uintptr
	_, _ = d, v
	v = libx11.XXGetDefault(tls, dpy, __ccgo_ts+578, option)
	if v != 0 {
		d = libc.Xstrtod(tls, v, bp)
		if *(*uintptr)(unsafe.Pointer(bp)) != v {
			return libfontconfig.XFcPatternAddDouble(tls, pat, option, d)
		}
	}
	return int32(m_True)
}

func __XftDefaultInitInteger(tls *libc.TLS, dpy uintptr, pat uintptr, option uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v uintptr
	var _ /* e at bp+0 */ uintptr
	var _ /* i at bp+8 */ int32
	_ = v
	v = libx11.XXGetDefault(tls, dpy, __ccgo_ts+578, option)
	if v != 0 {
		if libfontconfig.XFcNameConstant(tls, v, bp+8) != 0 {
			return libfontconfig.XFcPatternAddInteger(tls, pat, option, *(*int32)(unsafe.Pointer(bp + 8)))
		}
		*(*int32)(unsafe.Pointer(bp + 8)) = int32(libc.Xstrtol(tls, v, bp, 0))
		if *(*uintptr)(unsafe.Pointer(bp)) != v {
			return libfontconfig.XFcPatternAddInteger(tls, pat, option, *(*int32)(unsafe.Pointer(bp + 8)))
		}
	}
	return int32(m_True)
}

func __XftDefaultInit(tls *libc.TLS, dpy uintptr) (r uintptr) {
	var pat uintptr
	_ = pat
	pat = libfontconfig.XFcPatternCreate(tls)
	if !(pat != 0) {
		goto bail0
	}
	if !(__XftDefaultInitDouble(tls, dpy, pat, __ccgo_ts+582) != 0) {
		goto bail1
	}
	if !(__XftDefaultInitDouble(tls, dpy, pat, __ccgo_ts+588) != 0) {
		goto bail1
	}
	if !(__XftDefaultInitBool(tls, dpy, pat, __ccgo_ts+592) != 0) {
		goto bail1
	}
	if !(__XftDefaultInitInteger(tls, dpy, pat, __ccgo_ts+599) != 0) {
		goto bail1
	}
	if !(__XftDefaultInitInteger(tls, dpy, pat, __ccgo_ts+604) != 0) {
		goto bail1
	}
	if !(__XftDefaultInitBool(tls, dpy, pat, __ccgo_ts+614) != 0) {
		goto bail1
	}
	if !(__XftDefaultInitBool(tls, dpy, pat, __ccgo_ts+624) != 0) {
		goto bail1
	}
	if !(__XftDefaultInitBool(tls, dpy, pat, __ccgo_ts+633) != 0) {
		goto bail1
	}
	if !(__XftDefaultInitInteger(tls, dpy, pat, __ccgo_ts+642) != 0) {
		goto bail1
	}
	if !(__XftDefaultInitBool(tls, dpy, pat, __ccgo_ts+652) != 0) {
		goto bail1
	}
	if !(__XftDefaultInitBool(tls, dpy, pat, __ccgo_ts+660) != 0) {
		goto bail1
	}
	if !(__XftDefaultInitInteger(tls, dpy, pat, __ccgo_ts+201) != 0) {
		goto bail1
	}
	return pat
	goto bail1
bail1:
	;
	libfontconfig.XFcPatternDestroy(tls, pat)
	goto bail0
bail0:
	;
	return libc.UintptrFromInt32(0)
	return r
}

func __XftDefaultGet(tls *libc.TLS, dpy uintptr, object uintptr, screen int32, v uintptr) (r1 TFcResult) {
	var info uintptr
	var r TFcResult
	_, _ = info, r
	info = X_XftDisplayInfoGet(tls, dpy, int32(m_True))
	if !(info != 0) {
		return int32(_FcResultNoMatch)
	}
	if !((*TXftDisplayInfo)(unsafe.Pointer(info)).Fdefaults != 0) {
		(*TXftDisplayInfo)(unsafe.Pointer(info)).Fdefaults = __XftDefaultInit(tls, dpy)
		if !((*TXftDisplayInfo)(unsafe.Pointer(info)).Fdefaults != 0) {
			return int32(_FcResultNoMatch)
		}
	}
	r = libfontconfig.XFcPatternGet(tls, (*TXftDisplayInfo)(unsafe.Pointer(info)).Fdefaults, object, screen, v)
	if r == int32(_FcResultNoId) && screen > 0 {
		r = libfontconfig.XFcPatternGet(tls, (*TXftDisplayInfo)(unsafe.Pointer(info)).Fdefaults, object, 0, v)
	}
	return r
}

func XXftDefaultGetBool(tls *libc.TLS, dpy uintptr, object uintptr, screen int32, def int32) (r1 int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r TFcResult
	var _ /* v at bp+0 */ TFcValue
	_ = r
	r = __XftDefaultGet(tls, dpy, object, screen, bp)
	if r != int32(_FcResultMatch) || (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 != int32(_FcTypeBool) {
		return def
	}
	return *(*TFcBool)(unsafe.Pointer(bp + 8))
}

func XXftDefaultGetInteger(tls *libc.TLS, dpy uintptr, object uintptr, screen int32, def int32) (r1 int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r TFcResult
	var _ /* v at bp+0 */ TFcValue
	_ = r
	r = __XftDefaultGet(tls, dpy, object, screen, bp)
	if r != int32(_FcResultMatch) || (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 != int32(_FcTypeInteger) {
		return def
	}
	return *(*int32)(unsafe.Pointer(bp + 8))
}

func XXftDefaultGetDouble(tls *libc.TLS, dpy uintptr, object uintptr, screen int32, def float64) (r1 float64) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r TFcResult
	var _ /* v at bp+0 */ TFcValue
	_ = r
	r = __XftDefaultGet(tls, dpy, object, screen, bp)
	if r != int32(_FcResultMatch) || (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 != int32(_FcTypeDouble) {
		return def
	}
	return *(*float64)(unsafe.Pointer(bp + 8))
}

func XXftDefaultSubstitute(tls *libc.TLS, dpy uintptr, screen int32, pattern uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var dpi float64
	var render_order, subpixel int32
	var _ /* v at bp+0 */ TFcValue
	_, _, _ = dpi, render_order, subpixel
	if libfontconfig.XFcPatternGet(tls, pattern, __ccgo_ts+592, 0, bp) == int32(_FcResultNoMatch) {
		libfontconfig.XFcPatternAddBool(tls, pattern, __ccgo_ts+592, XXftDefaultGetBool(tls, dpy, __ccgo_ts+592, screen, XXftDefaultHasRender(tls, dpy)))
	}
	if libfontconfig.XFcPatternGet(tls, pattern, __ccgo_ts+614, 0, bp) == int32(_FcResultNoMatch) {
		libfontconfig.XFcPatternAddBool(tls, pattern, __ccgo_ts+614, XXftDefaultGetBool(tls, dpy, __ccgo_ts+614, screen, int32(m_True)))
	}
	if libfontconfig.XFcPatternGet(tls, pattern, __ccgo_ts+624, 0, bp) == int32(_FcResultNoMatch) {
		libfontconfig.XFcPatternAddBool(tls, pattern, __ccgo_ts+624, XXftDefaultGetBool(tls, dpy, __ccgo_ts+624, screen, m_False))
	}
	if libfontconfig.XFcPatternGet(tls, pattern, __ccgo_ts+652, 0, bp) == int32(_FcResultNoMatch) {
		libfontconfig.XFcPatternAddBool(tls, pattern, __ccgo_ts+652, XXftDefaultGetBool(tls, dpy, __ccgo_ts+652, screen, int32(m_True)))
	}
	if libfontconfig.XFcPatternGet(tls, pattern, __ccgo_ts+642, 0, bp) == int32(_FcResultNoMatch) {
		libfontconfig.XFcPatternAddInteger(tls, pattern, __ccgo_ts+642, XXftDefaultGetInteger(tls, dpy, __ccgo_ts+642, screen, int32(m_FC_HINT_FULL)))
	}
	if libfontconfig.XFcPatternGet(tls, pattern, __ccgo_ts+633, 0, bp) == int32(_FcResultNoMatch) {
		libfontconfig.XFcPatternAddBool(tls, pattern, __ccgo_ts+633, XXftDefaultGetBool(tls, dpy, __ccgo_ts+633, screen, m_False))
	}
	if libfontconfig.XFcPatternGet(tls, pattern, __ccgo_ts+599, 0, bp) == int32(_FcResultNoMatch) {
		subpixel = m_FC_RGBA_UNKNOWN
		if XXftDefaultHasRender(tls, dpy) != 0 {
			render_order = libxrender.XXRenderQuerySubpixelOrder(tls, dpy, screen)
			switch render_order {
			default:
				fallthrough
			case m_SubPixelUnknown:
				subpixel = m_FC_RGBA_UNKNOWN
			case int32(m_SubPixelHorizontalRGB):
				subpixel = int32(m_FC_RGBA_RGB)
			case int32(m_SubPixelHorizontalBGR):
				subpixel = int32(m_FC_RGBA_BGR)
			case int32(m_SubPixelVerticalRGB):
				subpixel = int32(m_FC_RGBA_VRGB)
			case int32(m_SubPixelVerticalBGR):
				subpixel = int32(m_FC_RGBA_VBGR)
			case int32(m_SubPixelNone):
				subpixel = int32(m_FC_RGBA_NONE)
				break
			}
		}
		libfontconfig.XFcPatternAddInteger(tls, pattern, __ccgo_ts+599, XXftDefaultGetInteger(tls, dpy, __ccgo_ts+599, screen, subpixel))
	}
	if libfontconfig.XFcPatternGet(tls, pattern, __ccgo_ts+604, 0, bp) == int32(_FcResultNoMatch) {
		libfontconfig.XFcPatternAddInteger(tls, pattern, __ccgo_ts+604, XXftDefaultGetInteger(tls, dpy, __ccgo_ts+604, screen, int32(m_FC_LCD_DEFAULT)))
	}
	if libfontconfig.XFcPatternGet(tls, pattern, __ccgo_ts+660, 0, bp) == int32(_FcResultNoMatch) {
		libfontconfig.XFcPatternAddBool(tls, pattern, __ccgo_ts+660, XXftDefaultGetBool(tls, dpy, __ccgo_ts+660, screen, m_False))
	}
	if libfontconfig.XFcPatternGet(tls, pattern, __ccgo_ts+588, 0, bp) == int32(_FcResultNoMatch) {
		dpi = float64((*TScreen)(unsafe.Pointer((*struct {
			Fext_data            uintptr
			Fprivate1            uintptr
			Ffd                  int32
			Fprivate2            int32
			Fproto_major_version int32
			Fproto_minor_version int32
			Fvendor              uintptr
			Fprivate3            TXID
			Fprivate4            TXID
			Fprivate5            TXID
			Fprivate6            int32
			Fresource_alloc      uintptr
			Fbyte_order          int32
			Fbitmap_unit         int32
			Fbitmap_pad          int32
			Fbitmap_bit_order    int32
			Fnformats            int32
			Fpixmap_format       uintptr
			Fprivate8            int32
			Frelease             int32
			Fprivate9            uintptr
			Fprivate10           uintptr
			Fqlen                int32
			Flast_request_read   uint64
			Frequest             uint64
			Fprivate11           TXPointer
			Fprivate12           TXPointer
			Fprivate13           TXPointer
			Fprivate14           TXPointer
			Fmax_request_size    uint32
			Fdb                  uintptr
			Fprivate15           uintptr
			Fdisplay_name        uintptr
			Fdefault_screen      int32
			Fnscreens            int32
			Fscreens             uintptr
			Fmotion_buffer       uint64
			Fprivate16           uint64
			Fmin_keycode         int32
			Fmax_keycode         int32
			Fprivate17           TXPointer
			Fprivate18           TXPointer
			Fprivate19           int32
			Fxdefaults           uintptr
		})(unsafe.Pointer(dpy)).Fscreens+uintptr(screen)*128)).Fheight) * float64(25.4) / float64((*TScreen)(unsafe.Pointer((*struct {
			Fext_data            uintptr
			Fprivate1            uintptr
			Ffd                  int32
			Fprivate2            int32
			Fproto_major_version int32
			Fproto_minor_version int32
			Fvendor              uintptr
			Fprivate3            TXID
			Fprivate4            TXID
			Fprivate5            TXID
			Fprivate6            int32
			Fresource_alloc      uintptr
			Fbyte_order          int32
			Fbitmap_unit         int32
			Fbitmap_pad          int32
			Fbitmap_bit_order    int32
			Fnformats            int32
			Fpixmap_format       uintptr
			Fprivate8            int32
			Frelease             int32
			Fprivate9            uintptr
			Fprivate10           uintptr
			Fqlen                int32
			Flast_request_read   uint64
			Frequest             uint64
			Fprivate11           TXPointer
			Fprivate12           TXPointer
			Fprivate13           TXPointer
			Fprivate14           TXPointer
			Fmax_request_size    uint32
			Fdb                  uintptr
			Fprivate15           uintptr
			Fdisplay_name        uintptr
			Fdefault_screen      int32
			Fnscreens            int32
			Fscreens             uintptr
			Fmotion_buffer       uint64
			Fprivate16           uint64
			Fmin_keycode         int32
			Fmax_keycode         int32
			Fprivate17           TXPointer
			Fprivate18           TXPointer
			Fprivate19           int32
			Fxdefaults           uintptr
		})(unsafe.Pointer(dpy)).Fscreens+uintptr(screen)*128)).Fmheight)
		libfontconfig.XFcPatternAddDouble(tls, pattern, __ccgo_ts+588, XXftDefaultGetDouble(tls, dpy, __ccgo_ts+588, screen, dpi))
	}
	if libfontconfig.XFcPatternGet(tls, pattern, __ccgo_ts+582, 0, bp) == int32(_FcResultNoMatch) {
		libfontconfig.XFcPatternAddDouble(tls, pattern, __ccgo_ts+582, XXftDefaultGetDouble(tls, dpy, __ccgo_ts+582, screen, float64(1)))
	}
	if libfontconfig.XFcPatternGet(tls, pattern, __ccgo_ts+201, 0, bp) == int32(_FcResultNoMatch) {
		libfontconfig.XFcPatternAddInteger(tls, pattern, __ccgo_ts+201, XXftDefaultGetInteger(tls, dpy, __ccgo_ts+201, screen, libc.Int32FromInt32(1024)*libc.Int32FromInt32(1024)))
	}
	libfontconfig.XFcDefaultSubstitute(tls, pattern)
}

const m_VisualIDMask1 = 1
const m_VisualScreenMask1 = 2

/* xftxlfd.c */

/*
 * Ok, this is a pain.  To share source pictures across multiple destinations,
 * the screen for each drawable must be discovered.
 */

func __XftDrawScreen(tls *libc.TLS, dpy uintptr, drawable TDrawable, visual uintptr) (r int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var ret uintptr
	var s int32
	var _ /* borderWidth at bp+24 */ uint32
	var _ /* depth at bp+28 */ uint32
	var _ /* height at bp+20 */ uint32
	var _ /* nret at bp+96 */ int32
	var _ /* root at bp+0 */ TWindow
	var _ /* template at bp+32 */ TXVisualInfo
	var _ /* width at bp+16 */ uint32
	var _ /* x at bp+8 */ int32
	var _ /* y at bp+12 */ int32
	_, _ = ret, s
	/* Special case the most common environment */
	if (*struct {
		Fext_data            uintptr
		Fprivate1            uintptr
		Ffd                  int32
		Fprivate2            int32
		Fproto_major_version int32
		Fproto_minor_version int32
		Fvendor              uintptr
		Fprivate3            TXID
		Fprivate4            TXID
		Fprivate5            TXID
		Fprivate6            int32
		Fresource_alloc      uintptr
		Fbyte_order          int32
		Fbitmap_unit         int32
		Fbitmap_pad          int32
		Fbitmap_bit_order    int32
		Fnformats            int32
		Fpixmap_format       uintptr
		Fprivate8            int32
		Frelease             int32
		Fprivate9            uintptr
		Fprivate10           uintptr
		Fqlen                int32
		Flast_request_read   uint64
		Frequest             uint64
		Fprivate11           TXPointer
		Fprivate12           TXPointer
		Fprivate13           TXPointer
		Fprivate14           TXPointer
		Fmax_request_size    uint32
		Fdb                  uintptr
		Fprivate15           uintptr
		Fdisplay_name        uintptr
		Fdefault_screen      int32
		Fnscreens            int32
		Fscreens             uintptr
		Fmotion_buffer       uint64
		Fprivate16           uint64
		Fmin_keycode         int32
		Fmax_keycode         int32
		Fprivate17           TXPointer
		Fprivate18           TXPointer
		Fprivate19           int32
		Fxdefaults           uintptr
	})(unsafe.Pointer(dpy)).Fnscreens == int32(1) {
		return 0
	}
	/*
	 * If we've got a visual, look for the screen that points at it.
	 * This requires no round trip.
	 */
	if visual != 0 {
		s = 0
		for {
			if !(s < (*struct {
				Fext_data            uintptr
				Fprivate1            uintptr
				Ffd                  int32
				Fprivate2            int32
				Fproto_major_version int32
				Fproto_minor_version int32
				Fvendor              uintptr
				Fprivate3            TXID
				Fprivate4            TXID
				Fprivate5            TXID
				Fprivate6            int32
				Fresource_alloc      uintptr
				Fbyte_order          int32
				Fbitmap_unit         int32
				Fbitmap_pad          int32
				Fbitmap_bit_order    int32
				Fnformats            int32
				Fpixmap_format       uintptr
				Fprivate8            int32
				Frelease             int32
				Fprivate9            uintptr
				Fprivate10           uintptr
				Fqlen                int32
				Flast_request_read   uint64
				Frequest             uint64
				Fprivate11           TXPointer
				Fprivate12           TXPointer
				Fprivate13           TXPointer
				Fprivate14           TXPointer
				Fmax_request_size    uint32
				Fdb                  uintptr
				Fprivate15           uintptr
				Fdisplay_name        uintptr
				Fdefault_screen      int32
				Fnscreens            int32
				Fscreens             uintptr
				Fmotion_buffer       uint64
				Fprivate16           uint64
				Fmin_keycode         int32
				Fmax_keycode         int32
				Fprivate17           TXPointer
				Fprivate18           TXPointer
				Fprivate19           int32
				Fxdefaults           uintptr
			})(unsafe.Pointer(dpy)).Fnscreens) {
				break
			}
			(*(*TXVisualInfo)(unsafe.Pointer(bp + 32))).Fvisualid = (*TVisual)(unsafe.Pointer(visual)).Fvisualid
			(*(*TXVisualInfo)(unsafe.Pointer(bp + 32))).Fscreen = s
			ret = libx11.XXGetVisualInfo(tls, dpy, int64(libc.Int32FromInt32(m_VisualIDMask1)|libc.Int32FromInt32(m_VisualScreenMask1)), bp+32, bp+96)
			if ret != 0 {
				libx11.XXFree(tls, ret)
				return s
			}
			goto _1
		_1:
			;
			s++
		}
	}
	/*
	 * Otherwise, as the server for the drawable geometry and find
	 * the screen from the root window.
	 * This takes a round trip.
	 */
	if libx11.XXGetGeometry(tls, dpy, drawable, bp, bp+8, bp+12, bp+16, bp+20, bp+24, bp+28) != 0 {
		s = 0
		for {
			if !(s < (*struct {
				Fext_data            uintptr
				Fprivate1            uintptr
				Ffd                  int32
				Fprivate2            int32
				Fproto_major_version int32
				Fproto_minor_version int32
				Fvendor              uintptr
				Fprivate3            TXID
				Fprivate4            TXID
				Fprivate5            TXID
				Fprivate6            int32
				Fresource_alloc      uintptr
				Fbyte_order          int32
				Fbitmap_unit         int32
				Fbitmap_pad          int32
				Fbitmap_bit_order    int32
				Fnformats            int32
				Fpixmap_format       uintptr
				Fprivate8            int32
				Frelease             int32
				Fprivate9            uintptr
				Fprivate10           uintptr
				Fqlen                int32
				Flast_request_read   uint64
				Frequest             uint64
				Fprivate11           TXPointer
				Fprivate12           TXPointer
				Fprivate13           TXPointer
				Fprivate14           TXPointer
				Fmax_request_size    uint32
				Fdb                  uintptr
				Fprivate15           uintptr
				Fdisplay_name        uintptr
				Fdefault_screen      int32
				Fnscreens            int32
				Fscreens             uintptr
				Fmotion_buffer       uint64
				Fprivate16           uint64
				Fmin_keycode         int32
				Fmax_keycode         int32
				Fprivate17           TXPointer
				Fprivate18           TXPointer
				Fprivate19           int32
				Fxdefaults           uintptr
			})(unsafe.Pointer(dpy)).Fnscreens) {
				break
			}
			if (*TScreen)(unsafe.Pointer((*struct {
				Fext_data            uintptr
				Fprivate1            uintptr
				Ffd                  int32
				Fprivate2            int32
				Fproto_major_version int32
				Fproto_minor_version int32
				Fvendor              uintptr
				Fprivate3            TXID
				Fprivate4            TXID
				Fprivate5            TXID
				Fprivate6            int32
				Fresource_alloc      uintptr
				Fbyte_order          int32
				Fbitmap_unit         int32
				Fbitmap_pad          int32
				Fbitmap_bit_order    int32
				Fnformats            int32
				Fpixmap_format       uintptr
				Fprivate8            int32
				Frelease             int32
				Fprivate9            uintptr
				Fprivate10           uintptr
				Fqlen                int32
				Flast_request_read   uint64
				Frequest             uint64
				Fprivate11           TXPointer
				Fprivate12           TXPointer
				Fprivate13           TXPointer
				Fprivate14           TXPointer
				Fmax_request_size    uint32
				Fdb                  uintptr
				Fprivate15           uintptr
				Fdisplay_name        uintptr
				Fdefault_screen      int32
				Fnscreens            int32
				Fscreens             uintptr
				Fmotion_buffer       uint64
				Fprivate16           uint64
				Fmin_keycode         int32
				Fmax_keycode         int32
				Fprivate17           TXPointer
				Fprivate18           TXPointer
				Fprivate19           int32
				Fxdefaults           uintptr
			})(unsafe.Pointer(dpy)).Fscreens+uintptr(s)*128)).Froot == *(*TWindow)(unsafe.Pointer(bp)) {
				return s
			}
			goto _2
		_2:
			;
			s++
		}
	}
	/*
	 * Make a guess -- it's probably wrong, but then the app probably
	 * handed us a bogus drawable in this case
	 */
	return 0
}

func XXftDrawDepth(tls *libc.TLS, draw uintptr) (r uint32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* borderWidth at bp+24 */ uint32
	var _ /* depth at bp+28 */ uint32
	var _ /* height at bp+20 */ uint32
	var _ /* root at bp+0 */ TWindow
	var _ /* width at bp+16 */ uint32
	var _ /* x at bp+8 */ int32
	var _ /* y at bp+12 */ int32
	if !((*TXftDraw)(unsafe.Pointer(draw)).Fdepth != 0) {
		if libx11.XXGetGeometry(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, bp, bp+8, bp+12, bp+16, bp+20, bp+24, bp+28) != 0 {
			(*TXftDraw)(unsafe.Pointer(draw)).Fdepth = *(*uint32)(unsafe.Pointer(bp + 28))
		}
	}
	return (*TXftDraw)(unsafe.Pointer(draw)).Fdepth
}

func XXftDrawBitsPerPixel(tls *libc.TLS, draw uintptr) (r uint32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var depth, v1 uint32
	var formats, v2 uintptr
	var i int32
	var v3 bool
	var _ /* nformats at bp+0 */ int32
	_, _, _, _, _, _ = depth, formats, i, v1, v2, v3
	if !((*TXftDraw)(unsafe.Pointer(draw)).Fbits_per_pixel != 0) {
		v1 = XXftDrawDepth(tls, draw)
		depth = v1
		if v3 = v1 != 0; v3 {
			v2 = libx11.XXListPixmapFormats(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, bp)
			formats = v2
		}
		if v3 && v2 != 0 {
			i = 0
			for {
				if !(i < *(*int32)(unsafe.Pointer(bp))) {
					break
				}
				if uint32((*(*TXPixmapFormatValues)(unsafe.Pointer(formats + uintptr(i)*12))).Fdepth) == depth {
					(*TXftDraw)(unsafe.Pointer(draw)).Fbits_per_pixel = uint32((*(*TXPixmapFormatValues)(unsafe.Pointer(formats + uintptr(i)*12))).Fbits_per_pixel)
					break
				}
				goto _4
			_4:
				;
				i++
			}
			libx11.XXFree(tls, formats)
		}
	}
	return (*TXftDraw)(unsafe.Pointer(draw)).Fbits_per_pixel
}

func XXftDrawCreate(tls *libc.TLS, dpy uintptr, drawable TDrawable, visual uintptr, colormap TColormap) (r uintptr) {
	var draw uintptr
	_ = draw
	draw = libc.Xmalloc(tls, uint64(96))
	if !(draw != 0) {
		return libc.UintptrFromInt32(0)
	}
	(*TXftDraw)(unsafe.Pointer(draw)).Fdpy = dpy
	(*TXftDraw)(unsafe.Pointer(draw)).Fdrawable = drawable
	(*TXftDraw)(unsafe.Pointer(draw)).Fscreen = __XftDrawScreen(tls, dpy, drawable, visual)
	(*TXftDraw)(unsafe.Pointer(draw)).Fdepth = uint32(0)          /* don't find out unless we need to know */
	(*TXftDraw)(unsafe.Pointer(draw)).Fbits_per_pixel = uint32(0) /* don't find out unless we need to know */
	(*TXftDraw)(unsafe.Pointer(draw)).Fvisual = visual
	(*TXftDraw)(unsafe.Pointer(draw)).Fcolormap = colormap
	(*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict = uint64(0)
	(*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc = libc.UintptrFromInt32(0)
	(*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fuse_pixmap = 0
	(*TXftDraw)(unsafe.Pointer(draw)).Fclip_type = int32(_XftClipTypeNone)
	(*TXftDraw)(unsafe.Pointer(draw)).Fsubwindow_mode = m_ClipByChildren
	XXftMemAlloc(tls, int32(_XFT_MEM_DRAW), uint64(96))
	return draw
}

func XXftDrawCreateBitmap(tls *libc.TLS, dpy uintptr, bitmap TPixmap) (r uintptr) {
	var draw uintptr
	_ = draw
	draw = libc.Xmalloc(tls, uint64(96))
	if !(draw != 0) {
		return libc.UintptrFromInt32(0)
	}
	(*TXftDraw)(unsafe.Pointer(draw)).Fdpy = dpy
	(*TXftDraw)(unsafe.Pointer(draw)).Fdrawable = bitmap
	(*TXftDraw)(unsafe.Pointer(draw)).Fscreen = __XftDrawScreen(tls, dpy, bitmap, libc.UintptrFromInt32(0))
	(*TXftDraw)(unsafe.Pointer(draw)).Fdepth = uint32(1)
	(*TXftDraw)(unsafe.Pointer(draw)).Fbits_per_pixel = uint32(1)
	(*TXftDraw)(unsafe.Pointer(draw)).Fvisual = libc.UintptrFromInt32(0)
	(*TXftDraw)(unsafe.Pointer(draw)).Fcolormap = uint64(0)
	(*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict = uint64(0)
	(*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc = libc.UintptrFromInt32(0)
	(*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fuse_pixmap = 0
	(*TXftDraw)(unsafe.Pointer(draw)).Fclip_type = int32(_XftClipTypeNone)
	(*TXftDraw)(unsafe.Pointer(draw)).Fsubwindow_mode = m_ClipByChildren
	XXftMemAlloc(tls, int32(_XFT_MEM_DRAW), uint64(96))
	return draw
}

func XXftDrawCreateAlpha(tls *libc.TLS, dpy uintptr, pixmap TPixmap, depth int32) (r uintptr) {
	var draw uintptr
	_ = draw
	draw = libc.Xmalloc(tls, uint64(96))
	if !(draw != 0) {
		return libc.UintptrFromInt32(0)
	}
	(*TXftDraw)(unsafe.Pointer(draw)).Fdpy = dpy
	(*TXftDraw)(unsafe.Pointer(draw)).Fdrawable = pixmap
	(*TXftDraw)(unsafe.Pointer(draw)).Fscreen = __XftDrawScreen(tls, dpy, pixmap, libc.UintptrFromInt32(0))
	(*TXftDraw)(unsafe.Pointer(draw)).Fdepth = uint32(depth)
	(*TXftDraw)(unsafe.Pointer(draw)).Fbits_per_pixel = uint32(0) /* don't find out until we need it */
	(*TXftDraw)(unsafe.Pointer(draw)).Fvisual = libc.UintptrFromInt32(0)
	(*TXftDraw)(unsafe.Pointer(draw)).Fcolormap = uint64(0)
	(*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict = uint64(0)
	(*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc = libc.UintptrFromInt32(0)
	(*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fuse_pixmap = 0
	(*TXftDraw)(unsafe.Pointer(draw)).Fclip_type = int32(_XftClipTypeNone)
	(*TXftDraw)(unsafe.Pointer(draw)).Fsubwindow_mode = m_ClipByChildren
	XXftMemAlloc(tls, int32(_XFT_MEM_DRAW), uint64(96))
	return draw
}

func __XftDrawFormat(tls *libc.TLS, draw uintptr) (r uintptr) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var info uintptr
	var _ /* pf at bp+0 */ TXRenderPictFormat
	_ = info
	info = X_XftDisplayInfoGet(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, int32(m_True))
	if !(info != 0) || !((*TXftDisplayInfo)(unsafe.Pointer(info)).FhasRender != 0) {
		return libc.UintptrFromInt32(0)
	}
	if (*TXftDraw)(unsafe.Pointer(draw)).Fvisual == libc.UintptrFromInt32(0) {
		(*(*TXRenderPictFormat)(unsafe.Pointer(bp))).Ftype1 = int32(m_PictTypeDirect)
		(*(*TXRenderPictFormat)(unsafe.Pointer(bp))).Fdepth = int32(XXftDrawDepth(tls, draw))
		(*(*TXRenderPictFormat)(unsafe.Pointer(bp))).Fdirect.Falpha = 0
		(*(*TXRenderPictFormat)(unsafe.Pointer(bp))).Fdirect.FalphaMask = int16(libc.Int32FromInt32(1)<<(*(*TXRenderPictFormat)(unsafe.Pointer(bp))).Fdepth - libc.Int32FromInt32(1))
		return libxrender.XXRenderFindFormat(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, uint64(libc.Int32FromInt32(1)<<libc.Int32FromInt32(1)|libc.Int32FromInt32(1)<<libc.Int32FromInt32(2)|libc.Int32FromInt32(1)<<libc.Int32FromInt32(9)|libc.Int32FromInt32(1)<<libc.Int32FromInt32(10)), bp, 0)
	} else {
		return libxrender.XXRenderFindVisualFormat(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fvisual)
	}
	return r
}

func XXftDrawChange(tls *libc.TLS, draw uintptr, drawable TDrawable) {
	(*TXftDraw)(unsafe.Pointer(draw)).Fdrawable = drawable
	if (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict != 0 {
		libxrender.XXRenderFreePicture(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict)
		(*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict = uint64(0)
	}
	if (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc != 0 {
		libx11.XXFreeGC(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc)
		(*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc = libc.UintptrFromInt32(0)
	}
}

func XXftDrawDisplay(tls *libc.TLS, draw uintptr) (r uintptr) {
	return (*TXftDraw)(unsafe.Pointer(draw)).Fdpy
}

func XXftDrawDrawable(tls *libc.TLS, draw uintptr) (r TDrawable) {
	return (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable
}

func XXftDrawColormap(tls *libc.TLS, draw uintptr) (r TColormap) {
	return (*TXftDraw)(unsafe.Pointer(draw)).Fcolormap
}

func XXftDrawVisual(tls *libc.TLS, draw uintptr) (r uintptr) {
	return (*TXftDraw)(unsafe.Pointer(draw)).Fvisual
}

func XXftDrawDestroy(tls *libc.TLS, draw uintptr) {
	if (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict != 0 {
		libxrender.XXRenderFreePicture(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict)
	}
	if (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc != 0 {
		libx11.XXFreeGC(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc)
	}
	switch (*TXftDraw)(unsafe.Pointer(draw)).Fclip_type {
	case int32(_XftClipTypeRegion):
		libx11.XXDestroyRegion(tls, *(*TRegion)(unsafe.Pointer(draw + 56)))
	case int32(_XftClipTypeRectangles):
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(draw + 56)))
	case int32(_XftClipTypeNone):
		break
	}
	XXftMemFree(tls, int32(_XFT_MEM_DRAW), uint64(96))
	libc.Xfree(tls, draw)
}

func XXftDrawSrcPicture(tls *libc.TLS, draw uintptr, color uintptr) (r TPicture) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var dpy, info uintptr
	var i int32
	var pix TPixmap
	var _ /* bitmapColor at bp+0 */ TXftColor
	var _ /* pa at bp+16 */ TXRenderPictureAttributes
	_, _, _, _ = dpy, i, info, pix
	dpy = (*TXftDraw)(unsafe.Pointer(draw)).Fdpy
	info = X_XftDisplayInfoGet(tls, dpy, int32(m_True))
	if !(info != 0) || !((*TXftDisplayInfo)(unsafe.Pointer(info)).FsolidFormat != 0) {
		return uint64(0)
	}
	/*
	 * Monochrome targets require special handling; the PictOp controls
	 * the color, and the color must be opaque
	 */
	if !((*TXftDraw)(unsafe.Pointer(draw)).Fvisual != 0) && (*TXftDraw)(unsafe.Pointer(draw)).Fdepth == uint32(1) {
		(*(*TXftColor)(unsafe.Pointer(bp))).Fcolor.Falpha = uint16(0xffff)
		(*(*TXftColor)(unsafe.Pointer(bp))).Fcolor.Fred = uint16(0xffff)
		(*(*TXftColor)(unsafe.Pointer(bp))).Fcolor.Fgreen = uint16(0xffff)
		(*(*TXftColor)(unsafe.Pointer(bp))).Fcolor.Fblue = uint16(0xffff)
		color = bp
	}
	/*
	 * See if there's one already available
	 */
	i = 0
	for {
		if !(i < int32(m_XFT_NUM_SOLID_COLOR)) {
			break
		}
		if (*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fpict != 0 && (*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fscreen == (*TXftDraw)(unsafe.Pointer(draw)).Fscreen && !(libc.Xmemcmp(tls, color+8, info+88+uintptr(i)*24, uint64(8)) != 0) {
			return (*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fpict
		}
		goto _1
	_1:
		;
		i++
	}
	/*
	 * Pick one to replace at random
	 */
	i = int32(uint32(libc.Xrand(tls)) % uint32(m_XFT_NUM_SOLID_COLOR))
	if (*TXftDisplayInfo)(unsafe.Pointer(info)).FhasSolid != 0 {
		/*
		 * Free any existing entry
		 */
		if (*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fpict != 0 {
			libxrender.XXRenderFreePicture(tls, dpy, (*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fpict)
		}
		/*
		 * Create picture
		 */
		(*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fpict = libxrender.XXRenderCreateSolidFill(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, color+8)
	} else {
		if (*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fscreen != (*TXftDraw)(unsafe.Pointer(draw)).Fscreen && (*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fpict != 0 {
			libxrender.XXRenderFreePicture(tls, dpy, (*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fpict)
			(*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fpict = uint64(0)
		}
		/*
		 * Create picture if necessary
		 */
		if !((*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fpict != 0) {
			pix = libx11.XXCreatePixmap(tls, dpy, (*TScreen)(unsafe.Pointer((*struct {
				Fext_data            uintptr
				Fprivate1            uintptr
				Ffd                  int32
				Fprivate2            int32
				Fproto_major_version int32
				Fproto_minor_version int32
				Fvendor              uintptr
				Fprivate3            TXID
				Fprivate4            TXID
				Fprivate5            TXID
				Fprivate6            int32
				Fresource_alloc      uintptr
				Fbyte_order          int32
				Fbitmap_unit         int32
				Fbitmap_pad          int32
				Fbitmap_bit_order    int32
				Fnformats            int32
				Fpixmap_format       uintptr
				Fprivate8            int32
				Frelease             int32
				Fprivate9            uintptr
				Fprivate10           uintptr
				Fqlen                int32
				Flast_request_read   uint64
				Frequest             uint64
				Fprivate11           TXPointer
				Fprivate12           TXPointer
				Fprivate13           TXPointer
				Fprivate14           TXPointer
				Fmax_request_size    uint32
				Fdb                  uintptr
				Fprivate15           uintptr
				Fdisplay_name        uintptr
				Fdefault_screen      int32
				Fnscreens            int32
				Fscreens             uintptr
				Fmotion_buffer       uint64
				Fprivate16           uint64
				Fmin_keycode         int32
				Fmax_keycode         int32
				Fprivate17           TXPointer
				Fprivate18           TXPointer
				Fprivate19           int32
				Fxdefaults           uintptr
			})(unsafe.Pointer(dpy)).Fscreens+uintptr((*TXftDraw)(unsafe.Pointer(draw)).Fscreen)*128)).Froot, uint32(1), uint32(1), uint32((*TXRenderPictFormat)(unsafe.Pointer((*TXftDisplayInfo)(unsafe.Pointer(info)).FsolidFormat)).Fdepth))
			(*(*TXRenderPictureAttributes)(unsafe.Pointer(bp + 16))).Frepeat = int32(m_True)
			(*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fpict = libxrender.XXRenderCreatePicture(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, pix, (*TXftDisplayInfo)(unsafe.Pointer(info)).FsolidFormat, uint64(libc.Int32FromInt32(1)<<libc.Int32FromInt32(0)), bp+16)
			libx11.XXFreePixmap(tls, dpy, pix)
		}
		/*
		 * Set to the new color
		 */
		(*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fcolor = (*TXftColor)(unsafe.Pointer(color)).Fcolor
		(*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fscreen = (*TXftDraw)(unsafe.Pointer(draw)).Fscreen
		libxrender.XXRenderFillRectangle(tls, dpy, int32(m_PictOpSrc), (*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fpict, color+8, 0, 0, uint32(1), uint32(1))
	}
	(*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fcolor = (*TXftColor)(unsafe.Pointer(color)).Fcolor
	(*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fscreen = (*TXftDraw)(unsafe.Pointer(draw)).Fscreen
	return (*(*TXftSolidColor)(unsafe.Pointer(info + 88 + uintptr(i)*24))).Fpict
}

func __XftDrawOp(tls *libc.TLS, draw uintptr, color uintptr) (r int32) {
	if (*TXftDraw)(unsafe.Pointer(draw)).Fvisual != 0 || (*TXftDraw)(unsafe.Pointer(draw)).Fdepth != uint32(1) {
		return int32(m_PictOpOver)
	}
	if int32((*TXftColor)(unsafe.Pointer(color)).Fcolor.Falpha) >= int32(0x8000) {
		return int32(m_PictOpOver)
	}
	return int32(m_PictOpOutReverse)
}

func __XftDrawRenderPrepare(tls *libc.TLS, draw uintptr) (r TFcBool) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var format uintptr
	var mask uint64
	var _ /* pa at bp+0 */ TXRenderPictureAttributes
	_, _ = format, mask
	if !((*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict != 0) {
		mask = uint64(0)
		format = __XftDrawFormat(tls, draw)
		if !(format != 0) {
			return m_FcFalse
		}
		if (*TXftDraw)(unsafe.Pointer(draw)).Fsubwindow_mode == int32(m_IncludeInferiors) {
			(*(*TXRenderPictureAttributes)(unsafe.Pointer(bp))).Fsubwindow_mode = int32(m_IncludeInferiors)
			mask |= uint64(libc.Int32FromInt32(1) << libc.Int32FromInt32(8))
		}
		(*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict = libxrender.XXRenderCreatePicture(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, format, mask, bp)
		if !((*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict != 0) {
			return m_FcFalse
		}
		switch (*TXftDraw)(unsafe.Pointer(draw)).Fclip_type {
		case int32(_XftClipTypeRegion):
			libxrender.XXRenderSetPictureClipRegion(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict, *(*TRegion)(unsafe.Pointer(draw + 56)))
		case int32(_XftClipTypeRectangles):
			libxrender.XXRenderSetPictureClipRectangles(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict, (*TXftClipRect)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(draw + 56)))).FxOrigin, (*TXftClipRect)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(draw + 56)))).FyOrigin, *(*uintptr)(unsafe.Pointer(draw + 56))+libc.UintptrFromInt32(1)*12, (*TXftClipRect)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(draw + 56)))).Fn)
		case int32(_XftClipTypeNone):
			break
		}
	}
	return int32(m_FcTrue)
}

func __XftDrawCorePrepare(tls *libc.TLS, draw uintptr, color uintptr) (r TFcBool) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var mask uint64
	var _ /* gcv at bp+0 */ TXGCValues
	_ = mask
	if !((*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc != 0) {
		mask = uint64(0)
		if (*TXftDraw)(unsafe.Pointer(draw)).Fsubwindow_mode == int32(m_IncludeInferiors) {
			(*(*TXGCValues)(unsafe.Pointer(bp))).Fsubwindow_mode = int32(m_IncludeInferiors)
			mask |= uint64(libc.Int64FromInt64(1) << libc.Int32FromInt32(15))
		}
		(*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc = libx11.XXCreateGC(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, mask, bp)
		if !((*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc != 0) {
			return m_FcFalse
		}
		switch (*TXftDraw)(unsafe.Pointer(draw)).Fclip_type {
		case int32(_XftClipTypeRegion):
			libx11.XXSetRegion(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, *(*TRegion)(unsafe.Pointer(draw + 56)))
		case int32(_XftClipTypeRectangles):
			libx11.XXSetClipRectangles(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, (*TXftClipRect)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(draw + 56)))).FxOrigin, (*TXftClipRect)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(draw + 56)))).FyOrigin, *(*uintptr)(unsafe.Pointer(draw + 56))+libc.UintptrFromInt32(1)*12, (*TXftClipRect)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(draw + 56)))).Fn, m_Unsorted)
		case int32(_XftClipTypeNone):
			break
		}
	}
	libx11.XXSetForeground(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, (*TXftColor)(unsafe.Pointer(color)).Fpixel)
	return int32(m_FcTrue)
}

func XXftDrawPicture(tls *libc.TLS, draw uintptr) (r TPicture) {
	if !(__XftDrawRenderPrepare(tls, draw) != 0) {
		return uint64(0)
	}
	return (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict
}

func XXftDrawGlyphs(tls *libc.TLS, draw uintptr, color uintptr, pub uintptr, x int32, y int32, glyphs uintptr, nglyphs int32) {
	var font uintptr
	var src, v1 TPicture
	var v2 bool
	_, _, _, _ = font, src, v1, v2
	font = pub
	if (*TXftFontInt)(unsafe.Pointer(font)).Fformat != 0 {
		if v2 = __XftDrawRenderPrepare(tls, draw) != 0; v2 {
			v1 = XXftDrawSrcPicture(tls, draw, color)
			src = v1
		}
		if v2 && v1 != 0 {
			XXftGlyphRender(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, __XftDrawOp(tls, draw, color), src, pub, (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict, 0, 0, x, y, glyphs, nglyphs)
		}
	} else {
		if __XftDrawCorePrepare(tls, draw, color) != 0 {
			XXftGlyphCore(tls, draw, color, pub, x, y, glyphs, nglyphs)
		}
	}
}

func XXftDrawString8(tls *libc.TLS, draw uintptr, color uintptr, pub uintptr, x int32, y int32, string1 uintptr, len1 int32) {
	bp := tls.Alloc(4128)
	defer tls.Free(4128)
	var glyphs uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	_, _ = glyphs, i
	if XXftDebug(tls)&int32(m_XFT_DBG_DRAW) != 0 {
		libc.Xprintf(tls, __ccgo_ts+669, libc.VaList(bp+4104, len1, len1, string1))
	}
	if len1 <= int32(m_NUM_LOCAL) {
		glyphs = bp
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(4))
		if !(glyphs != 0) {
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4)) = XXftCharIndex(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, pub, uint32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i)))))
		goto _1
	_1:
		;
		i++
	}
	XXftDrawGlyphs(tls, draw, color, pub, x, y, glyphs, len1)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftDrawString16(tls *libc.TLS, draw uintptr, color uintptr, pub uintptr, x int32, y int32, string1 uintptr, len1 int32) {
	bp := tls.Alloc(4096)
	defer tls.Free(4096)
	var glyphs uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	_, _ = glyphs, i
	if len1 <= 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		glyphs = bp
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(4))
		if !(glyphs != 0) {
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4)) = XXftCharIndex(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, pub, uint32(*(*TFcChar16)(unsafe.Pointer(string1 + uintptr(i)*2))))
		goto _1
	_1:
		;
		i++
	}
	XXftDrawGlyphs(tls, draw, color, pub, x, y, glyphs, len1)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftDrawString32(tls *libc.TLS, draw uintptr, color uintptr, pub uintptr, x int32, y int32, string1 uintptr, len1 int32) {
	bp := tls.Alloc(4096)
	defer tls.Free(4096)
	var glyphs uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	_, _ = glyphs, i
	if len1 <= 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		glyphs = bp
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(4))
		if !(glyphs != 0) {
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4)) = XXftCharIndex(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, pub, *(*TFcChar32)(unsafe.Pointer(string1 + uintptr(i)*4)))
		goto _1
	_1:
		;
		i++
	}
	XXftDrawGlyphs(tls, draw, color, pub, x, y, glyphs, len1)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftDrawStringUtf8(tls *libc.TLS, draw uintptr, color uintptr, pub uintptr, x int32, y int32, string1 uintptr, len1 int32) {
	bp := tls.Alloc(4112)
	defer tls.Free(4112)
	var glyphs, glyphs_new uintptr
	var i, l, size, v1, v3 int32
	var v2 bool
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	var _ /* ucs4 at bp+4096 */ TFcChar32
	_, _, _, _, _, _, _, _ = glyphs, glyphs_new, i, l, size, v1, v2, v3
	if len1 <= 0 {
		return
	}
	i = 0
	glyphs = bp
	size = int32(m_NUM_LOCAL)
	for {
		if v2 = len1 != 0; v2 {
			v1 = libfontconfig.XFcUtf8ToUcs4(tls, string1, bp+4096, len1)
			l = v1
		}
		if !(v2 && v1 > 0) {
			break
		}
		if i == size {
			glyphs_new = libc.Xmalloc(tls, uint64(size*libc.Int32FromInt32(2))*uint64(4))
			if !(glyphs_new != 0) {
				if glyphs != bp {
					libc.Xfree(tls, glyphs)
				}
				return
			}
			libc.X__builtin___memcpy_chk(tls, glyphs_new, glyphs, uint64(size)*uint64(4), uint64(libc.X__builtin_object_size(tls, glyphs_new, 0)))
			size *= int32(2)
			if glyphs != bp {
				libc.Xfree(tls, glyphs)
			}
			glyphs = glyphs_new
		}
		v3 = i
		i++
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(v3)*4)) = XXftCharIndex(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, pub, *(*TFcChar32)(unsafe.Pointer(bp + 4096)))
		string1 += uintptr(l)
		len1 -= l
	}
	XXftDrawGlyphs(tls, draw, color, pub, x, y, glyphs, i)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftDrawStringUtf16(tls *libc.TLS, draw uintptr, color uintptr, pub uintptr, x int32, y int32, string1 uintptr, endian TFcEndian, len1 int32) {
	bp := tls.Alloc(4112)
	defer tls.Free(4112)
	var glyphs, glyphs_new uintptr
	var i, l, size, v1, v3 int32
	var v2 bool
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	var _ /* ucs4 at bp+4096 */ TFcChar32
	_, _, _, _, _, _, _, _ = glyphs, glyphs_new, i, l, size, v1, v2, v3
	if len1 <= 0 {
		return
	}
	i = 0
	glyphs = bp
	size = int32(m_NUM_LOCAL)
	for {
		if v2 = len1 != 0; v2 {
			v1 = libfontconfig.XFcUtf16ToUcs4(tls, string1, endian, bp+4096, len1)
			l = v1
		}
		if !(v2 && v1 > 0) {
			break
		}
		if i == size {
			glyphs_new = libc.Xmalloc(tls, uint64(size*libc.Int32FromInt32(2))*uint64(4))
			if !(glyphs_new != 0) {
				if glyphs != bp {
					libc.Xfree(tls, glyphs)
				}
				return
			}
			libc.X__builtin___memcpy_chk(tls, glyphs_new, glyphs, uint64(size)*uint64(4), uint64(libc.X__builtin_object_size(tls, glyphs_new, 0)))
			size *= int32(2)
			if glyphs != bp {
				libc.Xfree(tls, glyphs)
			}
			glyphs = glyphs_new
		}
		v3 = i
		i++
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(v3)*4)) = XXftCharIndex(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, pub, *(*TFcChar32)(unsafe.Pointer(bp + 4096)))
		string1 += uintptr(l)
		len1 -= l
	}
	XXftDrawGlyphs(tls, draw, color, pub, x, y, glyphs, i)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftDrawGlyphSpec(tls *libc.TLS, draw uintptr, color uintptr, pub uintptr, glyphs uintptr, len1 int32) {
	var font uintptr
	var src, v1 TPicture
	var v2 bool
	_, _, _, _ = font, src, v1, v2
	font = pub
	if (*TXftFontInt)(unsafe.Pointer(font)).Fformat != 0 {
		if v2 = __XftDrawRenderPrepare(tls, draw) != 0; v2 {
			v1 = XXftDrawSrcPicture(tls, draw, color)
			src = v1
		}
		if v2 && v1 != 0 {
			XXftGlyphSpecRender(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, __XftDrawOp(tls, draw, color), src, pub, (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict, 0, 0, glyphs, len1)
		}
	} else {
		if __XftDrawCorePrepare(tls, draw, color) != 0 {
			XXftGlyphSpecCore(tls, draw, color, pub, glyphs, len1)
		}
	}
}

func XXftDrawGlyphFontSpec(tls *libc.TLS, draw uintptr, color uintptr, glyphs uintptr, len1 int32) {
	var i, start int32
	var src, v1 TPicture
	var v2 bool
	_, _, _, _, _ = i, src, start, v1, v2
	i = 0
	for i < len1 {
		start = i
		if (*TXftFontInt)(unsafe.Pointer((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont)).Fformat != 0 {
			for i < len1 && (*TXftFontInt)(unsafe.Pointer((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont)).Fformat != 0 {
				i++
			}
			if v2 = __XftDrawRenderPrepare(tls, draw) != 0; v2 {
				v1 = XXftDrawSrcPicture(tls, draw, color)
				src = v1
			}
			if v2 && v1 != 0 {
				XXftGlyphFontSpecRender(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, __XftDrawOp(tls, draw, color), src, (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict, 0, 0, glyphs+uintptr(start)*16, i-start)
			}
		} else {
			for i < len1 && !((*TXftFontInt)(unsafe.Pointer((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont)).Fformat != 0) {
				i++
			}
			if __XftDrawCorePrepare(tls, draw, color) != 0 {
				XXftGlyphFontSpecCore(tls, draw, color, glyphs+uintptr(start)*16, i-start)
			}
		}
	}
}

func XXftDrawCharSpec(tls *libc.TLS, draw uintptr, color uintptr, pub uintptr, chars uintptr, len1 int32) {
	bp := tls.Alloc(8192)
	defer tls.Free(8192)
	var glyphs uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TXftGlyphSpec
	_, _ = glyphs, i
	if len1 <= 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		glyphs = bp
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(8))
		if !(glyphs != 0) {
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		(*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fglyph = XXftCharIndex(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, pub, (*(*TXftCharSpec)(unsafe.Pointer(chars + uintptr(i)*8))).Fucs4)
		(*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fx = (*(*TXftCharSpec)(unsafe.Pointer(chars + uintptr(i)*8))).Fx
		(*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fy = (*(*TXftCharSpec)(unsafe.Pointer(chars + uintptr(i)*8))).Fy
		goto _1
	_1:
		;
		i++
	}
	XXftDrawGlyphSpec(tls, draw, color, pub, glyphs, len1)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftDrawCharFontSpec(tls *libc.TLS, draw uintptr, color uintptr, chars uintptr, len1 int32) {
	bp := tls.Alloc(16384)
	defer tls.Free(16384)
	var glyphs uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TXftGlyphFontSpec
	_, _ = glyphs, i
	if len1 <= 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		glyphs = bp
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(16))
		if !(glyphs != 0) {
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		(*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont = (*(*TXftCharFontSpec)(unsafe.Pointer(chars + uintptr(i)*16))).Ffont
		(*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fglyph = XXftCharIndex(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont, (*(*TXftCharFontSpec)(unsafe.Pointer(chars + uintptr(i)*16))).Fucs4)
		(*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fx = (*(*TXftCharFontSpec)(unsafe.Pointer(chars + uintptr(i)*16))).Fx
		(*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fy = (*(*TXftCharFontSpec)(unsafe.Pointer(chars + uintptr(i)*16))).Fy
		goto _1
	_1:
		;
		i++
	}
	XXftDrawGlyphFontSpec(tls, draw, color, glyphs, len1)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftDrawRect(tls *libc.TLS, draw uintptr, color uintptr, x int32, y int32, width uint32, height uint32) {
	if __XftDrawRenderPrepare(tls, draw) != 0 {
		libxrender.XXRenderFillRectangle(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, int32(m_PictOpSrc), (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict, color+8, x, y, width, height)
	} else {
		if __XftDrawCorePrepare(tls, draw, color) != 0 {
			/* note: not XftRectCore() */
			libx11.XXSetForeground(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, (*TXftColor)(unsafe.Pointer(color)).Fpixel)
			libx11.XXFillRectangle(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fdrawable, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, x, y, width, height)
		}
	}
}

func XXftDrawSetClip(tls *libc.TLS, draw uintptr, r TRegion) (r1 int32) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var n TRegion
	var _ /* pa at bp+0 */ TXRenderPictureAttributes
	_ = n
	n = libc.UintptrFromInt32(0)
	/*
	 * Check for quick exits
	 */
	if !(r != 0) && (*TXftDraw)(unsafe.Pointer(draw)).Fclip_type == int32(_XftClipTypeNone) {
		return int32(m_True)
	}
	if r != 0 && (*TXftDraw)(unsafe.Pointer(draw)).Fclip_type == int32(_XftClipTypeRegion) && libx11.XXEqualRegion(tls, r, *(*TRegion)(unsafe.Pointer(draw + 56))) != 0 {
		return int32(m_True)
	}
	/*
	 * Duplicate the region so future changes can be short circuited
	 */
	if r != 0 {
		n = libx11.XXCreateRegion(tls)
		if n != 0 {
			if !(libx11.XXUnionRegion(tls, n, r, n) != 0) {
				libx11.XXDestroyRegion(tls, n)
				return m_False
			}
		}
	}
	/*
	 * Destroy existing clip
	 */
	switch (*TXftDraw)(unsafe.Pointer(draw)).Fclip_type {
	case int32(_XftClipTypeRegion):
		libx11.XXDestroyRegion(tls, *(*TRegion)(unsafe.Pointer(draw + 56)))
	case int32(_XftClipTypeRectangles):
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(draw + 56)))
	case int32(_XftClipTypeNone):
		break
	}
	/*
	 * Set the clip
	 */
	if n != 0 {
		(*TXftDraw)(unsafe.Pointer(draw)).Fclip_type = int32(_XftClipTypeRegion)
		*(*TRegion)(unsafe.Pointer(draw + 56)) = n
	} else {
		(*TXftDraw)(unsafe.Pointer(draw)).Fclip_type = int32(_XftClipTypeNone)
	}
	/*
	 * Apply new clip to existing objects
	 */
	if (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict != 0 {
		if n != 0 {
			libxrender.XXRenderSetPictureClipRegion(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict, n)
		} else {
			(*(*TXRenderPictureAttributes)(unsafe.Pointer(bp))).Fclip_mask = uint64(0)
			libxrender.XXRenderChangePicture(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict, uint64(libc.Int32FromInt32(1)<<libc.Int32FromInt32(6)), bp)
		}
	}
	if (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc != 0 {
		if n != 0 {
			libx11.XXSetRegion(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, *(*TRegion)(unsafe.Pointer(draw + 56)))
		} else {
			libx11.XXSetClipMask(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, uint64(0))
		}
	}
	return int32(m_True)
}

func XXftDrawSetClipRectangles(tls *libc.TLS, draw uintptr, xOrigin int32, yOrigin int32, rects uintptr, n int32) (r int32) {
	var new1 uintptr
	_ = new1
	new1 = libc.UintptrFromInt32(0)
	/*
	 * Check for quick exit
	 */
	if (*TXftDraw)(unsafe.Pointer(draw)).Fclip_type == int32(_XftClipTypeRectangles) && (*TXftClipRect)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(draw + 56)))).Fn == n && (n == 0 || (*TXftClipRect)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(draw + 56)))).FxOrigin == xOrigin && (*TXftClipRect)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(draw + 56)))).FyOrigin == yOrigin) && !(libc.Xmemcmp(tls, *(*uintptr)(unsafe.Pointer(draw + 56))+libc.UintptrFromInt32(1)*12, rects, uint64(n)*uint64(8)) != 0) {
		return int32(m_True)
	}
	/*
	 * Duplicate the region so future changes can be short circuited
	 */
	new1 = libc.Xmalloc(tls, uint64(12)+uint64(n)*uint64(8))
	if !(new1 != 0) {
		return m_False
	}
	(*TXftClipRect)(unsafe.Pointer(new1)).Fn = n
	(*TXftClipRect)(unsafe.Pointer(new1)).FxOrigin = xOrigin
	(*TXftClipRect)(unsafe.Pointer(new1)).FyOrigin = yOrigin
	libc.X__builtin___memcpy_chk(tls, new1+libc.UintptrFromInt32(1)*12, rects, uint64(n)*uint64(8), uint64(libc.X__builtin_object_size(tls, new1+libc.UintptrFromInt32(1)*12, 0)))
	/*
	 * Destroy existing clip
	 */
	switch (*TXftDraw)(unsafe.Pointer(draw)).Fclip_type {
	case int32(_XftClipTypeRegion):
		libx11.XXDestroyRegion(tls, *(*TRegion)(unsafe.Pointer(draw + 56)))
	case int32(_XftClipTypeRectangles):
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(draw + 56)))
	case int32(_XftClipTypeNone):
		break
	}
	/*
	 * Set the clip
	 */
	(*TXftDraw)(unsafe.Pointer(draw)).Fclip_type = int32(_XftClipTypeRectangles)
	*(*uintptr)(unsafe.Pointer(draw + 56)) = new1
	/*
	 * Apply new clip to existing objects
	 */
	if (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict != 0 {
		libxrender.XXRenderSetPictureClipRectangles(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict, (*TXftClipRect)(unsafe.Pointer(new1)).FxOrigin, (*TXftClipRect)(unsafe.Pointer(new1)).FyOrigin, new1+libc.UintptrFromInt32(1)*12, (*TXftClipRect)(unsafe.Pointer(new1)).Fn)
	}
	if (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc != 0 {
		libx11.XXSetClipRectangles(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, (*TXftClipRect)(unsafe.Pointer(new1)).FxOrigin, (*TXftClipRect)(unsafe.Pointer(new1)).FyOrigin, new1+libc.UintptrFromInt32(1)*12, (*TXftClipRect)(unsafe.Pointer(new1)).Fn, m_Unsorted)
	}
	return int32(m_True)
}

func XXftDrawSetSubwindowMode(tls *libc.TLS, draw uintptr, mode int32) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var _ /* pa at bp+0 */ TXRenderPictureAttributes
	if mode == (*TXftDraw)(unsafe.Pointer(draw)).Fsubwindow_mode {
		return
	}
	(*TXftDraw)(unsafe.Pointer(draw)).Fsubwindow_mode = mode
	if (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict != 0 {
		(*(*TXRenderPictureAttributes)(unsafe.Pointer(bp))).Fsubwindow_mode = mode
		libxrender.XXRenderChangePicture(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Frender.Fpict, uint64(libc.Int32FromInt32(1)<<libc.Int32FromInt32(8)), bp)
	}
	if (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc != 0 {
		libx11.XXSetSubwindowMode(tls, (*TXftDraw)(unsafe.Pointer(draw)).Fdpy, (*TXftDraw)(unsafe.Pointer(draw)).Fcore.Fgc, mode)
	}
}

const m_VisualIDMask2 = 0x1
const m_VisualScreenMask2 = 0x2

/* xftxlfd.c */
func XXftGlyphExtents(tls *libc.TLS, dpy uintptr, pub uintptr, glyphs uintptr, nglyphs int32, extents uintptr) {
	bp := tls.Alloc(1040)
	defer tls.Free(1040)
	var bottom, left, n, overall_bottom, overall_left, overall_right, overall_top, right, top, x, y, v1, v6 int32
	var font, g, xftg, v2, v3, v4, v7, v8 uintptr
	var glyph TFT_UInt
	var glyphs_loaded TFcBool
	var v5, v9 bool
	var _ /* missing at bp+0 */ [256]TFT_UInt
	var _ /* nmissing at bp+1024 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = bottom, font, g, glyph, glyphs_loaded, left, n, overall_bottom, overall_left, overall_right, overall_top, right, top, x, xftg, y, v1, v2, v3, v4, v5, v6, v7, v8, v9
	font = pub
	g = glyphs
	n = nglyphs
	*(*int32)(unsafe.Pointer(bp + 1024)) = 0
	glyphs_loaded = m_FcFalse
	for {
		v1 = n
		n--
		if !(v1 != 0) {
			break
		}
		v2 = g
		g += 4
		if XXftFontCheckGlyph(tls, dpy, pub, m_FcFalse, *(*TFT_UInt)(unsafe.Pointer(v2)), bp, bp+1024) != 0 {
			glyphs_loaded = int32(m_FcTrue)
		}
	}
	if *(*int32)(unsafe.Pointer(bp + 1024)) != 0 {
		XXftFontLoadGlyphs(tls, dpy, pub, m_FcFalse, bp, *(*int32)(unsafe.Pointer(bp + 1024)))
	}
	g = glyphs
	n = nglyphs
	xftg = libc.UintptrFromInt32(0)
	for n != 0 {
		v3 = g
		g += 4
		glyph = *(*TFT_UInt)(unsafe.Pointer(v3))
		n--
		if v5 = glyph < (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs; v5 {
			v4 = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(glyph)*8))
			xftg = v4
		}
		if v5 && v4 != 0 {
			break
		}
	}
	if n == 0 {
		if xftg != 0 {
			*(*TXGlyphInfo)(unsafe.Pointer(extents)) = (*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics
		} else {
			libc.X__builtin___memset_chk(tls, extents, int32('\000'), uint64(12), uint64(libc.X__builtin_object_size(tls, extents, 0)))
		}
	} else {
		x = 0
		y = 0
		overall_left = x - int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fx)
		overall_top = y - int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fy)
		overall_right = overall_left + int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fwidth)
		overall_bottom = overall_top + int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fheight)
		x += int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FxOff)
		y += int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FyOff)
		for {
			v6 = n
			n--
			if !(v6 != 0) {
				break
			}
			v7 = g
			g += 4
			glyph = *(*TFT_UInt)(unsafe.Pointer(v7))
			if v9 = glyph < (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs; v9 {
				v8 = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(glyph)*8))
				xftg = v8
			}
			if v9 && v8 != 0 {
				left = x - int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fx)
				top = y - int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fy)
				right = left + int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fwidth)
				bottom = top + int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fheight)
				if left < overall_left {
					overall_left = left
				}
				if top < overall_top {
					overall_top = top
				}
				if right > overall_right {
					overall_right = right
				}
				if bottom > overall_bottom {
					overall_bottom = bottom
				}
				x += int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FxOff)
				y += int32((*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FyOff)
			}
		}
		(*TXGlyphInfo)(unsafe.Pointer(extents)).Fx = int16(-overall_left)
		(*TXGlyphInfo)(unsafe.Pointer(extents)).Fy = int16(-overall_top)
		(*TXGlyphInfo)(unsafe.Pointer(extents)).Fwidth = uint16(overall_right - overall_left)
		(*TXGlyphInfo)(unsafe.Pointer(extents)).Fheight = uint16(overall_bottom - overall_top)
		(*TXGlyphInfo)(unsafe.Pointer(extents)).FxOff = int16(x)
		(*TXGlyphInfo)(unsafe.Pointer(extents)).FyOff = int16(y)
	}
	if glyphs_loaded != 0 {
		X_XftFontManageMemory(tls, dpy, pub)
	}
}

func XXftTextExtents8(tls *libc.TLS, dpy uintptr, pub uintptr, string1 uintptr, len1 int32, extents uintptr) {
	bp := tls.Alloc(4096)
	defer tls.Free(4096)
	var glyphs, v1 uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	_, _, _ = glyphs, i, v1
	if len1 < 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		v1 = bp
		glyphs = v1
		*(*TFT_UInt)(unsafe.Pointer(v1)) = uint32(0)
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(4))
		if !(glyphs != 0) {
			libc.X__builtin___memset_chk(tls, extents, int32('\000'), uint64(12), uint64(libc.X__builtin_object_size(tls, extents, 0)))
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4)) = XXftCharIndex(tls, dpy, pub, uint32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i)))))
		goto _2
	_2:
		;
		i++
	}
	XXftGlyphExtents(tls, dpy, pub, glyphs, len1, extents)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftTextExtents16(tls *libc.TLS, dpy uintptr, pub uintptr, string1 uintptr, len1 int32, extents uintptr) {
	bp := tls.Alloc(4096)
	defer tls.Free(4096)
	var glyphs, v1 uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	_, _, _ = glyphs, i, v1
	if len1 < 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		v1 = bp
		glyphs = v1
		*(*TFT_UInt)(unsafe.Pointer(v1)) = uint32(0)
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(4))
		if !(glyphs != 0) {
			libc.X__builtin___memset_chk(tls, extents, int32('\000'), uint64(12), uint64(libc.X__builtin_object_size(tls, extents, 0)))
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4)) = XXftCharIndex(tls, dpy, pub, uint32(*(*TFcChar16)(unsafe.Pointer(string1 + uintptr(i)*2))))
		goto _2
	_2:
		;
		i++
	}
	XXftGlyphExtents(tls, dpy, pub, glyphs, len1, extents)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftTextExtents32(tls *libc.TLS, dpy uintptr, pub uintptr, string1 uintptr, len1 int32, extents uintptr) {
	bp := tls.Alloc(4096)
	defer tls.Free(4096)
	var glyphs, v1 uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	_, _, _ = glyphs, i, v1
	if len1 < 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		v1 = bp
		glyphs = v1
		*(*TFT_UInt)(unsafe.Pointer(v1)) = uint32(0)
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(4))
		if !(glyphs != 0) {
			libc.X__builtin___memset_chk(tls, extents, int32('\000'), uint64(12), uint64(libc.X__builtin_object_size(tls, extents, 0)))
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4)) = XXftCharIndex(tls, dpy, pub, *(*TFcChar32)(unsafe.Pointer(string1 + uintptr(i)*4)))
		goto _2
	_2:
		;
		i++
	}
	XXftGlyphExtents(tls, dpy, pub, glyphs, len1, extents)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftTextExtentsUtf8(tls *libc.TLS, dpy uintptr, pub uintptr, string1 uintptr, len1 int32, extents uintptr) {
	bp := tls.Alloc(4112)
	defer tls.Free(4112)
	var glyphs, glyphs_new, v1 uintptr
	var i, l, size, v2, v4 int32
	var v3 bool
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	var _ /* ucs4 at bp+4096 */ TFcChar32
	_, _, _, _, _, _, _, _, _ = glyphs, glyphs_new, i, l, size, v1, v2, v3, v4
	if len1 < 0 {
		return
	}
	i = 0
	v1 = bp
	glyphs = v1
	*(*TFT_UInt)(unsafe.Pointer(v1)) = uint32(0)
	size = int32(m_NUM_LOCAL)
	for {
		if v3 = len1 != 0; v3 {
			v2 = libfontconfig.XFcUtf8ToUcs4(tls, string1, bp+4096, len1)
			l = v2
		}
		if !(v3 && v2 > 0) {
			break
		}
		if i == size {
			glyphs_new = libc.Xmalloc(tls, uint64(size*libc.Int32FromInt32(2))*uint64(4))
			if !(glyphs_new != 0) {
				if glyphs != bp {
					libc.Xfree(tls, glyphs)
				}
				libc.X__builtin___memset_chk(tls, extents, int32('\000'), uint64(12), uint64(libc.X__builtin_object_size(tls, extents, 0)))
				return
			}
			libc.X__builtin___memcpy_chk(tls, glyphs_new, glyphs, uint64(size)*uint64(4), uint64(libc.X__builtin_object_size(tls, glyphs_new, 0)))
			size *= int32(2)
			if glyphs != bp {
				libc.Xfree(tls, glyphs)
			}
			glyphs = glyphs_new
		}
		v4 = i
		i++
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(v4)*4)) = XXftCharIndex(tls, dpy, pub, *(*TFcChar32)(unsafe.Pointer(bp + 4096)))
		string1 += uintptr(l)
		len1 -= l
	}
	XXftGlyphExtents(tls, dpy, pub, glyphs, i, extents)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftTextExtentsUtf16(tls *libc.TLS, dpy uintptr, pub uintptr, string1 uintptr, endian TFcEndian, len1 int32, extents uintptr) {
	bp := tls.Alloc(4112)
	defer tls.Free(4112)
	var glyphs, glyphs_new, v1 uintptr
	var i, l, size, v2, v4 int32
	var v3 bool
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	var _ /* ucs4 at bp+4096 */ TFcChar32
	_, _, _, _, _, _, _, _, _ = glyphs, glyphs_new, i, l, size, v1, v2, v3, v4
	if len1 < 0 {
		return
	}
	i = 0
	v1 = bp
	glyphs = v1
	*(*TFT_UInt)(unsafe.Pointer(v1)) = uint32(0)
	size = int32(m_NUM_LOCAL)
	for {
		if v3 = len1 != 0; v3 {
			v2 = libfontconfig.XFcUtf16ToUcs4(tls, string1, endian, bp+4096, len1)
			l = v2
		}
		if !(v3 && v2 > 0) {
			break
		}
		if i == size {
			glyphs_new = libc.Xmalloc(tls, uint64(size*libc.Int32FromInt32(2))*uint64(4))
			if !(glyphs_new != 0) {
				if glyphs != bp {
					libc.Xfree(tls, glyphs)
				}
				libc.X__builtin___memset_chk(tls, extents, int32('\000'), uint64(12), uint64(libc.X__builtin_object_size(tls, extents, 0)))
				return
			}
			libc.X__builtin___memcpy_chk(tls, glyphs_new, glyphs, uint64(size)*uint64(4), uint64(libc.X__builtin_object_size(tls, glyphs_new, 0)))
			size *= int32(2)
			if glyphs != bp {
				libc.Xfree(tls, glyphs)
			}
			glyphs = glyphs_new
		}
		v4 = i
		i++
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(v4)*4)) = XXftCharIndex(tls, dpy, pub, *(*TFcChar32)(unsafe.Pointer(bp + 4096)))
		string1 += uintptr(l)
		len1 -= l
	}
	XXftGlyphExtents(tls, dpy, pub, glyphs, i, extents)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

/* xftxlfd.c */
func XXftFontMatch(tls *libc.TLS, dpy uintptr, screen int32, pattern uintptr, result uintptr) (r uintptr) {
	var match, new1 uintptr
	_, _ = match, new1
	if !(XXftInit(tls, libc.UintptrFromInt32(0)) != 0) {
		return libc.UintptrFromInt32(0)
	}
	new1 = libfontconfig.XFcPatternDuplicate(tls, pattern)
	if !(new1 != 0) {
		return libc.UintptrFromInt32(0)
	}
	if XXftDebug(tls)&int32(m_XFT_DBG_OPENV) != 0 {
		libc.Xprintf(tls, __ccgo_ts+689, 0)
		libfontconfig.XFcPatternPrint(tls, new1)
	}
	libfontconfig.XFcConfigSubstitute(tls, libc.UintptrFromInt32(0), new1, int32(_FcMatchPattern))
	if XXftDebug(tls)&int32(m_XFT_DBG_OPENV) != 0 {
		libc.Xprintf(tls, __ccgo_ts+711, 0)
		libfontconfig.XFcPatternPrint(tls, new1)
	}
	XXftDefaultSubstitute(tls, dpy, screen, new1)
	if XXftDebug(tls)&int32(m_XFT_DBG_OPENV) != 0 {
		libc.Xprintf(tls, __ccgo_ts+754, 0)
		libfontconfig.XFcPatternPrint(tls, new1)
	}
	match = libfontconfig.XFcFontMatch(tls, libc.UintptrFromInt32(0), new1, result)
	if XXftDebug(tls)&int32(m_XFT_DBG_OPENV) != 0 {
		libc.Xprintf(tls, __ccgo_ts+799, 0)
		libfontconfig.XFcPatternPrint(tls, match)
	}
	libfontconfig.XFcPatternDestroy(tls, new1)
	return match
}

func XXftFontOpen(tls *libc.TLS, dpy uintptr, screen int32, va1 uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var font, match, pat uintptr
	var va Tva_list
	var _ /* result at bp+0 */ TFcResult
	_, _, _, _ = font, match, pat, va
	va = va1
	pat = libfontconfig.XFcPatternVaBuild(tls, libc.UintptrFromInt32(0), va)
	_ = va
	if !(pat != 0) {
		if XXftDebug(tls)&int32(m_XFT_DBG_OPEN) != 0 {
			libc.Xprintf(tls, __ccgo_ts+820, 0)
		}
		return libc.UintptrFromInt32(0)
	}
	match = XXftFontMatch(tls, dpy, screen, pat, bp)
	if XXftDebug(tls)&int32(m_XFT_DBG_OPEN) != 0 {
		libc.Xprintf(tls, __ccgo_ts+859, 0)
		libfontconfig.XFcPatternPrint(tls, pat)
		if match != 0 {
			libc.Xprintf(tls, __ccgo_ts+868, 0)
			libfontconfig.XFcPatternPrint(tls, match)
		} else {
			libc.Xprintf(tls, __ccgo_ts+875, 0)
		}
	}
	libfontconfig.XFcPatternDestroy(tls, pat)
	if !(match != 0) {
		return libc.UintptrFromInt32(0)
	}
	font = XXftFontOpenPattern(tls, dpy, match)
	if !(font != 0) {
		if XXftDebug(tls)&int32(m_XFT_DBG_OPEN) != 0 {
			libc.Xprintf(tls, __ccgo_ts+885, 0)
		}
		libfontconfig.XFcPatternDestroy(tls, match)
	}
	return font
}

func XXftFontOpenName(tls *libc.TLS, dpy uintptr, screen int32, name uintptr) (r uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var font, match, pat uintptr
	var _ /* result at bp+0 */ TFcResult
	_, _, _ = font, match, pat
	pat = libfontconfig.XFcNameParse(tls, name)
	if XXftDebug(tls)&int32(m_XFT_DBG_OPEN) != 0 {
		libc.Xprintf(tls, __ccgo_ts+894, libc.VaList(bp+16, name))
		if pat != 0 {
			libfontconfig.XFcPatternPrint(tls, pat)
		} else {
			libc.Xprintf(tls, __ccgo_ts+917, 0)
		}
	}
	if !(pat != 0) {
		return libc.UintptrFromInt32(0)
	}
	match = XXftFontMatch(tls, dpy, screen, pat, bp)
	if XXftDebug(tls)&int32(m_XFT_DBG_OPEN) != 0 {
		if match != 0 {
			libc.Xprintf(tls, __ccgo_ts+868, 0)
			libfontconfig.XFcPatternPrint(tls, match)
		} else {
			libc.Xprintf(tls, __ccgo_ts+875, 0)
		}
	}
	libfontconfig.XFcPatternDestroy(tls, pat)
	if !(match != 0) {
		return libc.UintptrFromInt32(0)
	}
	font = XXftFontOpenPattern(tls, dpy, match)
	if !(font != 0) {
		if XXftDebug(tls)&int32(m_XFT_DBG_OPEN) != 0 {
			libc.Xprintf(tls, __ccgo_ts+885, 0)
		}
		libfontconfig.XFcPatternDestroy(tls, match)
	}
	return font
}

func XXftFontOpenXlfd(tls *libc.TLS, dpy uintptr, screen int32, xlfd uintptr) (r uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var font, match, pat uintptr
	var _ /* result at bp+0 */ TFcResult
	_, _, _ = font, match, pat
	pat = XXftXlfdParse(tls, xlfd, m_FcFalse, m_FcFalse)
	if XXftDebug(tls)&int32(m_XFT_DBG_OPEN) != 0 {
		libc.Xprintf(tls, __ccgo_ts+931, libc.VaList(bp+16, xlfd))
		if pat != 0 {
			libc.Xprintf(tls, __ccgo_ts+954, 0)
		} else {
			libfontconfig.XFcPatternPrint(tls, pat)
		}
	}
	if !(pat != 0) {
		return libc.UintptrFromInt32(0)
	}
	match = XXftFontMatch(tls, dpy, screen, pat, bp)
	if XXftDebug(tls)&int32(m_XFT_DBG_OPEN) != 0 {
		if match != 0 {
			libc.Xprintf(tls, __ccgo_ts+868, 0)
			libfontconfig.XFcPatternPrint(tls, match)
		} else {
			libc.Xprintf(tls, __ccgo_ts+875, 0)
		}
	}
	libfontconfig.XFcPatternDestroy(tls, pat)
	if !(match != 0) {
		return libc.UintptrFromInt32(0)
	}
	font = XXftFontOpenPattern(tls, dpy, match)
	if !(font != 0) {
		if XXftDebug(tls)&int32(m_XFT_DBG_OPEN) != 0 {
			libc.Xprintf(tls, __ccgo_ts+885, 0)
		}
		libfontconfig.XFcPatternDestroy(tls, match)
	}
	return font
}

const m_FT_LOAD_DEFAULT1 = 0
const m_XFT_EMBEDDED_BITMAP = "embeddedbitmap"

/*
 * List of all open files (each face in a file is managed separately)
 */

var __XftFtFiles uintptr
var _XftMaxFreeTypeFiles = int32(5)

func __XftGetFile(tls *libc.TLS, file uintptr, id int32) (r uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var f uintptr
	var v2, v3, v4 TFT_Fixed
	_, _, _, _ = f, v2, v3, v4
	if !(XXftInitFtLibrary(tls) != 0) {
		return libc.UintptrFromInt32(0)
	}
	f = __XftFtFiles
	for {
		if !(f != 0) {
			break
		}
		if !(libc.Xstrcmp(tls, (*TXftFtFile)(unsafe.Pointer(f)).Ffile, file) != 0) && (*TXftFtFile)(unsafe.Pointer(f)).Fid == id {
			(*TXftFtFile)(unsafe.Pointer(f)).Fref++
			if XXftDebug(tls)&int32(m_XFT_DBG_REF) != 0 {
				libc.Xprintf(tls, __ccgo_ts+968, libc.VaList(bp+8, file, id, (*TXftFtFile)(unsafe.Pointer(f)).Fref))
			}
			return f
		}
		goto _1
	_1:
		;
		f = (*TXftFtFile)(unsafe.Pointer(f)).Fnext
	}
	f = libc.Xmalloc(tls, uint64(96)+libc.Xstrlen(tls, file)+uint64(1))
	if !(f != 0) {
		return libc.UintptrFromInt32(0)
	}
	XXftMemAlloc(tls, int32(_XFT_MEM_FILE), uint64(96)+libc.Xstrlen(tls, file)+uint64(1))
	if XXftDebug(tls)&int32(m_XFT_DBG_REF) != 0 {
		libc.Xprintf(tls, __ccgo_ts+1006, libc.VaList(bp+8, file, id))
	}
	(*TXftFtFile)(unsafe.Pointer(f)).Fnext = __XftFtFiles
	__XftFtFiles = f
	(*TXftFtFile)(unsafe.Pointer(f)).Fref = int32(1)
	(*TXftFtFile)(unsafe.Pointer(f)).Ffile = f + libc.UintptrFromInt32(1)*96
	libc.X__builtin___strcpy_chk(tls, (*TXftFtFile)(unsafe.Pointer(f)).Ffile, file, libc.X__builtin_object_size(tls, (*TXftFtFile)(unsafe.Pointer(f)).Ffile, int32(1)))
	(*TXftFtFile)(unsafe.Pointer(f)).Fid = id
	(*TXftFtFile)(unsafe.Pointer(f)).Flock = 0
	(*TXftFtFile)(unsafe.Pointer(f)).Fface = libc.UintptrFromInt32(0)
	(*TXftFtFile)(unsafe.Pointer(f)).Fxsize = 0
	(*TXftFtFile)(unsafe.Pointer(f)).Fysize = 0
	v4 = libc.Int64FromInt32(0)
	(*TXftFtFile)(unsafe.Pointer(f)).Fmatrix.Fyy = v4
	v3 = v4
	(*TXftFtFile)(unsafe.Pointer(f)).Fmatrix.Fyx = v3
	v2 = v3
	(*TXftFtFile)(unsafe.Pointer(f)).Fmatrix.Fxy = v2
	(*TXftFtFile)(unsafe.Pointer(f)).Fmatrix.Fxx = v2
	return f
}

func __XftGetFaceFile(tls *libc.TLS, face TFT_Face) (r uintptr) {
	var f uintptr
	var v1, v2, v3 TFT_Fixed
	_, _, _, _ = f, v1, v2, v3
	f = libc.Xmalloc(tls, uint64(96))
	if !(f != 0) {
		return libc.UintptrFromInt32(0)
	}
	XXftMemAlloc(tls, int32(_XFT_MEM_FILE), uint64(96))
	(*TXftFtFile)(unsafe.Pointer(f)).Fnext = libc.UintptrFromInt32(0)
	(*TXftFtFile)(unsafe.Pointer(f)).Fref = int32(1)
	(*TXftFtFile)(unsafe.Pointer(f)).Ffile = libc.UintptrFromInt32(0)
	(*TXftFtFile)(unsafe.Pointer(f)).Fid = 0
	(*TXftFtFile)(unsafe.Pointer(f)).Flock = 0
	(*TXftFtFile)(unsafe.Pointer(f)).Fface = face
	(*TXftFtFile)(unsafe.Pointer(f)).Fxsize = 0
	(*TXftFtFile)(unsafe.Pointer(f)).Fysize = 0
	v3 = libc.Int64FromInt32(0)
	(*TXftFtFile)(unsafe.Pointer(f)).Fmatrix.Fyy = v3
	v2 = v3
	(*TXftFtFile)(unsafe.Pointer(f)).Fmatrix.Fyx = v2
	v1 = v2
	(*TXftFtFile)(unsafe.Pointer(f)).Fmatrix.Fxy = v1
	(*TXftFtFile)(unsafe.Pointer(f)).Fmatrix.Fxx = v1
	return f
}

func __XftNumFiles(tls *libc.TLS) (r int32) {
	var count int32
	var f uintptr
	_, _ = count, f
	count = 0
	f = __XftFtFiles
	for {
		if !(f != 0) {
			break
		}
		if (*TXftFtFile)(unsafe.Pointer(f)).Fface != 0 && !((*TXftFtFile)(unsafe.Pointer(f)).Flock != 0) {
			count++
		}
		goto _1
	_1:
		;
		f = (*TXftFtFile)(unsafe.Pointer(f)).Fnext
	}
	return count
}

func __XftNthFile(tls *libc.TLS, n int32) (r uintptr) {
	var count, v2 int32
	var f uintptr
	_, _, _ = count, f, v2
	count = 0
	f = __XftFtFiles
	for {
		if !(f != 0) {
			break
		}
		if (*TXftFtFile)(unsafe.Pointer(f)).Fface != 0 && !((*TXftFtFile)(unsafe.Pointer(f)).Flock != 0) {
			v2 = count
			count++
			if v2 == n {
				break
			}
		}
		goto _1
	_1:
		;
		f = (*TXftFtFile)(unsafe.Pointer(f)).Fnext
	}
	return f
}

func __XftUncacheFiles(tls *libc.TLS) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var f uintptr
	var n, v1, v2 int32
	_, _, _, _ = f, n, v1, v2
	for {
		v1 = __XftNumFiles(tls)
		n = v1
		if !(v1 > _XftMaxFreeTypeFiles) {
			break
		}
		if n != 0 {
			v2 = libc.Xrand(tls) % n
		} else {
			v2 = 0
		}
		f = __XftNthFile(tls, v2)
		if f != 0 {
			if XXftDebug(tls)&int32(m_XFT_DBG_REF) != 0 {
				libc.Xprintf(tls, __ccgo_ts+1034, libc.VaList(bp+8, (*TXftFtFile)(unsafe.Pointer(f)).Ffile, (*TXftFtFile)(unsafe.Pointer(f)).Fid))
			}
			libfreetype.XFT_Done_Face(tls, (*TXftFtFile)(unsafe.Pointer(f)).Fface)
			(*TXftFtFile)(unsafe.Pointer(f)).Fface = libc.UintptrFromInt32(0)
		}
	}
}

func __XftLockFile(tls *libc.TLS, f uintptr) (r TFT_Face) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var v1, v2, v3 TFT_Fixed
	_, _, _ = v1, v2, v3
	(*TXftFtFile)(unsafe.Pointer(f)).Flock++
	if !((*TXftFtFile)(unsafe.Pointer(f)).Fface != 0) {
		if XXftDebug(tls)&int32(m_XFT_DBG_REF) != 0 {
			libc.Xprintf(tls, __ccgo_ts+1065, libc.VaList(bp+8, (*TXftFtFile)(unsafe.Pointer(f)).Ffile, (*TXftFtFile)(unsafe.Pointer(f)).Fid))
		}
		if libfreetype.XFT_New_Face(tls, X_XftFTlibrary, (*TXftFtFile)(unsafe.Pointer(f)).Ffile, int64((*TXftFtFile)(unsafe.Pointer(f)).Fid), f+88) != 0 {
			(*TXftFtFile)(unsafe.Pointer(f)).Flock--
		}
		(*TXftFtFile)(unsafe.Pointer(f)).Fxsize = 0
		(*TXftFtFile)(unsafe.Pointer(f)).Fysize = 0
		v3 = libc.Int64FromInt32(0)
		(*TXftFtFile)(unsafe.Pointer(f)).Fmatrix.Fyy = v3
		v2 = v3
		(*TXftFtFile)(unsafe.Pointer(f)).Fmatrix.Fyx = v2
		v1 = v2
		(*TXftFtFile)(unsafe.Pointer(f)).Fmatrix.Fxy = v1
		(*TXftFtFile)(unsafe.Pointer(f)).Fmatrix.Fxx = v1
		__XftUncacheFiles(tls)
	}
	return (*TXftFtFile)(unsafe.Pointer(f)).Fface
}

func __XftLockError(tls *libc.TLS, reason uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+1085, libc.VaList(bp+8, reason))
}

func __XftUnlockFile(tls *libc.TLS, f uintptr) {
	var v1 int32
	var v2 uintptr
	_, _ = v1, v2
	v2 = f + 80
	*(*int32)(unsafe.Pointer(v2))--
	v1 = *(*int32)(unsafe.Pointer(v2))
	if v1 < 0 {
		__XftLockError(tls, __ccgo_ts+1108)
	}
}

func X_XftSetFace(tls *libc.TLS, f uintptr, xsize TFT_F26Dot6, ysize TFT_F26Dot6, matrix uintptr) (r TFcBool) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var best, i int32
	var face TFT_Face
	var v2, v3, v4, v5, v6, v7 int64
	var v8, v9 bool
	_, _, _, _, _, _, _, _, _, _, _ = best, face, i, v2, v3, v4, v5, v6, v7, v8, v9
	face = (*TXftFtFile)(unsafe.Pointer(f)).Fface
	if (*TXftFtFile)(unsafe.Pointer(f)).Fxsize != xsize || (*TXftFtFile)(unsafe.Pointer(f)).Fysize != ysize {
		if XXftDebug(tls)&int32(m_XFT_DBG_GLYPH) != 0 {
			libc.Xprintf(tls, __ccgo_ts+1130, libc.VaList(bp+8, int32(xsize>>libc.Int32FromInt32(6)), int32(ysize>>libc.Int32FromInt32(6)), int32(xsize), int32(ysize)))
		}
		/*
		 * Bitmap only faces must match exactly, so find the closest
		 * one (height dominant search)
		 */
		if !((*TFT_FaceRec_)(unsafe.Pointer(face)).Fface_flags&(libc.Int64FromInt64(1)<<libc.Int32FromInt32(0)) != 0) {
			best = 0
			i = int32(1)
			for {
				if !(i < (*TFT_FaceRec_)(unsafe.Pointer(face)).Fnum_fixed_sizes) {
					break
				}
				if ysize-(*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(i)*32))).Fy_ppem < 0 {
					v2 = -(ysize - (*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(i)*32))).Fy_ppem)
				} else {
					v2 = ysize - (*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(i)*32))).Fy_ppem
				}
				if ysize-(*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(best)*32))).Fy_ppem < 0 {
					v3 = -(ysize - (*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(best)*32))).Fy_ppem)
				} else {
					v3 = ysize - (*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(best)*32))).Fy_ppem
				}
				if v9 = v2 < v3; !v9 {
					if ysize-(*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(i)*32))).Fy_ppem < 0 {
						v4 = -(ysize - (*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(i)*32))).Fy_ppem)
					} else {
						v4 = ysize - (*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(i)*32))).Fy_ppem
					}
					if ysize-(*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(best)*32))).Fy_ppem < 0 {
						v5 = -(ysize - (*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(best)*32))).Fy_ppem)
					} else {
						v5 = ysize - (*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(best)*32))).Fy_ppem
					}
					if v8 = v4 == v5; v8 {
						if xsize-(*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(i)*32))).Fx_ppem < 0 {
							v6 = -(xsize - (*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(i)*32))).Fx_ppem)
						} else {
							v6 = xsize - (*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(i)*32))).Fx_ppem
						}
						if xsize-(*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(best)*32))).Fx_ppem < 0 {
							v7 = -(xsize - (*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(best)*32))).Fx_ppem)
						} else {
							v7 = xsize - (*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(best)*32))).Fx_ppem
						}
					}
				}
				if v9 || v8 && v6 < v7 {
					best = i
				}
				goto _1
			_1:
				;
				i++
			}
			/*
			 * Freetype 2.1.7 and earlier used width/height
			 * for matching sizes in the BDF and PCF loaders.
			 * This has been fixed for 2.1.8.  Because BDF and PCF
			 * files have but a single strike per file, we can
			 * simply try both sizes.
			 */
			if libfreetype.XFT_Set_Char_Size(tls, face, (*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(best)*32))).Fx_ppem, (*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(best)*32))).Fy_ppem, uint32(0), uint32(0)) != 0 && libfreetype.XFT_Set_Char_Size(tls, face, int64(int32((*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(best)*32))).Fwidth)<<int32(6)), int64(int32((*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(best)*32))).Fheight)<<int32(6)), uint32(0), uint32(0)) != 0 {
				return m_False
			}
		} else {
			if libfreetype.XFT_Set_Char_Size(tls, face, xsize, ysize, uint32(0), uint32(0)) != 0 {
				return m_False
			}
		}
		(*TXftFtFile)(unsafe.Pointer(f)).Fxsize = xsize
		(*TXftFtFile)(unsafe.Pointer(f)).Fysize = ysize
	}
	if !((*TFT_Matrix)(unsafe.Pointer(f+48)).Fxx == (*TFT_Matrix)(unsafe.Pointer(matrix)).Fxx && (*TFT_Matrix)(unsafe.Pointer(f+48)).Fyy == (*TFT_Matrix)(unsafe.Pointer(matrix)).Fyy && (*TFT_Matrix)(unsafe.Pointer(f+48)).Fxy == (*TFT_Matrix)(unsafe.Pointer(matrix)).Fxy && (*TFT_Matrix)(unsafe.Pointer(f+48)).Fyx == (*TFT_Matrix)(unsafe.Pointer(matrix)).Fyx) {
		if XXftDebug(tls)&int32(m_XFT_DBG_GLYPH) != 0 {
			libc.Xprintf(tls, __ccgo_ts+1162, libc.VaList(bp+8, float64((*TFT_Matrix)(unsafe.Pointer(matrix)).Fxx)/libc.Float64FromInt32(0x10000), float64((*TFT_Matrix)(unsafe.Pointer(matrix)).Fxy)/libc.Float64FromInt32(0x10000), float64((*TFT_Matrix)(unsafe.Pointer(matrix)).Fyx)/libc.Float64FromInt32(0x10000), float64((*TFT_Matrix)(unsafe.Pointer(matrix)).Fyy)/libc.Float64FromInt32(0x10000)))
		}
		libfreetype.XFT_Set_Transform(tls, face, matrix, libc.UintptrFromInt32(0))
		(*TXftFtFile)(unsafe.Pointer(f)).Fmatrix = *(*TFT_Matrix)(unsafe.Pointer(matrix))
	}
	return int32(m_True)
}

func __XftReleaseFile(tls *libc.TLS, f uintptr) {
	var prev, v2 uintptr
	var v1 int32
	var v4 uint64
	_, _, _, _ = prev, v1, v2, v4
	v2 = f + 8
	*(*int32)(unsafe.Pointer(v2))--
	v1 = *(*int32)(unsafe.Pointer(v2))
	if v1 != 0 {
		return
	}
	if (*TXftFtFile)(unsafe.Pointer(f)).Flock != 0 {
		__XftLockError(tls, __ccgo_ts+1196)
	}
	if (*TXftFtFile)(unsafe.Pointer(f)).Ffile != 0 {
		prev = uintptr(unsafe.Pointer(&__XftFtFiles))
		for {
			if !(*(*uintptr)(unsafe.Pointer(prev)) != 0) {
				break
			}
			if *(*uintptr)(unsafe.Pointer(prev)) == f {
				*(*uintptr)(unsafe.Pointer(prev)) = (*TXftFtFile)(unsafe.Pointer(f)).Fnext
				break
			}
			goto _3
		_3:
			;
			prev = *(*uintptr)(unsafe.Pointer(prev))
		}
		if (*TXftFtFile)(unsafe.Pointer(f)).Fface != 0 {
			libfreetype.XFT_Done_Face(tls, (*TXftFtFile)(unsafe.Pointer(f)).Fface)
		}
	}
	if (*TXftFtFile)(unsafe.Pointer(f)).Ffile != 0 {
		v4 = libc.Xstrlen(tls, (*TXftFtFile)(unsafe.Pointer(f)).Ffile) + uint64(1)
	} else {
		v4 = uint64(0)
	}
	XXftMemFree(tls, int32(_XFT_MEM_FILE), libc.Uint64FromInt64(96)+v4)
	libc.Xfree(tls, f)
}

/*
 * Find a prime larger than the minimum reasonable hash size
 */

func __XftSqrt(tls *libc.TLS, a TFcChar32) (r TFcChar32) {
	var h, l, m TFcChar32
	_, _, _ = h, l, m
	l = uint32(2)
	h = a / uint32(2)
	for h-l > uint32(1) {
		m = (h + l) >> int32(1)
		if m*m < a {
			l = m
		} else {
			h = m
		}
	}
	return h
}

func __XftIsPrime(tls *libc.TLS, i TFcChar32) (r TFcBool) {
	var l, t TFcChar32
	_, _ = l, t
	if i < uint32(2) {
		return m_FcFalse
	}
	if i&uint32(1) == uint32(0) {
		if i == uint32(2) {
			return int32(m_FcTrue)
		}
		return m_FcFalse
	}
	l = __XftSqrt(tls, i) + uint32(1)
	t = uint32(3)
	for {
		if !(t <= l) {
			break
		}
		if i%t == uint32(0) {
			return m_FcFalse
		}
		goto _1
	_1:
		;
		t += uint32(2)
	}
	return int32(m_FcTrue)
}

func __XftHashSize(tls *libc.TLS, num_unicode TFcChar32) (r TFcChar32) {
	var hash TFcChar32
	_ = hash
	/* at least 31.25 % extra space */
	hash = num_unicode + num_unicode>>libc.Int32FromInt32(2) + num_unicode>>libc.Int32FromInt32(4)
	if hash&uint32(1) == uint32(0) {
		hash++
	}
	for !(__XftIsPrime(tls, hash) != 0) {
		hash += uint32(2)
	}
	return hash
}

func XXftLockFace(tls *libc.TLS, public uintptr) (r TFT_Face) {
	var face TFT_Face
	var fi, font uintptr
	_, _, _ = face, fi, font
	font = public
	fi = font + 48
	face = __XftLockFile(tls, (*TXftFontInfo)(unsafe.Pointer(fi)).Ffile)
	/*
	 * Make sure the face is usable at the requested size
	 */
	if face != 0 && !(X_XftSetFace(tls, (*TXftFontInfo)(unsafe.Pointer(fi)).Ffile, (*TXftFontInfo)(unsafe.Pointer(fi)).Fxsize, (*TXftFontInfo)(unsafe.Pointer(fi)).Fysize, fi+56) != 0) {
		__XftUnlockFile(tls, (*TXftFontInfo)(unsafe.Pointer(fi)).Ffile)
		face = libc.UintptrFromInt32(0)
	}
	return face
}

func XXftUnlockFace(tls *libc.TLS, public uintptr) {
	var font uintptr
	_ = font
	font = public
	__XftUnlockFile(tls, (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Ffile)
}

func _XftFontInfoFill(tls *libc.TLS, dpy uintptr, pattern uintptr, fi uintptr) (r TFcBool) {
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var hash TFcChar32
	var hashp, info, v1, v12, p10, p6, p7, p8, p9 uintptr
	var mid, nhash, v11 int32
	var v2, v3 TFT_Fixed
	var v4, v5 float64
	var _ /* aspect at bp+24 */ float64
	var _ /* autohint at bp+80 */ TFcBool
	var _ /* bitmap at bp+104 */ TFcBool
	var _ /* dsize at bp+16 */ float64
	var _ /* face at bp+96 */ TFT_Face
	var _ /* filename at bp+0 */ uintptr
	var _ /* fm1 at bp+40 */ TFcMatrix
	var _ /* font_matrix at bp+32 */ uintptr
	var _ /* global_advance at bp+84 */ TFcBool
	var _ /* hint_style at bp+88 */ int32
	var _ /* hinting at bp+72 */ TFcBool
	var _ /* id at bp+8 */ int32
	var _ /* vertical_layout at bp+76 */ TFcBool
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = hash, hashp, info, mid, nhash, v1, v11, v12, v2, v3, v4, v5, p10, p6, p7, p8, p9
	info = X_XftDisplayInfoGet(tls, dpy, int32(m_True))
	if !(info != 0) {
		return m_FcFalse
	}
	/*
	 * Initialize the whole XftFontInfo so that padding doesn't interfere with
	 * hash or XftFontInfoEqual().
	 */
	libc.X__builtin___memset_chk(tls, fi, int32('\000'), uint64(112), uint64(libc.X__builtin_object_size(tls, fi, 0)))
	/*
	 * Find the associated file
	 */
	switch libfontconfig.XFcPatternGetString(tls, pattern, __ccgo_ts+1225, 0, bp) {
	case int32(_FcResultNoMatch):
		*(*uintptr)(unsafe.Pointer(bp)) = libc.UintptrFromInt32(0)
	case int32(_FcResultMatch):
	default:
		goto bail0
	}
	switch libfontconfig.XFcPatternGetInteger(tls, pattern, __ccgo_ts+1230, 0, bp+8) {
	case int32(_FcResultNoMatch):
		*(*int32)(unsafe.Pointer(bp + 8)) = 0
	case int32(_FcResultMatch):
	default:
		goto bail0
	}
	if *(*uintptr)(unsafe.Pointer(bp)) != 0 {
		(*TXftFontInfo)(unsafe.Pointer(fi)).Ffile = __XftGetFile(tls, *(*uintptr)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 8)))
	} else {
		if libfontconfig.XFcPatternGetFTFace(tls, pattern, __ccgo_ts+1236, 0, bp+96) == int32(_FcResultMatch) && *(*TFT_Face)(unsafe.Pointer(bp + 96)) != 0 {
			(*TXftFontInfo)(unsafe.Pointer(fi)).Ffile = __XftGetFaceFile(tls, *(*TFT_Face)(unsafe.Pointer(bp + 96)))
		}
	}
	if !((*TXftFontInfo)(unsafe.Pointer(fi)).Ffile != 0) {
		goto bail0
	}
	/*
	 * Compute pixel size
	 */
	if libfontconfig.XFcPatternGetDouble(tls, pattern, __ccgo_ts+1243, 0, bp+16) != int32(_FcResultMatch) {
		goto bail1
	}
	if libfontconfig.XFcPatternGetDouble(tls, pattern, __ccgo_ts+1253, 0, bp+24) != int32(_FcResultMatch) {
		*(*float64)(unsafe.Pointer(bp + 24)) = float64(1)
	}
	(*TXftFontInfo)(unsafe.Pointer(fi)).Fysize = int64(*(*float64)(unsafe.Pointer(bp + 16)) * libc.Float64FromFloat64(64))
	(*TXftFontInfo)(unsafe.Pointer(fi)).Fxsize = int64(*(*float64)(unsafe.Pointer(bp + 16)) * *(*float64)(unsafe.Pointer(bp + 24)) * libc.Float64FromFloat64(64))
	if XXftDebug(tls)&int32(m_XFT_DBG_OPEN) != 0 {
		if *(*uintptr)(unsafe.Pointer(bp)) != 0 {
			v1 = *(*uintptr)(unsafe.Pointer(bp))
		} else {
			v1 = __ccgo_ts + 1260
		}
		libc.Xprintf(tls, __ccgo_ts+1267, libc.VaList(bp+120, v1, *(*int32)(unsafe.Pointer(bp + 8)), *(*float64)(unsafe.Pointer(bp + 16))))
	}
	/*
	 * Get antialias value
	 */
	switch libfontconfig.XFcPatternGetBool(tls, pattern, __ccgo_ts+614, 0, fi+32) {
	case int32(_FcResultNoMatch):
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fantialias = int32(m_True)
	case int32(_FcResultMatch):
	default:
		goto bail1
	}
	/*
	 * Get rgba value
	 */
	switch libfontconfig.XFcPatternGetInteger(tls, pattern, __ccgo_ts+599, 0, fi+44) {
	case int32(_FcResultNoMatch):
		(*TXftFontInfo)(unsafe.Pointer(fi)).Frgba = m_FC_RGBA_UNKNOWN
	case int32(_FcResultMatch):
	default:
		goto bail1
	}
	/*
	 * Get lcd_filter value
	 */
	switch libfontconfig.XFcPatternGetInteger(tls, pattern, __ccgo_ts+604, 0, fi+48) {
	case int32(_FcResultNoMatch):
		(*TXftFontInfo)(unsafe.Pointer(fi)).Flcd_filter = int32(m_FC_LCD_DEFAULT)
	case int32(_FcResultMatch):
	default:
		goto bail1
	}
	/*
	 * Get matrix and transform values
	 */
	switch libfontconfig.XFcPatternGetMatrix(tls, pattern, __ccgo_ts+1304, 0, bp+32) {
	case int32(_FcResultNoMatch):
		v2 = libc.Int64FromInt32(0x10000)
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fyy = v2
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fxx = v2
		v3 = libc.Int64FromInt32(0)
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fyx = v3
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fxy = v3
	case int32(_FcResultMatch):
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fxx = int64(libc.Float64FromInt64(0x10000) * (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Fxx)
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fyy = int64(libc.Float64FromInt64(0x10000) * (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Fyy)
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fxy = int64(libc.Float64FromInt64(0x10000) * (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Fxy)
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fyx = int64(libc.Float64FromInt64(0x10000) * (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Fyx)
	default:
		goto bail1
	}
	mid = int32(1)
	for libfontconfig.XFcPatternGetMatrix(tls, pattern, __ccgo_ts+1304, mid, bp+32) == int32(_FcResultMatch) {
		v4 = libc.Float64FromInt32(1)
		(*TFcMatrix)(unsafe.Pointer(bp + 40)).Fyy = v4
		(*TFcMatrix)(unsafe.Pointer(bp + 40)).Fxx = v4
		v5 = libc.Float64FromInt32(0)
		(*TFcMatrix)(unsafe.Pointer(bp + 40)).Fyx = v5
		(*TFcMatrix)(unsafe.Pointer(bp + 40)).Fxy = v5
		(*(*TFcMatrix)(unsafe.Pointer(bp + 40))).Fxx = float64((*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fxx) / libc.Float64FromInt64(0x10000)
		(*(*TFcMatrix)(unsafe.Pointer(bp + 40))).Fyy = float64((*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fyy) / libc.Float64FromInt64(0x10000)
		(*(*TFcMatrix)(unsafe.Pointer(bp + 40))).Fxy = float64((*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fxy) / libc.Float64FromInt64(0x10000)
		(*(*TFcMatrix)(unsafe.Pointer(bp + 40))).Fyx = float64((*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fyx) / libc.Float64FromInt64(0x10000)
		libfontconfig.XFcMatrixMultiply(tls, bp+40, *(*uintptr)(unsafe.Pointer(bp + 32)), bp+40)
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fxx = int64(libc.Float64FromInt64(0x10000) * (*(*TFcMatrix)(unsafe.Pointer(bp + 40))).Fxx)
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fyy = int64(libc.Float64FromInt64(0x10000) * (*(*TFcMatrix)(unsafe.Pointer(bp + 40))).Fyy)
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fxy = int64(libc.Float64FromInt64(0x10000) * (*(*TFcMatrix)(unsafe.Pointer(bp + 40))).Fxy)
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fyx = int64(libc.Float64FromInt64(0x10000) * (*(*TFcMatrix)(unsafe.Pointer(bp + 40))).Fyx)
		mid++
	}
	(*TXftFontInfo)(unsafe.Pointer(fi)).Ftransform = libc.BoolInt32((*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fxx != int64(0x10000) || (*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fxy != 0 || (*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fyx != 0 || (*TXftFontInfo)(unsafe.Pointer(fi)).Fmatrix.Fyy != int64(0x10000))
	/*
	 * Get render value, set to false if no Render extension present
	 */
	if (*TXftDisplayInfo)(unsafe.Pointer(info)).FhasRender != 0 {
		switch libfontconfig.XFcPatternGetBool(tls, pattern, __ccgo_ts+592, 0, fi+96) {
		case int32(_FcResultTypeMismatch):
			/*
			 * Fontconfig no longer supports xft's custom values in
			 * text patterns, so any name specifying render:true or
			 * render:false will have an invalid type in the resulting
			 * pattern. Just ignore that case so that the app doesn't
			 * just fail
			 */
			/* fall through ... */
			fallthrough
		case int32(_FcResultNoMatch):
			(*TXftFontInfo)(unsafe.Pointer(fi)).Frender = (*TXftDisplayInfo)(unsafe.Pointer(info)).FhasRender
		case int32(_FcResultMatch):
		default:
			goto bail1
		}
	} else {
		(*TXftFontInfo)(unsafe.Pointer(fi)).Frender = m_FcFalse
	}
	/*
	 * Compute glyph load flags
	 */
	(*TXftFontInfo)(unsafe.Pointer(fi)).Fload_flags = int32(libc.Int64FromInt32(m_FT_LOAD_DEFAULT1) | libc.Int64FromInt64(1)<<libc.Int32FromInt32(20))
	switch libfontconfig.XFcPatternGetBool(tls, pattern, __ccgo_ts+1311, 0, bp+104) {
	case int32(_FcResultNoMatch):
		*(*TFcBool)(unsafe.Pointer(bp + 104)) = m_FcFalse
	case int32(_FcResultMatch):
	default:
		goto bail1
	}
	/* disable bitmaps when anti-aliasing or transforming glyphs */
	if !(*(*TFcBool)(unsafe.Pointer(bp + 104)) != 0) && (*TXftFontInfo)(unsafe.Pointer(fi)).Fantialias != 0 || (*TXftFontInfo)(unsafe.Pointer(fi)).Ftransform != 0 {
		p6 = fi + 92
		*(*TFT_Int)(unsafe.Pointer(p6)) = TFT_Int(int64(*(*TFT_Int)(unsafe.Pointer(p6))) | libc.Int64FromInt64(1)<<libc.Int32FromInt32(3))
	}
	/* disable hinting if requested */
	switch libfontconfig.XFcPatternGetBool(tls, pattern, __ccgo_ts+652, 0, bp+72) {
	case int32(_FcResultNoMatch):
		*(*TFcBool)(unsafe.Pointer(bp + 72)) = int32(m_FcTrue)
	case int32(_FcResultMatch):
	default:
		goto bail1
	}
	switch libfontconfig.XFcPatternGetBool(tls, pattern, __ccgo_ts+624, 0, fi+36) {
	case int32(_FcResultNoMatch):
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fembolden = m_FcFalse
	case int32(_FcResultMatch):
	default:
		goto bail1
	}
	switch libfontconfig.XFcPatternGetInteger(tls, pattern, __ccgo_ts+642, 0, bp+88) {
	case int32(_FcResultNoMatch):
		*(*int32)(unsafe.Pointer(bp + 88)) = int32(m_FC_HINT_FULL)
	case int32(_FcResultMatch):
	default:
		goto bail1
	}
	if !(*(*TFcBool)(unsafe.Pointer(bp + 72)) != 0) || *(*int32)(unsafe.Pointer(bp + 88)) == m_FC_HINT_NONE {
		p7 = fi + 92
		*(*TFT_Int)(unsafe.Pointer(p7)) = TFT_Int(int64(*(*TFT_Int)(unsafe.Pointer(p7))) | libc.Int64FromInt64(1)<<libc.Int32FromInt32(1))
	}
	/* Figure out the load target, which modifies the hinting
	 * behavior of FreeType based on the intended use of the glyphs.
	 */
	if (*TXftFontInfo)(unsafe.Pointer(fi)).Fantialias != 0 {
		if m_FC_HINT_NONE < *(*int32)(unsafe.Pointer(bp + 88)) && *(*int32)(unsafe.Pointer(bp + 88)) < int32(m_FC_HINT_FULL) {
			*(*TFT_Int)(unsafe.Pointer(fi + 92)) |= int32(_FT_RENDER_MODE_LIGHT) & libc.Int32FromInt32(15) << libc.Int32FromInt32(16)
		} else {
			/* autohinter will snap stems to integer widths, when
			 * the LCD targets are used.
			 */
			switch (*TXftFontInfo)(unsafe.Pointer(fi)).Frgba {
			case int32(m_FC_RGBA_RGB):
				fallthrough
			case int32(m_FC_RGBA_BGR):
				*(*TFT_Int)(unsafe.Pointer(fi + 92)) |= int32(_FT_RENDER_MODE_LCD) & libc.Int32FromInt32(15) << libc.Int32FromInt32(16)
			case int32(m_FC_RGBA_VRGB):
				fallthrough
			case int32(m_FC_RGBA_VBGR):
				*(*TFT_Int)(unsafe.Pointer(fi + 92)) |= int32(_FT_RENDER_MODE_LCD_V) & libc.Int32FromInt32(15) << libc.Int32FromInt32(16)
				break
			}
		}
	} else {
		*(*TFT_Int)(unsafe.Pointer(fi + 92)) |= int32(_FT_RENDER_MODE_MONO) & libc.Int32FromInt32(15) << libc.Int32FromInt32(16)
	}
	/* set vertical layout if requested */
	switch libfontconfig.XFcPatternGetBool(tls, pattern, __ccgo_ts+1326, 0, bp+76) {
	case int32(_FcResultNoMatch):
		*(*TFcBool)(unsafe.Pointer(bp + 76)) = m_FcFalse
	case int32(_FcResultMatch):
	default:
		goto bail1
	}
	if *(*TFcBool)(unsafe.Pointer(bp + 76)) != 0 {
		p8 = fi + 92
		*(*TFT_Int)(unsafe.Pointer(p8)) = TFT_Int(int64(*(*TFT_Int)(unsafe.Pointer(p8))) | libc.Int64FromInt64(1)<<libc.Int32FromInt32(4))
	}
	/* force autohinting if requested */
	switch libfontconfig.XFcPatternGetBool(tls, pattern, __ccgo_ts+633, 0, bp+80) {
	case int32(_FcResultNoMatch):
		*(*TFcBool)(unsafe.Pointer(bp + 80)) = m_FcFalse
	case int32(_FcResultMatch):
	default:
		goto bail1
	}
	if *(*TFcBool)(unsafe.Pointer(bp + 80)) != 0 {
		p9 = fi + 92
		*(*TFT_Int)(unsafe.Pointer(p9)) = TFT_Int(int64(*(*TFT_Int)(unsafe.Pointer(p9))) | libc.Int64FromInt64(1)<<libc.Int32FromInt32(5))
	}
	/* disable global advance width (for broken DynaLab TT CJK fonts) */
	switch libfontconfig.XFcPatternGetBool(tls, pattern, __ccgo_ts+1341, 0, bp+84) {
	case int32(_FcResultNoMatch):
		*(*TFcBool)(unsafe.Pointer(bp + 84)) = int32(m_FcTrue)
	case int32(_FcResultMatch):
	default:
		goto bail1
	}
	if !(*(*TFcBool)(unsafe.Pointer(bp + 84)) != 0) {
		p10 = fi + 92
		*(*TFT_Int)(unsafe.Pointer(p10)) = TFT_Int(int64(*(*TFT_Int)(unsafe.Pointer(p10))) | libc.Int64FromInt64(1)<<libc.Int32FromInt32(9))
	}
	/*
	 * Get requested spacing value
	 */
	switch libfontconfig.XFcPatternGetInteger(tls, pattern, __ccgo_ts+1355, 0, fi+100) {
	case int32(_FcResultNoMatch):
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fspacing = m_FC_PROPORTIONAL
	case int32(_FcResultMatch):
	default:
		goto bail1
	}
	/*
	 * Check for minspace
	 */
	switch libfontconfig.XFcPatternGetBool(tls, pattern, __ccgo_ts+660, 0, fi+104) {
	case int32(_FcResultNoMatch):
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fminspace = m_FcFalse
	case int32(_FcResultMatch):
	default:
		goto bail1
	}
	/*
	 * Check for fixed pixel spacing
	 */
	switch libfontconfig.XFcPatternGetInteger(tls, pattern, __ccgo_ts+1363, 0, fi+108) {
	case int32(_FcResultNoMatch):
		(*TXftFontInfo)(unsafe.Pointer(fi)).Fchar_width = 0
	case int32(_FcResultMatch):
		if (*TXftFontInfo)(unsafe.Pointer(fi)).Fchar_width != 0 {
			(*TXftFontInfo)(unsafe.Pointer(fi)).Fspacing = int32(m_FC_MONO)
		}
	default:
		goto bail1
	}
	/*
	 * Step over hash value in the structure
	 */
	hash = uint32(0)
	hashp = fi + uintptr(1)*4
	nhash = int32(libc.Uint64FromInt64(112)/libc.Uint64FromInt64(4) - libc.Uint64FromInt32(1))
	for {
		v11 = nhash
		nhash--
		if !(v11 != 0) {
			break
		}
		v12 = hashp
		hashp += 4
		hash += *(*TFcChar32)(unsafe.Pointer(v12))
	}
	(*TXftFontInfo)(unsafe.Pointer(fi)).Fhash = hash
	/*
	 * All done
	 */
	return int32(m_FcTrue)
	goto bail1
bail1:
	;
	__XftReleaseFile(tls, (*TXftFontInfo)(unsafe.Pointer(fi)).Ffile)
	(*TXftFontInfo)(unsafe.Pointer(fi)).Ffile = libc.UintptrFromInt32(0)
	goto bail0
bail0:
	;
	return m_FcFalse
	return r
}

func _XftFontInfoEmpty(tls *libc.TLS, dpy uintptr, fi uintptr) {
	if (*TXftFontInfo)(unsafe.Pointer(fi)).Ffile != 0 {
		__XftReleaseFile(tls, (*TXftFontInfo)(unsafe.Pointer(fi)).Ffile)
	}
}

func XXftFontInfoCreate(tls *libc.TLS, dpy uintptr, pattern uintptr) (r uintptr) {
	var fi uintptr
	_ = fi
	fi = libc.Xmalloc(tls, uint64(112))
	if !(fi != 0) {
		return libc.UintptrFromInt32(0)
	}
	if !(_XftFontInfoFill(tls, dpy, pattern, fi) != 0) {
		libc.Xfree(tls, fi)
		fi = libc.UintptrFromInt32(0)
	}
	XXftMemAlloc(tls, int32(_XFT_MEM_FONT), uint64(112))
	return fi
}

func XXftFontInfoDestroy(tls *libc.TLS, dpy uintptr, fi uintptr) {
	_XftFontInfoEmpty(tls, dpy, fi)
	XXftMemFree(tls, int32(_XFT_MEM_FONT), uint64(112))
	libc.Xfree(tls, fi)
}

func XXftFontInfoHash(tls *libc.TLS, fi uintptr) (r TFcChar32) {
	return (*TXftFontInfo)(unsafe.Pointer(fi)).Fhash
}

func XXftFontInfoEqual(tls *libc.TLS, a uintptr, b uintptr) (r TFcBool) {
	return libc.BoolInt32(libc.Xmemcmp(tls, a, b, uint64(112)) == 0)
}

func XXftFontOpenInfo(tls *libc.TLS, dpy uintptr, pattern uintptr, fi uintptr) (r uintptr) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var alloc_size Tsize_t
	var antialias, color TFcBool
	var ascent, descent, height, i, v2, v4 int32
	var bucket, font, format, info, v3 uintptr
	var face TFT_Face
	var hash_value, num_unicode, rehash_value TFcChar32
	var num_glyphs TFT_UInt
	var v6 uint64
	var _ /* charset at bp+0 */ uintptr
	var _ /* max_glyph_memory at bp+8 */ int32
	var _ /* vector at bp+16 */ TFT_Vector
	var _ /* vector at bp+32 */ TFT_Vector
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = alloc_size, antialias, ascent, bucket, color, descent, face, font, format, hash_value, height, i, info, num_glyphs, num_unicode, rehash_value, v2, v3, v4, v6
	info = X_XftDisplayInfoGet(tls, dpy, int32(m_True))
	if !(info != 0) {
		return libc.UintptrFromInt32(0)
	}
	/*
	 * Find a matching previously opened font
	 */
	bucket = info + 472 + uintptr((*TXftFontInfo)(unsafe.Pointer(fi)).Fhash%uint32(m_XFT_NUM_FONT_HASH))*8
	font = *(*uintptr)(unsafe.Pointer(bucket))
	for {
		if !(font != 0) {
			break
		}
		if XXftFontInfoEqual(tls, font+48, fi) != 0 {
			v3 = font + 160
			v2 = *(*int32)(unsafe.Pointer(v3))
			*(*int32)(unsafe.Pointer(v3))++
			if !(v2 != 0) {
				(*TXftDisplayInfo)(unsafe.Pointer(info)).Fnum_unref_fonts--
			}
			libfontconfig.XFcPatternDestroy(tls, pattern)
			return font
		}
		goto _1
	_1:
		;
		font = (*TXftFontInt)(unsafe.Pointer(font)).Fhash_next
	}
	/*
	 * No existing font, create another.
	 */
	if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
		libc.Xprintf(tls, __ccgo_ts+1373, libc.VaList(bp+56, (*TXftFtFile)(unsafe.Pointer((*TXftFontInfo)(unsafe.Pointer(fi)).Ffile)).Ffile, (*TXftFtFile)(unsafe.Pointer((*TXftFontInfo)(unsafe.Pointer(fi)).Ffile)).Fid, int32((*TXftFontInfo)(unsafe.Pointer(fi)).Fxsize)>>int32(6), int32((*TXftFontInfo)(unsafe.Pointer(fi)).Fysize)>>int32(6)))
	}
	if libfontconfig.XFcPatternGetInteger(tls, pattern, __ccgo_ts+201, 0, bp+8) != int32(_FcResultMatch) {
		*(*int32)(unsafe.Pointer(bp + 8)) = libc.Int32FromInt32(1024) * libc.Int32FromInt32(1024)
	}
	face = __XftLockFile(tls, (*TXftFontInfo)(unsafe.Pointer(fi)).Ffile)
	if !(face != 0) {
		goto bail0
	}
	if !(X_XftSetFace(tls, (*TXftFontInfo)(unsafe.Pointer(fi)).Ffile, (*TXftFontInfo)(unsafe.Pointer(fi)).Fxsize, (*TXftFontInfo)(unsafe.Pointer(fi)).Fysize, fi+56) != 0) {
		goto bail1
	}
	/*
	 * Get the set of Unicode codepoints covered by the font.
	 * If the incoming pattern doesn't provide this data, go
	 * off and compute it.  Yes, this is expensive, but it's
	 * required to map Unicode to glyph indices.
	 */
	if libfontconfig.XFcPatternGetCharSet(tls, pattern, __ccgo_ts+1400, 0, bp) == int32(_FcResultMatch) {
		*(*uintptr)(unsafe.Pointer(bp)) = libfontconfig.XFcCharSetCopy(tls, *(*uintptr)(unsafe.Pointer(bp)))
	} else {
		*(*uintptr)(unsafe.Pointer(bp)) = libfontconfig.XFcFreeTypeCharSet(tls, face, libfontconfig.XFcConfigGetBlanks(tls, libc.UintptrFromInt32(0)))
	}
	antialias = (*TXftFontInfo)(unsafe.Pointer(fi)).Fantialias
	if !((*TFT_FaceRec_)(unsafe.Pointer(face)).Fface_flags&(libc.Int64FromInt64(1)<<libc.Int32FromInt32(0)) != 0) {
		antialias = m_FcFalse
	}
	if !!((*TFT_FaceRec_)(unsafe.Pointer(face)).Fface_flags&(libc.Int64FromInt64(1)<<libc.Int32FromInt32(14)) != 0) {
		v4 = int32(m_FcTrue)
	} else {
		v4 = m_FcFalse
	}
	color = v4
	/*
	 * Find the appropriate picture format
	 */
	if (*TXftFontInfo)(unsafe.Pointer(fi)).Frender != 0 {
		if color != 0 {
			format = libxrender.XXRenderFindStandardFormat(tls, dpy, m_PictStandardARGB32)
		} else {
			if antialias != 0 {
				switch (*TXftFontInfo)(unsafe.Pointer(fi)).Frgba {
				case int32(m_FC_RGBA_RGB):
					fallthrough
				case int32(m_FC_RGBA_BGR):
					fallthrough
				case int32(m_FC_RGBA_VRGB):
					fallthrough
				case int32(m_FC_RGBA_VBGR):
					format = libxrender.XXRenderFindStandardFormat(tls, dpy, m_PictStandardARGB32)
				default:
					format = libxrender.XXRenderFindStandardFormat(tls, dpy, int32(m_PictStandardA8))
					break
				}
			} else {
				format = libxrender.XXRenderFindStandardFormat(tls, dpy, int32(m_PictStandardA1))
			}
		}
		if !(format != 0) {
			goto bail2
		}
	} else {
		format = libc.UintptrFromInt32(0)
	}
	if *(*uintptr)(unsafe.Pointer(bp)) != 0 {
		num_unicode = libfontconfig.XFcCharSetCount(tls, *(*uintptr)(unsafe.Pointer(bp)))
		hash_value = __XftHashSize(tls, num_unicode)
		rehash_value = hash_value - uint32(2)
	} else {
		hash_value = uint32(0)
		rehash_value = uint32(0)
	}
	/*
	 * Sometimes the glyphs are numbered 1..n, other times 0..n-1,
	 * accept either numbering scheme by making room in the table
	 */
	num_glyphs = uint32((*TFT_FaceRec_)(unsafe.Pointer(face)).Fnum_glyphs) + uint32(1)
	alloc_size = libc.Uint64FromInt64(256) + uint64(num_glyphs)*libc.Uint64FromInt64(8) + uint64(hash_value)*libc.Uint64FromInt64(8)
	font = libc.Xmalloc(tls, alloc_size)
	if !(font != 0) {
		goto bail2
	}
	XXftMemAlloc(tls, int32(_XFT_MEM_FONT), alloc_size)
	/*
	 * Public fields
	 */
	if (*TXftFontInfo)(unsafe.Pointer(fi)).Ftransform != 0 {
		(*(*TFT_Vector)(unsafe.Pointer(bp + 16))).Fx = 0
		(*(*TFT_Vector)(unsafe.Pointer(bp + 16))).Fy = (*TFT_SizeRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fsize)).Fmetrics.Fdescender
		libfreetype.XFT_Vector_Transform(tls, bp+16, fi+56)
		descent = int32(-((*(*TFT_Vector)(unsafe.Pointer(bp + 16))).Fy >> libc.Int32FromInt32(6)))
		(*(*TFT_Vector)(unsafe.Pointer(bp + 16))).Fx = 0
		(*(*TFT_Vector)(unsafe.Pointer(bp + 16))).Fy = (*TFT_SizeRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fsize)).Fmetrics.Fascender
		libfreetype.XFT_Vector_Transform(tls, bp+16, fi+56)
		ascent = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 16))).Fy >> libc.Int32FromInt32(6))
		if (*TXftFontInfo)(unsafe.Pointer(fi)).Fminspace != 0 {
			height = ascent + descent
		} else {
			(*(*TFT_Vector)(unsafe.Pointer(bp + 16))).Fx = 0
			(*(*TFT_Vector)(unsafe.Pointer(bp + 16))).Fy = (*TFT_SizeRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fsize)).Fmetrics.Fheight
			libfreetype.XFT_Vector_Transform(tls, bp+16, fi+56)
			height = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 16))).Fy >> libc.Int32FromInt32(6))
		}
	} else {
		descent = -int32((*TFT_SizeRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fsize)).Fmetrics.Fdescender >> libc.Int32FromInt32(6))
		ascent = int32((*TFT_SizeRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fsize)).Fmetrics.Fascender >> libc.Int32FromInt32(6))
		if (*TXftFontInfo)(unsafe.Pointer(fi)).Fminspace != 0 {
			height = ascent + descent
		} else {
			height = int32((*TFT_SizeRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fsize)).Fmetrics.Fheight >> libc.Int32FromInt32(6))
		}
	}
	(*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fascent = ascent
	(*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fdescent = descent
	(*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fheight = height
	if (*TXftFontInfo)(unsafe.Pointer(fi)).Fchar_width != 0 {
		(*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fmax_advance_width = (*TXftFontInfo)(unsafe.Pointer(fi)).Fchar_width
	} else {
		if (*TXftFontInfo)(unsafe.Pointer(fi)).Ftransform != 0 {
			(*(*TFT_Vector)(unsafe.Pointer(bp + 32))).Fx = (*TFT_SizeRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fsize)).Fmetrics.Fmax_advance
			(*(*TFT_Vector)(unsafe.Pointer(bp + 32))).Fy = 0
			libfreetype.XFT_Vector_Transform(tls, bp+32, fi+56)
			(*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fmax_advance_width = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 32))).Fx >> libc.Int32FromInt32(6))
		} else {
			(*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fmax_advance_width = int32((*TFT_SizeRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fsize)).Fmetrics.Fmax_advance >> libc.Int32FromInt32(6))
		}
	}
	(*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fcharset = *(*uintptr)(unsafe.Pointer(bp))
	(*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fpattern = pattern
	/*
	 * Management fields
	 */
	(*TXftFontInt)(unsafe.Pointer(font)).Fref = int32(1)
	(*TXftFontInt)(unsafe.Pointer(font)).Fnext = (*TXftDisplayInfo)(unsafe.Pointer(info)).Ffonts
	(*TXftDisplayInfo)(unsafe.Pointer(info)).Ffonts = font
	(*TXftFontInt)(unsafe.Pointer(font)).Fhash_next = *(*uintptr)(unsafe.Pointer(bucket))
	*(*uintptr)(unsafe.Pointer(bucket)) = font
	/*
	 * Copy the info over
	 */
	(*TXftFontInt)(unsafe.Pointer(font)).Finfo = *(*TXftFontInfo)(unsafe.Pointer(fi))
	/*
	 * reset the antialias field.  It can't
	 * be set correctly until the font is opened,
	 * which doesn't happen in XftFontInfoFill
	 */
	(*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fantialias = antialias
	/*
	 * Set color value, which is only known once the
	 * font was loaded
	 */
	(*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fcolor = color
	/*
	 * bump XftFile reference count
	 */
	(*TXftFtFile)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Ffile)).Fref++
	/*
	 * Per glyph information
	 */
	(*TXftFontInt)(unsafe.Pointer(font)).Fglyphs = font + libc.UintptrFromInt32(1)*256
	libc.X__builtin___memset_chk(tls, (*TXftFontInt)(unsafe.Pointer(font)).Fglyphs, int32('\000'), uint64(num_glyphs)*uint64(8), uint64(libc.X__builtin_object_size(tls, (*TXftFontInt)(unsafe.Pointer(font)).Fglyphs, 0)))
	(*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs = num_glyphs
	/*
	 * Memory-usage tracking
	 */
	(*TXftFontInt)(unsafe.Pointer(font)).Fnewest = libc.Uint32FromInt32(m___INT_MAX__)*libc.Uint32FromUint32(2) + libc.Uint32FromUint32(1)
	(*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse = uint32(0)
	/*
	 * Unicode hash table information
	 */
	(*TXftFontInt)(unsafe.Pointer(font)).Fhash_table = (*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr((*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs)*8
	i = 0
	for {
		if !(uint32(i) < hash_value) {
			break
		}
		(*(*TXftUcsHash)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fhash_table + uintptr(i)*8))).Fucs4 = uint32(^libc.Int32FromInt32(0))
		(*(*TXftUcsHash)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fhash_table + uintptr(i)*8))).Fglyph = uint32(0)
		goto _5
	_5:
		;
		i++
	}
	(*TXftFontInt)(unsafe.Pointer(font)).Fhash_value = int32(hash_value)
	(*TXftFontInt)(unsafe.Pointer(font)).Frehash_value = int32(rehash_value)
	/*
	 * X specific fields
	 */
	(*TXftFontInt)(unsafe.Pointer(font)).Fglyphset = uint64(0)
	(*TXftFontInt)(unsafe.Pointer(font)).Fformat = format
	/*
	 * Glyph memory management fields
	 */
	(*TXftFontInt)(unsafe.Pointer(font)).Fglyph_memory = uint64(0)
	(*TXftFontInt)(unsafe.Pointer(font)).Fmax_glyph_memory = uint64(*(*int32)(unsafe.Pointer(bp + 8)))
	(*TXftFontInt)(unsafe.Pointer(font)).Ftrack_mem_usage = (*TXftDisplayInfo)(unsafe.Pointer(info)).Ftrack_mem_usage
	(*TXftFontInt)(unsafe.Pointer(font)).Fuse_free_glyphs = (*TXftDisplayInfo)(unsafe.Pointer(info)).Fuse_free_glyphs
	if (*TXftFontInt)(unsafe.Pointer(font)).Ftrack_mem_usage != 0 {
		v6 = uint64(48)
	} else {
		v6 = uint64(40)
	}
	(*TXftFontInt)(unsafe.Pointer(font)).Fsizeof_glyph = uint32(v6)
	__XftUnlockFile(tls, (*TXftFontInfo)(unsafe.Pointer(fi)).Ffile)
	return font
	goto bail2
bail2:
	;
	libfontconfig.XFcCharSetDestroy(tls, *(*uintptr)(unsafe.Pointer(bp)))
	goto bail1
bail1:
	;
	__XftUnlockFile(tls, (*TXftFontInfo)(unsafe.Pointer(fi)).Ffile)
	goto bail0
bail0:
	;
	return libc.UintptrFromInt32(0)
	return r
}

func XXftFontOpenPattern(tls *libc.TLS, dpy uintptr, pattern uintptr) (r uintptr) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var font uintptr
	var _ /* info at bp+0 */ TXftFontInfo
	_ = font
	if !(_XftFontInfoFill(tls, dpy, pattern, bp) != 0) {
		return libc.UintptrFromInt32(0)
	}
	font = XXftFontOpenInfo(tls, dpy, pattern, bp)
	_XftFontInfoEmpty(tls, dpy, bp)
	return font
}

func XXftFontCopy(tls *libc.TLS, dpy uintptr, public uintptr) (r uintptr) {
	var font uintptr
	_ = font
	font = public
	(*TXftFontInt)(unsafe.Pointer(font)).Fref++
	return public
}

func _XftFontDestroy(tls *libc.TLS, dpy uintptr, public uintptr) {
	var font, info, xftg uintptr
	var i TFT_UInt
	_, _, _, _ = font, i, info, xftg
	info = X_XftDisplayInfoGet(tls, dpy, m_False)
	font = public
	/* note reduction in memory use */
	if info != 0 {
		*(*uint64)(unsafe.Pointer(info + 56)) -= (*TXftFontInt)(unsafe.Pointer(font)).Fglyph_memory
	}
	/* Clean up the info */
	_XftFontInfoEmpty(tls, dpy, font+48)
	/* Free the glyphset */
	if (*TXftFontInt)(unsafe.Pointer(font)).Fglyphset != 0 {
		libxrender.XXRenderFreeGlyphSet(tls, dpy, (*TXftFontInt)(unsafe.Pointer(font)).Fglyphset)
	}
	/* Free the glyphs */
	i = uint32(0)
	for {
		if !(i < (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs) {
			break
		}
		xftg = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(i)*8))
		if xftg != 0 {
			if (*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap != 0 {
				libc.Xfree(tls, (*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap)
			}
			libc.Xfree(tls, xftg)
		}
		goto _1
	_1:
		;
		i++
	}
	/* Free the pattern and the charset */
	libfontconfig.XFcPatternDestroy(tls, (*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fpattern)
	libfontconfig.XFcCharSetDestroy(tls, (*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fcharset)
	/* Finally, free the font structure */
	XXftMemFree(tls, int32(_XFT_MEM_FONT), libc.Uint64FromInt64(256)+uint64((*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs)*libc.Uint64FromInt64(8)+uint64((*TXftFontInt)(unsafe.Pointer(font)).Fhash_value)*libc.Uint64FromInt64(8))
	libc.Xfree(tls, font)
}

func _XftFontFindNthUnref(tls *libc.TLS, info uintptr, n int32) (r uintptr) {
	var font, public uintptr
	var v2 int32
	var v3 bool
	_, _, _, _ = font, public, v2, v3
	public = (*TXftDisplayInfo)(unsafe.Pointer(info)).Ffonts
	for {
		if !(public != 0) {
			break
		}
		font = public
		if v3 = !((*TXftFontInt)(unsafe.Pointer(font)).Fref != 0); v3 {
			v2 = n
			n--
		}
		if v3 && !(v2 != 0) {
			break
		}
		goto _1
	_1:
		;
		public = (*TXftFontInt)(unsafe.Pointer(font)).Fnext
	}
	return public
}

func XXftFontManageMemory(tls *libc.TLS, dpy uintptr) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var font, info, prev, public uintptr
	_, _, _, _ = font, info, prev, public
	info = X_XftDisplayInfoGet(tls, dpy, m_False)
	if !(info != 0) {
		return
	}
	for (*TXftDisplayInfo)(unsafe.Pointer(info)).Fnum_unref_fonts > (*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_unref_fonts {
		public = _XftFontFindNthUnref(tls, info, libc.Xrand(tls)%(*TXftDisplayInfo)(unsafe.Pointer(info)).Fnum_unref_fonts)
		font = public
		if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
			libc.Xprintf(tls, __ccgo_ts+1408, libc.VaList(bp+8, (*TXftFtFile)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Ffile)).Ffile, (*TXftFtFile)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Ffile)).Fid, int32((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fxsize)>>int32(6), int32((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fysize)>>int32(6)))
		}
		/* Unhook from display list */
		prev = info + 40
		for {
			if !(*(*uintptr)(unsafe.Pointer(prev)) != 0) {
				break
			}
			if *(*uintptr)(unsafe.Pointer(prev)) == public {
				*(*uintptr)(unsafe.Pointer(prev)) = (*TXftFontInt)(unsafe.Pointer(font)).Fnext
				break
			}
			goto _1
		_1:
			;
			prev = *(*uintptr)(unsafe.Pointer(prev)) + 32
		}
		/* Unhook from hash list */
		prev = info + 472 + uintptr((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fhash%uint32(m_XFT_NUM_FONT_HASH))*8
		for {
			if !(*(*uintptr)(unsafe.Pointer(prev)) != 0) {
				break
			}
			if *(*uintptr)(unsafe.Pointer(prev)) == public {
				*(*uintptr)(unsafe.Pointer(prev)) = (*TXftFontInt)(unsafe.Pointer(font)).Fhash_next
				break
			}
			goto _2
		_2:
			;
			prev = *(*uintptr)(unsafe.Pointer(prev)) + 40
		}
		/* Destroy the font */
		_XftFontDestroy(tls, dpy, public)
		(*TXftDisplayInfo)(unsafe.Pointer(info)).Fnum_unref_fonts--
	}
}

func XXftFontClose(tls *libc.TLS, dpy uintptr, public uintptr) {
	var font, info, v2 uintptr
	var v1 int32
	_, _, _, _ = font, info, v1, v2
	info = X_XftDisplayInfoGet(tls, dpy, m_False)
	font = public
	v2 = font + 160
	*(*int32)(unsafe.Pointer(v2))--
	v1 = *(*int32)(unsafe.Pointer(v2))
	if v1 != 0 {
		return
	}
	if info != 0 {
		(*TXftDisplayInfo)(unsafe.Pointer(info)).Fnum_unref_fonts++
		XXftFontManageMemory(tls, dpy)
	} else {
		_XftFontDestroy(tls, dpy, public)
	}
}

func XXftInitFtLibrary(tls *libc.TLS) (r TFcBool) {
	if X_XftFTlibrary != 0 {
		return int32(m_FcTrue)
	}
	if libfreetype.XFT_Init_FreeType(tls, uintptr(unsafe.Pointer(&X_XftFTlibrary))) != 0 {
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

const m_FT_LCD_FILTER_FIVE_TAPS = 5
const m_FT_LOAD_DEFAULT2 = 0x0
const m_FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY = "FT_PARAM_TAG_IGNORE_TYPOGRAPHIC_FAMILY"
const m_FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY = "FT_PARAM_TAG_IGNORE_TYPOGRAPHIC_SUBFAMILY"
const m_ft_glyph_bbox_gridfit = "FT_GLYPH_BBOX_GRIDFIT"
const m_ft_glyph_bbox_pixels = "FT_GLYPH_BBOX_PIXELS"
const m_ft_glyph_bbox_subpixels = "FT_GLYPH_BBOX_SUBPIXELS"
const m_ft_glyph_bbox_truncate = "FT_GLYPH_BBOX_TRUNCATE"
const m_ft_glyph_bbox_unscaled = "FT_GLYPH_BBOX_UNSCALED"

type TFT_Orientation = int32

type _FT_Orientation_ = int32

const _FT_ORIENTATION_TRUETYPE = 0
const _FT_ORIENTATION_POSTSCRIPT = 1
const _FT_ORIENTATION_FILL_RIGHT = 0
const _FT_ORIENTATION_FILL_LEFT = 1
const _FT_ORIENTATION_NONE = 2

type TFT_LcdFilter = int32

type _FT_LcdFilter_ = int32

const _FT_LCD_FILTER_NONE = 0
const _FT_LCD_FILTER_DEFAULT = 1
const _FT_LCD_FILTER_LIGHT = 2
const _FT_LCD_FILTER_LEGACY1 = 3
const _FT_LCD_FILTER_LEGACY = 16
const _FT_LCD_FILTER_MAX = 17

type TFT_LcdFiveTapFilter = [5]TFT_Byte

type TFT_Glyph = uintptr

type TFT_GlyphRec_ = struct {
	Flibrary TFT_Library
	Fclazz   uintptr
	Fformat  TFT_Glyph_Format
	Fadvance TFT_Vector
}

type TFT_GlyphRec = struct {
	Flibrary TFT_Library
	Fclazz   uintptr
	Fformat  TFT_Glyph_Format
	Fadvance TFT_Vector
}

type TFT_BitmapGlyph = uintptr

type TFT_BitmapGlyphRec_ = struct {
	Froot   TFT_GlyphRec
	Fleft   TFT_Int
	Ftop    TFT_Int
	Fbitmap TFT_Bitmap
}

type TFT_BitmapGlyphRec = struct {
	Froot   TFT_GlyphRec
	Fleft   TFT_Int
	Ftop    TFT_Int
	Fbitmap TFT_Bitmap
}

type TFT_OutlineGlyph = uintptr

type TFT_OutlineGlyphRec_ = struct {
	Froot    TFT_GlyphRec
	Foutline TFT_Outline
}

type TFT_OutlineGlyphRec = struct {
	Froot    TFT_GlyphRec
	Foutline TFT_Outline
}

type TFT_Glyph_BBox_Mode = int32

type _FT_Glyph_BBox_Mode_ = int32

const _FT_GLYPH_BBOX_UNSCALED = 0
const _FT_GLYPH_BBOX_SUBPIXELS = 0
const _FT_GLYPH_BBOX_GRIDFIT = 1
const _FT_GLYPH_BBOX_TRUNCATE = 2
const _FT_GLYPH_BBOX_PIXELS = 3

/* */

/* END */

/* Local Variables: */
/* coding: utf-8    */
/* End:             */

type Tm3x3 = [3][3]float64

func _m3x3_uniform(tls *libc.TLS, m uintptr) {
	var v1, v2, v3, v4, v5, v6, v7 float64
	_, _, _, _, _, _, _ = v1, v2, v3, v4, v5, v6, v7
	v2 = libc.Float64FromFloat64(1)
	*(*float64)(unsafe.Pointer(m + 2*24 + 2*8)) = v2
	v1 = v2
	*(*float64)(unsafe.Pointer(m + 1*24 + 1*8)) = v1
	*(*float64)(unsafe.Pointer(m)) = v1
	v7 = libc.Float64FromInt32(0)
	*(*float64)(unsafe.Pointer(m + 2*24 + 1*8)) = v7
	v6 = v7
	*(*float64)(unsafe.Pointer(m + 2*24)) = v6
	v5 = v6
	*(*float64)(unsafe.Pointer(m + 1*24 + 2*8)) = v5
	v4 = v5
	*(*float64)(unsafe.Pointer(m + 2*8)) = v4
	v3 = v4
	*(*float64)(unsafe.Pointer(m + 1*24)) = v3
	*(*float64)(unsafe.Pointer(m + 1*8)) = v3
}

func _m3x3_transform(tls *libc.TLS, v uintptr, m uintptr) {
	var x, y float64
	_, _ = x, y
	x = float64((*TFT_Vector)(unsafe.Pointer(v)).Fx)
	y = float64((*TFT_Vector)(unsafe.Pointer(v)).Fy)
	(*TFT_Vector)(unsafe.Pointer(v)).Fx = int64(x**(*float64)(unsafe.Pointer(m)) + y**(*float64)(unsafe.Pointer(m + 1*8)) + *(*float64)(unsafe.Pointer(m + 2*8)) + libc.Float64FromFloat64(0.5))
	(*TFT_Vector)(unsafe.Pointer(v)).Fy = int64(x**(*float64)(unsafe.Pointer(m + 1*24)) + y**(*float64)(unsafe.Pointer(m + 1*24 + 1*8)) + *(*float64)(unsafe.Pointer(m + 1*24 + 2*8)) + libc.Float64FromFloat64(0.5))
}

func _m3x3_invert(tls *libc.TLS, m uintptr, mi uintptr) {
	var det float64
	_ = det
	det = *(*float64)(unsafe.Pointer(m)) * (*(*float64)(unsafe.Pointer(m + 1*24 + 1*8))**(*float64)(unsafe.Pointer(m + 2*24 + 2*8)) - *(*float64)(unsafe.Pointer(m + 1*24 + 2*8))**(*float64)(unsafe.Pointer(m + 2*24 + 1*8)))
	det -= *(*float64)(unsafe.Pointer(m + 1*8)) * (*(*float64)(unsafe.Pointer(m + 1*24))**(*float64)(unsafe.Pointer(m + 2*24 + 2*8)) - *(*float64)(unsafe.Pointer(m + 1*24 + 2*8))**(*float64)(unsafe.Pointer(m + 2*24)))
	det += *(*float64)(unsafe.Pointer(m + 2*8)) * (*(*float64)(unsafe.Pointer(m + 1*24))**(*float64)(unsafe.Pointer(m + 2*24 + 1*8)) - *(*float64)(unsafe.Pointer(m + 1*24 + 1*8))**(*float64)(unsafe.Pointer(m + 2*24)))
	det = float64(1) / det
	*(*float64)(unsafe.Pointer(mi)) = det * (*(*float64)(unsafe.Pointer(m + 1*24 + 1*8))**(*float64)(unsafe.Pointer(m + 2*24 + 2*8)) - *(*float64)(unsafe.Pointer(m + 1*24 + 2*8))**(*float64)(unsafe.Pointer(m + 2*24 + 1*8)))
	*(*float64)(unsafe.Pointer(mi + 1*24)) = det * (*(*float64)(unsafe.Pointer(m + 1*24 + 2*8))**(*float64)(unsafe.Pointer(m + 2*24)) - *(*float64)(unsafe.Pointer(m + 1*24))**(*float64)(unsafe.Pointer(m + 2*24 + 2*8)))
	*(*float64)(unsafe.Pointer(mi + 2*24)) = det * (*(*float64)(unsafe.Pointer(m + 1*24))**(*float64)(unsafe.Pointer(m + 2*24 + 1*8)) - *(*float64)(unsafe.Pointer(m + 1*24 + 1*8))**(*float64)(unsafe.Pointer(m + 2*24)))
	*(*float64)(unsafe.Pointer(mi + 1*8)) = det * (*(*float64)(unsafe.Pointer(m + 2*8))**(*float64)(unsafe.Pointer(m + 2*24 + 1*8)) - *(*float64)(unsafe.Pointer(m + 1*8))**(*float64)(unsafe.Pointer(m + 2*24 + 2*8)))
	*(*float64)(unsafe.Pointer(mi + 1*24 + 1*8)) = det * (*(*float64)(unsafe.Pointer(m))**(*float64)(unsafe.Pointer(m + 2*24 + 2*8)) - *(*float64)(unsafe.Pointer(m + 2*8))**(*float64)(unsafe.Pointer(m + 2*24)))
	*(*float64)(unsafe.Pointer(mi + 2*24 + 1*8)) = det * (*(*float64)(unsafe.Pointer(m + 1*8))**(*float64)(unsafe.Pointer(m + 2*24)) - *(*float64)(unsafe.Pointer(m))**(*float64)(unsafe.Pointer(m + 2*24 + 1*8)))
	*(*float64)(unsafe.Pointer(mi + 2*8)) = det * (*(*float64)(unsafe.Pointer(m + 1*8))**(*float64)(unsafe.Pointer(m + 1*24 + 2*8)) - *(*float64)(unsafe.Pointer(m + 2*8))**(*float64)(unsafe.Pointer(m + 1*24 + 1*8)))
	*(*float64)(unsafe.Pointer(mi + 1*24 + 2*8)) = det * (*(*float64)(unsafe.Pointer(m + 2*8))**(*float64)(unsafe.Pointer(m + 1*24)) - *(*float64)(unsafe.Pointer(m))**(*float64)(unsafe.Pointer(m + 1*24 + 2*8)))
	*(*float64)(unsafe.Pointer(mi + 2*24 + 2*8)) = det * (*(*float64)(unsafe.Pointer(m))**(*float64)(unsafe.Pointer(m + 1*24 + 1*8)) - *(*float64)(unsafe.Pointer(m + 1*8))**(*float64)(unsafe.Pointer(m + 1*24)))
}

/*
 * Validate the memory info for a font
 */

func __XftFontValidateMemory(tls *libc.TLS, dpy uintptr, public uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var font, xftg uintptr
	var glyph_memory uint64
	var glyphindex TFT_UInt
	_, _, _, _ = font, glyph_memory, glyphindex, xftg
	font = public
	glyph_memory = uint64(0)
	glyphindex = uint32(0)
	for {
		if !(glyphindex < (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs) {
			break
		}
		xftg = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(glyphindex)*8))
		if xftg != 0 {
			glyph_memory += (*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory
		}
		goto _1
	_1:
		;
		glyphindex++
	}
	if glyph_memory != (*TXftFontInt)(unsafe.Pointer(font)).Fglyph_memory {
		libc.Xprintf(tls, __ccgo_ts+1452, libc.VaList(bp+8, (*TXftFontInt)(unsafe.Pointer(font)).Fglyph_memory, glyph_memory))
	}
}

// C documentation
//
//	/*
//	 * Validate the glyph usage-links for a font.
//	 */
func __XftValidateGlyphUsage(tls *libc.TLS, font uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var forward, next, reverse, v2, v4 TFT_UInt
	var x1st, xuse uintptr
	_, _, _, _, _, _, _ = forward, next, reverse, x1st, xuse, v2, v4
	if (*TXftFontInt)(unsafe.Pointer(font)).Fnewest != libc.Uint32FromInt32(m___INT_MAX__)*libc.Uint32FromUint32(2)+libc.Uint32FromUint32(1) {
		x1st = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr((*TXftFontInt)(unsafe.Pointer(font)).Fnewest)*8))
		xuse = x1st
		forward = uint32(1)
		next = (*TXftGlyphUsage)(unsafe.Pointer(x1st)).Fnewer
		for {
			if !(xuse != libc.UintptrFromInt32(0) && next != (*TXftFontInt)(unsafe.Pointer(font)).Fnewest) {
				break
			}
			if next >= (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs {
				libc.Xprintf(tls, __ccgo_ts+1511, libc.VaList(bp+8, next))
				break
			}
			forward++
			v2 = forward
			if v2 > (*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse {
				libc.Xprintf(tls, __ccgo_ts+1534, libc.VaList(bp+8, forward, (*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse))
				if forward > (*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse+uint32(10) {
					break
				}
			}
			xuse = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(next)*8))
			goto _1
		_1:
			;
			next = (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Fnewer
		}
		if forward < (*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse {
			libc.Xprintf(tls, __ccgo_ts+1574, libc.VaList(bp+8, forward, (*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse))
		}
		reverse = uint32(1)
		next = (*TXftGlyphUsage)(unsafe.Pointer(x1st)).Folder
		for {
			if !(xuse != libc.UintptrFromInt32(0) && next != (*TXftFontInt)(unsafe.Pointer(font)).Fnewest) {
				break
			}
			if next >= (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs {
				libc.Xprintf(tls, __ccgo_ts+1613, libc.VaList(bp+8, next))
				break
			}
			reverse++
			v4 = reverse
			if v4 > (*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse {
				libc.Xprintf(tls, __ccgo_ts+1534, libc.VaList(bp+8, reverse, (*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse))
				if reverse > (*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse+uint32(10) {
					break
				}
			}
			xuse = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(next)*8))
			goto _3
		_3:
			;
			next = (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Folder
		}
		if reverse < (*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse {
			libc.Xprintf(tls, __ccgo_ts+1574, libc.VaList(bp+8, reverse, (*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse))
		}
		if forward != reverse {
			libc.Xprintf(tls, __ccgo_ts+1635, libc.VaList(bp+8, forward, reverse))
			libc.Xexit(tls, int32(1))
		}
	}
}

// C documentation
//
//	/* we sometimes need to convert the glyph bitmap in a FT_GlyphSlot
//	 * into a different format. For example, we want to convert a
//	 * FT_PIXEL_MODE_LCD or FT_PIXEL_MODE_LCD_V bitmap into a 32-bit
//	 * ARGB or ABGR bitmap.
//	 *
//	 * this function prepares a target descriptor for this operation.
//	 *
//	 * input :: target bitmap descriptor. The function will set its
//	 *          'width', 'rows' and 'pitch' fields, and only these
//	 *
//	 * slot  :: the glyph slot containing the source bitmap. this
//	 *          function assumes that slot->format == FT_GLYPH_FORMAT_BITMAP
//	 *
//	 * mode  :: the requested final rendering mode. supported values are
//	 *          MONO, NORMAL (i.e. gray), LCD and LCD_V
//	 *
//	 * the function returns the size in bytes of the corresponding buffer,
//	 * it's up to the caller to allocate the corresponding memory block
//	 * before calling _fill_xrender_bitmap
//	 *
//	 * it also returns -1 in case of error (e.g. incompatible arguments,
//	 * like trying to convert a gray bitmap into a monochrome one)
//	 */
func __compute_xrender_bitmap_size(tls *libc.TLS, target uintptr, slot TFT_GlyphSlot, mode TFT_Render_Mode, matrix uintptr, m uintptr) (r int32) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var bottom, height, left, pitch, right, top, width, xc, yc, v1, v2, v3, v6, v7 int32
	var ftbit uintptr
	var v10 float64
	var v8 TFT_Fixed
	var v9 TFT_Pos
	var _ /* inverse at bp+32 */ TFT_Matrix
	var _ /* mirror at bp+0 */ TFT_Matrix
	var _ /* vector at bp+64 */ TFT_Vector
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = bottom, ftbit, height, left, pitch, right, top, width, xc, yc, v1, v10, v2, v3, v6, v7, v8, v9
	if (*TFT_GlyphSlotRec_)(unsafe.Pointer(slot)).Fformat != int32(_FT_GLYPH_FORMAT_BITMAP) {
		return -int32(1)
	}
	/* compute the size of the final bitmap */
	ftbit = slot + 152
	width = int32((*TFT_Bitmap)(unsafe.Pointer(ftbit)).Fwidth)
	height = int32((*TFT_Bitmap)(unsafe.Pointer(ftbit)).Frows)
	if matrix != 0 && mode == int32(_FT_RENDER_MODE_NORMAL) {
		v3 = libc.Int32FromInt32(0)
		bottom = v3
		v2 = v3
		top = v2
		v1 = v2
		right = v1
		left = v1
		xc = 0
		for {
			if !(xc <= int32(1)) {
				break
			}
			yc = 0
			for {
				if !(yc <= int32(1)) {
					break
				}
				(*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fx = int64(xc * width)
				(*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fy = int64(yc * height)
				libfreetype.XFT_Vector_Transform(tls, bp+64, matrix)
				if xc == 0 && yc == 0 {
					v6 = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fx)
					right = v6
					left = v6
					v7 = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fy)
					bottom = v7
					top = v7
				} else {
					if int64(left) > (*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fx {
						left = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fx)
					}
					if int64(right) < (*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fx {
						right = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fx)
					}
					if int64(bottom) > (*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fy {
						bottom = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fy)
					}
					if int64(top) < (*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fy {
						top = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fy)
					}
				}
				goto _5
			_5:
				;
				yc++
			}
			goto _4
		_4:
			;
			xc++
		}
		width = right - left
		height = top - bottom
		(*(*TFT_Matrix)(unsafe.Pointer(bp))).Fxx = int64(+libc.Int32FromInt32(0x10000))
		(*(*TFT_Matrix)(unsafe.Pointer(bp))).Fyy = int64(-int32(0x10000))
		v8 = libc.Int64FromInt32(0)
		(*(*TFT_Matrix)(unsafe.Pointer(bp))).Fyx = v8
		(*(*TFT_Matrix)(unsafe.Pointer(bp))).Fxy = v8
		*(*TFT_Matrix)(unsafe.Pointer(bp + 32)) = *(*TFT_Matrix)(unsafe.Pointer(matrix))
		libfreetype.XFT_Matrix_Multiply(tls, bp, bp+32)
		libfreetype.XFT_Matrix_Invert(tls, bp+32)
		libfreetype.XFT_Matrix_Multiply(tls, bp, bp+32)
		v9 = libc.Int64FromInt32(0)
		(*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fy = v9
		(*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fx = v9
		libfreetype.XFT_Vector_Transform(tls, bp+64, bp+32)
		left = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fx)
		bottom = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fy)
		(*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fx = int64(width)
		(*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fy = int64(height)
		libfreetype.XFT_Vector_Transform(tls, bp+64, bp+32)
		right = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fx)
		top = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 64))).Fy)
		left = right - left - int32((*TFT_Bitmap)(unsafe.Pointer(ftbit)).Fwidth)
		bottom = top - bottom - int32((*TFT_Bitmap)(unsafe.Pointer(ftbit)).Frows)
		*(*float64)(unsafe.Pointer(m)) = float64((*(*TFT_Matrix)(unsafe.Pointer(bp + 32))).Fxx) / libc.Float64FromInt32(0x10000)
		*(*float64)(unsafe.Pointer(m + 1*8)) = float64((*(*TFT_Matrix)(unsafe.Pointer(bp + 32))).Fxy) / libc.Float64FromInt32(0x10000)
		*(*float64)(unsafe.Pointer(m + 1*24)) = float64((*(*TFT_Matrix)(unsafe.Pointer(bp + 32))).Fyx) / libc.Float64FromInt32(0x10000)
		*(*float64)(unsafe.Pointer(m + 1*24 + 1*8)) = float64((*(*TFT_Matrix)(unsafe.Pointer(bp + 32))).Fyy) / libc.Float64FromInt32(0x10000)
		*(*float64)(unsafe.Pointer(m + 2*8)) = float64(-left) / libc.Float64FromInt32(2)
		*(*float64)(unsafe.Pointer(m + 1*24 + 2*8)) = float64(-bottom) / libc.Float64FromInt32(2)
		v10 = libc.Float64FromFloat64(0)
		*(*float64)(unsafe.Pointer(m + 2*24 + 1*8)) = v10
		*(*float64)(unsafe.Pointer(m + 2*24)) = v10
		*(*float64)(unsafe.Pointer(m + 2*24 + 2*8)) = float64(1)
	}
	pitch = (width + int32(3)) & ^libc.Int32FromInt32(3)
	switch int32((*TFT_Bitmap)(unsafe.Pointer(ftbit)).Fpixel_mode) {
	case int32(_FT_PIXEL_MODE_MONO):
		if mode == int32(_FT_RENDER_MODE_MONO) {
			pitch = (width + int32(31)) & ^libc.Int32FromInt32(31) >> int32(3)
			break
		}
		/* fall-through */
		fallthrough
	case int32(_FT_PIXEL_MODE_GRAY):
		if mode == int32(_FT_RENDER_MODE_LCD) || mode == int32(_FT_RENDER_MODE_LCD_V) {
			/* each pixel is replicated into a 32-bit ARGB value */
			pitch = width * int32(4)
		}
	case int32(_FT_PIXEL_MODE_BGRA):
		pitch = width * int32(4)
	case int32(_FT_PIXEL_MODE_LCD):
		if mode != int32(_FT_RENDER_MODE_LCD) {
			return -int32(1)
		}
		/* horz pixel triplets are packed into 32-bit ARGB values */
		width /= int32(3)
		pitch = width * int32(4)
	case int32(_FT_PIXEL_MODE_LCD_V):
		if mode != int32(_FT_RENDER_MODE_LCD_V) {
			return -int32(1)
		}
		/* vert pixel triplets are packed into 32-bit ARGB values */
		height /= int32(3)
		pitch = width * int32(4)
	default: /* unsupported source format */
		return -int32(1)
	}
	(*TFT_Bitmap)(unsafe.Pointer(target)).Fwidth = uint32(width)
	(*TFT_Bitmap)(unsafe.Pointer(target)).Frows = uint32(height)
	(*TFT_Bitmap)(unsafe.Pointer(target)).Fpitch = pitch
	(*TFT_Bitmap)(unsafe.Pointer(target)).Fbuffer = libc.UintptrFromInt32(0)
	return pitch * height
}

// C documentation
//
//	/* this functions converts the glyph bitmap found in a FT_GlyphSlot
//	 * into a different format while scaling by applying the given matrix
//	 * (see _compute_xrender_bitmap_size)
//	 *
//	 * you should call this function after _compute_xrender_bitmap_size
//	 *
//	 * target :: target bitmap descriptor. Note that its 'buffer' pointer
//	 *           must point to memory allocated by the caller
//	 *
//	 * source :: the source bitmap descriptor
//	 *
//	 * matrix :: the scaling matrix to apply
//	 */
func __scaled_fill_xrender_bitmap(tls *libc.TLS, target uintptr, source uintptr, m uintptr) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var dst_line, src, src_buf uintptr
	var height, i, pitch, sample_count, sample_x, sample_y, sampling_height, sampling_width, src_pitch, src_x, src_y, width, x, y int32
	var _ /* bgra at bp+32 */ [4]int32
	var _ /* vector at bp+0 */ TFT_Vector
	var _ /* vector0 at bp+16 */ TFT_Vector
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = dst_line, height, i, pitch, sample_count, sample_x, sample_y, sampling_height, sampling_width, src, src_buf, src_pitch, src_x, src_y, width, x, y
	src_buf = (*TFT_Bitmap)(unsafe.Pointer(source)).Fbuffer
	dst_line = (*TFT_Bitmap)(unsafe.Pointer(target)).Fbuffer
	src_pitch = (*TFT_Bitmap)(unsafe.Pointer(source)).Fpitch
	width = int32((*TFT_Bitmap)(unsafe.Pointer(target)).Fwidth)
	height = int32((*TFT_Bitmap)(unsafe.Pointer(target)).Frows)
	pitch = (*TFT_Bitmap)(unsafe.Pointer(target)).Fpitch
	if src_pitch < 0 {
		src_buf -= uintptr(uint32(src_pitch) * ((*TFT_Bitmap)(unsafe.Pointer(source)).Frows - libc.Uint32FromInt32(1)))
	}
	/* compute how many source pixels a target pixel spans */
	(*(*TFT_Vector)(unsafe.Pointer(bp))).Fx = int64(1)
	(*(*TFT_Vector)(unsafe.Pointer(bp))).Fy = int64(1)
	_m3x3_transform(tls, bp, m)
	(*(*TFT_Vector)(unsafe.Pointer(bp + 16))).Fx = 0
	(*(*TFT_Vector)(unsafe.Pointer(bp + 16))).Fy = 0
	_m3x3_transform(tls, bp+16, m)
	sampling_width = int32(((*(*TFT_Vector)(unsafe.Pointer(bp))).Fx - (*(*TFT_Vector)(unsafe.Pointer(bp + 16))).Fx) / libc.Int64FromInt32(2))
	sampling_height = int32(((*(*TFT_Vector)(unsafe.Pointer(bp))).Fy - (*(*TFT_Vector)(unsafe.Pointer(bp + 16))).Fy) / libc.Int64FromInt32(2))
	if sampling_width < 0 {
		sampling_width = -sampling_width
	}
	if sampling_height < 0 {
		sampling_height = -sampling_height
	}
	sample_count = (int32(2)*sampling_width + int32(1)) * (int32(2)*sampling_height + int32(1))
	y = height
	for {
		if !(y > 0) {
			break
		}
		x = 0
		for {
			if !(x < width) {
				break
			}
			/* compute target pixel location in source space */
			(*(*TFT_Vector)(unsafe.Pointer(bp))).Fx = int64(x)
			(*(*TFT_Vector)(unsafe.Pointer(bp))).Fy = int64(height - y)
			_m3x3_transform(tls, bp, m)
			if int32((*TFT_Bitmap)(unsafe.Pointer(source)).Fpixel_mode) == int32(_FT_PIXEL_MODE_BGRA) {
				if (*(*TFT_Vector)(unsafe.Pointer(bp))).Fx < int64(-sampling_width) || (*(*TFT_Vector)(unsafe.Pointer(bp))).Fx > int64((*TFT_Bitmap)(unsafe.Pointer(source)).Fwidth+uint32(sampling_width)) {
					goto _2
				}
				if (*(*TFT_Vector)(unsafe.Pointer(bp))).Fy < int64(-sampling_height) || (*(*TFT_Vector)(unsafe.Pointer(bp))).Fy > int64((*TFT_Bitmap)(unsafe.Pointer(source)).Frows+uint32(sampling_height)) {
					goto _2
				}
			} else {
				if (*(*TFT_Vector)(unsafe.Pointer(bp))).Fx < 0 || (*(*TFT_Vector)(unsafe.Pointer(bp))).Fx >= int64((*TFT_Bitmap)(unsafe.Pointer(source)).Fwidth) {
					goto _2
				}
				if (*(*TFT_Vector)(unsafe.Pointer(bp))).Fy < 0 || (*(*TFT_Vector)(unsafe.Pointer(bp))).Fy >= int64((*TFT_Bitmap)(unsafe.Pointer(source)).Frows) {
					goto _2
				}
			}
			switch int32((*TFT_Bitmap)(unsafe.Pointer(source)).Fpixel_mode) {
			case int32(_FT_PIXEL_MODE_MONO): /* convert mono to 8-bit gray, scale using nearest pixel */
				src = src_buf + uintptr((*(*TFT_Vector)(unsafe.Pointer(bp))).Fy*int64(src_pitch))
				if int32(*(*uint8)(unsafe.Pointer(src + uintptr((*(*TFT_Vector)(unsafe.Pointer(bp))).Fx>>libc.Int32FromInt32(3)))))&(int32(0x80)>>((*(*TFT_Vector)(unsafe.Pointer(bp))).Fx&int64(7))) != 0 {
					*(*uint8)(unsafe.Pointer(dst_line + uintptr(x))) = uint8(0xff)
				}
			case int32(_FT_PIXEL_MODE_GRAY): /* scale using nearest pixel */
				src = src_buf + uintptr((*(*TFT_Vector)(unsafe.Pointer(bp))).Fy*int64(src_pitch))
				*(*uint8)(unsafe.Pointer(dst_line + uintptr(x))) = *(*uint8)(unsafe.Pointer(src + uintptr((*(*TFT_Vector)(unsafe.Pointer(bp))).Fx)))
			case int32(_FT_PIXEL_MODE_BGRA): /* scale by averaging all relevant source pixels, keep BGRA format */
				*(*[4]int32)(unsafe.Pointer(bp + 32)) = [4]int32{}
				sample_y = -sampling_height
				for {
					if !(sample_y < sampling_height+int32(1)) {
						break
					}
					src_y = int32((*(*TFT_Vector)(unsafe.Pointer(bp))).Fy + int64(sample_y))
					if src_y < 0 || int64(src_y) >= int64((*TFT_Bitmap)(unsafe.Pointer(source)).Frows) {
						goto _3
					}
					src = src_buf + uintptr(src_y*src_pitch)
					sample_x = -sampling_width
					for {
						if !(sample_x < sampling_width+int32(1)) {
							break
						}
						src_x = int32((*(*TFT_Vector)(unsafe.Pointer(bp))).Fx + int64(sample_x))
						if src_x < 0 || int64(src_x) >= int64((*TFT_Bitmap)(unsafe.Pointer(source)).Fwidth) {
							goto _4
						}
						i = 0
						for {
							if !(i < int32(4)) {
								break
							}
							*(*int32)(unsafe.Pointer(bp + 32 + uintptr(i)*4)) += int32(*(*uint8)(unsafe.Pointer(src + uintptr(src_x*int32(4)+i))))
							goto _5
						_5:
							;
							i++
						}
						goto _4
					_4:
						;
						sample_x++
					}
					goto _3
				_3:
					;
					sample_y++
				}
				i = 0
				for {
					if !(i < int32(4)) {
						break
					}
					*(*uint8)(unsafe.Pointer(dst_line + uintptr(int32(4)*x+i))) = uint8((*(*[4]int32)(unsafe.Pointer(bp + 32)))[i] / sample_count)
					goto _6
				_6:
					;
					i++
				}
				break
			}
			goto _2
		_2:
			;
			x++
		}
		goto _1
	_1:
		;
		y--
		dst_line += uintptr(pitch)
	}
}

// C documentation
//
//	/* this functions converts the glyph bitmap found in a FT_GlyphSlot
//	 * into a different format (see _compute_xrender_bitmap_size)
//	 *
//	 * you should call this function after _compute_xrender_bitmap_size
//	 *
//	 * target :: target bitmap descriptor. Note that its 'buffer' pointer
//	 *           must point to memory allocated by the caller
//	 *
//	 * slot   :: the glyph slot containing the source bitmap
//	 *
//	 * mode   :: the requested final rendering mode
//	 *
//	 * bgr    :: boolean, set if BGR or VBGR pixel ordering is needed
//	 */
func __fill_xrender_bitmap(tls *libc.TLS, target uintptr, slot TFT_GlyphSlot, mode TFT_Render_Mode, bgr int32) {
	var bytes, h, height, pitch, src_pitch, subpixel, width, x, x1, x2, x3, x4, x5, x6 int32
	var dst, dst1, dst2, dst3, dst4, dstLine, ftbit, src, src1, src2, src3, srcLine uintptr
	var pix, pix1, pix2, pix3, pix4 uint32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = bytes, dst, dst1, dst2, dst3, dst4, dstLine, ftbit, h, height, pitch, pix, pix1, pix2, pix3, pix4, src, src1, src2, src3, srcLine, src_pitch, subpixel, width, x, x1, x2, x3, x4, x5, x6
	ftbit = slot + 152
	srcLine = (*TFT_Bitmap)(unsafe.Pointer(ftbit)).Fbuffer
	dstLine = (*TFT_Bitmap)(unsafe.Pointer(target)).Fbuffer
	src_pitch = (*TFT_Bitmap)(unsafe.Pointer(ftbit)).Fpitch
	width = int32((*TFT_Bitmap)(unsafe.Pointer(target)).Fwidth)
	height = int32((*TFT_Bitmap)(unsafe.Pointer(target)).Frows)
	pitch = (*TFT_Bitmap)(unsafe.Pointer(target)).Fpitch
	subpixel = libc.BoolInt32(mode == int32(_FT_RENDER_MODE_LCD) || mode == int32(_FT_RENDER_MODE_LCD_V))
	if src_pitch < 0 {
		srcLine -= uintptr(uint32(src_pitch) * ((*TFT_Bitmap)(unsafe.Pointer(ftbit)).Frows - libc.Uint32FromInt32(1)))
	}
	switch int32((*TFT_Bitmap)(unsafe.Pointer(ftbit)).Fpixel_mode) {
	case int32(_FT_PIXEL_MODE_MONO):
		goto _1
	case int32(_FT_PIXEL_MODE_GRAY):
		goto _2
	case int32(_FT_PIXEL_MODE_BGRA):
		goto _3
	case int32(_FT_PIXEL_MODE_LCD):
		goto _4
	default:
		goto _5
	}
	goto _6
_1:
	;
	if subpixel != 0 { /* convert mono to ARGB32 values */
		h = height
		for {
			if !(h > 0) {
				break
			}
			x = 0
			for {
				if !(x < width) {
					break
				}
				if int32(*(*uint8)(unsafe.Pointer(srcLine + uintptr(x>>libc.Int32FromInt32(3)))))&(int32(0x80)>>(x&int32(7))) != 0 {
					*(*uint32)(unsafe.Pointer(dstLine + uintptr(x)*4)) = uint32(0xffffffff)
				}
				goto _8
			_8:
				;
				x++
			}
			goto _7
		_7:
			;
			h--
			srcLine += uintptr(src_pitch)
			dstLine += uintptr(pitch)
		}
	} else {
		if mode == int32(_FT_RENDER_MODE_NORMAL) { /* convert mono to 8-bit gray */
			h = height
			for {
				if !(h > 0) {
					break
				}
				x1 = 0
				for {
					if !(x1 < width) {
						break
					}
					if int32(*(*uint8)(unsafe.Pointer(srcLine + uintptr(x1>>libc.Int32FromInt32(3)))))&(int32(0x80)>>(x1&int32(7))) != 0 {
						*(*uint8)(unsafe.Pointer(dstLine + uintptr(x1))) = uint8(0xff)
					}
					goto _10
				_10:
					;
					x1++
				}
				goto _9
			_9:
				;
				h--
				srcLine += uintptr(src_pitch)
				dstLine += uintptr(pitch)
			}
		} else { /* copy mono to mono */
			bytes = (width + int32(7)) >> int32(3)
			h = height
			for {
				if !(h > 0) {
					break
				}
				libc.X__builtin___memcpy_chk(tls, dstLine, srcLine, uint64(bytes), uint64(libc.X__builtin_object_size(tls, dstLine, 0)))
				goto _11
			_11:
				;
				h--
				srcLine += uintptr(src_pitch)
				dstLine += uintptr(pitch)
			}
		}
	}
	goto _6
_2:
	;
	if subpixel != 0 { /* convert gray to ARGB32 values */
		h = height
		for {
			if !(h > 0) {
				break
			}
			dst = dstLine
			x2 = 0
			for {
				if !(x2 < width) {
					break
				}
				pix = uint32(*(*uint8)(unsafe.Pointer(srcLine + uintptr(x2))))
				pix |= pix << int32(8)
				pix |= pix << int32(16)
				*(*uint32)(unsafe.Pointer(dst + uintptr(x2)*4)) = pix
				goto _13
			_13:
				;
				x2++
			}
			goto _12
		_12:
			;
			h--
			srcLine += uintptr(src_pitch)
			dstLine += uintptr(pitch)
		}
	} else { /* copy gray into gray */
		h = height
		for {
			if !(h > 0) {
				break
			}
			libc.X__builtin___memcpy_chk(tls, dstLine, srcLine, uint64(width), uint64(libc.X__builtin_object_size(tls, dstLine, 0)))
			goto _14
		_14:
			;
			h--
			srcLine += uintptr(src_pitch)
			dstLine += uintptr(pitch)
		}
	}
	goto _6
_3:
	; /* Preserve BGRA format */
	h = height
_17:
	;
	if !(h > 0) {
		goto _15
	}
	libc.X__builtin___memcpy_chk(tls, dstLine, srcLine, uint64(width)*uint64(4), uint64(libc.X__builtin_object_size(tls, dstLine, 0)))
	goto _16
_16:
	;
	h--
	srcLine += uintptr(src_pitch)
	dstLine += uintptr(pitch)
	goto _17
	goto _15
_15:
	;
	goto _6
_4:
	;
	if !(bgr != 0) {
		/* convert horizontal RGB into ARGB32 */
		h = height
		for {
			if !(h > 0) {
				break
			}
			src = srcLine
			dst1 = dstLine
			x3 = 0
			for {
				if !(x3 < width) {
					break
				}
				pix1 = uint32(*(*uint8)(unsafe.Pointer(src)))<<int32(16) | uint32(*(*uint8)(unsafe.Pointer(src + 1)))<<int32(8) | uint32(*(*uint8)(unsafe.Pointer(src + 2))) | uint32(*(*uint8)(unsafe.Pointer(src + 1)))<<int32(24)
				*(*uint32)(unsafe.Pointer(dst1 + uintptr(x3)*4)) = pix1
				goto _19
			_19:
				;
				x3++
				src += uintptr(3)
			}
			goto _18
		_18:
			;
			h--
			srcLine += uintptr(src_pitch)
			dstLine += uintptr(pitch)
		}
	} else {
		/* convert horizontal BGR into ARGB32 */
		h = height
		for {
			if !(h > 0) {
				break
			}
			src1 = srcLine
			dst2 = dstLine
			x4 = 0
			for {
				if !(x4 < width) {
					break
				}
				pix2 = uint32(*(*uint8)(unsafe.Pointer(src1 + 2)))<<int32(16) | uint32(*(*uint8)(unsafe.Pointer(src1 + 1)))<<int32(8) | uint32(*(*uint8)(unsafe.Pointer(src1))) | uint32(*(*uint8)(unsafe.Pointer(src1 + 1)))<<int32(24)
				*(*uint32)(unsafe.Pointer(dst2 + uintptr(x4)*4)) = pix2
				goto _21
			_21:
				;
				x4++
				src1 += uintptr(3)
			}
			goto _20
		_20:
			;
			h--
			srcLine += uintptr(src_pitch)
			dstLine += uintptr(pitch)
		}
	}
	goto _6
_5:
	; /* FT_PIXEL_MODE_LCD_V */
	/* convert vertical RGB into ARGB32 */
	if !(bgr != 0) {
		h = height
		for {
			if !(h > 0) {
				break
			}
			src2 = srcLine
			dst3 = dstLine
			x5 = 0
			for {
				if !(x5 < width) {
					break
				}
				pix3 = uint32(*(*uint8)(unsafe.Pointer(src2)))<<int32(16) | uint32(*(*uint8)(unsafe.Pointer(src2 + uintptr(src_pitch))))<<int32(8) | uint32(*(*uint8)(unsafe.Pointer(src2 + uintptr(src_pitch*int32(2))))) | uint32(*(*uint8)(unsafe.Pointer(src2 + uintptr(src_pitch))))<<int32(24)
				*(*uint32)(unsafe.Pointer(dst3 + uintptr(x5)*4)) = pix3
				goto _23
			_23:
				;
				x5++
				src2 += uintptr(1)
			}
			goto _22
		_22:
			;
			h--
			srcLine += uintptr(int32(3) * src_pitch)
			dstLine += uintptr(pitch)
		}
	} else {
		h = height
		for {
			if !(h > 0) {
				break
			}
			src3 = srcLine
			dst4 = dstLine
			x6 = 0
			for {
				if !(x6 < width) {
					break
				}
				pix4 = uint32(*(*uint8)(unsafe.Pointer(src3 + uintptr(src_pitch*int32(2)))))<<int32(16) | uint32(*(*uint8)(unsafe.Pointer(src3 + uintptr(src_pitch))))<<int32(8) | uint32(*(*uint8)(unsafe.Pointer(src3))) | uint32(*(*uint8)(unsafe.Pointer(src3 + uintptr(src_pitch))))<<int32(24)
				*(*uint32)(unsafe.Pointer(dst4 + uintptr(x6)*4)) = pix4
				goto _25
			_25:
				;
				x6++
				src3 += uintptr(1)
			}
			goto _24
		_24:
			;
			h--
			srcLine += uintptr(int32(3) * src_pitch)
			dstLine += uintptr(pitch)
		}
	}
_6:
}

func XXftFontLoadGlyphs(tls *libc.TLS, dpy uintptr, pub uintptr, need_bitmaps TFcBool, glyphs uintptr, nglyph int32) {
	bp := tls.Alloc(4544)
	defer tls.Free(4544)
	var adjust, adjust1, bottom, bufSize, c, height, i, left, right, size, top, width, x, xc, y, yc, v1, v10, v11, v15, v17, v3, v4, v5, v8, v9 int32
	var bufBitmap, font, ftbit, info, line, line1, xftg, xnew, xold, xuse, v16, v18, v2 uintptr
	var error1 TFT_Error
	var face TFT_Face
	var gc TGC
	var glyph_transform, transform TFcBool
	var glyphindex TFT_UInt
	var glyphslot TFT_GlyphSlot
	var maximum_x, maximum_y, trimmed_x, trimmed_y int16
	var mode TFT_Render_Mode
	var pixmap TPixmap
	var _ /* bufLocal at bp+8 */ [4096]uint8
	var _ /* glyph at bp+0 */ TGlyph
	var _ /* image at bp+4304 */ TXImage
	var _ /* local at bp+4104 */ TFT_Bitmap
	var _ /* m at bp+4160 */ Tm3x3
	var _ /* mi at bp+4232 */ Tm3x3
	var _ /* vector at bp+4144 */ TFT_Vector
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = adjust, adjust1, bottom, bufBitmap, bufSize, c, error1, face, font, ftbit, gc, glyph_transform, glyphindex, glyphslot, height, i, info, left, line, line1, maximum_x, maximum_y, mode, pixmap, right, size, top, transform, trimmed_x, trimmed_y, width, x, xc, xftg, xnew, xold, xuse, y, yc, v1, v10, v11, v15, v16, v17, v18, v2, v3, v4, v5, v8, v9
	info = X_XftDisplayInfoGet(tls, dpy, int32(m_True))
	font = pub
	bufBitmap = bp + 8
	bufSize = int32(4096)
	mode = int32(_FT_RENDER_MODE_MONO)
	if !(info != 0) {
		return
	}
	face = XXftLockFace(tls, font)
	if !(face != 0) {
		return
	}
	if (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fcolor != 0 {
		mode = int32(_FT_RENDER_MODE_NORMAL)
	}
	if (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fantialias != 0 {
		switch (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Frgba {
		case int32(m_FC_RGBA_RGB):
			fallthrough
		case int32(m_FC_RGBA_BGR):
			mode = int32(_FT_RENDER_MODE_LCD)
		case int32(m_FC_RGBA_VRGB):
			fallthrough
		case int32(m_FC_RGBA_VBGR):
			mode = int32(_FT_RENDER_MODE_LCD_V)
		default:
			mode = int32(_FT_RENDER_MODE_NORMAL)
		}
	}
	transform = libc.BoolInt32((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Ftransform != 0 && mode != int32(_FT_RENDER_MODE_MONO))
	for {
		v1 = nglyph
		nglyph--
		if !(v1 != 0) {
			break
		}
		v2 = glyphs
		glyphs += 4
		glyphindex = *(*TFT_UInt)(unsafe.Pointer(v2))
		xftg = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(glyphindex)*8))
		if !(xftg != 0) {
			continue
		}
		if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
			__XftFontValidateMemory(tls, dpy, pub)
		}
		/*
		 * Check to see if this glyph has just been loaded,
		 * this happens when drawing the same glyph twice
		 * in a single string
		 */
		if (*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory != 0 {
			continue
		}
		libfreetype.XFT_Library_SetLcdFilter(tls, X_XftFTlibrary, (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Flcd_filter)
		error1 = libfreetype.XFT_Load_Glyph(tls, face, glyphindex, (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fload_flags)
		if error1 != 0 {
			/*
			 * If anti-aliasing or transforming glyphs and
			 * no outline version exists, fallback to the
			 * bitmap and let things look bad instead of
			 * missing the glyph
			 */
			if int64((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fload_flags)&(libc.Int64FromInt64(1)<<libc.Int32FromInt32(3)) != 0 {
				error1 = libfreetype.XFT_Load_Glyph(tls, face, glyphindex, int32(int64((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fload_flags) & ^(libc.Int64FromInt64(1)<<libc.Int32FromInt32(3))))
			}
			if error1 != 0 {
				continue
			}
		}
		glyphslot = (*TFT_FaceRec_)(unsafe.Pointer(face)).Fglyph
		/*
		 * Embolden if required
		 */
		if (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fembolden != 0 {
			libfreetype.XFT_GlyphSlot_Embolden(tls, glyphslot)
		}
		/*
		 * Compute glyph metrics from FreeType information
		 */
		if transform != 0 {
			v5 = libc.Int32FromInt32(0)
			bottom = v5
			v4 = v5
			top = v4
			v3 = v4
			right = v3
			left = v3
			xc = 0
			for {
				if !(xc <= int32(1)) {
					break
				}
				yc = 0
				for {
					if !(yc <= int32(1)) {
						break
					}
					(*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fx = (*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fmetrics.FhoriBearingX + int64(xc)*(*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fmetrics.Fwidth
					(*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fy = (*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fmetrics.FhoriBearingY - int64(yc)*(*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fmetrics.Fheight
					libfreetype.XFT_Vector_Transform(tls, bp+4144, font+48+56)
					if XXftDebug(tls)&int32(m_XFT_DBG_GLYPH) != 0 {
						libc.Xprintf(tls, __ccgo_ts+1666, libc.VaList(bp+4448, xc, yc, int32((*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fx), int32((*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fy)))
					}
					if xc == 0 && yc == 0 {
						v8 = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fx)
						right = v8
						left = v8
						v9 = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fy)
						bottom = v9
						top = v9
					} else {
						if int64(left) > (*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fx {
							left = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fx)
						}
						if int64(right) < (*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fx {
							right = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fx)
						}
						if int64(bottom) > (*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fy {
							bottom = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fy)
						}
						if int64(top) < (*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fy {
							top = int32((*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fy)
						}
					}
					goto _7
				_7:
					;
					yc++
				}
				goto _6
			_6:
				;
				xc++
			}
			left = left & -libc.Int32FromInt32(64)
			right = (right + libc.Int32FromInt32(63)) & -libc.Int32FromInt32(64)
			bottom = bottom & -libc.Int32FromInt32(64)
			top = (top + libc.Int32FromInt32(63)) & -libc.Int32FromInt32(64)
		} else {
			left = int32((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fmetrics.FhoriBearingX & int64(-libc.Int32FromInt32(64)))
			right = int32(((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fmetrics.FhoriBearingX + (*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fmetrics.Fwidth + libc.Int64FromInt32(63)) & int64(-libc.Int32FromInt32(64)))
			top = int32(((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fmetrics.FhoriBearingY + libc.Int64FromInt32(63)) & int64(-libc.Int32FromInt32(64)))
			bottom = int32(((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fmetrics.FhoriBearingY - (*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fmetrics.Fheight) & int64(-libc.Int32FromInt32(64)))
		}
		/*
		 * Clip charcell glyphs to the bounding box
		 * XXX transformed?
		 */
		if (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fspacing >= int32(m_FC_CHARCELL) && !(transform != 0) {
			if int64((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fload_flags)&(libc.Int64FromInt64(1)<<libc.Int32FromInt32(4)) != 0 {
				if bottom>>int32(6) > (*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fmax_advance_width {
					adjust = bottom - (*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fmax_advance_width<<int32(6)
					if adjust > top {
						adjust = top
					}
					top -= adjust
					bottom -= adjust
				}
			} else {
				if right>>int32(6) > (*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fmax_advance_width {
					adjust1 = right - (*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fmax_advance_width<<int32(6)
					if adjust1 > left {
						adjust1 = left
					}
					left -= adjust1
					right -= adjust1
				}
			}
		}
		glyph_transform = transform
		if (*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fformat != int32(_FT_GLYPH_FORMAT_BITMAP) {
			error1 = libfreetype.XFT_Render_Glyph(tls, (*TFT_FaceRec_)(unsafe.Pointer(face)).Fglyph, mode)
			if error1 != 0 {
				continue
			}
			glyph_transform = m_False
		}
		libfreetype.XFT_Library_SetLcdFilter(tls, X_XftFTlibrary, int32(_FT_LCD_FILTER_NONE))
		if (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fspacing >= int32(m_FC_MONO) {
			if transform != 0 {
				if int64((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fload_flags)&(libc.Int64FromInt64(1)<<libc.Int32FromInt32(4)) != 0 {
					(*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fx = 0
					(*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fy = -(*TFT_SizeRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fsize)).Fmetrics.Fmax_advance
				} else {
					(*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fx = (*TFT_SizeRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fsize)).Fmetrics.Fmax_advance
					(*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fy = 0
				}
				libfreetype.XFT_Vector_Transform(tls, bp+4144, font+48+56)
				(*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FxOff = int16(((*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fx + libc.Int64FromInt32(32)) & int64(-libc.Int32FromInt32(64)) >> libc.Int32FromInt32(6))
				(*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FyOff = int16(-(((*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fy + libc.Int64FromInt32(32)) & int64(-libc.Int32FromInt32(64)) >> libc.Int32FromInt32(6)))
			} else {
				maximum_x = int16((*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fmax_advance_width)
				maximum_y = int16(-(*TXftFontInt)(unsafe.Pointer(font)).Fpublic.Fmax_advance_width)
				trimmed_x = int16(((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fadvance.Fx + libc.Int64FromInt32(32)) & int64(-libc.Int32FromInt32(64)) >> libc.Int32FromInt32(6))
				trimmed_y = int16(-(((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fadvance.Fy + libc.Int64FromInt32(32)) & int64(-libc.Int32FromInt32(64)) >> libc.Int32FromInt32(6)))
				if int64((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fload_flags)&(libc.Int64FromInt64(1)<<libc.Int32FromInt32(4)) != 0 {
					(*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FxOff = 0
					if int32(maximum_y) < int32(trimmed_y) {
						v10 = int32(maximum_y)
					} else {
						v10 = int32(trimmed_y)
					}
					(*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FyOff = int16(v10)
				} else {
					if int32(maximum_x) < int32(trimmed_x) {
						v11 = int32(maximum_x)
					} else {
						v11 = int32(trimmed_x)
					}
					(*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FxOff = int16(v11)
					(*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FyOff = 0
				}
			}
		} else {
			(*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FxOff = int16(((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fadvance.Fx + libc.Int64FromInt32(32)) & int64(-libc.Int32FromInt32(64)) >> libc.Int32FromInt32(6))
			(*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.FyOff = int16(-(((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fadvance.Fy + libc.Int64FromInt32(32)) & int64(-libc.Int32FromInt32(64)) >> libc.Int32FromInt32(6)))
		}
		/* compute the size of the final bitmap */
		ftbit = glyphslot + 152
		width = int32((*TFT_Bitmap)(unsafe.Pointer(ftbit)).Fwidth)
		height = int32((*TFT_Bitmap)(unsafe.Pointer(ftbit)).Frows)
		if XXftDebug(tls)&int32(m_XFT_DBG_GLYPH) != 0 {
			libc.Xprintf(tls, __ccgo_ts+1686, libc.VaList(bp+4448, int32(glyphindex)))
			libc.Xprintf(tls, __ccgo_ts+1697, libc.VaList(bp+4448, int32((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fmetrics.FhoriBearingX), int32((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fmetrics.FhoriBearingY), int32((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fmetrics.Fwidth), int32((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fmetrics.Fheight), left, right, top, bottom, width, height))
			if XXftDebug(tls)&int32(m_XFT_DBG_GLYPHV) != 0 {
				line = (*TFT_Bitmap)(unsafe.Pointer(ftbit)).Fbuffer
				if (*TFT_Bitmap)(unsafe.Pointer(ftbit)).Fpitch < 0 {
					line -= uintptr((*TFT_Bitmap)(unsafe.Pointer(ftbit)).Fpitch * (height - int32(1)))
				}
				y = 0
				for {
					if !(y < height) {
						break
					}
					if (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fantialias != 0 {
						x = 0
						for {
							if !(x < width) {
								break
							}
							libc.Xprintf(tls, __ccgo_ts+1750, libc.VaList(bp+4448, int32(_den[int32(*(*uint8)(unsafe.Pointer(line + uintptr(x))))>>int32(5)])))
							goto _13
						_13:
							;
							x++
						}
					} else {
						x = 0
						for {
							if !(x < width*int32(8)) {
								break
							}
							if int32(*(*uint8)(unsafe.Pointer(line + uintptr(x>>int32(3)))))&(int32(1)<<(x&int32(7))) != 0 {
								v15 = int32('#')
							} else {
								v15 = int32(' ')
							}
							libc.Xprintf(tls, __ccgo_ts+1750, libc.VaList(bp+4448, v15))
							goto _14
						_14:
							;
							x++
						}
					}
					libc.Xprintf(tls, __ccgo_ts+1753, 0)
					line += uintptr((*TFT_Bitmap)(unsafe.Pointer(ftbit)).Fpitch)
					goto _12
				_12:
					;
					y++
				}
				libc.Xprintf(tls, __ccgo_ts+1756, 0)
			}
		}
		_m3x3_uniform(tls, bp+4160)
		if glyph_transform != 0 {
			v16 = font + 48 + 56
		} else {
			v16 = libc.UintptrFromInt32(0)
		}
		size = __compute_xrender_bitmap_size(tls, bp+4104, glyphslot, mode, v16, bp+4160)
		if size < 0 {
			continue
		}
		(*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fwidth = uint16((*(*TFT_Bitmap)(unsafe.Pointer(bp + 4104))).Fwidth)
		(*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fheight = uint16((*(*TFT_Bitmap)(unsafe.Pointer(bp + 4104))).Frows)
		if glyph_transform != 0 {
			_m3x3_invert(tls, bp+4160, bp+4232)
			(*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fx = int64(-(*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fbitmap_left)
			(*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fy = int64((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fbitmap_top)
			_m3x3_transform(tls, bp+4144, bp+4232)
			(*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fx = int16((*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fx)
			(*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fy = int16((*(*TFT_Vector)(unsafe.Pointer(bp + 4144))).Fy)
		} else {
			(*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fx = int16(-(*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fbitmap_left)
			(*TXftGlyph)(unsafe.Pointer(xftg)).Fmetrics.Fy = int16((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fbitmap_top)
		}
		/*
		 * If the glyph is relatively large (> 1% of server memory),
		 * don't send it until necessary.
		 */
		if !(need_bitmaps != 0) && uint64(size) > (*TXftDisplayInfo)(unsafe.Pointer(info)).Fmax_glyph_memory/uint64(100) {
			continue
		}
		/*
		 * Make sure there is enough buffer space for the glyph.
		 */
		if size > bufSize {
			if bufBitmap != bp+8 {
				libc.Xfree(tls, bufBitmap)
			}
			bufBitmap = libc.Xmalloc(tls, uint64(size))
			if !(bufBitmap != 0) {
				continue
			}
			bufSize = size
		}
		libc.X__builtin___memset_chk(tls, bufBitmap, 0, uint64(size), uint64(libc.X__builtin_object_size(tls, bufBitmap, 0)))
		(*(*TFT_Bitmap)(unsafe.Pointer(bp + 4104))).Fbuffer = bufBitmap
		if mode == int32(_FT_RENDER_MODE_NORMAL) && glyph_transform != 0 {
			__scaled_fill_xrender_bitmap(tls, bp+4104, glyphslot+152, bp+4160)
		} else {
			__fill_xrender_bitmap(tls, bp+4104, glyphslot, mode, libc.BoolInt32((*TXftFontInt)(unsafe.Pointer(font)).Finfo.Frgba == int32(m_FC_RGBA_BGR) || (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Frgba == int32(m_FC_RGBA_VBGR)))
		}
		/*
		 * Copy or convert into local buffer.
		 */
		/*
		 * Use the glyph index as the wire encoding; it
		 * might be more efficient for some locales to map
		 * these by first usage to smaller values, but that
		 * would require persistently storing the map when
		 * glyphs were freed.
		 */
		*(*TGlyph)(unsafe.Pointer(bp)) = uint64(glyphindex)
		if (*TXftGlyph)(unsafe.Pointer(xftg)).Fpicture != 0 {
			libxrender.XXRenderFreePicture(tls, dpy, (*TXftGlyph)(unsafe.Pointer(xftg)).Fpicture)
			(*TXftGlyph)(unsafe.Pointer(xftg)).Fpicture = uint64(0)
		}
		(*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory = uint64(size) + uint64((*TXftFontInt)(unsafe.Pointer(font)).Fsizeof_glyph)
		if (*TXftFontInt)(unsafe.Pointer(font)).Fformat != 0 {
			if !((*TXftFontInt)(unsafe.Pointer(font)).Fglyphset != 0) {
				(*TXftFontInt)(unsafe.Pointer(font)).Fglyphset = libxrender.XXRenderCreateGlyphSet(tls, dpy, (*TXftFontInt)(unsafe.Pointer(font)).Fformat)
			}
			if mode == int32(_FT_RENDER_MODE_MONO) {
				/* swap bits in each byte */
				if (*struct {
					Fext_data            uintptr
					Fprivate1            uintptr
					Ffd                  int32
					Fprivate2            int32
					Fproto_major_version int32
					Fproto_minor_version int32
					Fvendor              uintptr
					Fprivate3            TXID
					Fprivate4            TXID
					Fprivate5            TXID
					Fprivate6            int32
					Fresource_alloc      uintptr
					Fbyte_order          int32
					Fbitmap_unit         int32
					Fbitmap_pad          int32
					Fbitmap_bit_order    int32
					Fnformats            int32
					Fpixmap_format       uintptr
					Fprivate8            int32
					Frelease             int32
					Fprivate9            uintptr
					Fprivate10           uintptr
					Fqlen                int32
					Flast_request_read   uint64
					Frequest             uint64
					Fprivate11           TXPointer
					Fprivate12           TXPointer
					Fprivate13           TXPointer
					Fprivate14           TXPointer
					Fmax_request_size    uint32
					Fdb                  uintptr
					Fprivate15           uintptr
					Fdisplay_name        uintptr
					Fdefault_screen      int32
					Fnscreens            int32
					Fscreens             uintptr
					Fmotion_buffer       uint64
					Fprivate16           uint64
					Fmin_keycode         int32
					Fmax_keycode         int32
					Fprivate17           TXPointer
					Fprivate18           TXPointer
					Fprivate19           int32
					Fxdefaults           uintptr
				})(unsafe.Pointer(dpy)).Fbitmap_bit_order != int32(m_MSBFirst) {
					line1 = bufBitmap
					i = size
					for {
						v17 = i
						i--
						if !(v17 != 0) {
							break
						}
						c = int32(*(*uint8)(unsafe.Pointer(line1)))
						c = c<<int32(1)&int32(0xaa) | c>>int32(1)&int32(0x55)
						c = c<<int32(2)&int32(0xcc) | c>>int32(2)&int32(0x33)
						c = c<<int32(4)&int32(0xf0) | c>>int32(4)&int32(0x0f)
						v18 = line1
						line1++
						*(*uint8)(unsafe.Pointer(v18)) = uint8(c)
					}
				}
			} else {
				if int32((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fbitmap.Fpixel_mode) == int32(_FT_PIXEL_MODE_BGRA) || mode != int32(_FT_RENDER_MODE_NORMAL) {
					/* invert ARGB <=> BGRA */
					if (*struct {
						Fext_data            uintptr
						Fprivate1            uintptr
						Ffd                  int32
						Fprivate2            int32
						Fproto_major_version int32
						Fproto_minor_version int32
						Fvendor              uintptr
						Fprivate3            TXID
						Fprivate4            TXID
						Fprivate5            TXID
						Fprivate6            int32
						Fresource_alloc      uintptr
						Fbyte_order          int32
						Fbitmap_unit         int32
						Fbitmap_pad          int32
						Fbitmap_bit_order    int32
						Fnformats            int32
						Fpixmap_format       uintptr
						Fprivate8            int32
						Frelease             int32
						Fprivate9            uintptr
						Fprivate10           uintptr
						Fqlen                int32
						Flast_request_read   uint64
						Frequest             uint64
						Fprivate11           TXPointer
						Fprivate12           TXPointer
						Fprivate13           TXPointer
						Fprivate14           TXPointer
						Fmax_request_size    uint32
						Fdb                  uintptr
						Fprivate15           uintptr
						Fdisplay_name        uintptr
						Fdefault_screen      int32
						Fnscreens            int32
						Fscreens             uintptr
						Fmotion_buffer       uint64
						Fprivate16           uint64
						Fmin_keycode         int32
						Fmax_keycode         int32
						Fprivate17           TXPointer
						Fprivate18           TXPointer
						Fprivate19           int32
						Fxdefaults           uintptr
					})(unsafe.Pointer(dpy)).Fbyte_order != XXftNativeByteOrder(tls) {
						XXftSwapCARD32(tls, bufBitmap, size>>int32(2))
					}
				}
			}
			if int32((*TFT_GlyphSlotRec_)(unsafe.Pointer(glyphslot)).Fbitmap.Fpixel_mode) == int32(_FT_PIXEL_MODE_BGRA) {
				pixmap = libx11.XXCreatePixmap(tls, dpy, (*TScreen)(unsafe.Pointer((*struct {
					Fext_data            uintptr
					Fprivate1            uintptr
					Ffd                  int32
					Fprivate2            int32
					Fproto_major_version int32
					Fproto_minor_version int32
					Fvendor              uintptr
					Fprivate3            TXID
					Fprivate4            TXID
					Fprivate5            TXID
					Fprivate6            int32
					Fresource_alloc      uintptr
					Fbyte_order          int32
					Fbitmap_unit         int32
					Fbitmap_pad          int32
					Fbitmap_bit_order    int32
					Fnformats            int32
					Fpixmap_format       uintptr
					Fprivate8            int32
					Frelease             int32
					Fprivate9            uintptr
					Fprivate10           uintptr
					Fqlen                int32
					Flast_request_read   uint64
					Frequest             uint64
					Fprivate11           TXPointer
					Fprivate12           TXPointer
					Fprivate13           TXPointer
					Fprivate14           TXPointer
					Fmax_request_size    uint32
					Fdb                  uintptr
					Fprivate15           uintptr
					Fdisplay_name        uintptr
					Fdefault_screen      int32
					Fnscreens            int32
					Fscreens             uintptr
					Fmotion_buffer       uint64
					Fprivate16           uint64
					Fmin_keycode         int32
					Fmax_keycode         int32
					Fprivate17           TXPointer
					Fprivate18           TXPointer
					Fprivate19           int32
					Fxdefaults           uintptr
				})(unsafe.Pointer(dpy)).Fscreens+uintptr((*struct {
					Fext_data            uintptr
					Fprivate1            uintptr
					Ffd                  int32
					Fprivate2            int32
					Fproto_major_version int32
					Fproto_minor_version int32
					Fvendor              uintptr
					Fprivate3            TXID
					Fprivate4            TXID
					Fprivate5            TXID
					Fprivate6            int32
					Fresource_alloc      uintptr
					Fbyte_order          int32
					Fbitmap_unit         int32
					Fbitmap_pad          int32
					Fbitmap_bit_order    int32
					Fnformats            int32
					Fpixmap_format       uintptr
					Fprivate8            int32
					Frelease             int32
					Fprivate9            uintptr
					Fprivate10           uintptr
					Fqlen                int32
					Flast_request_read   uint64
					Frequest             uint64
					Fprivate11           TXPointer
					Fprivate12           TXPointer
					Fprivate13           TXPointer
					Fprivate14           TXPointer
					Fmax_request_size    uint32
					Fdb                  uintptr
					Fprivate15           uintptr
					Fdisplay_name        uintptr
					Fdefault_screen      int32
					Fnscreens            int32
					Fscreens             uintptr
					Fmotion_buffer       uint64
					Fprivate16           uint64
					Fmin_keycode         int32
					Fmax_keycode         int32
					Fprivate17           TXPointer
					Fprivate18           TXPointer
					Fprivate19           int32
					Fxdefaults           uintptr
				})(unsafe.Pointer(dpy)).Fdefault_screen)*128)).Froot, (*(*TFT_Bitmap)(unsafe.Pointer(bp + 4104))).Fwidth, (*(*TFT_Bitmap)(unsafe.Pointer(bp + 4104))).Frows, uint32(32))
				gc = libx11.XXCreateGC(tls, dpy, pixmap, uint64(0), libc.UintptrFromInt32(0))
				*(*TXImage)(unsafe.Pointer(bp + 4304)) = TXImage{
					Fwidth:            int32((*(*TFT_Bitmap)(unsafe.Pointer(bp + 4104))).Fwidth),
					Fheight:           int32((*(*TFT_Bitmap)(unsafe.Pointer(bp + 4104))).Frows),
					Fformat:           int32(m_ZPixmap),
					Fdata:             bufBitmap,
					Fbyte_order:       (*TDisplay)(unsafe.Pointer(dpy)).Fbyte_order,
					Fbitmap_unit:      (*TDisplay)(unsafe.Pointer(dpy)).Fbitmap_unit,
					Fbitmap_bit_order: (*TDisplay)(unsafe.Pointer(dpy)).Fbitmap_bit_order,
					Fbitmap_pad:       int32(32),
					Fdepth:            int32(32),
					Fbytes_per_line:   int32((*(*TFT_Bitmap)(unsafe.Pointer(bp + 4104))).Fwidth*libc.Uint32FromInt32(4) - uint32((*(*TFT_Bitmap)(unsafe.Pointer(bp + 4104))).Fpitch)),
					Fbits_per_pixel:   int32(32),
				}
				libx11.XXInitImage(tls, bp+4304)
				libx11.XXPutImage(tls, dpy, pixmap, gc, bp+4304, 0, 0, 0, 0, (*(*TFT_Bitmap)(unsafe.Pointer(bp + 4104))).Fwidth, (*(*TFT_Bitmap)(unsafe.Pointer(bp + 4104))).Frows)
				(*TXftGlyph)(unsafe.Pointer(xftg)).Fpicture = libxrender.XXRenderCreatePicture(tls, dpy, pixmap, (*TXftFontInt)(unsafe.Pointer(font)).Fformat, uint64(0), libc.UintptrFromInt32(0))
				libx11.XXFreeGC(tls, dpy, gc)
				libx11.XXFreePixmap(tls, dpy, pixmap)
				/*
				 * Record 256 times higher memory pressure for unrotated
				 * pictures, and maximum for rotated pictures.
				 */
				if (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fmatrix.Fxy != 0 || (*TXftFontInt)(unsafe.Pointer(font)).Finfo.Fmatrix.Fyx != 0 {
					*(*uint64)(unsafe.Pointer(xftg + 24)) += (*TXftFontInt)(unsafe.Pointer(font)).Fmax_glyph_memory - uint64(size)
				} else {
					*(*uint64)(unsafe.Pointer(xftg + 24)) += uint64(size) * uint64(255)
				}
			} else {
				libxrender.XXRenderAddGlyphs(tls, dpy, (*TXftFontInt)(unsafe.Pointer(font)).Fglyphset, bp, xftg, int32(1), bufBitmap, size)
			}
		} else {
			if size != 0 {
				(*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap = libc.Xmalloc(tls, uint64(size))
				if (*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap != 0 {
					libc.X__builtin___memcpy_chk(tls, (*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap, bufBitmap, uint64(size), uint64(libc.X__builtin_object_size(tls, (*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap, 0)))
				}
			} else {
				(*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap = libc.UintptrFromInt32(0)
			}
		}
		*(*uint64)(unsafe.Pointer(font + 216)) += (*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory
		*(*uint64)(unsafe.Pointer(info + 56)) += (*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory
		if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
			__XftFontValidateMemory(tls, dpy, pub)
		}
		if XXftDebug(tls)&int32(m_XFT_DBG_CACHEV) != 0 {
			libc.Xprintf(tls, __ccgo_ts+1758, libc.VaList(bp+4448, glyphindex, (*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory))
		}
		if (*TXftFontInt)(unsafe.Pointer(font)).Ftrack_mem_usage != 0 {
			xuse = xftg
			if (*TXftFontInt)(unsafe.Pointer(font)).Fnewest == libc.Uint32FromInt32(m___INT_MAX__)*libc.Uint32FromUint32(2)+libc.Uint32FromUint32(1) {
				(*TXftGlyphUsage)(unsafe.Pointer(xuse)).Folder = glyphindex
				(*TXftGlyphUsage)(unsafe.Pointer(xuse)).Fnewer = glyphindex
				if XXftDebug(tls)&int32(m_XFT_DBG_USAGE) != 0 {
					libc.Xprintf(tls, __ccgo_ts+1787, libc.VaList(bp+4448, font, glyphindex, xuse, (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Folder, (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Fnewer))
				}
			} else {
				xnew = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr((*TXftFontInt)(unsafe.Pointer(font)).Fnewest)*8))
				xold = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr((*TXftGlyphUsage)(unsafe.Pointer(xnew)).Fnewer)*8))
				(*TXftGlyphUsage)(unsafe.Pointer(xuse)).Folder = (*TXftFontInt)(unsafe.Pointer(font)).Fnewest
				(*TXftGlyphUsage)(unsafe.Pointer(xuse)).Fnewer = (*TXftGlyphUsage)(unsafe.Pointer(xnew)).Fnewer
				(*TXftGlyphUsage)(unsafe.Pointer(xnew)).Fnewer = glyphindex
				(*TXftGlyphUsage)(unsafe.Pointer(xold)).Folder = glyphindex
				if XXftDebug(tls)&int32(m_XFT_DBG_USAGE) != 0 {
					libc.Xprintf(tls, __ccgo_ts+1817, libc.VaList(bp+4448, font, glyphindex, xuse, (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Folder, (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Fnewer, xnew, (*TXftGlyphUsage)(unsafe.Pointer(xnew)).Folder, (*TXftGlyphUsage)(unsafe.Pointer(xnew)).Fnewer, xold, (*TXftGlyphUsage)(unsafe.Pointer(xold)).Folder, (*TXftGlyphUsage)(unsafe.Pointer(xold)).Fnewer))
				}
			}
			(*TXftFontInt)(unsafe.Pointer(font)).Fnewest = glyphindex
			(*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse++
			if XXftDebug(tls)&int32(m_XFT_DBG_USAGE) != 0 {
				__XftValidateGlyphUsage(tls, font)
			}
		}
	}
	if bufBitmap != bp+8 {
		libc.Xfree(tls, bufBitmap)
	}
	XXftUnlockFace(tls, font)
}

var _den = [9]int8{' ', '.', ':', ';', '=', '+', '*', '#'}

func XXftFontUnloadGlyphs(tls *libc.TLS, dpy uintptr, pub uintptr, glyphs uintptr, nglyph int32) {
	bp := tls.Alloc(8240)
	defer tls.Free(8240)
	var font, info, xftg, xtmp, xuse, v2 uintptr
	var glyphindex TFT_UInt
	var nused, v1, v3 int32
	var _ /* glyphBuf at bp+0 */ [1024]TGlyph
	_, _, _, _, _, _, _, _, _, _ = font, glyphindex, info, nused, xftg, xtmp, xuse, v1, v2, v3
	info = X_XftDisplayInfoGet(tls, dpy, m_False)
	font = pub
	nused = 0
	for {
		v1 = nglyph
		nglyph--
		if !(v1 != 0) {
			break
		}
		v2 = glyphs
		glyphs += 4
		glyphindex = *(*TFT_UInt)(unsafe.Pointer(v2))
		xftg = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(glyphindex)*8))
		if !(xftg != 0) {
			continue
		}
		if (*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory != 0 {
			if XXftDebug(tls)&int32(m_XFT_DBG_CACHEV) != 0 {
				libc.Xprintf(tls, __ccgo_ts+1874, libc.VaList(bp+8200, glyphindex, (*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory))
			}
			if (*TXftFontInt)(unsafe.Pointer(font)).Fformat != 0 {
				if (*TXftGlyph)(unsafe.Pointer(xftg)).Fpicture != 0 {
					libxrender.XXRenderFreePicture(tls, dpy, (*TXftGlyph)(unsafe.Pointer(xftg)).Fpicture)
				} else {
					if (*TXftFontInt)(unsafe.Pointer(font)).Fglyphset != 0 {
						v3 = nused
						nused++
						(*(*[1024]TGlyph)(unsafe.Pointer(bp)))[v3] = uint64(glyphindex)
						if uint64(nused) == libc.Uint64FromInt64(8192)/libc.Uint64FromInt64(8) {
							libxrender.XXRenderFreeGlyphs(tls, dpy, (*TXftFontInt)(unsafe.Pointer(font)).Fglyphset, bp, nused)
							nused = 0
						}
					}
				}
			} else {
				if (*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap != 0 {
					libc.Xfree(tls, (*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap)
				}
			}
			*(*uint64)(unsafe.Pointer(font + 216)) -= (*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory
			if info != 0 {
				*(*uint64)(unsafe.Pointer(info + 56)) -= (*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory
			}
		}
		if (*TXftFontInt)(unsafe.Pointer(font)).Ftrack_mem_usage != 0 {
			xuse = xftg
			if XXftDebug(tls)&int32(m_XFT_DBG_USAGE) != 0 {
				libc.Xprintf(tls, __ccgo_ts+1905, libc.VaList(bp+8200, font, xuse, (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Folder, (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Fnewer))
			}
			if (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Folder != libc.Uint32FromInt32(m___INT_MAX__)*libc.Uint32FromUint32(2)+libc.Uint32FromUint32(1) {
				xtmp = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr((*TXftGlyphUsage)(unsafe.Pointer(xuse)).Folder)*8))
				if xtmp != libc.UintptrFromInt32(0) {
					/* update link around to oldest glyph */
					(*TXftGlyphUsage)(unsafe.Pointer(xtmp)).Fnewer = (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Fnewer
				}
				if (*TXftFontInt)(unsafe.Pointer(font)).Fnewest == glyphindex {
					if (*TXftFontInt)(unsafe.Pointer(font)).Fnewest == (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Folder {
						(*TXftFontInt)(unsafe.Pointer(font)).Fnewest = libc.Uint32FromInt32(m___INT_MAX__)*libc.Uint32FromUint32(2) + libc.Uint32FromUint32(1)
					} else {
						(*TXftFontInt)(unsafe.Pointer(font)).Fnewest = (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Folder
					}
				}
			}
			if (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Fnewer != libc.Uint32FromInt32(m___INT_MAX__)*libc.Uint32FromUint32(2)+libc.Uint32FromUint32(1) {
				xtmp = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr((*TXftGlyphUsage)(unsafe.Pointer(xuse)).Fnewer)*8))
				if xtmp != libc.UintptrFromInt32(0) {
					/* update link around to newest glyph */
					(*TXftGlyphUsage)(unsafe.Pointer(xtmp)).Folder = (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Folder
				}
			}
			if (*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse != 0 {
				(*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse--
			} else {
				libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+1930, 0)
			}
			if XXftDebug(tls)&int32(m_XFT_DBG_USAGE) != 0 {
				__XftValidateGlyphUsage(tls, font)
			}
		}
		libc.Xfree(tls, xftg)
		XXftMemFree(tls, int32(_XFT_MEM_GLYPH), uint64((*TXftFontInt)(unsafe.Pointer(font)).Fsizeof_glyph))
		*(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(glyphindex)*8)) = libc.UintptrFromInt32(0)
	}
	if (*TXftFontInt)(unsafe.Pointer(font)).Fglyphset != 0 && nused != 0 {
		libxrender.XXRenderFreeGlyphs(tls, dpy, (*TXftFontInt)(unsafe.Pointer(font)).Fglyphset, bp, nused)
	}
}

func XXftFontCheckGlyph(tls *libc.TLS, dpy uintptr, pub uintptr, need_bitmaps TFcBool, glyph TFT_UInt, missing uintptr, nmissing uintptr) (r TFcBool) {
	var font, xftg, xnew, xold, xtmp, xuse, xuse1 uintptr
	var n, v1 int32
	_, _, _, _, _, _, _, _, _ = font, n, xftg, xnew, xold, xtmp, xuse, xuse1, v1
	font = pub
	if glyph >= (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs {
		return m_FcFalse
	}
	xftg = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(glyph)*8))
	if !(xftg != 0) || need_bitmaps != 0 && !((*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory != 0) {
		if !(xftg != 0) {
			xftg = libc.Xmalloc(tls, uint64((*TXftFontInt)(unsafe.Pointer(font)).Fsizeof_glyph))
			if !(xftg != 0) {
				return m_FcFalse
			}
			XXftMemAlloc(tls, int32(_XFT_MEM_GLYPH), uint64((*TXftFontInt)(unsafe.Pointer(font)).Fsizeof_glyph))
			(*TXftGlyph)(unsafe.Pointer(xftg)).Fbitmap = libc.UintptrFromInt32(0)
			(*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory = uint64(0)
			(*TXftGlyph)(unsafe.Pointer(xftg)).Fpicture = uint64(0)
			*(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(glyph)*8)) = xftg
			if (*TXftFontInt)(unsafe.Pointer(font)).Ftrack_mem_usage != 0 {
				xuse = xftg
				(*TXftGlyphUsage)(unsafe.Pointer(xuse)).Folder = libc.Uint32FromInt32(m___INT_MAX__)*libc.Uint32FromUint32(2) + libc.Uint32FromUint32(1)
				(*TXftGlyphUsage)(unsafe.Pointer(xuse)).Fnewer = libc.Uint32FromInt32(m___INT_MAX__)*libc.Uint32FromUint32(2) + libc.Uint32FromUint32(1)
			}
		}
		n = *(*int32)(unsafe.Pointer(nmissing))
		v1 = n
		n++
		*(*TFT_UInt)(unsafe.Pointer(missing + uintptr(v1)*4)) = glyph
		if n == int32(m_XFT_NMISSING) {
			XXftFontLoadGlyphs(tls, dpy, pub, need_bitmaps, missing, n)
			n = 0
		}
		*(*int32)(unsafe.Pointer(nmissing)) = n
		return int32(m_FcTrue)
	}
	/*
	 * Make unloading faster by moving newly-referenced glyphs to the front
	 * of the list, leaving the less-used glyphs on the end.
	 *
	 * If the glyph is zero, the older/newer data may not have been set.
	 */
	if glyph != uint32(0) && (*TXftFontInt)(unsafe.Pointer(font)).Ftrack_mem_usage != 0 && (*TXftFontInt)(unsafe.Pointer(font)).Ftotal_inuse > uint32(10) && (*TXftFontInt)(unsafe.Pointer(font)).Fnewest != libc.Uint32FromInt32(m___INT_MAX__)*libc.Uint32FromUint32(2)+libc.Uint32FromUint32(1) && (*TXftFontInt)(unsafe.Pointer(font)).Fnewest != glyph {
		xuse1 = xftg
		xtmp = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr((*TXftFontInt)(unsafe.Pointer(font)).Fnewest)*8))
		/* delink */
		xold = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr((*TXftGlyphUsage)(unsafe.Pointer(xuse1)).Folder)*8))
		xnew = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr((*TXftGlyphUsage)(unsafe.Pointer(xuse1)).Fnewer)*8))
		(*TXftGlyphUsage)(unsafe.Pointer(xold)).Fnewer = (*TXftGlyphUsage)(unsafe.Pointer(xuse1)).Fnewer
		(*TXftGlyphUsage)(unsafe.Pointer(xnew)).Folder = (*TXftGlyphUsage)(unsafe.Pointer(xuse1)).Folder
		/* relink */
		xnew = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr((*TXftGlyphUsage)(unsafe.Pointer(xtmp)).Fnewer)*8))
		(*TXftGlyphUsage)(unsafe.Pointer(xnew)).Folder = glyph
		(*TXftGlyphUsage)(unsafe.Pointer(xuse1)).Folder = (*TXftFontInt)(unsafe.Pointer(font)).Fnewest
		(*TXftGlyphUsage)(unsafe.Pointer(xuse1)).Fnewer = (*TXftGlyphUsage)(unsafe.Pointer(xtmp)).Fnewer
		(*TXftGlyphUsage)(unsafe.Pointer(xtmp)).Fnewer = glyph
		(*TXftFontInt)(unsafe.Pointer(font)).Fnewest = glyph
	}
	return m_FcFalse
}

func XXftCharExists(tls *libc.TLS, dpy uintptr, pub uintptr, ucs4 TFcChar32) (r TFcBool) {
	if (*TXftFont)(unsafe.Pointer(pub)).Fcharset != 0 {
		return libfontconfig.XFcCharSetHasChar(tls, (*TXftFont)(unsafe.Pointer(pub)).Fcharset, ucs4)
	}
	return m_FcFalse
}

func XXftCharIndex(tls *libc.TLS, dpy uintptr, pub uintptr, ucs4 TFcChar32) (r TFT_UInt) {
	var ent, offset TFcChar32
	var face TFT_Face
	var font uintptr
	_, _, _, _ = ent, face, font, offset
	font = pub
	if !((*TXftFontInt)(unsafe.Pointer(font)).Fhash_value != 0) {
		return uint32(0)
	}
	ent = ucs4 % uint32((*TXftFontInt)(unsafe.Pointer(font)).Fhash_value)
	offset = uint32(0)
	for (*(*TXftUcsHash)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fhash_table + uintptr(ent)*8))).Fucs4 != ucs4 {
		if (*(*TXftUcsHash)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fhash_table + uintptr(ent)*8))).Fucs4 == uint32(^libc.Int32FromInt32(0)) {
			if !(XXftCharExists(tls, dpy, pub, ucs4) != 0) {
				return uint32(0)
			}
			face = XXftLockFace(tls, pub)
			if !(face != 0) {
				return uint32(0)
			}
			(*(*TXftUcsHash)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fhash_table + uintptr(ent)*8))).Fucs4 = ucs4
			(*(*TXftUcsHash)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fhash_table + uintptr(ent)*8))).Fglyph = libfontconfig.XFcFreeTypeCharIndex(tls, face, ucs4)
			XXftUnlockFace(tls, pub)
			break
		}
		if !(offset != 0) {
			offset = ucs4 % uint32((*TXftFontInt)(unsafe.Pointer(font)).Frehash_value)
			if !(offset != 0) {
				offset = uint32(1)
			}
		}
		ent = ent + offset
		if ent >= uint32((*TXftFontInt)(unsafe.Pointer(font)).Fhash_value) {
			ent -= uint32((*TXftFontInt)(unsafe.Pointer(font)).Fhash_value)
		}
	}
	return (*(*TXftUcsHash)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fhash_table + uintptr(ent)*8))).Fglyph
}

// C documentation
//
//	/*
//	 * Remove glyph(s) from the font to reduce memory-usage.
//	 */
func X_XftFontUncacheGlyph(tls *libc.TLS, dpy uintptr, pub uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var font, xftg, xuse uintptr
	var glyph_memory uint64
	var v1 TFT_UInt
	var _ /* glyphindex at bp+0 */ TFT_UInt
	_, _, _, _, _ = font, glyph_memory, xftg, xuse, v1
	font = pub
	if !((*TXftFontInt)(unsafe.Pointer(font)).Fglyph_memory != 0) {
		return
	}
	if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
		__XftFontValidateMemory(tls, dpy, pub)
	}
	if (*TXftFontInt)(unsafe.Pointer(font)).Ftrack_mem_usage != 0 {
		/*
		 * Remove the oldest glyph from the font.
		 */
		if (*TXftFontInt)(unsafe.Pointer(font)).Fnewest != libc.Uint32FromInt32(m___INT_MAX__)*libc.Uint32FromUint32(2)+libc.Uint32FromUint32(1) {
			xuse = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr((*TXftFontInt)(unsafe.Pointer(font)).Fnewest)*8))
			v1 = (*TXftGlyphUsage)(unsafe.Pointer(xuse)).Fnewer
			*(*TFT_UInt)(unsafe.Pointer(bp)) = v1
			if v1 != libc.Uint32FromInt32(m___INT_MAX__)*libc.Uint32FromUint32(2)+libc.Uint32FromUint32(1) {
				XXftFontUnloadGlyphs(tls, dpy, pub, bp, int32(1))
			}
		}
	} else {
		if (*TXftFontInt)(unsafe.Pointer(font)).Fuse_free_glyphs != 0 {
			/*
			 * Pick a random glyph from the font and remove it from the cache
			 */
			glyph_memory = uint64(libc.Xrand(tls)) % (*TXftFontInt)(unsafe.Pointer(font)).Fglyph_memory
			*(*TFT_UInt)(unsafe.Pointer(bp)) = uint32(0)
			for {
				if !(*(*TFT_UInt)(unsafe.Pointer(bp)) < (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs) {
					break
				}
				xftg = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(*(*TFT_UInt)(unsafe.Pointer(bp)))*8))
				if xftg != 0 {
					if (*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory > glyph_memory {
						XXftFontUnloadGlyphs(tls, dpy, pub, bp, int32(1))
						break
					}
					glyph_memory -= (*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory
				}
				goto _2
			_2:
				;
				*(*TFT_UInt)(unsafe.Pointer(bp))++
			}
		} else {
			/*
			 * Free all glyphs, since they are part of a set.
			 */
			if (*TXftFontInt)(unsafe.Pointer(font)).Fglyphset != 0 {
				libxrender.XXRenderFreeGlyphSet(tls, dpy, (*TXftFontInt)(unsafe.Pointer(font)).Fglyphset)
				(*TXftFontInt)(unsafe.Pointer(font)).Fglyphset = uint64(0)
			}
			*(*TFT_UInt)(unsafe.Pointer(bp)) = uint32(0)
			for {
				if !(*(*TFT_UInt)(unsafe.Pointer(bp)) < (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs) {
					break
				}
				xftg = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(*(*TFT_UInt)(unsafe.Pointer(bp)))*8))
				if xftg != 0 {
					if (*TXftGlyph)(unsafe.Pointer(xftg)).Fglyph_memory > uint64(0) {
						XXftFontUnloadGlyphs(tls, dpy, pub, bp, int32(1))
					}
				}
				goto _3
			_3:
				;
				*(*TFT_UInt)(unsafe.Pointer(bp))++
			}
		}
	}
	if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
		__XftFontValidateMemory(tls, dpy, pub)
	}
}

func X_XftFontManageMemory(tls *libc.TLS, dpy uintptr, pub uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var font uintptr
	var v1 uint64
	_, _ = font, v1
	font = pub
	if (*TXftFontInt)(unsafe.Pointer(font)).Fmax_glyph_memory != 0 {
		if XXftDebug(tls)&int32(m_XFT_DBG_CACHE) != 0 {
			if (*TXftFontInt)(unsafe.Pointer(font)).Fglyph_memory > (*TXftFontInt)(unsafe.Pointer(font)).Fmax_glyph_memory {
				if (*TXftFontInt)(unsafe.Pointer(font)).Fglyphset != 0 {
					v1 = (*TXftFontInt)(unsafe.Pointer(font)).Fglyphset
				} else {
					v1 = uint64(font)
				}
				libc.Xprintf(tls, __ccgo_ts+1954, libc.VaList(bp+8, v1, (*TXftFontInt)(unsafe.Pointer(font)).Fglyph_memory, (*TXftFontInt)(unsafe.Pointer(font)).Fmax_glyph_memory))
			}
		}
		for (*TXftFontInt)(unsafe.Pointer(font)).Fglyph_memory > (*TXftFontInt)(unsafe.Pointer(font)).Fmax_glyph_memory {
			X_XftFontUncacheGlyph(tls, dpy, pub)
		}
	}
	X_XftDisplayManageMemory(tls, dpy)
}

/* xftxlfd.c */

var __XftConfigInitialized int32

func XXftInit(tls *libc.TLS, config uintptr) (r int32) {
	if __XftConfigInitialized != 0 {
		return int32(m_True)
	}
	__XftConfigInitialized = int32(m_True)
	if !(libfontconfig.XFcInit(tls) != 0) {
		return m_False
	}
	return int32(m_True)
}

func XXftGetVersion(tls *libc.TLS) (r int32) {
	return libc.Int32FromInt32(m_XFT_MAJOR)*libc.Int32FromInt32(10000) + libc.Int32FromInt32(m_XFT_MINOR)*libc.Int32FromInt32(100) + libc.Int32FromInt32(m_XFT_REVISION)
}

var _XftInUse = [4]struct {
	Fname        uintptr
	Falloc_count int32
	Falloc_mem   Tsize_t
	Ffree_count  int32
	Ffree_mem    Tsize_t
}{
	0: {
		Fname: __ccgo_ts + 2000,
	},
	1: {
		Fname: __ccgo_ts + 2008,
	},
	2: {
		Fname: __ccgo_ts + 2016,
	},
	3: {
		Fname: __ccgo_ts + 2026,
	},
}

var _XftAllocCount int32
var _XftAllocMem Tsize_t

var _XftFreeCount int32
var _XftFreeMem Tsize_t

var _XftMemNotice = uint64(libc.Int32FromInt32(1) * libc.Int32FromInt32(1024) * libc.Int32FromInt32(1024))

var _XftAllocNotify Tsize_t
var _XftFreeNotify Tsize_t

func XXftMemReport(tls *libc.TLS) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var i int32
	_ = i
	libc.Xprintf(tls, __ccgo_ts+2035, 0)
	libc.Xprintf(tls, __ccgo_ts+2054, 0)
	libc.Xprintf(tls, __ccgo_ts+2093, 0)
	i = 0
	for {
		if !(i < int32(_XFT_MEM_NUM)) {
			break
		}
		libc.Xprintf(tls, __ccgo_ts+2137, libc.VaList(bp+8, _XftInUse[i].Fname, _XftInUse[i].Falloc_count, _XftInUse[i].Falloc_mem, _XftInUse[i].Ffree_count, _XftInUse[i].Ffree_mem))
		goto _1
	_1:
		;
		i++
	}
	libc.Xprintf(tls, __ccgo_ts+2137, libc.VaList(bp+8, __ccgo_ts+2159, _XftAllocCount, _XftAllocMem, _XftFreeCount, _XftFreeMem))
	_XftAllocNotify = uint64(0)
	_XftFreeNotify = uint64(0)
}

func XXftMemAlloc(tls *libc.TLS, kind int32, size Tsize_t) {
	if XXftDebug(tls)&int32(m_XFT_DBG_MEMORY) != 0 {
		_XftInUse[kind].Falloc_count++
		_XftInUse[kind].Falloc_mem += size
		_XftAllocCount++
		_XftAllocMem += size
		_XftAllocNotify += size
		if _XftAllocNotify > _XftMemNotice {
			XXftMemReport(tls)
		}
	}
}

func XXftMemFree(tls *libc.TLS, kind int32, size Tsize_t) {
	if XXftDebug(tls)&int32(m_XFT_DBG_MEMORY) != 0 {
		_XftInUse[kind].Ffree_count++
		_XftInUse[kind].Ffree_mem += size
		_XftFreeCount++
		_XftFreeMem += size
		_XftFreeNotify += size
		if _XftFreeNotify > _XftMemNotice {
			XXftMemReport(tls)
		}
	}
}

/* xftxlfd.c */
func XXftListFontsPatternObjects(tls *libc.TLS, dpy uintptr, screen int32, pattern uintptr, os uintptr) (r uintptr) {
	return libfontconfig.XFcFontList(tls, libc.UintptrFromInt32(0), pattern, os)
}

func XXftListFonts(tls *libc.TLS, dpy uintptr, screen int32, va1 uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var __o__, __ob__, __os__, __p__, first, fs, os, pattern uintptr
	var va Tva_list
	var _ /* __v__ at bp+0 */ TFcValue
	_, _, _, _, _, _, _, _, _ = __o__, __ob__, __os__, __p__, first, fs, os, pattern, va
	va = va1
	__p__ = libc.UintptrFromInt32(0)
	if !(__p__ != 0) {
		__p__ = libfontconfig.XFcPatternCreate(tls)
		if !(__p__ != 0) {
			goto _FcPatternVapBuild_bail0
		}
	}
	for {
		__o__ = libc.VaUintptr(&va)
		if !(__o__ != 0) {
			break
		}
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = libc.VaInt32(&va)
		switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
		case int32(_FcTypeUnknown):
			fallthrough
		case int32(_FcTypeVoid):
			goto _FcPatternVapBuild_bail1
		case int32(_FcTypeInteger):
			*(*int32)(unsafe.Pointer(bp + 8)) = libc.VaInt32(&va)
		case int32(_FcTypeDouble):
			*(*float64)(unsafe.Pointer(bp + 8)) = libc.VaFloat64(&va)
		case int32(_FcTypeString):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeBool):
			*(*TFcBool)(unsafe.Pointer(bp + 8)) = libc.VaInt32(&va)
		case int32(_FcTypeMatrix):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeCharSet):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeFTFace):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeLangSet):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeRange):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
			break
		}
		if !(libfontconfig.XFcPatternAdd(tls, __p__, __o__, *(*TFcValue)(unsafe.Pointer(bp)), int32(m_FcTrue)) != 0) {
			goto _FcPatternVapBuild_bail1
		}
		goto _1
	_1:
	}
	pattern = __p__
	goto _FcPatternVapBuild_return
	goto _FcPatternVapBuild_bail1
_FcPatternVapBuild_bail1:
	;
	if !(libc.UintptrFromInt32(0) != 0) {
		libfontconfig.XFcPatternDestroy(tls, __p__)
	}
	goto _FcPatternVapBuild_bail0
_FcPatternVapBuild_bail0:
	;
	pattern = libc.UintptrFromInt32(0)
	goto _FcPatternVapBuild_return
_FcPatternVapBuild_return:
	;
	first = libc.VaUintptr(&va)
	os = uintptr(0)
	__os__ = libfontconfig.XFcObjectSetCreate(tls)
	if !(__os__ != 0) {
		goto _FcObjectSetVapBuild_bail0
	}
	__ob__ = first
	for __ob__ != 0 {
		if !(libfontconfig.XFcObjectSetAdd(tls, __os__, __ob__) != 0) {
			goto _FcObjectSetVapBuild_bail1
		}
		__ob__ = libc.VaUintptr(&va)
	}
	os = __os__
	goto _FcObjectSetVapBuild_bail1
_FcObjectSetVapBuild_bail1:
	;
	if !(os != 0) && __os__ != 0 {
		libfontconfig.XFcObjectSetDestroy(tls, __os__)
	}
	goto _FcObjectSetVapBuild_bail0
_FcObjectSetVapBuild_bail0:
	;
	_ = va
	fs = XXftListFontsPatternObjects(tls, dpy, screen, pattern, os)
	libfontconfig.XFcPatternDestroy(tls, pattern)
	libfontconfig.XFcObjectSetDestroy(tls, os)
	return fs
}

/* xftxlfd.c */
func XXftNameParse(tls *libc.TLS, name uintptr) (r uintptr) {
	return libfontconfig.XFcNameParse(tls, name)
}

func XXftNameUnparse(tls *libc.TLS, pat uintptr, dest uintptr, len1 int32) (r TFcBool) {
	var name, new1 uintptr
	_, _ = name, new1
	name = libfontconfig.XFcNameUnparse(tls, pat)
	if !(name != 0) {
		return m_FcFalse
	}
	if libc.Xstrlen(tls, name)+uint64(1) > uint64(len1) {
		new1 = libfontconfig.XFcPatternDuplicate(tls, pat)
		libc.Xfree(tls, name)
		libfontconfig.XFcPatternDel(tls, new1, __ccgo_ts+2165)
		libfontconfig.XFcPatternDel(tls, new1, __ccgo_ts+1400)
		name = libfontconfig.XFcNameUnparse(tls, new1)
		libfontconfig.XFcPatternDestroy(tls, new1)
		if !(name != 0) {
			return m_FcFalse
		}
		if libc.Xstrlen(tls, name)+uint64(1) > uint64(len1) {
			libc.X__builtin___strncpy_chk(tls, dest, name, uint64(len1)-uint64(1), uint64(libc.X__builtin_object_size(tls, dest, int32(1))))
			*(*int8)(unsafe.Pointer(dest + uintptr(len1-int32(1)))) = int8('\000')
			libc.Xfree(tls, name)
			return m_FcFalse
		}
	}
	libc.X__builtin___strcpy_chk(tls, dest, name, libc.X__builtin_object_size(tls, dest, int32(1)))
	libc.Xfree(tls, name)
	return int32(m_FcTrue)
}

const m_NUM_ELT_LOCAL = 128

/* xftxlfd.c */
/*===---- stdint.h - Standard header for sized integer types --------------===* *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
\*===----------------------------------------------------------------------===*/

// C documentation
//
//	/*
//	 * Dispatch glyph drawing to the correct XRenderCompositeString function
//	 */
func __XftCompositeString(tls *libc.TLS, dpy uintptr, op int32, src TPicture, dst TPicture, format uintptr, glyphset TGlyphSet, srcx int32, srcy int32, dstx int32, dsty int32, charwidth int32, chars uintptr, nchars int32) {
	if nchars == 0 {
		return
	}
	switch charwidth {
	case int32(1):
		fallthrough
	default:
		libxrender.XXRenderCompositeString8(tls, dpy, op, src, dst, format, glyphset, srcx, srcy, dstx, dsty, chars, nchars)
	case int32(2):
		libxrender.XXRenderCompositeString16(tls, dpy, op, src, dst, format, glyphset, srcx, srcy, dstx, dsty, chars, nchars)
	case int32(4):
		libxrender.XXRenderCompositeString32(tls, dpy, op, src, dst, format, glyphset, srcx, srcy, dstx, dsty, chars, nchars)
		break
	}
}

/*
 * Use the Render extension to draw the glyphs
 */
func XXftGlyphRender(tls *libc.TLS, dpy uintptr, op int32, src TPicture, pub uintptr, dst TPicture, srcx int32, srcy int32, x int32, y int32, glyphs uintptr, nglyphs int32) {
	bp := tls.Alloc(5136)
	defer tls.Free(5136)
	var char16, char32, char8, chars, font, glyph uintptr
	var dstx, dsty, i, j, width int32
	var g, max TFT_UInt
	var glyphs_loaded TFcBool
	var needed, size Tsize_t
	var wire TGlyph
	var _ /* char_local at bp+1028 */ [1024]uint32
	var _ /* missing at bp+0 */ [256]TFT_UInt
	var _ /* nmissing at bp+1024 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = char16, char32, char8, chars, dstx, dsty, font, g, glyph, glyphs_loaded, i, j, max, needed, size, width, wire
	font = pub
	if !((*TXftFontInt)(unsafe.Pointer(font)).Fformat != 0) {
		return
	}
	/*
	 * Load missing glyphs
	 */
	*(*int32)(unsafe.Pointer(bp + 1024)) = 0
	max = uint32(0)
	glyphs_loaded = m_FcFalse
	i = 0
	for {
		if !(i < nglyphs) {
			break
		}
		g = *(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4))
		if g > max {
			max = g
		}
		if XXftFontCheckGlyph(tls, dpy, pub, int32(m_FcTrue), g, bp, bp+1024) != 0 {
			glyphs_loaded = int32(m_FcTrue)
		}
		goto _1
	_1:
		;
		i++
	}
	if *(*int32)(unsafe.Pointer(bp + 1024)) != 0 {
		XXftFontLoadGlyphs(tls, dpy, pub, int32(m_FcTrue), bp, *(*int32)(unsafe.Pointer(bp + 1024)))
	}
	if !((*TXftFontInt)(unsafe.Pointer(font)).Fglyphset != 0) {
		goto bail1
	}
	if max < uint32(0x100) {
		width = int32(1)
		size = uint64(1)
	} else {
		if max < uint32(0x10000) {
			width = int32(2)
			size = uint64(2)
		} else {
			width = int32(4)
			size = uint64(4)
		}
	}
	chars = bp + 1028
	if uint64(nglyphs) > uint64(18446744073709551615)/size {
		goto bail1
	}
	needed = uint64(nglyphs) * size
	if needed > uint64(4096) {
		chars = libc.Xmalloc(tls, needed)
		if !(chars != 0) {
			goto bail1
		}
	}
	dstx = x
	dsty = y
	char8 = chars
	char16 = chars
	char32 = chars
	i = 0
	j = libc.Int32FromInt32(0)
	for {
		if !(i < nglyphs) {
			break
		}
		wire = uint64(*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4)))
		if wire >= uint64((*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs) || !(*(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(wire)*8)) != 0) {
			wire = uint64(0)
		}
		glyph = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(wire)*8))
		if glyph == libc.UintptrFromInt32(0) {
			goto _2
		}
		if (*TXftGlyph)(unsafe.Pointer(glyph)).Fpicture != 0 {
			__XftCompositeString(tls, dpy, op, src, dst, (*TXftFontInt)(unsafe.Pointer(font)).Fformat, (*TXftFontInt)(unsafe.Pointer(font)).Fglyphset, srcx, srcy, x, y, width, chars, j)
			libxrender.XXRenderComposite(tls, dpy, int32(m_PictOpOver), (*TXftGlyph)(unsafe.Pointer(glyph)).Fpicture, uint64(0), dst, 0, 0, 0, 0, dstx-int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fx), dsty-int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fy), uint32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fwidth), uint32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fheight))
			dstx += int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FxOff)
			dsty += int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FyOff)
			x = dstx
			y = dsty
			j = 0
		} else {
			switch width {
			case int32(1):
				*(*int8)(unsafe.Pointer(char8 + uintptr(j))) = int8(wire)
			case int32(2):
				*(*uint16)(unsafe.Pointer(char16 + uintptr(j)*2)) = uint16(wire)
			case int32(4):
				*(*uint32)(unsafe.Pointer(char32 + uintptr(j)*4)) = uint32(wire)
				break
			}
			dstx += int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FxOff)
			dsty += int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FyOff)
			j++
		}
		goto _2
	_2:
		;
		i++
	}
	__XftCompositeString(tls, dpy, op, src, dst, (*TXftFontInt)(unsafe.Pointer(font)).Fformat, (*TXftFontInt)(unsafe.Pointer(font)).Fglyphset, srcx, srcy, x, y, width, chars, j)
	if chars != bp+1028 {
		libc.Xfree(tls, chars)
	}
	goto bail1
bail1:
	;
	if glyphs_loaded != 0 {
		X_XftFontManageMemory(tls, dpy, pub)
	}
}

// C documentation
//
//	/*
//	 * Dispatch glyph drawing to the correct XRenderCompositeText function
//	 */
func __XftCompositeText(tls *libc.TLS, dpy uintptr, op int32, src TPicture, dst TPicture, format uintptr, srcx int32, srcy int32, dstx int32, dsty int32, eltwidth int32, elts uintptr, nelt int32) {
	if nelt == 0 {
		return
	}
	switch eltwidth {
	case int32(1):
		fallthrough
	default:
		libxrender.XXRenderCompositeText8(tls, dpy, op, src, dst, format, srcx, srcy, dstx, dsty, elts, nelt)
	case int32(2):
		libxrender.XXRenderCompositeText16(tls, dpy, op, src, dst, format, srcx, srcy, dstx, dsty, elts, nelt)
	case int32(4):
		libxrender.XXRenderCompositeText32(tls, dpy, op, src, dst, format, srcx, srcy, dstx, dsty, elts, nelt)
		break
	}
}

func XXftGlyphSpecRender(tls *libc.TLS, dpy uintptr, op int32, src TPicture, pub uintptr, dst TPicture, srcx int32, srcy int32, glyphs uintptr, nglyphs int32) {
	bp := tls.Alloc(9232)
	defer tls.Free(9232)
	var char16, char32, char8, chars, elts, font, glyph, v4, v7 uintptr
	var g, max TFT_UInt
	var glyphs_loaded TFcBool
	var i, j, n, nelt, size, width, x, y, v3, v5 int32
	var _ /* char_local at bp+1028 */ [1024]uint32
	var _ /* elts_local at bp+5128 */ [128]TXGlyphElt8
	var _ /* missing at bp+0 */ [256]TFT_UInt
	var _ /* nmissing at bp+1024 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = char16, char32, char8, chars, elts, font, g, glyph, glyphs_loaded, i, j, max, n, nelt, size, width, x, y, v3, v4, v5, v7
	font = pub
	if !((*TXftFontInt)(unsafe.Pointer(font)).Fformat != 0) {
		return
	}
	if !(nglyphs != 0) {
		return
	}
	/*
	 * Load missing glyphs
	 */
	max = uint32(0)
	*(*int32)(unsafe.Pointer(bp + 1024)) = 0
	glyphs_loaded = m_FcFalse
	g = (*(*TXftGlyphSpec)(unsafe.Pointer(glyphs))).Fglyph
	i = 0
	for {
		if !(i < nglyphs) {
			break
		}
		g = (*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fglyph
		if g > max {
			max = g
		}
		if XXftFontCheckGlyph(tls, dpy, pub, int32(m_FcTrue), g, bp, bp+1024) != 0 {
			glyphs_loaded = int32(m_FcTrue)
		}
		goto _1
	_1:
		;
		i++
	}
	if *(*int32)(unsafe.Pointer(bp + 1024)) != 0 {
		XXftFontLoadGlyphs(tls, dpy, pub, int32(m_FcTrue), bp, *(*int32)(unsafe.Pointer(bp + 1024)))
	}
	if !((*TXftFontInt)(unsafe.Pointer(font)).Fglyphset != 0) {
		goto bail1
	}
	/*
	 * See what encoding size is needed
	 */
	if max < uint32(0x100) {
		size = int32(1)
		width = int32(1)
	} else {
		if max < uint32(0x10000) {
			size = int32(2)
			width = int32(2)
		} else {
			size = int32(4)
			width = int32(4)
		}
	}
	chars = bp + 1028
	if nglyphs*size > int32(m_NUM_LOCAL) {
		chars = libc.Xmalloc(tls, uint64(nglyphs*size))
		if !(chars != 0) {
			goto bail1
		}
	}
	char8 = chars
	char16 = chars
	char32 = chars
	/*
	 * Compute the number of glyph elts needed
	 */
	nelt = int32(1)
	i = 0
	for {
		if !(i < nglyphs) {
			break
		}
		g = (*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fglyph
		/* Substitute default for non-existent glyphs */
		if g >= (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs || !(*(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(g)*8)) != 0) {
			g = uint32(0)
		}
		if *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(g)*8)) != 0 {
			break
		}
		goto _2
	_2:
		;
		i++
	}
	if i == nglyphs {
		goto bail2
	}
	glyph = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(g)*8))
	x = int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fx) + int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FxOff)
	y = int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fy) + int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FyOff)
	for {
		i++
		v3 = i
		if !(v3 < nglyphs) {
			break
		}
		g = (*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fglyph
		/* Substitute default for non-existent glyphs */
		if g >= (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs || !(*(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(g)*8)) != 0) {
			g = uint32(0)
		}
		/*
		 * check to see if the glyph is placed where it would
		 * fall using the normal spacing and if it would render
		 * as a XRender glyph
		 */
		v4 = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(g)*8))
		glyph = v4
		if v4 != 0 && !((*TXftGlyph)(unsafe.Pointer(glyph)).Fpicture != 0) {
			if x != int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fx) || y != int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fy) {
				x = int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fx)
				y = int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fy)
				nelt++
			}
			x += int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FxOff)
			y += int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FyOff)
		}
	}
	elts = bp + 5128
	if nelt > int32(m_NUM_ELT_LOCAL) {
		elts = libc.Xmalloc(tls, uint64(nelt)*uint64(32))
		if !(elts != 0) {
			goto bail2
		}
	}
	/*
	 * Generate the list of glyph elts or render color glyphs
	 */
	nelt = 0
	v5 = libc.Int32FromInt32(0)
	y = v5
	x = v5
	n = 0
	j = 0
	i = 0
	for {
		if !(i < nglyphs) {
			break
		}
		g = (*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fglyph
		/* Substitute default for non-existent glyphs */
		if g >= (*TXftFontInt)(unsafe.Pointer(font)).Fnum_glyphs || !(*(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(g)*8)) != 0) {
			g = uint32(0)
		}
		v7 = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font)).Fglyphs + uintptr(g)*8))
		glyph = v7
		if v7 != 0 {
			if (*TXftGlyph)(unsafe.Pointer(glyph)).Fpicture != 0 {
				libxrender.XXRenderComposite(tls, dpy, int32(m_PictOpOver), (*TXftGlyph)(unsafe.Pointer(glyph)).Fpicture, uint64(0), dst, 0, 0, 0, 0, int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fx)-int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fx), int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fy)-int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fy), uint32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fwidth), uint32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fheight))
				goto _6
			}
			if !(i != 0) || x != int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fx) || y != int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fy) {
				if n != 0 {
					(*(*TXGlyphElt8)(unsafe.Pointer(elts + uintptr(nelt)*32))).Fnchars = n
					nelt++
				}
				(*(*TXGlyphElt8)(unsafe.Pointer(elts + uintptr(nelt)*32))).Fglyphset = (*TXftFontInt)(unsafe.Pointer(font)).Fglyphset
				(*(*TXGlyphElt8)(unsafe.Pointer(elts + uintptr(nelt)*32))).Fchars = char8 + uintptr(size*j)
				(*(*TXGlyphElt8)(unsafe.Pointer(elts + uintptr(nelt)*32))).FxOff = int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fx) - x
				(*(*TXGlyphElt8)(unsafe.Pointer(elts + uintptr(nelt)*32))).FyOff = int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fy) - y
				x = int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fx)
				y = int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fy)
				n = 0
			}
			switch width {
			case int32(1):
				*(*int8)(unsafe.Pointer(char8 + uintptr(j))) = int8(g)
			case int32(2):
				*(*uint16)(unsafe.Pointer(char16 + uintptr(j)*2)) = uint16(g)
			case int32(4):
				*(*uint32)(unsafe.Pointer(char32 + uintptr(j)*4)) = g
				break
			}
			x += int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FxOff)
			y += int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FyOff)
			j++
			n++
		}
		goto _6
	_6:
		;
		i++
	}
	if n != 0 {
		(*(*TXGlyphElt8)(unsafe.Pointer(elts + uintptr(nelt)*32))).Fnchars = n
		nelt++
	}
	__XftCompositeText(tls, dpy, op, src, dst, (*TXftFontInt)(unsafe.Pointer(font)).Fformat, srcx, srcy, int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs))).Fx), int32((*(*TXftGlyphSpec)(unsafe.Pointer(glyphs))).Fy), width, elts, nelt)
	if elts != bp+5128 {
		libc.Xfree(tls, elts)
	}
	goto bail2
bail2:
	;
	if chars != bp+1028 {
		libc.Xfree(tls, chars)
	}
	goto bail1
bail1:
	;
	if glyphs_loaded != 0 {
		X_XftFontManageMemory(tls, dpy, pub)
	}
}

func XXftCharSpecRender(tls *libc.TLS, dpy uintptr, op int32, src TPicture, pub uintptr, dst TPicture, srcx int32, srcy int32, chars uintptr, len1 int32) {
	bp := tls.Alloc(8192)
	defer tls.Free(8192)
	var glyphs uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TXftGlyphSpec
	_, _ = glyphs, i
	if len1 <= 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		glyphs = bp
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(8))
		if !(glyphs != 0) {
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		(*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fglyph = XXftCharIndex(tls, dpy, pub, (*(*TXftCharSpec)(unsafe.Pointer(chars + uintptr(i)*8))).Fucs4)
		(*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fx = (*(*TXftCharSpec)(unsafe.Pointer(chars + uintptr(i)*8))).Fx
		(*(*TXftGlyphSpec)(unsafe.Pointer(glyphs + uintptr(i)*8))).Fy = (*(*TXftCharSpec)(unsafe.Pointer(chars + uintptr(i)*8))).Fy
		goto _1
	_1:
		;
		i++
	}
	XXftGlyphSpecRender(tls, dpy, op, src, pub, dst, srcx, srcy, glyphs, len1)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

/*
 * Choose which format to draw text in when drawing with fonts
 * of different formats.  The trick is that ARGB formats aren't
 * compatible with A formats as PictOpAdd does the wrong thing, so
 * fall back to an A format when presented with an ARGB and A format
 */

func _XftPreferFormat(tls *libc.TLS, dpy uintptr, a uintptr, b uintptr) (r uintptr) {
	var prefer uintptr
	_ = prefer
	prefer = libc.UintptrFromInt32(0)
	if a == b {
		prefer = a
	} else {
		if libc.BoolInt32((*TXRenderPictFormat)(unsafe.Pointer(a)).Fdepth == int32(32)) != libc.BoolInt32((*TXRenderPictFormat)(unsafe.Pointer(b)).Fdepth == int32(32)) {
			prefer = libxrender.XXRenderFindStandardFormat(tls, dpy, int32(m_PictStandardA8))
		} else {
			if (*TXRenderPictFormat)(unsafe.Pointer(a)).Fdepth > (*TXRenderPictFormat)(unsafe.Pointer(b)).Fdepth {
				prefer = a
			} else {
				prefer = b
			}
		}
	}
	return prefer
}

func XXftGlyphFontSpecRender(tls *libc.TLS, dpy uintptr, op int32, src TPicture, dst TPicture, srcx int32, srcy int32, glyphs uintptr, nglyphs int32) {
	bp := tls.Alloc(9232)
	defer tls.Free(9232)
	var char16, char32, char8, chars, elts, firstFont, font, font1, font2, font3, format, glyph, prevPublic, pub, pub1, pub2, pub3, v4, v7 uintptr
	var g, max TFT_UInt
	var glyphs_loaded TFcBool
	var i, j, n, nelt, size, width, x, y, v3, v5 int32
	var _ /* char_local at bp+1028 */ [1024]uint32
	var _ /* elts_local at bp+5128 */ [128]TXGlyphElt8
	var _ /* missing at bp+0 */ [256]TFT_UInt
	var _ /* nmissing at bp+1024 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = char16, char32, char8, chars, elts, firstFont, font, font1, font2, font3, format, g, glyph, glyphs_loaded, i, j, max, n, nelt, prevPublic, pub, pub1, pub2, pub3, size, width, x, y, v3, v4, v5, v7
	if !(nglyphs != 0) {
		return
	}
	/*
	 * Load missing glyphs.  Have to load them
	 * one at a time in case the font changes
	 */
	max = uint32(0)
	glyphs_loaded = m_FcFalse
	g = (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs))).Fglyph
	i = 0
	for {
		if !(i < nglyphs) {
			break
		}
		pub = (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont
		font = pub
		g = (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fglyph
		if g > max {
			max = g
		}
		*(*int32)(unsafe.Pointer(bp + 1024)) = 0
		if XXftFontCheckGlyph(tls, dpy, pub, int32(m_FcTrue), g, bp, bp+1024) != 0 {
			glyphs_loaded = int32(m_FcTrue)
		}
		if *(*int32)(unsafe.Pointer(bp + 1024)) != 0 {
			XXftFontLoadGlyphs(tls, dpy, pub, int32(m_FcTrue), bp, *(*int32)(unsafe.Pointer(bp + 1024)))
		}
		if !((*TXftFontInt)(unsafe.Pointer(font)).Fformat != 0) {
			goto bail1
		}
		if !((*TXftFontInt)(unsafe.Pointer(font)).Fglyphset != 0) {
			goto bail1
		}
		goto _1
	_1:
		;
		i++
	}
	/*
	 * See what encoding size is needed
	 */
	if max < uint32(0x100) {
		size = int32(1)
		width = int32(1)
	} else {
		if max < uint32(0x10000) {
			size = int32(2)
			width = int32(2)
		} else {
			size = int32(4)
			width = int32(4)
		}
	}
	chars = bp + 1028
	if nglyphs*size > int32(m_NUM_LOCAL) {
		chars = libc.Xmalloc(tls, uint64(nglyphs*size))
		if !(chars != 0) {
			goto bail1
		}
	}
	char8 = chars
	char16 = chars
	char32 = chars
	/*
	 * Compute the number of glyph elts needed
	 */
	nelt = int32(1)
	firstFont = libc.UintptrFromInt32(0)
	i = 0
	for {
		if !(i < nglyphs) {
			break
		}
		pub1 = (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont
		font1 = pub1
		g = (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fglyph
		/* Substitute default for non-existent glyphs */
		if g >= (*TXftFontInt)(unsafe.Pointer(font1)).Fnum_glyphs || !(*(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font1)).Fglyphs + uintptr(g)*8)) != 0) {
			g = uint32(0)
		}
		if *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font1)).Fglyphs + uintptr(g)*8)) != 0 {
			firstFont = font1
			break
		}
		goto _2
	_2:
		;
		i++
	}
	if i == nglyphs || !(firstFont != 0) {
		goto bail2
	}
	glyph = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(firstFont)).Fglyphs + uintptr(g)*8))
	format = (*TXftFontInt)(unsafe.Pointer(firstFont)).Fformat
	x = int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fx) + int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FxOff)
	y = int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fy) + int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FyOff)
	prevPublic = libc.UintptrFromInt32(0)
	for {
		i++
		v3 = i
		if !(v3 < nglyphs) {
			break
		}
		pub2 = (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont
		font2 = pub2
		g = (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fglyph
		/* Substitute default for non-existent glyphs */
		if g >= (*TXftFontInt)(unsafe.Pointer(font2)).Fnum_glyphs || !(*(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font2)).Fglyphs + uintptr(g)*8)) != 0) {
			g = uint32(0)
		}
		/*
		 * check to see if the glyph is placed where it would
		 * fall using the normal spacing
		 */
		v4 = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font2)).Fglyphs + uintptr(g)*8))
		glyph = v4
		if v4 != 0 && !((*TXftGlyph)(unsafe.Pointer(glyph)).Fpicture != 0) {
			if pub2 != prevPublic || x != int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fx) || y != int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fy) {
				prevPublic = pub2
				if (*TXftFontInt)(unsafe.Pointer(font2)).Fformat != format {
					format = _XftPreferFormat(tls, dpy, (*TXftFontInt)(unsafe.Pointer(font2)).Fformat, format)
				}
				x = int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fx)
				y = int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fy)
				nelt++
			}
			x += int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FxOff)
			y += int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FyOff)
		}
	}
	elts = bp + 5128
	if nelt > int32(m_NUM_ELT_LOCAL) {
		elts = libc.Xmalloc(tls, uint64(nelt)*uint64(32))
		if !(elts != 0) {
			goto bail2
		}
	}
	/*
	 * Generate the list of glyph elts and render color glyphs
	 */
	nelt = 0
	v5 = libc.Int32FromInt32(0)
	y = v5
	x = v5
	n = 0
	j = 0
	prevPublic = libc.UintptrFromInt32(0)
	i = 0
	for {
		if !(i < nglyphs) {
			break
		}
		pub3 = (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont
		font3 = pub3
		g = (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fglyph
		/* Substitute default for non-existent glyphs */
		if g >= (*TXftFontInt)(unsafe.Pointer(font3)).Fnum_glyphs || !(*(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font3)).Fglyphs + uintptr(g)*8)) != 0) {
			g = uint32(0)
		}
		v7 = *(*uintptr)(unsafe.Pointer((*TXftFontInt)(unsafe.Pointer(font3)).Fglyphs + uintptr(g)*8))
		glyph = v7
		if v7 != 0 {
			if (*TXftGlyph)(unsafe.Pointer(glyph)).Fpicture != 0 {
				libxrender.XXRenderComposite(tls, dpy, int32(m_PictOpOver), (*TXftGlyph)(unsafe.Pointer(glyph)).Fpicture, uint64(0), dst, 0, 0, 0, 0, int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fx)-int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fx), int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fy)-int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fy), uint32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fwidth), uint32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.Fheight))
				goto _6
			}
			if !(i != 0) || pub3 != prevPublic || x != int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fx) || y != int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fy) {
				if n != 0 {
					(*(*TXGlyphElt8)(unsafe.Pointer(elts + uintptr(nelt)*32))).Fnchars = n
					nelt++
				}
				(*(*TXGlyphElt8)(unsafe.Pointer(elts + uintptr(nelt)*32))).Fglyphset = (*TXftFontInt)(unsafe.Pointer(font3)).Fglyphset
				(*(*TXGlyphElt8)(unsafe.Pointer(elts + uintptr(nelt)*32))).Fchars = char8 + uintptr(size*j)
				(*(*TXGlyphElt8)(unsafe.Pointer(elts + uintptr(nelt)*32))).FxOff = int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fx) - x
				(*(*TXGlyphElt8)(unsafe.Pointer(elts + uintptr(nelt)*32))).FyOff = int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fy) - y
				prevPublic = pub3
				x = int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fx)
				y = int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fy)
				n = 0
			}
			switch width {
			case int32(1):
				*(*int8)(unsafe.Pointer(char8 + uintptr(j))) = int8(g)
			case int32(2):
				*(*uint16)(unsafe.Pointer(char16 + uintptr(j)*2)) = uint16(g)
			case int32(4):
				*(*uint32)(unsafe.Pointer(char32 + uintptr(j)*4)) = g
				break
			}
			x += int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FxOff)
			y += int32((*TXftGlyph)(unsafe.Pointer(glyph)).Fmetrics.FyOff)
			j++
			n++
		}
		goto _6
	_6:
		;
		i++
	}
	if n != 0 {
		(*(*TXGlyphElt8)(unsafe.Pointer(elts + uintptr(nelt)*32))).Fnchars = n
		nelt++
	}
	__XftCompositeText(tls, dpy, op, src, dst, format, srcx, srcy, int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs))).Fx), int32((*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs))).Fy), width, elts, nelt)
	if elts != bp+5128 {
		libc.Xfree(tls, elts)
	}
	goto bail2
bail2:
	;
	if chars != bp+1028 {
		libc.Xfree(tls, chars)
	}
	goto bail1
bail1:
	;
	if glyphs_loaded != 0 {
		i = 0
		for {
			if !(i < nglyphs) {
				break
			}
			X_XftFontManageMemory(tls, dpy, (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont)
			goto _8
		_8:
			;
			i++
		}
	}
}

func XXftCharFontSpecRender(tls *libc.TLS, dpy uintptr, op int32, src TPicture, dst TPicture, srcx int32, srcy int32, chars uintptr, len1 int32) {
	bp := tls.Alloc(16384)
	defer tls.Free(16384)
	var glyphs uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TXftGlyphFontSpec
	_, _ = glyphs, i
	if len1 <= 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		glyphs = bp
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(16))
		if !(glyphs != 0) {
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		(*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont = (*(*TXftCharFontSpec)(unsafe.Pointer(chars + uintptr(i)*16))).Ffont
		(*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fglyph = XXftCharIndex(tls, dpy, (*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Ffont, (*(*TXftCharFontSpec)(unsafe.Pointer(chars + uintptr(i)*16))).Fucs4)
		(*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fx = (*(*TXftCharFontSpec)(unsafe.Pointer(chars + uintptr(i)*16))).Fx
		(*(*TXftGlyphFontSpec)(unsafe.Pointer(glyphs + uintptr(i)*16))).Fy = (*(*TXftCharFontSpec)(unsafe.Pointer(chars + uintptr(i)*16))).Fy
		goto _1
	_1:
		;
		i++
	}
	XXftGlyphFontSpecRender(tls, dpy, op, src, dst, srcx, srcy, glyphs, len1)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftTextRender8(tls *libc.TLS, dpy uintptr, op int32, src TPicture, pub uintptr, dst TPicture, srcx int32, srcy int32, x int32, y int32, string1 uintptr, len1 int32) {
	bp := tls.Alloc(4096)
	defer tls.Free(4096)
	var glyphs uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	_, _ = glyphs, i
	if len1 <= 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		glyphs = bp
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(4))
		if !(glyphs != 0) {
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4)) = XXftCharIndex(tls, dpy, pub, uint32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i)))))
		goto _1
	_1:
		;
		i++
	}
	XXftGlyphRender(tls, dpy, op, src, pub, dst, srcx, srcy, x, y, glyphs, len1)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftTextRender16(tls *libc.TLS, dpy uintptr, op int32, src TPicture, pub uintptr, dst TPicture, srcx int32, srcy int32, x int32, y int32, string1 uintptr, len1 int32) {
	bp := tls.Alloc(4096)
	defer tls.Free(4096)
	var glyphs uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	_, _ = glyphs, i
	if len1 <= 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		glyphs = bp
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(4))
		if !(glyphs != 0) {
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4)) = XXftCharIndex(tls, dpy, pub, uint32(*(*TFcChar16)(unsafe.Pointer(string1 + uintptr(i)*2))))
		goto _1
	_1:
		;
		i++
	}
	XXftGlyphRender(tls, dpy, op, src, pub, dst, srcx, srcy, x, y, glyphs, len1)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftTextRender16BE(tls *libc.TLS, dpy uintptr, op int32, src TPicture, pub uintptr, dst TPicture, srcx int32, srcy int32, x int32, y int32, string1 uintptr, len1 int32) {
	bp := tls.Alloc(4096)
	defer tls.Free(4096)
	var glyphs uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	_, _ = glyphs, i
	if len1 <= 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		glyphs = bp
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(4))
		if !(glyphs != 0) {
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4)) = XXftCharIndex(tls, dpy, pub, uint32(int32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i*int32(2)))))<<libc.Int32FromInt32(8)|int32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i*int32(2)+int32(1)))))))
		goto _1
	_1:
		;
		i++
	}
	XXftGlyphRender(tls, dpy, op, src, pub, dst, srcx, srcy, x, y, glyphs, len1)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftTextRender16LE(tls *libc.TLS, dpy uintptr, op int32, src TPicture, pub uintptr, dst TPicture, srcx int32, srcy int32, x int32, y int32, string1 uintptr, len1 int32) {
	bp := tls.Alloc(4096)
	defer tls.Free(4096)
	var glyphs uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	_, _ = glyphs, i
	if len1 <= 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		glyphs = bp
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(4))
		if !(glyphs != 0) {
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4)) = XXftCharIndex(tls, dpy, pub, uint32(int32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i*int32(2)))))|int32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i*int32(2)+int32(1)))))<<libc.Int32FromInt32(8)))
		goto _1
	_1:
		;
		i++
	}
	XXftGlyphRender(tls, dpy, op, src, pub, dst, srcx, srcy, x, y, glyphs, len1)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftTextRender32(tls *libc.TLS, dpy uintptr, op int32, src TPicture, pub uintptr, dst TPicture, srcx int32, srcy int32, x int32, y int32, string1 uintptr, len1 int32) {
	bp := tls.Alloc(4096)
	defer tls.Free(4096)
	var glyphs uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	_, _ = glyphs, i
	if len1 <= 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		glyphs = bp
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(4))
		if !(glyphs != 0) {
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4)) = XXftCharIndex(tls, dpy, pub, *(*TFcChar32)(unsafe.Pointer(string1 + uintptr(i)*4)))
		goto _1
	_1:
		;
		i++
	}
	XXftGlyphRender(tls, dpy, op, src, pub, dst, srcx, srcy, x, y, glyphs, len1)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftTextRender32BE(tls *libc.TLS, dpy uintptr, op int32, src TPicture, pub uintptr, dst TPicture, srcx int32, srcy int32, x int32, y int32, string1 uintptr, len1 int32) {
	bp := tls.Alloc(4096)
	defer tls.Free(4096)
	var glyphs uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	_, _ = glyphs, i
	if len1 <= 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		glyphs = bp
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(4))
		if !(glyphs != 0) {
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4)) = XXftCharIndex(tls, dpy, pub, uint32(int32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i*int32(4)))))<<libc.Int32FromInt32(24)|int32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i*int32(4)+int32(1)))))<<libc.Int32FromInt32(16)|int32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i*int32(4)+int32(2)))))<<libc.Int32FromInt32(8)|int32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i*int32(4)+int32(3)))))))
		goto _1
	_1:
		;
		i++
	}
	XXftGlyphRender(tls, dpy, op, src, pub, dst, srcx, srcy, x, y, glyphs, len1)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftTextRender32LE(tls *libc.TLS, dpy uintptr, op int32, src TPicture, pub uintptr, dst TPicture, srcx int32, srcy int32, x int32, y int32, string1 uintptr, len1 int32) {
	bp := tls.Alloc(4096)
	defer tls.Free(4096)
	var glyphs uintptr
	var i int32
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	_, _ = glyphs, i
	if len1 <= 0 {
		return
	}
	if len1 <= int32(m_NUM_LOCAL) {
		glyphs = bp
	} else {
		glyphs = libc.Xmalloc(tls, uint64(len1)*uint64(4))
		if !(glyphs != 0) {
			return
		}
	}
	i = 0
	for {
		if !(i < len1) {
			break
		}
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(i)*4)) = XXftCharIndex(tls, dpy, pub, uint32(int32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i*int32(4)))))|int32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i*int32(4)+int32(1)))))<<libc.Int32FromInt32(8)|int32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i*int32(4)+int32(2)))))<<libc.Int32FromInt32(16)|int32(*(*TFcChar8)(unsafe.Pointer(string1 + uintptr(i*int32(4)+int32(3)))))<<libc.Int32FromInt32(24)))
		goto _1
	_1:
		;
		i++
	}
	XXftGlyphRender(tls, dpy, op, src, pub, dst, srcx, srcy, x, y, glyphs, len1)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftTextRenderUtf8(tls *libc.TLS, dpy uintptr, op int32, src TPicture, pub uintptr, dst TPicture, srcx int32, srcy int32, x int32, y int32, string1 uintptr, len1 int32) {
	bp := tls.Alloc(4112)
	defer tls.Free(4112)
	var glyphs, glyphs_new uintptr
	var i, l, size, v1, v3 int32
	var v2 bool
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	var _ /* ucs4 at bp+4096 */ TFcChar32
	_, _, _, _, _, _, _, _ = glyphs, glyphs_new, i, l, size, v1, v2, v3
	if len1 <= 0 {
		return
	}
	i = 0
	glyphs = bp
	size = int32(m_NUM_LOCAL)
	for {
		if v2 = len1 != 0; v2 {
			v1 = libfontconfig.XFcUtf8ToUcs4(tls, string1, bp+4096, len1)
			l = v1
		}
		if !(v2 && v1 > 0) {
			break
		}
		if i == size {
			glyphs_new = libc.Xmalloc(tls, uint64(size*libc.Int32FromInt32(2))*uint64(4))
			if !(glyphs_new != 0) {
				if glyphs != bp {
					libc.Xfree(tls, glyphs)
				}
				return
			}
			libc.X__builtin___memcpy_chk(tls, glyphs_new, glyphs, uint64(size)*uint64(4), uint64(libc.X__builtin_object_size(tls, glyphs_new, 0)))
			size *= int32(2)
			if glyphs != bp {
				libc.Xfree(tls, glyphs)
			}
			glyphs = glyphs_new
		}
		v3 = i
		i++
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(v3)*4)) = XXftCharIndex(tls, dpy, pub, *(*TFcChar32)(unsafe.Pointer(bp + 4096)))
		string1 += uintptr(l)
		len1 -= l
	}
	XXftGlyphRender(tls, dpy, op, src, pub, dst, srcx, srcy, x, y, glyphs, i)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

func XXftTextRenderUtf16(tls *libc.TLS, dpy uintptr, op int32, src TPicture, pub uintptr, dst TPicture, srcx int32, srcy int32, x int32, y int32, string1 uintptr, endian TFcEndian, len1 int32) {
	bp := tls.Alloc(4112)
	defer tls.Free(4112)
	var glyphs, glyphs_new uintptr
	var i, l, size, v1, v3 int32
	var v2 bool
	var _ /* glyphs_local at bp+0 */ [1024]TFT_UInt
	var _ /* ucs4 at bp+4096 */ TFcChar32
	_, _, _, _, _, _, _, _ = glyphs, glyphs_new, i, l, size, v1, v2, v3
	if len1 <= 0 {
		return
	}
	i = 0
	glyphs = bp
	size = int32(m_NUM_LOCAL)
	for {
		if v2 = len1 != 0; v2 {
			v1 = libfontconfig.XFcUtf16ToUcs4(tls, string1, endian, bp+4096, len1)
			l = v1
		}
		if !(v2 && v1 > 0) {
			break
		}
		if i == size {
			glyphs_new = libc.Xmalloc(tls, uint64(size*libc.Int32FromInt32(2))*uint64(4))
			if !(glyphs_new != 0) {
				if glyphs != bp {
					libc.Xfree(tls, glyphs)
				}
				return
			}
			libc.X__builtin___memcpy_chk(tls, glyphs_new, glyphs, uint64(size)*uint64(4), uint64(libc.X__builtin_object_size(tls, glyphs_new, 0)))
			size *= int32(2)
			if glyphs != bp {
				libc.Xfree(tls, glyphs)
			}
			glyphs = glyphs_new
		}
		v3 = i
		i++
		*(*TFT_UInt)(unsafe.Pointer(glyphs + uintptr(v3)*4)) = XXftCharIndex(tls, dpy, pub, *(*TFcChar32)(unsafe.Pointer(bp + 4096)))
		string1 += uintptr(l)
		len1 -= l
	}
	XXftGlyphRender(tls, dpy, int32(m_PictOpOver), src, pub, dst, srcx, srcy, x, y, glyphs, i)
	if glyphs != bp {
		libc.Xfree(tls, glyphs)
	}
}

/* xftxlfd.c */
func X_XftMatchSymbolic(tls *libc.TLS, s uintptr, n int32, name uintptr, def int32) (r int32) {
	var v1 int32
	_ = v1
	for {
		v1 = n
		n--
		if !(v1 != 0) {
			break
		}
		if !(libfontconfig.XFcStrCmpIgnoreCase(tls, (*TXftSymbolic)(unsafe.Pointer(s)).Fname, name) != 0) {
			return (*TXftSymbolic)(unsafe.Pointer(s)).Fvalue
		}
		s += 16
	}
	return def
}

/* xftxlfd.c */
func XXftNativeByteOrder(tls *libc.TLS) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* whichbyte at bp+0 */ int32
	*(*int32)(unsafe.Pointer(bp)) = int32(1)
	if *(*int8)(unsafe.Pointer(bp)) != 0 {
		return m_LSBFirst
	}
	return int32(m_MSBFirst)
}

/* byte swap a 32-bit value */

/* byte swap a short */

/* byte swap a three-byte unit */
func XXftSwapCARD32(tls *libc.TLS, data uintptr, u int32) {
	var n int8
	var v1 int32
	_, _ = n, v1
	for {
		v1 = u
		u--
		if !(v1 != 0) {
			break
		}
		n = *(*int8)(unsafe.Pointer(data))
		*(*int8)(unsafe.Pointer(data)) = *(*int8)(unsafe.Pointer(data + 3))
		*(*int8)(unsafe.Pointer(data + 3)) = n
		n = *(*int8)(unsafe.Pointer(data + 1))
		*(*int8)(unsafe.Pointer(data + 1)) = *(*int8)(unsafe.Pointer(data + 2))
		*(*int8)(unsafe.Pointer(data + 2)) = n
		data += 4
	}
}

func XXftSwapCARD24(tls *libc.TLS, data uintptr, width int32, height int32) {
	var d uintptr
	var n int8
	var u, units, v1, v2 int32
	_, _, _, _, _, _ = d, n, u, units, v1, v2
	units = width / int32(3)
	for {
		v1 = height
		height--
		if !(v1 != 0) {
			break
		}
		d = data
		data += uintptr(width)
		u = units
		for {
			v2 = u
			u--
			if !(v2 != 0) {
				break
			}
			n = *(*int8)(unsafe.Pointer(d))
			*(*int8)(unsafe.Pointer(d)) = *(*int8)(unsafe.Pointer(d + 2))
			*(*int8)(unsafe.Pointer(d + 2)) = n
			d += uintptr(3)
		}
	}
}

func XXftSwapCARD16(tls *libc.TLS, data uintptr, u int32) {
	var n int8
	var v1 int32
	_, _ = n, v1
	for {
		v1 = u
		u--
		if !(v1 != 0) {
			break
		}
		n = *(*int8)(unsafe.Pointer(data))
		*(*int8)(unsafe.Pointer(data)) = *(*int8)(unsafe.Pointer(data + 1))
		*(*int8)(unsafe.Pointer(data + 1)) = n
		data += 2
	}
}

func XXftSwapImage(tls *libc.TLS, image uintptr) {
	switch (*TXImage)(unsafe.Pointer(image)).Fbits_per_pixel {
	case int32(32):
		XXftSwapCARD32(tls, (*TXImage)(unsafe.Pointer(image)).Fdata, (*TXImage)(unsafe.Pointer(image)).Fheight*(*TXImage)(unsafe.Pointer(image)).Fbytes_per_line>>int32(2))
	case int32(24):
		XXftSwapCARD24(tls, (*TXImage)(unsafe.Pointer(image)).Fdata, (*TXImage)(unsafe.Pointer(image)).Fbytes_per_line, (*TXImage)(unsafe.Pointer(image)).Fheight)
	case int32(16):
		XXftSwapCARD16(tls, (*TXImage)(unsafe.Pointer(image)).Fdata, (*TXImage)(unsafe.Pointer(image)).Fheight*(*TXImage)(unsafe.Pointer(image)).Fbytes_per_line>>int32(1))
	default:
		break
	}
}

/* xftxlfd.c */

var _XftXlfdWeights = [6]TXftSymbolic{
	0: {
		Fname:  __ccgo_ts + 2170,
		Fvalue: int32(m_FC_WEIGHT_LIGHT),
	},
	1: {
		Fname:  __ccgo_ts + 2176,
		Fvalue: int32(m_FC_WEIGHT_MEDIUM),
	},
	2: {
		Fname:  __ccgo_ts + 2183,
		Fvalue: int32(m_FC_WEIGHT_MEDIUM),
	},
	3: {
		Fname:  __ccgo_ts + 2191,
		Fvalue: int32(m_FC_WEIGHT_DEMIBOLD),
	},
	4: {
		Fname:  __ccgo_ts + 2200,
		Fvalue: int32(m_FC_WEIGHT_BOLD),
	},
	5: {
		Fname:  __ccgo_ts + 2205,
		Fvalue: int32(m_FC_WEIGHT_BLACK),
	},
}

var _XftXlfdSlants = [3]TXftSymbolic{
	0: {
		Fname: __ccgo_ts + 2211,
	},
	1: {
		Fname:  __ccgo_ts + 2213,
		Fvalue: int32(m_FC_SLANT_ITALIC),
	},
	2: {
		Fname:  __ccgo_ts + 2215,
		Fvalue: int32(m_FC_SLANT_OBLIQUE),
	},
}

// C documentation
//
//	/*
//	 * Cut out one XLFD field, placing it in 'save' and return
//	 * the start of 'save'
//	 */
func _XftSplitStr(tls *libc.TLS, field uintptr, save uintptr) (r uintptr) {
	var c int8
	var s, v1, v2 uintptr
	_, _, _, _ = c, s, v1, v2
	s = save
	for *(*int8)(unsafe.Pointer(field)) != 0 {
		if int32(*(*int8)(unsafe.Pointer(field))) == int32('-') {
			break
		}
		v1 = field
		field++
		c = *(*int8)(unsafe.Pointer(v1))
		v2 = save
		save++
		*(*int8)(unsafe.Pointer(v2)) = c
	}
	*(*int8)(unsafe.Pointer(save)) = 0
	return s
}

/*
 * convert one XLFD numeric field.  Return -1 if the field is '*'
 */

func _XftGetInt(tls *libc.TLS, ptr uintptr, val uintptr) (r uintptr) {
	var v2 uintptr
	_ = v2
	if int32(*(*int8)(unsafe.Pointer(ptr))) == int32('*') {
		*(*int32)(unsafe.Pointer(val)) = -int32(1)
		ptr++
	} else {
		*(*int32)(unsafe.Pointer(val)) = 0
		for {
			if !(int32(*(*int8)(unsafe.Pointer(ptr))) >= int32('0') && int32(*(*int8)(unsafe.Pointer(ptr))) <= int32('9')) {
				break
			}
			v2 = ptr
			ptr++
			*(*int32)(unsafe.Pointer(val)) = *(*int32)(unsafe.Pointer(val))*int32(10) + int32(*(*int8)(unsafe.Pointer(v2))) - int32('0')
			goto _1
		_1:
		}
	}
	if int32(*(*int8)(unsafe.Pointer(ptr))) == int32('-') {
		return ptr
	}
	return libc.UintptrFromInt32(0)
}

func XXftXlfdParse(tls *libc.TLS, xlfd_orig uintptr, ignore_scalable TFcBool, complete TFcBool) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var dpixel float64
	var family, foundry, pat, save, slant, weight_name, xlfd, v1, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v2, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v3, v30, v31, v4, v5, v6, v7, v8, v9 uintptr
	var slant_value, weight_value int32
	var _ /* pixel at bp+0 */ int32
	var _ /* point at bp+4 */ int32
	var _ /* resx at bp+8 */ int32
	var _ /* resy at bp+12 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = dpixel, family, foundry, pat, save, slant, slant_value, weight_name, weight_value, xlfd, v1, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v2, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v3, v30, v31, v4, v5, v6, v7, v8, v9
	xlfd = xlfd_orig
	if int32(*(*int8)(unsafe.Pointer(xlfd))) != int32('-') {
		return libc.UintptrFromInt32(0)
	}
	xlfd++
	v3 = xlfd
	v2 = v3
	foundry = v2
	v1 = libc.Xstrchr(tls, v2, int32('-'))
	xlfd = v1
	if !(v1 != 0) {
		return libc.UintptrFromInt32(0)
	}
	xlfd++
	v6 = xlfd
	v5 = v6
	family = v5
	v4 = libc.Xstrchr(tls, v5, int32('-'))
	xlfd = v4
	if !(v4 != 0) {
		return libc.UintptrFromInt32(0)
	}
	xlfd++
	v9 = xlfd
	v8 = v9
	weight_name = v8
	v7 = libc.Xstrchr(tls, v8, int32('-'))
	xlfd = v7
	if !(v7 != 0) {
		return libc.UintptrFromInt32(0)
	}
	xlfd++
	v12 = xlfd
	v11 = v12
	slant = v11
	v10 = libc.Xstrchr(tls, v11, int32('-'))
	xlfd = v10
	if !(v10 != 0) {
		return libc.UintptrFromInt32(0)
	}
	xlfd++
	v14 = xlfd
	v13 = libc.Xstrchr(tls, v14, int32('-'))
	xlfd = v13
	if !(v13 != 0) {
		return libc.UintptrFromInt32(0)
	}
	xlfd++
	v16 = xlfd
	v15 = libc.Xstrchr(tls, v16, int32('-'))
	xlfd = v15
	if !(v15 != 0) {
		return libc.UintptrFromInt32(0)
	}
	xlfd++
	v18 = xlfd
	v17 = _XftGetInt(tls, v18, bp)
	xlfd = v17
	if !(v17 != 0) {
		return libc.UintptrFromInt32(0)
	}
	xlfd++
	v20 = xlfd
	v19 = _XftGetInt(tls, v20, bp+4)
	xlfd = v19
	if !(v19 != 0) {
		return libc.UintptrFromInt32(0)
	}
	xlfd++
	v22 = xlfd
	v21 = _XftGetInt(tls, v22, bp+8)
	xlfd = v21
	if !(v21 != 0) {
		return libc.UintptrFromInt32(0)
	}
	xlfd++
	v24 = xlfd
	v23 = _XftGetInt(tls, v24, bp+12)
	xlfd = v23
	if !(v23 != 0) {
		return libc.UintptrFromInt32(0)
	}
	xlfd++
	v26 = xlfd
	v25 = libc.Xstrchr(tls, v26, int32('-'))
	xlfd = v25
	if !(v25 != 0) {
		return libc.UintptrFromInt32(0)
	}
	xlfd++
	v28 = xlfd
	v27 = libc.Xstrchr(tls, v28, int32('-'))
	xlfd = v27
	if !(v27 != 0) {
		return libc.UintptrFromInt32(0)
	}
	xlfd++
	v30 = xlfd
	v29 = libc.Xstrchr(tls, v30, int32('-'))
	xlfd = v29
	if !(v29 != 0) {
		return libc.UintptrFromInt32(0)
	}
	/* make sure no fields follow this one */
	xlfd++
	v31 = xlfd
	if libc.Xstrchr(tls, v31, int32('-')) != 0 {
		return libc.UintptrFromInt32(0)
	}
	if !(*(*int32)(unsafe.Pointer(bp)) != 0) {
		return libc.UintptrFromInt32(0)
	}
	pat = libfontconfig.XFcPatternCreate(tls)
	if !(pat != 0) {
		return libc.UintptrFromInt32(0)
	}
	save = libc.Xmalloc(tls, libc.Xstrlen(tls, foundry)+uint64(1))
	if !(save != 0) {
		libfontconfig.XFcPatternDestroy(tls, pat)
		return libc.UintptrFromInt32(0)
	}
	if !(libfontconfig.XFcPatternAddString(tls, pat, __ccgo_ts+2217, xlfd_orig) != 0) {
		goto bail
	}
	_XftSplitStr(tls, foundry, save)
	if *(*int8)(unsafe.Pointer(save)) != 0 && libc.Xstrcmp(tls, save, __ccgo_ts+2222) != 0 {
		if !(libfontconfig.XFcPatternAddString(tls, pat, __ccgo_ts+2224, save) != 0) {
			goto bail
		}
	}
	_XftSplitStr(tls, family, save)
	if *(*int8)(unsafe.Pointer(save)) != 0 && libc.Xstrcmp(tls, save, __ccgo_ts+2222) != 0 {
		if !(libfontconfig.XFcPatternAddString(tls, pat, __ccgo_ts+2232, save) != 0) {
			goto bail
		}
	}
	weight_value = X_XftMatchSymbolic(tls, uintptr(unsafe.Pointer(&_XftXlfdWeights)), int32(libc.Uint64FromInt64(96)/libc.Uint64FromInt64(16)), _XftSplitStr(tls, weight_name, save), int32(m_FC_WEIGHT_MEDIUM))
	if !(libfontconfig.XFcPatternAddInteger(tls, pat, __ccgo_ts+2239, weight_value) != 0) {
		goto bail
	}
	slant_value = X_XftMatchSymbolic(tls, uintptr(unsafe.Pointer(&_XftXlfdSlants)), int32(libc.Uint64FromInt64(48)/libc.Uint64FromInt64(16)), _XftSplitStr(tls, slant, save), m_FC_SLANT_ROMAN)
	if !(libfontconfig.XFcPatternAddInteger(tls, pat, __ccgo_ts+2246, slant_value) != 0) {
		goto bail
	}
	dpixel = float64(*(*int32)(unsafe.Pointer(bp)))
	if *(*int32)(unsafe.Pointer(bp + 4)) > 0 {
		if !(libfontconfig.XFcPatternAddDouble(tls, pat, __ccgo_ts+2252, float64(*(*int32)(unsafe.Pointer(bp + 4)))/float64(10)) != 0) {
			goto bail
		}
		if *(*int32)(unsafe.Pointer(bp)) <= 0 && *(*int32)(unsafe.Pointer(bp + 12)) > 0 {
			dpixel = float64(*(*int32)(unsafe.Pointer(bp + 4))) * float64(*(*int32)(unsafe.Pointer(bp + 12))) / float64(720)
		}
	}
	if dpixel > libc.Float64FromInt32(0) {
		if !(libfontconfig.XFcPatternAddDouble(tls, pat, __ccgo_ts+1243, dpixel) != 0) {
			goto bail
		}
	}
	libc.Xfree(tls, save)
	return pat
	goto bail
bail:
	;
	libc.Xfree(tls, save)
	libfontconfig.XFcPatternDestroy(tls, pat)
	return libc.UintptrFromInt32(0)
}

func __ccgo_fp(f interface{}) uintptr {
	type iface [2]uintptr
	return (*iface)(unsafe.Pointer(&f))[1]
}

/* xftxlfd.c */
var X_XftDisplayInfo uintptr

/* xftxlfd.c */
var X_XftFTlibrary TFT_Library

var __ccgo_ts = (*reflect.StringHeader)(unsafe.Pointer(&__ccgo_ts1)).Data

var __ccgo_ts1 = "XFT_DEBUG\x00XFT_DEBUG=%s\n\x00XftDisplayInfoGet Default visual 0x%x \x00format %d,%d,%d,%d\n\x00format indexed\n\x00No Render format for default visual\n\x00True\x00False\x00XftDisplayInfoGet initialized, hasRender set to \"%s\"\n\x00maxglyphmemory\x00global max cache memory %lu\n\x00maxunreffonts\x00global max unref fonts  %d\n\x00trackmemusage\x00true\x00false\x00global track mem usage  %s\n\x00XftDisplayInfoGet failed to initialize, Xft unhappy\n\x00Display glyph cache incorrect has %lu bytes, should have %lu\n\x00Reduce global memory from %lu to %lu\n\x00update max cache memory %lu\n\x00update max unref fonts  %d\n\x00update track mem usage  %s\n\x00Xft\x00scale\x00dpi\x00render\x00rgba\x00lcdfilter\x00antialias\x00embolden\x00autohint\x00hintstyle\x00hinting\x00minspace\x00DrawString \"%*.*s\"\n\x00XftFontMatch pattern \x00XftFontMatch after FcConfig substitutions \x00XftFontMatch after X resource substitutions \x00XftFontMatch result \x00XftFontOpen: Invalid pattern argument\n\x00Pattern \x00Match \x00No Match\n\x00No Font\n\x00XftFontOpenName \"%s\": \x00Invalid name\n\x00XftFontOpenXlfd \"%s\": \x00Invalid xlfd\n\x00FontFile %s/%d matches existing (%d)\n\x00FontFile %s/%d matches new\n\x00Discard file %s/%d from cache\n\x00Loading file %s/%d\n\x00Xft: locking error %s\n\x00too many file unlocks\x00Set face size to %dx%d (%dx%d)\n\x00Set face matrix to (%g,%g,%g,%g)\n\x00Attempt to close locked file\x00file\x00index\x00ftface\x00pixelsize\x00aspect\x00<none>\x00XftFontInfoFill: %s: %d (%g pixels)\n\x00matrix\x00embeddedbitmap\x00verticallayout\x00globaladvance\x00spacing\x00charwidth\x00New font %s/%d size %dx%d\n\x00charset\x00freeing unreferenced font %s/%d size %dx%d\n\x00Font glyph cache incorrect has %lu bytes, should have %lu\n\x00Xft: out of range; %d\n\x00Xft: too many in-use glyphs (%d vs %d)\n\x00Xft: too few in-use glyphs (%u vs %d)\n\x00Xft out of range; %d\n\x00Xft: forward %d vs reverse %d\n\x00Trans %d %d: %d %d\n\x00glyph %d:\n\x00 xywh (%d %d %d %d), trans (%d %d %d %d) wh (%d %d)\n\x00%c\x00|\n\x00\n\x00Caching glyph 0x%x size %lu\n\x00alloc %p -> %d: %p USE %d.%d\n\x00alloc %p -> %d: %p USE %d.%d, %p NEW %d.%d %p OLD %d.%d\n\x00Uncaching glyph 0x%x size %lu\n\x00free %p -> %p USE %d.%d\n\x00Xft: glyph count error\n\x00Reduce memory for font 0x%lx from %lu to %lu\n\x00XftDraw\x00XftFont\x00XftFtFile\x00XftGlyph\x00Xft Memory Usage:\n\x00\t    Which       Alloc           Free\n\x00\t            count   bytes   count   bytes\n\x00\t%9.9s%8d%8lu%8d%8lu\n\x00Total\x00lang\x00light\x00medium\x00regular\x00demibold\x00bold\x00black\x00r\x00i\x00o\x00xlfd\x00*\x00foundry\x00family\x00weight\x00slant\x00size\x00"
