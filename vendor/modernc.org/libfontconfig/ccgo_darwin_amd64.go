// Code generated for darwin/amd64 by 'generator -D__sync_fetch_and_add(var, val)=__sync_fetch_and_add_impl(&(var), val) --predef int __sync_fetch_and_add_impl(int *p, int val); --predef int __sync_bool_compare_and_swap(void *p, void *old, void *new); --predef int initstate_r(unsigned int seed, char statebuf[], __SIZE_TYPE__ statelen, struct random_data *buf); --prefix-enumerator=_ --prefix-external=x_ --prefix-field=F --prefix-macro=m_ --prefix-static-internal=_ --prefix-static-none=_ --prefix-tagged-enum=_ --prefix-tagged-struct=T --prefix-tagged-union=T --prefix-typename=T --prefix-undefined=_ -extended-errors -ignore-unsupported-alignment -ignore-link-errors -I /Users/jnml/src/modernc.org/builder/.exclude/modernc.org/libexpat/include/darwin/amd64 -I /Users/jnml/src/modernc.org/builder/.exclude/modernc.org/libfreetype/include/darwin/amd64 -lexpat -lfreetype -o libfontconfig.go --package-name libfontconfig src/.libs/libfontconfig.a', DO NOT EDIT.

//go:build darwin && amd64

package libfontconfig

import (
	"reflect"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libexpat"
	"modernc.org/libfreetype"
)

var _ reflect.Type
var _ unsafe.Pointer

const m_ACCESSX_MAX_DESCRIPTORS = 100
const m_ALIGNOF_VOID_P = 8
const m_BADSIG = "SIG_ERR"
const m_BC_BASE_MAX = 99
const m_BC_DIM_MAX = 2048
const m_BC_SCALE_MAX = 99
const m_BC_STRING_MAX = 1000
const m_BIG_ENDIAN = "__DARWIN_BIG_ENDIAN"
const m_BUFSIZ = 1024
const m_BUS_ADRALN = 1
const m_BUS_ADRERR = 2
const m_BUS_NOOP = 0
const m_BUS_OBJERR = 3
const m_BYTE_ORDER = "__DARWIN_BYTE_ORDER"
const m_CHARCLASS_NAME_MAX = 14
const m_CHILD_MAX = 266
const m_CLD_CONTINUED = 6
const m_CLD_DUMPED = 3
const m_CLD_EXITED = 1
const m_CLD_KILLED = 2
const m_CLD_NOOP = 0
const m_CLD_STOPPED = 5
const m_CLD_TRAPPED = 4
const m_CLOCK_MONOTONIC = "_CLOCK_MONOTONIC"
const m_CLOCK_MONOTONIC_RAW = "_CLOCK_MONOTONIC_RAW"
const m_CLOCK_MONOTONIC_RAW_APPROX = "_CLOCK_MONOTONIC_RAW_APPROX"
const m_CLOCK_PROCESS_CPUTIME_ID = "_CLOCK_PROCESS_CPUTIME_ID"
const m_CLOCK_REALTIME = "_CLOCK_REALTIME"
const m_CLOCK_THREAD_CPUTIME_ID = "_CLOCK_THREAD_CPUTIME_ID"
const m_CLOCK_UPTIME_RAW = "_CLOCK_UPTIME_RAW"
const m_CLOCK_UPTIME_RAW_APPROX = "_CLOCK_UPTIME_RAW_APPROX"
const m_COLL_WEIGHTS_MAX = 2
const m_CONFIGDIR = "/etc/fonts/conf.d"
const m_CPUMON_MAKE_FATAL = 0x1000
const m_DBL_DECIMAL_DIG = "__DBL_DECIMAL_DIG__"
const m_DBL_DIG = "__DBL_DIG__"
const m_DBL_EPSILON = "__DBL_EPSILON__"
const m_DBL_HAS_SUBNORM = "__DBL_HAS_DENORM__"
const m_DBL_MANT_DIG = "__DBL_MANT_DIG__"
const m_DBL_MAX = "__DBL_MAX__"
const m_DBL_MAX_10_EXP = "__DBL_MAX_10_EXP__"
const m_DBL_MAX_EXP = "__DBL_MAX_EXP__"
const m_DBL_MIN = "__DBL_MIN__"
const m_DBL_MIN_10_EXP = "__DBL_MIN_10_EXP__"
const m_DBL_MIN_EXP = "__DBL_MIN_EXP__"
const m_DBL_NORM_MAX = "__DBL_NORM_MAX__"
const m_DBL_TRUE_MIN = "__DBL_DENORM_MIN__"
const m_DECIMAL_DIG = "__DECIMAL_DIG__"
const m_DOMAIN = 1
const m_E2BIG = 7
const m_EACCES = 13
const m_EADDRINUSE = 48
const m_EADDRNOTAVAIL = 49
const m_EAFNOSUPPORT = 47
const m_EAGAIN = 35
const m_EALREADY = 37
const m_EAUTH = 80
const m_EBADARCH = 86
const m_EBADEXEC = 85
const m_EBADF = 9
const m_EBADMACHO = 88
const m_EBADMSG = 94
const m_EBADRPC = 72
const m_EBUSY = 16
const m_ECANCELED = 89
const m_ECHILD = 10
const m_ECONNABORTED = 53
const m_ECONNREFUSED = 61
const m_ECONNRESET = 54
const m_EDEADLK = 11
const m_EDESTADDRREQ = 39
const m_EDEVERR = 83
const m_EDOM = 33
const m_EDQUOT = 69
const m_EEXIST = 17
const m_EFAULT = 14
const m_EFBIG = 27
const m_EFTYPE = 79
const m_EF_IS_PURGEABLE = 0x00000008
const m_EF_IS_SPARSE = 0x00000010
const m_EF_IS_SYNC_ROOT = 0x00000004
const m_EF_IS_SYNTHETIC = 0x00000020
const m_EF_MAY_SHARE_BLOCKS = 0x00000001
const m_EF_NO_XATTRS = 0x00000002
const m_EF_SHARES_ALL_BLOCKS = 0x00000040
const m_EHOSTDOWN = 64
const m_EHOSTUNREACH = 65
const m_EIDRM = 90
const m_EILSEQ = 92
const m_EINPROGRESS = 36
const m_EINTR = 4
const m_EINVAL = 22
const m_EIO = 5
const m_EISCONN = 56
const m_EISDIR = 21
const m_ELAST = 106
const m_ELOOP = 62
const m_EMFILE = 24
const m_EMLINK = 31
const m_EMSGSIZE = 40
const m_EMULTIHOP = 95
const m_ENAMETOOLONG = 63
const m_ENEEDAUTH = 81
const m_ENETDOWN = 50
const m_ENETRESET = 52
const m_ENETUNREACH = 51
const m_ENFILE = 23
const m_ENOATTR = 93
const m_ENOBUFS = 55
const m_ENODATA = 96
const m_ENODEV = 19
const m_ENOENT = 2
const m_ENOEXEC = 8
const m_ENOLCK = 77
const m_ENOLINK = 97
const m_ENOMEM = 12
const m_ENOMSG = 91
const m_ENOPOLICY = 103
const m_ENOPROTOOPT = 42
const m_ENOSPC = 28
const m_ENOSR = 98
const m_ENOSTR = 99
const m_ENOSYS = 78
const m_ENOTBLK = 15
const m_ENOTCONN = 57
const m_ENOTDIR = 20
const m_ENOTEMPTY = 66
const m_ENOTRECOVERABLE = 104
const m_ENOTSOCK = 38
const m_ENOTSUP = 45
const m_ENOTTY = 25
const m_ENXIO = 6
const m_EOPNOTSUPP = 102
const m_EOVERFLOW = 84
const m_EOWNERDEAD = 105
const m_EPERM = 1
const m_EPFNOSUPPORT = 46
const m_EPIPE = 32
const m_EPROCLIM = 67
const m_EPROCUNAVAIL = 76
const m_EPROGMISMATCH = 75
const m_EPROGUNAVAIL = 74
const m_EPROTO = 100
const m_EPROTONOSUPPORT = 43
const m_EPROTOTYPE = 41
const m_EPWROFF = 82
const m_EQFULL = 106
const m_EQUIV_CLASS_MAX = 2
const m_ERANGE = 34
const m_EREMOTE = 71
const m_EROFS = 30
const m_ERPCMISMATCH = 73
const m_ESHLIBVERS = 87
const m_ESHUTDOWN = 58
const m_ESOCKTNOSUPPORT = 44
const m_ESPIPE = 29
const m_ESRCH = 3
const m_ESTALE = 70
const m_ETIME = 101
const m_ETIMEDOUT = 60
const m_ETOOMANYREFS = 59
const m_ETXTBSY = 26
const m_EUSERS = 68
const m_EWOULDBLOCK = "EAGAIN"
const m_EXDEV = 18
const m_EXIT_FAILURE = 1
const m_EXIT_SUCCESS = 0
const m_EXPR_NEST_MAX = 32
const m_FCSS_ALLOW_DUPLICATES = 1
const m_FCSS_DEFAULT = 0
const m_FCSS_GROW_BY_64 = 2
const m_FC_ADD_FONTS = "yes"
const m_FC_ANTIALIAS = "antialias"
const m_FC_ASPECT = "aspect"
const m_FC_ATOMIC_INT_FORMAT = "d"
const m_FC_AUTOHINT = "autohint"
const m_FC_CACHEDIR = "/usr/var/cache/fontconfig"
const m_FC_CACHE_MAGIC_ALLOC = 0xFC02FC05
const m_FC_CACHE_MAGIC_MMAP = 0xFC02FC04
const m_FC_CACHE_VERSION_NUMBER = 8
const m_FC_CAPABILITY = "capability"
const m_FC_CASE_FOLD_EVEN_ODD = 1
const m_FC_CASE_FOLD_FULL = 2
const m_FC_CASE_FOLD_RANGE = 0
const m_FC_CHARCELL = 110
const m_FC_CHARSET = "charset"
const m_FC_CHARWIDTH = "charwidth"
const m_FC_CHAR_HEIGHT = "charheight"
const m_FC_CHAR_WIDTH = "FC_CHARWIDTH"
const m_FC_COLOR = "color"
const m_FC_CONFIG_PATH = "fonts.conf"
const m_FC_DBG_CACHE = 16
const m_FC_DBG_CACHEV = 32
const m_FC_DBG_CONFIG = 1024
const m_FC_DBG_EDIT = 4
const m_FC_DBG_FONTSET = 8
const m_FC_DBG_LANGSET = 2048
const m_FC_DBG_MATCH = 1
const m_FC_DBG_MATCH2 = 4096
const m_FC_DBG_MATCHV = 2
const m_FC_DBG_PARSE = 64
const m_FC_DBG_SCAN = 128
const m_FC_DBG_SCANV = 256
const m_FC_DECORATIVE = "decorative"
const m_FC_DEFAULT_FONTS = "<dir>/System/Library/Fonts</dir> <dir>/Library/Fonts</dir> <dir>~/Library/Fonts</dir> <dir>/System/Library/Assets/com_apple_MobileAsset_Font3</dir> <dir>/System/Library/Assets/com_apple_MobileAsset_Font4</dir>"
const m_FC_DIR_SEPARATOR = '/'
const m_FC_DIR_SEPARATOR_S = "/"
const m_FC_DPI = "dpi"
const m_FC_DUAL = 90
const m_FC_EMBEDDED_BITMAP = "embeddedbitmap"
const m_FC_EMBOLDEN = "embolden"
const m_FC_EXT_OBJ_INDEX = 1024
const m_FC_FAMILY = "family"
const m_FC_FAMILYLANG = "familylang"
const m_FC_FILE = "file"
const m_FC_FONTFORMAT = "fontformat"
const m_FC_FONTVERSION = "fontversion"
const m_FC_FONT_FEATURES = "fontfeatures"
const m_FC_FONT_HAS_HINT = "fonthashint"
const m_FC_FONT_VARIATIONS = "fontvariations"
const m_FC_FOUNDRY = "foundry"
const m_FC_FT_FACE = "ftface"
const m_FC_FULLNAME = "fullname"
const m_FC_FULLNAMELANG = "fullnamelang"
const m_FC_GLOBAL_ADVANCE = "globaladvance"
const m_FC_HASH = "hash"
const m_FC_HINTING = "hinting"
const m_FC_HINT_FULL = 3
const m_FC_HINT_MEDIUM = 2
const m_FC_HINT_NONE = 0
const m_FC_HINT_SLIGHT = 1
const m_FC_HINT_STYLE = "hintstyle"
const m_FC_INDEX = "index"
const m_FC_LANG = "lang"
const m_FC_LCD_DEFAULT = 1
const m_FC_LCD_FILTER = "lcdfilter"
const m_FC_LCD_LEGACY = 3
const m_FC_LCD_LIGHT = 2
const m_FC_LCD_NONE = 0
const m_FC_MAJOR = 2
const m_FC_MATRIX = "matrix"
const m_FC_MAX_FILE_LEN = 4096
const m_FC_MINOR = 14
const m_FC_MINSPACE = "minspace"
const m_FC_MONO = 100
const m_FC_MUTEX_IMPL_INIT = 0
const m_FC_NAMELANG = "namelang"
const m_FC_NO_MT = 1
const m_FC_ORDER = "order"
const m_FC_OUTLINE = "outline"
const m_FC_PATH_MAX = "PATH_MAX"
const m_FC_PIXEL_SIZE = "pixelsize"
const m_FC_POSTSCRIPT_NAME = "postscriptname"
const m_FC_PRGNAME = "prgname"
const m_FC_PROPORTIONAL = 0
const m_FC_RASTERIZER = "rasterizer"
const m_FC_REVISION = 1
const m_FC_RGBA = "rgba"
const m_FC_RGBA_BGR = 2
const m_FC_RGBA_NONE = 5
const m_FC_RGBA_RGB = 1
const m_FC_RGBA_UNKNOWN = 0
const m_FC_RGBA_VBGR = 4
const m_FC_RGBA_VRGB = 3
const m_FC_SCALABLE = "scalable"
const m_FC_SCALE = "scale"
const m_FC_SEARCH_PATH_SEPARATOR = ':'
const m_FC_SIZE = "size"
const m_FC_SLANT = "slant"
const m_FC_SLANT_ITALIC = 100
const m_FC_SLANT_OBLIQUE = 110
const m_FC_SLANT_ROMAN = 0
const m_FC_SOURCE = "source"
const m_FC_SPACING = "spacing"
const m_FC_STMT_START = "do"
const m_FC_STYLE = "style"
const m_FC_STYLELANG = "stylelang"
const m_FC_SYMBOL = "symbol"
const m_FC_TEMPLATEDIR = "/usr/share/fontconfig/conf.avail"
const m_FC_UINT64_FORMAT = "llu"
const m_FC_UTF8_MAX_LEN = 6
const m_FC_VARIABLE = "variable"
const m_FC_VERTICAL_LAYOUT = "verticallayout"
const m_FC_WEIGHT = "weight"
const m_FC_WEIGHT_BLACK = 210
const m_FC_WEIGHT_BOLD = 200
const m_FC_WEIGHT_BOOK = 75
const m_FC_WEIGHT_DEMIBOLD = 180
const m_FC_WEIGHT_DEMILIGHT = 55
const m_FC_WEIGHT_EXTRABLACK = 215
const m_FC_WEIGHT_EXTRABOLD = 205
const m_FC_WEIGHT_EXTRALIGHT = 40
const m_FC_WEIGHT_HEAVY = "FC_WEIGHT_BLACK"
const m_FC_WEIGHT_LIGHT = 50
const m_FC_WEIGHT_MEDIUM = 100
const m_FC_WEIGHT_NORMAL = "FC_WEIGHT_REGULAR"
const m_FC_WEIGHT_REGULAR = 80
const m_FC_WEIGHT_SEMIBOLD = "FC_WEIGHT_DEMIBOLD"
const m_FC_WEIGHT_SEMILIGHT = "FC_WEIGHT_DEMILIGHT"
const m_FC_WEIGHT_THIN = 0
const m_FC_WEIGHT_ULTRABLACK = "FC_WEIGHT_EXTRABLACK"
const m_FC_WEIGHT_ULTRABOLD = "FC_WEIGHT_EXTRABOLD"
const m_FC_WEIGHT_ULTRALIGHT = "FC_WEIGHT_EXTRALIGHT"
const m_FC_WIDTH = "width"
const m_FC_WIDTH_CONDENSED = 75
const m_FC_WIDTH_EXPANDED = 125
const m_FC_WIDTH_EXTRACONDENSED = 63
const m_FC_WIDTH_EXTRAEXPANDED = 150
const m_FC_WIDTH_NORMAL = 100
const m_FC_WIDTH_SEMICONDENSED = 87
const m_FC_WIDTH_SEMIEXPANDED = 113
const m_FC_WIDTH_ULTRACONDENSED = 50
const m_FC_WIDTH_ULTRAEXPANDED = 200
const m_FD_SETSIZE = "__DARWIN_FD_SETSIZE"
const m_FILENAME_MAX = 1024
const m_FLT16_DECIMAL_DIG = "__FLT16_DECIMAL_DIG__"
const m_FLT16_DIG = "__FLT16_DIG__"
const m_FLT16_EPSILON = "__FLT16_EPSILON__"
const m_FLT16_MANT_DIG = "__FLT16_MANT_DIG__"
const m_FLT16_MAX = "__FLT16_MAX__"
const m_FLT16_MAX_10_EXP = "__FLT16_MAX_10_EXP__"
const m_FLT16_MAX_EXP = "__FLT16_MAX_EXP__"
const m_FLT16_MIN = "__FLT16_MIN__"
const m_FLT16_MIN_10_EXP = "__FLT16_MIN_10_EXP__"
const m_FLT16_MIN_EXP = "__FLT16_MIN_EXP__"
const m_FLT16_TRUE_MIN = "__FLT16_TRUE_MIN__"
const m_FLT_DECIMAL_DIG = "__FLT_DECIMAL_DIG__"
const m_FLT_DIG = "__FLT_DIG__"
const m_FLT_EPSILON = "__FLT_EPSILON__"
const m_FLT_EVAL_METHOD = "__FLT_EVAL_METHOD__"
const m_FLT_HAS_SUBNORM = "__FLT_HAS_DENORM__"
const m_FLT_MANT_DIG = "__FLT_MANT_DIG__"
const m_FLT_MAX = "__FLT_MAX__"
const m_FLT_MAX_10_EXP = "__FLT_MAX_10_EXP__"
const m_FLT_MAX_EXP = "__FLT_MAX_EXP__"
const m_FLT_MIN = "__FLT_MIN__"
const m_FLT_MIN_10_EXP = "__FLT_MIN_10_EXP__"
const m_FLT_MIN_EXP = "__FLT_MIN_EXP__"
const m_FLT_NORM_MAX = "__FLT_NORM_MAX__"
const m_FLT_RADIX = "__FLT_RADIX__"
const m_FLT_TRUE_MIN = "__FLT_DENORM_MIN__"
const m_FONTCONFIG_PATH = "/etc/fonts"
const m_FOOTPRINT_INTERVAL_RESET = 0x1
const m_FOPEN_MAX = 20
const m_FPE_FLTDIV = 1
const m_FPE_FLTINV = 5
const m_FPE_FLTOVF = 2
const m_FPE_FLTRES = 4
const m_FPE_FLTSUB = 6
const m_FPE_FLTUND = 3
const m_FPE_INTDIV = 7
const m_FPE_INTOVF = 8
const m_FPE_NOOP = 0
const m_FP_CHOP = 3
const m_FP_INFINITE = 2
const m_FP_NAN = 1
const m_FP_NORMAL = 4
const m_FP_PREC_24B = 0
const m_FP_PREC_53B = 2
const m_FP_PREC_64B = 3
const m_FP_QNAN = "FP_NAN"
const m_FP_RND_DOWN = 1
const m_FP_RND_NEAR = 0
const m_FP_RND_UP = 2
const m_FP_SNAN = "FP_NAN"
const m_FP_STATE_BYTES = 512
const m_FP_SUBNORMAL = 5
const m_FP_SUPERNORMAL = 6
const m_FP_ZERO = 3
const m_F_LOCK = 1
const m_F_OK = 0
const m_F_TEST = 3
const m_F_TLOCK = 2
const m_F_ULOCK = 0
const m_FcDontCare = 2
const m_FcFalse = 0
const m_FcTrue = 1
const m_GETTEXT_PACKAGE = "fontconfig"
const m_GID_MAX = 2147483647
const m_HAVE_CFLOCALECOPYCURRENT = 1
const m_HAVE_CFPREFERENCESCOPYAPPVALUE = 1
const m_HAVE_CONFIG_H = 1
const m_HAVE_DIRENT_H = 1
const m_HAVE_DLFCN_H = 1
const m_HAVE_FCNTL_H = 1
const m_HAVE_FSTATFS = 1
const m_HAVE_FSTATVFS = 1
const m_HAVE_GETOPT = 1
const m_HAVE_GETOPT_LONG = 1
const m_HAVE_GETPAGESIZE = 1
const m_HAVE_GETPROGNAME = 1
const m_HAVE_ICONV = 1
const m_HAVE_INTEL_ATOMIC_PRIMITIVES = 1
const m_HAVE_INTTYPES_H = 1
const m_HAVE_LINK = 1
const m_HAVE_LRAND48 = 1
const m_HAVE_LSTAT = 1
const m_HAVE_MKDTEMP = 1
const m_HAVE_MKOSTEMP = 1
const m_HAVE_MKSTEMP = 1
const m_HAVE_MMAP = 1
const m_HAVE_POSIX_FADVISE = 0
const m_HAVE_PTHREAD = 1
const m_HAVE_PTHREAD_PRIO_INHERIT = 1
const m_HAVE_RAND = 1
const m_HAVE_RANDOM = 1
const m_HAVE_RAND_R = 1
const m_HAVE_READLINK = 1
const m_HAVE_STDATOMIC_PRIMITIVES = 1
const m_HAVE_STDINT_H = 1
const m_HAVE_STDIO_H = 1
const m_HAVE_STDLIB_H = 1
const m_HAVE_STRERROR = 1
const m_HAVE_STRERROR_R = 1
const m_HAVE_STRINGS_H = 1
const m_HAVE_STRING_H = 1
const m_HAVE_STRUCT_DIRENT_D_TYPE = 1
const m_HAVE_STRUCT_STATFS_F_FLAGS = 1
const m_HAVE_STRUCT_STATFS_F_FSTYPENAME = 1
const m_HAVE_SYS_MOUNT_H = 1
const m_HAVE_SYS_PARAM_H = 1
const m_HAVE_SYS_STATVFS_H = 1
const m_HAVE_SYS_STAT_H = 1
const m_HAVE_SYS_TYPES_H = 1
const m_HAVE_UNISTD_H = 1
const m_HAVE_VPRINTF = 1
const m_HAVE_WARNING_CPP_DIRECTIVE = 1
const m_HAVE_WCHAR_H = 1
const m_HAVE_XML_SETDOCTYPEDECLHANDLER = 1
const m_HUGE = "MAXFLOAT"
const m_ILL_BADSTK = 8
const m_ILL_COPROC = 7
const m_ILL_ILLADR = 5
const m_ILL_ILLOPC = 1
const m_ILL_ILLOPN = 4
const m_ILL_ILLTRP = 2
const m_ILL_NOOP = 0
const m_ILL_PRVOPC = 3
const m_ILL_PRVREG = 6
const m_INTMAX_MAX = "__INTMAX_MAX__"
const m_INTPTR_MAX = "__INTPTR_MAX__"
const m_INT_FAST16_MAX = "__INT_LEAST16_MAX"
const m_INT_FAST16_MIN = "__INT_LEAST16_MIN"
const m_INT_FAST32_MAX = "__INT_LEAST32_MAX"
const m_INT_FAST32_MIN = "__INT_LEAST32_MIN"
const m_INT_FAST64_MAX = "__INT_LEAST64_MAX"
const m_INT_FAST64_MIN = "__INT_LEAST64_MIN"
const m_INT_FAST8_MAX = "__INT_LEAST8_MAX"
const m_INT_FAST8_MIN = "__INT_LEAST8_MIN"
const m_INT_LEAST16_MAX = "__INT_LEAST16_MAX"
const m_INT_LEAST16_MIN = "__INT_LEAST16_MIN"
const m_INT_LEAST32_MAX = "__INT_LEAST32_MAX"
const m_INT_LEAST32_MIN = "__INT_LEAST32_MIN"
const m_INT_LEAST64_MAX = "__INT_LEAST64_MAX"
const m_INT_LEAST64_MIN = "__INT_LEAST64_MIN"
const m_INT_LEAST8_MAX = "__INT_LEAST8_MAX"
const m_INT_LEAST8_MIN = "__INT_LEAST8_MIN"
const m_IOPOL_APPLICATION = "IOPOL_STANDARD"
const m_IOPOL_ATIME_UPDATES_DEFAULT = 0
const m_IOPOL_ATIME_UPDATES_OFF = 1
const m_IOPOL_DEFAULT = 0
const m_IOPOL_IMPORTANT = 1
const m_IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = 0
const m_IOPOL_MATERIALIZE_DATALESS_FILES_OFF = 1
const m_IOPOL_MATERIALIZE_DATALESS_FILES_ON = 2
const m_IOPOL_NORMAL = "IOPOL_IMPORTANT"
const m_IOPOL_PASSIVE = 2
const m_IOPOL_SCOPE_DARWIN_BG = 2
const m_IOPOL_SCOPE_PROCESS = 0
const m_IOPOL_SCOPE_THREAD = 1
const m_IOPOL_STANDARD = 5
const m_IOPOL_THROTTLE = 3
const m_IOPOL_TYPE_DISK = 0
const m_IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = 9
const m_IOPOL_TYPE_VFS_ATIME_UPDATES = 2
const m_IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = 10
const m_IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = 6
const m_IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = 7
const m_IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3
const m_IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = 8
const m_IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = 4
const m_IOPOL_TYPE_VFS_TRIGGER_RESOLVE = 5
const m_IOPOL_UTILITY = 4
const m_IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = 0
const m_IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = 1
const m_IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = 0
const m_IOPOL_VFS_CONTENT_PROTECTION_IGNORE = 1
const m_IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = 0
const m_IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = 1
const m_IOPOL_VFS_IGNORE_PERMISSIONS_OFF = 0
const m_IOPOL_VFS_IGNORE_PERMISSIONS_ON = 1
const m_IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = 0
const m_IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = 1
const m_IOPOL_VFS_SKIP_MTIME_UPDATE_IGNORE = 2
const m_IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = 0
const m_IOPOL_VFS_SKIP_MTIME_UPDATE_ON = 1
const m_IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = 1
const m_IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = 0
const m_IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = 0
const m_IOPOL_VFS_TRIGGER_RESOLVE_OFF = 1
const m_LCK_NAME = ".LCK"
const m_LDBL_DECIMAL_DIG = "__LDBL_DECIMAL_DIG__"
const m_LDBL_DIG = "__LDBL_DIG__"
const m_LDBL_EPSILON = "__LDBL_EPSILON__"
const m_LDBL_HAS_SUBNORM = "__LDBL_HAS_DENORM__"
const m_LDBL_MANT_DIG = "__LDBL_MANT_DIG__"
const m_LDBL_MAX = "__LDBL_MAX__"
const m_LDBL_MAX_10_EXP = "__LDBL_MAX_10_EXP__"
const m_LDBL_MAX_EXP = "__LDBL_MAX_EXP__"
const m_LDBL_MIN = "__LDBL_MIN__"
const m_LDBL_MIN_10_EXP = "__LDBL_MIN_10_EXP__"
const m_LDBL_MIN_EXP = "__LDBL_MIN_EXP__"
const m_LDBL_NORM_MAX = "__LDBL_NORM_MAX__"
const m_LDBL_TRUE_MIN = "__LDBL_DENORM_MIN__"
const m_LINE_MAX = 2048
const m_LINK_MAX = 32767
const m_LITTLE_ENDIAN = "__DARWIN_LITTLE_ENDIAN"
const m_LT_OBJDIR = ".libs/"
const m_L_INCR = "SEEK_CUR"
const m_L_SET = "SEEK_SET"
const m_L_XTND = "SEEK_END"
const m_L_ctermid = 1024
const m_L_tmpnam = 1024
const m_MAC_OS_VERSION_11_0 = "__MAC_11_0"
const m_MAC_OS_VERSION_11_1 = "__MAC_11_1"
const m_MAC_OS_VERSION_11_3 = "__MAC_11_3"
const m_MAC_OS_VERSION_11_4 = "__MAC_11_4"
const m_MAC_OS_VERSION_11_5 = "__MAC_11_5"
const m_MAC_OS_VERSION_11_6 = "__MAC_11_6"
const m_MAC_OS_VERSION_12_0 = "__MAC_12_0"
const m_MAC_OS_VERSION_12_1 = "__MAC_12_1"
const m_MAC_OS_VERSION_12_2 = "__MAC_12_2"
const m_MAC_OS_VERSION_12_3 = "__MAC_12_3"
const m_MAC_OS_VERSION_12_4 = "__MAC_12_4"
const m_MAC_OS_VERSION_12_5 = "__MAC_12_5"
const m_MAC_OS_VERSION_12_6 = "__MAC_12_6"
const m_MAC_OS_VERSION_12_7 = "__MAC_12_7"
const m_MAC_OS_VERSION_13_0 = "__MAC_13_0"
const m_MAC_OS_VERSION_13_1 = "__MAC_13_1"
const m_MAC_OS_VERSION_13_2 = "__MAC_13_2"
const m_MAC_OS_VERSION_13_3 = "__MAC_13_3"
const m_MAC_OS_VERSION_13_4 = "__MAC_13_4"
const m_MAC_OS_VERSION_13_5 = "__MAC_13_5"
const m_MAC_OS_VERSION_13_6 = "__MAC_13_6"
const m_MAC_OS_VERSION_13_7 = "__MAC_13_7"
const m_MAC_OS_VERSION_14_0 = "__MAC_14_0"
const m_MAC_OS_VERSION_14_1 = "__MAC_14_1"
const m_MAC_OS_VERSION_14_2 = "__MAC_14_2"
const m_MAC_OS_VERSION_14_3 = "__MAC_14_3"
const m_MAC_OS_VERSION_14_4 = "__MAC_14_4"
const m_MAC_OS_VERSION_14_5 = "__MAC_14_5"
const m_MAC_OS_VERSION_14_6 = "__MAC_14_6"
const m_MAC_OS_VERSION_14_7 = "__MAC_14_7"
const m_MAC_OS_VERSION_15_0 = "__MAC_15_0"
const m_MAC_OS_VERSION_15_1 = "__MAC_15_1"
const m_MAC_OS_VERSION_15_2 = "__MAC_15_2"
const m_MAC_OS_VERSION_15_3 = "__MAC_15_3"
const m_MAC_OS_VERSION_15_4 = "__MAC_15_4"
const m_MAC_OS_VERSION_15_5 = "__MAC_15_5"
const m_MAC_OS_X_VERSION_10_0 = "__MAC_10_0"
const m_MAC_OS_X_VERSION_10_1 = "__MAC_10_1"
const m_MAC_OS_X_VERSION_10_10 = "__MAC_10_10"
const m_MAC_OS_X_VERSION_10_10_2 = "__MAC_10_10_2"
const m_MAC_OS_X_VERSION_10_10_3 = "__MAC_10_10_3"
const m_MAC_OS_X_VERSION_10_11 = "__MAC_10_11"
const m_MAC_OS_X_VERSION_10_11_2 = "__MAC_10_11_2"
const m_MAC_OS_X_VERSION_10_11_3 = "__MAC_10_11_3"
const m_MAC_OS_X_VERSION_10_11_4 = "__MAC_10_11_4"
const m_MAC_OS_X_VERSION_10_12 = "__MAC_10_12"
const m_MAC_OS_X_VERSION_10_12_1 = "__MAC_10_12_1"
const m_MAC_OS_X_VERSION_10_12_2 = "__MAC_10_12_2"
const m_MAC_OS_X_VERSION_10_12_4 = "__MAC_10_12_4"
const m_MAC_OS_X_VERSION_10_13 = "__MAC_10_13"
const m_MAC_OS_X_VERSION_10_13_1 = "__MAC_10_13_1"
const m_MAC_OS_X_VERSION_10_13_2 = "__MAC_10_13_2"
const m_MAC_OS_X_VERSION_10_13_4 = "__MAC_10_13_4"
const m_MAC_OS_X_VERSION_10_14 = "__MAC_10_14"
const m_MAC_OS_X_VERSION_10_14_1 = "__MAC_10_14_1"
const m_MAC_OS_X_VERSION_10_14_4 = "__MAC_10_14_4"
const m_MAC_OS_X_VERSION_10_14_5 = "__MAC_10_14_5"
const m_MAC_OS_X_VERSION_10_14_6 = "__MAC_10_14_6"
const m_MAC_OS_X_VERSION_10_15 = "__MAC_10_15"
const m_MAC_OS_X_VERSION_10_15_1 = "__MAC_10_15_1"
const m_MAC_OS_X_VERSION_10_15_4 = "__MAC_10_15_4"
const m_MAC_OS_X_VERSION_10_16 = "__MAC_10_16"
const m_MAC_OS_X_VERSION_10_2 = "__MAC_10_2"
const m_MAC_OS_X_VERSION_10_3 = "__MAC_10_3"
const m_MAC_OS_X_VERSION_10_4 = "__MAC_10_4"
const m_MAC_OS_X_VERSION_10_5 = "__MAC_10_5"
const m_MAC_OS_X_VERSION_10_6 = "__MAC_10_6"
const m_MAC_OS_X_VERSION_10_7 = "__MAC_10_7"
const m_MAC_OS_X_VERSION_10_8 = "__MAC_10_8"
const m_MAC_OS_X_VERSION_10_9 = "__MAC_10_9"
const m_MATH_ERREXCEPT = 2
const m_MATH_ERRNO = 1
const m_MAXFLOAT = "0x1.fffffep+127f"
const m_MAX_CANON = 1024
const m_MAX_INPUT = 1024
const m_MB_CUR_MAX = "__mb_cur_max"
const m_MB_LEN_MAX = 1
const m_MINSIGSTKSZ = 32768
const m_M_1_PI = 0.318309886183790671537767526745028724
const m_M_2_PI = 0.636619772367581343075535053490057448
const m_M_2_SQRTPI = 1.12837916709551257389615890312154517
const m_M_E = 2.71828182845904523536028747135266250
const m_M_LN10 = 2.30258509299404568401799145468436421
const m_M_LN2 = 0.693147180559945309417232121458176568
const m_M_LOG10E = 0.434294481903251827651128918916605082
const m_M_LOG2E = 1.44269504088896340735992468100189214
const m_M_PI = 3.14159265358979323846264338327950288
const m_M_PI_2 = 1.57079632679489661923132169163975144
const m_M_PI_4 = 0.785398163397448309615660845819875721
const m_M_SQRT1_2 = 0.707106781186547524400844362104849039
const m_M_SQRT2 = 1.41421356237309504880168872420969808
const m_NAME_MAX = 255
const m_NBBY = "__DARWIN_NBBY"
const m_NDEBUG = 1
const m_NEW_NAME = ".NEW"
const m_NFDBITS = "__DARWIN_NFDBITS"
const m_NGROUPS_MAX = 16
const m_NSIG = "__DARWIN_NSIG"
const m_NZERO = 20
const m_OPEN_MAX = 10240
const m_OVERFLOW = 3
const m_PACKAGE = "fontconfig"
const m_PACKAGE_BUGREPORT = "https://gitlab.freedesktop.org/fontconfig/fontconfig/issues/new"
const m_PACKAGE_NAME = "fontconfig"
const m_PACKAGE_STRING = "fontconfig 2.14.1"
const m_PACKAGE_TARNAME = "fontconfig"
const m_PACKAGE_URL = ""
const m_PACKAGE_VERSION = "2.14.1"
const m_PATH_MAX = 1024
const m_PDP_ENDIAN = "__DARWIN_PDP_ENDIAN"
const m_PIPE_BUF = 512
const m_PLOSS = 6
const m_POLL_ERR = 4
const m_POLL_HUP = 6
const m_POLL_IN = 1
const m_POLL_MSG = 3
const m_POLL_OUT = 2
const m_POLL_PRI = 5
const m_PRIO_DARWIN_BG = 0x1000
const m_PRIO_DARWIN_NONUI = 0x1001
const m_PRIO_DARWIN_PROCESS = 4
const m_PRIO_DARWIN_THREAD = 3
const m_PRIO_MAX = 20
const m_PRIO_PGRP = 1
const m_PRIO_PROCESS = 0
const m_PRIO_USER = 2
const m_PTRDIFF_MAX = "__PTRDIFF_MAX__"
const m_P_tmpdir = "/var/tmp/"
const m_RAND_MAX = 0x7fffffff
const m_RENAME_EXCL = 0x00000004
const m_RENAME_NOFOLLOW_ANY = 0x00000010
const m_RENAME_RESERVED1 = 0x00000008
const m_RENAME_SECLUDE = 0x00000001
const m_RENAME_SWAP = 0x00000002
const m_RE_DUP_MAX = 255
const m_RLIMIT_AS = 5
const m_RLIMIT_CORE = 4
const m_RLIMIT_CPU = 0
const m_RLIMIT_CPU_USAGE_MONITOR = 0x2
const m_RLIMIT_DATA = 2
const m_RLIMIT_FOOTPRINT_INTERVAL = 0x4
const m_RLIMIT_FSIZE = 1
const m_RLIMIT_MEMLOCK = 6
const m_RLIMIT_NOFILE = 8
const m_RLIMIT_NPROC = 7
const m_RLIMIT_RSS = "RLIMIT_AS"
const m_RLIMIT_STACK = 3
const m_RLIMIT_THREAD_CPULIMITS = 0x3
const m_RLIMIT_WAKEUPS_MONITOR = 0x1
const m_RLIM_NLIMITS = 9
const m_RLIM_SAVED_CUR = "RLIM_INFINITY"
const m_RLIM_SAVED_MAX = "RLIM_INFINITY"
const m_RUSAGE_INFO_CURRENT = "RUSAGE_INFO_V6"
const m_RUSAGE_INFO_V0 = 0
const m_RUSAGE_INFO_V1 = 1
const m_RUSAGE_INFO_V2 = 2
const m_RUSAGE_INFO_V3 = 3
const m_RUSAGE_INFO_V4 = 4
const m_RUSAGE_INFO_V5 = 5
const m_RUSAGE_INFO_V6 = 6
const m_RUSAGE_SELF = 0
const m_RU_PROC_RUNS_RESLIDE = 0x00000001
const m_SA_64REGSET = 0x0200
const m_SA_NOCLDSTOP = 0x0008
const m_SA_NOCLDWAIT = 0x0020
const m_SA_NODEFER = 0x0010
const m_SA_ONSTACK = 0x0001
const m_SA_RESETHAND = 0x0004
const m_SA_RESTART = 0x0002
const m_SA_SIGINFO = 0x0040
const m_SA_USERTRAMP = 0x0100
const m_SEEK_CUR = 1
const m_SEEK_DATA = 4
const m_SEEK_END = 2
const m_SEEK_HOLE = 3
const m_SEEK_SET = 0
const m_SEGV_ACCERR = 2
const m_SEGV_MAPERR = 1
const m_SEGV_NOOP = 0
const m_SF_APPEND = 0x00040000
const m_SF_ARCHIVED = 0x00010000
const m_SF_DATALESS = 0x40000000
const m_SF_FIRMLINK = 0x00800000
const m_SF_IMMUTABLE = 0x00020000
const m_SF_NOUNLINK = 0x00100000
const m_SF_RESTRICTED = 0x00080000
const m_SF_SETTABLE = 0x3fff0000
const m_SF_SUPPORTED = 0x009f0000
const m_SF_SYNTHETIC = 0xc0000000
const m_SIGABRT = 6
const m_SIGALRM = 14
const m_SIGBUS = 10
const m_SIGCHLD = 20
const m_SIGCONT = 19
const m_SIGEMT = 7
const m_SIGEV_NONE = 0
const m_SIGEV_SIGNAL = 1
const m_SIGEV_THREAD = 3
const m_SIGFPE = 8
const m_SIGHUP = 1
const m_SIGILL = 4
const m_SIGINFO = 29
const m_SIGINT = 2
const m_SIGIO = 23
const m_SIGIOT = "SIGABRT"
const m_SIGKILL = 9
const m_SIGPIPE = 13
const m_SIGPROF = 27
const m_SIGQUIT = 3
const m_SIGSEGV = 11
const m_SIGSTKSZ = 131072
const m_SIGSTOP = 17
const m_SIGSYS = 12
const m_SIGTERM = 15
const m_SIGTRAP = 5
const m_SIGTSTP = 18
const m_SIGTTIN = 21
const m_SIGTTOU = 22
const m_SIGURG = 16
const m_SIGUSR1 = 30
const m_SIGUSR2 = 31
const m_SIGVTALRM = 26
const m_SIGWINCH = 28
const m_SIGXCPU = 24
const m_SIGXFSZ = 25
const m_SIG_BLOCK = 1
const m_SIG_SETMASK = 3
const m_SIG_UNBLOCK = 2
const m_SING = 2
const m_SIZE_MAX = "__SIZE_MAX__"
const m_SI_ASYNCIO = 0x10004
const m_SI_MESGQ = 0x10005
const m_SI_QUEUE = 0x10002
const m_SI_TIMER = 0x10003
const m_SI_USER = 0x10001
const m_SS_DISABLE = 0x0004
const m_SS_ONSTACK = 0x0001
const m_STDC_HEADERS = 1
const m_STDERR_FILENO = 2
const m_STDIN_FILENO = 0
const m_STDOUT_FILENO = 1
const m_SV_INTERRUPT = "SA_RESTART"
const m_SV_NOCLDSTOP = "SA_NOCLDSTOP"
const m_SV_NODEFER = "SA_NODEFER"
const m_SV_ONSTACK = "SA_ONSTACK"
const m_SV_RESETHAND = "SA_RESETHAND"
const m_SV_SIGINFO = "SA_SIGINFO"
const m_SYNC_VOLUME_FULLSYNC = 0x01
const m_SYNC_VOLUME_WAIT = 0x02
const m_S_BLKSIZE = 512
const m_S_IEXEC = "S_IXUSR"
const m_S_IFBLK = 0060000
const m_S_IFCHR = 0020000
const m_S_IFDIR = 0040000
const m_S_IFIFO = 0010000
const m_S_IFLNK = 0120000
const m_S_IFMT = 0170000
const m_S_IFREG = 0100000
const m_S_IFSOCK = 0140000
const m_S_IFWHT = 0160000
const m_S_IREAD = "S_IRUSR"
const m_S_IRGRP = 0000040
const m_S_IROTH = 0000004
const m_S_IRUSR = 0000400
const m_S_IRWXG = 0000070
const m_S_IRWXO = 0000007
const m_S_IRWXU = 0000700
const m_S_ISGID = 0002000
const m_S_ISTXT = "S_ISVTX"
const m_S_ISUID = 0004000
const m_S_ISVTX = 0001000
const m_S_IWGRP = 0000020
const m_S_IWOTH = 0000002
const m_S_IWRITE = "S_IWUSR"
const m_S_IWUSR = 0000200
const m_S_IXGRP = 0000010
const m_S_IXOTH = 0000001
const m_S_IXUSR = 0000100
const m_TARGET_IPHONE_SIMULATOR = 0
const m_TARGET_OS_ARROW = 0
const m_TARGET_OS_BRIDGE = 0
const m_TARGET_OS_DRIVERKIT = 0
const m_TARGET_OS_EMBEDDED = 0
const m_TARGET_OS_IOS = 0
const m_TARGET_OS_IOSMAC = 0
const m_TARGET_OS_IPHONE = 0
const m_TARGET_OS_LINUX = 0
const m_TARGET_OS_MAC = 1
const m_TARGET_OS_MACCATALYST = 0
const m_TARGET_OS_NANO = 0
const m_TARGET_OS_OSX = 1
const m_TARGET_OS_SIMULATOR = 0
const m_TARGET_OS_TV = 0
const m_TARGET_OS_UIKITFORMAC = 0
const m_TARGET_OS_UNIX = 0
const m_TARGET_OS_VISION = 0
const m_TARGET_OS_WATCH = 0
const m_TARGET_OS_WIN32 = 0
const m_TARGET_OS_WINDOWS = 0
const m_TARGET_OS_XR = 0
const m_TIME_UTC = 1
const m_TLOSS = 5
const m_TMP_MAX = 308915776
const m_TMP_NAME = ".TMP-XXXXXX"
const m_TRAP_BRKPT = 1
const m_TRAP_TRACE = 2
const m_UF_APPEND = 0x00000004
const m_UF_COMPRESSED = 0x00000020
const m_UF_DATAVAULT = 0x00000080
const m_UF_HIDDEN = 0x00008000
const m_UF_IMMUTABLE = 0x00000002
const m_UF_NODUMP = 0x00000001
const m_UF_OPAQUE = 0x00000008
const m_UF_SETTABLE = 0x0000ffff
const m_UF_TRACKED = 0x00000040
const m_UID_MAX = 2147483647
const m_UINTMAX_MAX = "__UINTMAX_MAX__"
const m_UINTPTR_MAX = "__UINTPTR_MAX__"
const m_UINT_FAST16_MAX = "__UINT_LEAST16_MAX"
const m_UINT_FAST32_MAX = "__UINT_LEAST32_MAX"
const m_UINT_FAST64_MAX = "__UINT_LEAST64_MAX"
const m_UINT_FAST8_MAX = "__UINT_LEAST8_MAX"
const m_UINT_LEAST16_MAX = "__UINT_LEAST16_MAX"
const m_UINT_LEAST32_MAX = "__UINT_LEAST32_MAX"
const m_UINT_LEAST64_MAX = "__UINT_LEAST64_MAX"
const m_UINT_LEAST8_MAX = "__UINT_LEAST8_MAX"
const m_UNDERFLOW = 4
const m_USE_ICONV = 0
const m_VERSION = "2.14.1"
const m_WAIT_MYPGRP = 0
const m_WAKEMON_DISABLE = 0x02
const m_WAKEMON_ENABLE = 0x01
const m_WAKEMON_GET_PARAMS = 0x04
const m_WAKEMON_MAKE_FATAL = 0x10
const m_WAKEMON_SET_DEFAULTS = 0x08
const m_WCHAR_MAX = "__WCHAR_MAX__"
const m_WCONTINUED = 0x00000010
const m_WCOREFLAG = 0200
const m_WEXITED = 0x00000004
const m_WNOHANG = 0x00000001
const m_WNOWAIT = 0x00000020
const m_WSTOPPED = 0x00000008
const m_WUNTRACED = 0x00000002
const m_X_TLOSS = 1.41484755040568800000e+16
const m__ALL_SOURCE = 1
const m__CS_DARWIN_USER_CACHE_DIR = 65538
const m__CS_DARWIN_USER_DIR = 65536
const m__CS_DARWIN_USER_TEMP_DIR = 65537
const m__CS_PATH = 1
const m__CS_POSIX_V6_ILP32_OFF32_CFLAGS = 2
const m__CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 3
const m__CS_POSIX_V6_ILP32_OFF32_LIBS = 4
const m__CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 5
const m__CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 6
const m__CS_POSIX_V6_ILP32_OFFBIG_LIBS = 7
const m__CS_POSIX_V6_LP64_OFF64_CFLAGS = 8
const m__CS_POSIX_V6_LP64_OFF64_LDFLAGS = 9
const m__CS_POSIX_V6_LP64_OFF64_LIBS = 10
const m__CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 11
const m__CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 12
const m__CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 13
const m__CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = 14
const m__CS_XBS5_ILP32_OFF32_CFLAGS = 20
const m__CS_XBS5_ILP32_OFF32_LDFLAGS = 21
const m__CS_XBS5_ILP32_OFF32_LIBS = 22
const m__CS_XBS5_ILP32_OFF32_LINTFLAGS = 23
const m__CS_XBS5_ILP32_OFFBIG_CFLAGS = 24
const m__CS_XBS5_ILP32_OFFBIG_LDFLAGS = 25
const m__CS_XBS5_ILP32_OFFBIG_LIBS = 26
const m__CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 27
const m__CS_XBS5_LP64_OFF64_CFLAGS = 28
const m__CS_XBS5_LP64_OFF64_LDFLAGS = 29
const m__CS_XBS5_LP64_OFF64_LIBS = 30
const m__CS_XBS5_LP64_OFF64_LINTFLAGS = 31
const m__CS_XBS5_LPBIG_OFFBIG_CFLAGS = 32
const m__CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 33
const m__CS_XBS5_LPBIG_OFFBIG_LIBS = 34
const m__CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 35
const m__CTYPE_A = 256
const m__CTYPE_B = 131072
const m__CTYPE_C = 512
const m__CTYPE_D = 1024
const m__CTYPE_G = 2048
const m__CTYPE_I = 524288
const m__CTYPE_L = 4096
const m__CTYPE_P = 8192
const m__CTYPE_Q = 2097152
const m__CTYPE_R = 262144
const m__CTYPE_S = 16384
const m__CTYPE_SW0 = 0x20000000
const m__CTYPE_SW1 = 0x40000000
const m__CTYPE_SW2 = 0x80000000
const m__CTYPE_SW3 = 0xc0000000
const m__CTYPE_SWM = 3758096384
const m__CTYPE_SWS = 30
const m__CTYPE_T = 1048576
const m__CTYPE_U = 32768
const m__CTYPE_X = 65536
const m__DARWIN_C_SOURCE = 1
const m__DARWIN_FEATURE_64_BIT_INODE = 1
const m__DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1
const m__DARWIN_FEATURE_UNIX_CONFORMANCE = 3
const m__FONTCONFIG_SRC_FCSTDINT_H = 1
const m__FORTIFY_SOURCE = 2
const m__GENERATED_STDINT_H = "fontconfig 2.14.1"
const m__GNU_SOURCE = 1
const m__HPUX_ALT_XOPEN_SOCKET_API = 1
const m__I386_SIGNAL_H_ = 1
const m__IOFBF = 0
const m__IOLBF = 1
const m__IONBF = 2
const m__LIBC_COUNT__MB_LEN_MAX = "_LIBC_UNSAFE_INDEXABLE"
const m__LIBC_COUNT__PATH_MAX = "_LIBC_UNSAFE_INDEXABLE"
const m__LP64 = 1
const m__NETBSD_SOURCE = 1
const m__OPENBSD_SOURCE = 1
const m__PC_2_SYMLINKS = 15
const m__PC_ALLOC_SIZE_MIN = 16
const m__PC_ASYNC_IO = 17
const m__PC_AUTH_OPAQUE_NP = 14
const m__PC_CASE_PRESERVING = 12
const m__PC_CASE_SENSITIVE = 11
const m__PC_CHOWN_RESTRICTED = 7
const m__PC_EXTENDED_SECURITY_NP = 13
const m__PC_FILESIZEBITS = 18
const m__PC_LINK_MAX = 1
const m__PC_MAX_CANON = 2
const m__PC_MAX_INPUT = 3
const m__PC_MIN_HOLE_SIZE = 27
const m__PC_NAME_CHARS_MAX = 10
const m__PC_NAME_MAX = 4
const m__PC_NO_TRUNC = 8
const m__PC_PATH_MAX = 5
const m__PC_PIPE_BUF = 6
const m__PC_PRIO_IO = 19
const m__PC_REC_INCR_XFER_SIZE = 20
const m__PC_REC_MAX_XFER_SIZE = 21
const m__PC_REC_MIN_XFER_SIZE = 22
const m__PC_REC_XFER_ALIGN = 23
const m__PC_SYMLINK_MAX = 24
const m__PC_SYNC_IO = 25
const m__PC_VDISABLE = 9
const m__PC_XATTR_SIZE_BITS = 26
const m__POSIX2_CHAR_TERM = 200112
const m__POSIX2_C_BIND = 200112
const m__POSIX2_C_DEV = 200112
const m__POSIX2_FORT_RUN = 200112
const m__POSIX2_LOCALEDEF = 200112
const m__POSIX2_SW_DEV = 200112
const m__POSIX2_UPE = 200112
const m__POSIX2_VERSION = 200112
const m__POSIX_CHOWN_RESTRICTED = 200112
const m__POSIX_FSYNC = 200112
const m__POSIX_IPV6 = 200112
const m__POSIX_JOB_CONTROL = 200112
const m__POSIX_MAPPED_FILES = 200112
const m__POSIX_MEMORY_PROTECTION = 200112
const m__POSIX_NO_TRUNC = 200112
const m__POSIX_PTHREAD_SEMANTICS = 1
const m__POSIX_READER_WRITER_LOCKS = 200112
const m__POSIX_REGEXP = 200112
const m__POSIX_SAVED_IDS = 200112
const m__POSIX_SHELL = 200112
const m__POSIX_SPAWN = 200112
const m__POSIX_THREADS = 200112
const m__POSIX_THREAD_ATTR_STACKADDR = 200112
const m__POSIX_THREAD_ATTR_STACKSIZE = 200112
const m__POSIX_THREAD_KEYS_MAX = 128
const m__POSIX_THREAD_PROCESS_SHARED = 200112
const m__POSIX_THREAD_SAFE_FUNCTIONS = 200112
const m__POSIX_V6_ILP32_OFF32 = "__ILP32_OFF32"
const m__POSIX_V6_ILP32_OFFBIG = "__ILP32_OFFBIG"
const m__POSIX_V6_LP64_OFF64 = "__LP64_OFF64"
const m__POSIX_V6_LPBIG_OFFBIG = "__LPBIG_OFFBIG"
const m__POSIX_V7_ILP32_OFF32 = "__ILP32_OFF32"
const m__POSIX_V7_ILP32_OFFBIG = "__ILP32_OFFBIG"
const m__POSIX_V7_LP64_OFF64 = "__LP64_OFF64"
const m__POSIX_V7_LPBIG_OFFBIG = "__LPBIG_OFFBIG"
const m__POSIX_VERSION = 200112
const m__QUAD_HIGHWORD = 1
const m__QUAD_LOWWORD = 0
const m__REENTRANT = 1
const m__RLIMIT_POSIX_FLAG = 0x1000
const m__RUNE_MAGIC_A = "RuneMagA"
const m__SC_2_CHAR_TERM = 20
const m__SC_2_C_BIND = 18
const m__SC_2_C_DEV = 19
const m__SC_2_FORT_DEV = 21
const m__SC_2_FORT_RUN = 22
const m__SC_2_LOCALEDEF = 23
const m__SC_2_PBS = 59
const m__SC_2_PBS_ACCOUNTING = 60
const m__SC_2_PBS_CHECKPOINT = 61
const m__SC_2_PBS_LOCATE = 62
const m__SC_2_PBS_MESSAGE = 63
const m__SC_2_PBS_TRACK = 64
const m__SC_2_SW_DEV = 24
const m__SC_2_UPE = 25
const m__SC_2_VERSION = 17
const m__SC_ADVISORY_INFO = 65
const m__SC_AIO_LISTIO_MAX = 42
const m__SC_AIO_MAX = 43
const m__SC_AIO_PRIO_DELTA_MAX = 44
const m__SC_ARG_MAX = 1
const m__SC_ASYNCHRONOUS_IO = 28
const m__SC_ATEXIT_MAX = 107
const m__SC_BARRIERS = 66
const m__SC_BC_BASE_MAX = 9
const m__SC_BC_DIM_MAX = 10
const m__SC_BC_SCALE_MAX = 11
const m__SC_BC_STRING_MAX = 12
const m__SC_CHILD_MAX = 2
const m__SC_CLK_TCK = 3
const m__SC_CLOCK_SELECTION = 67
const m__SC_COLL_WEIGHTS_MAX = 13
const m__SC_CPUTIME = 68
const m__SC_DELAYTIMER_MAX = 45
const m__SC_EXPR_NEST_MAX = 14
const m__SC_FILE_LOCKING = 69
const m__SC_FSYNC = 38
const m__SC_GETGR_R_SIZE_MAX = 70
const m__SC_GETPW_R_SIZE_MAX = 71
const m__SC_HOST_NAME_MAX = 72
const m__SC_IOV_MAX = 56
const m__SC_IPV6 = 118
const m__SC_JOB_CONTROL = 6
const m__SC_LINE_MAX = 15
const m__SC_LOGIN_NAME_MAX = 73
const m__SC_MAPPED_FILES = 47
const m__SC_MEMLOCK = 30
const m__SC_MEMLOCK_RANGE = 31
const m__SC_MEMORY_PROTECTION = 32
const m__SC_MESSAGE_PASSING = 33
const m__SC_MONOTONIC_CLOCK = 74
const m__SC_MQ_OPEN_MAX = 46
const m__SC_MQ_PRIO_MAX = 75
const m__SC_NGROUPS_MAX = 4
const m__SC_NPROCESSORS_CONF = 57
const m__SC_NPROCESSORS_ONLN = 58
const m__SC_OPEN_MAX = 5
const m__SC_PAGESIZE = 29
const m__SC_PAGE_SIZE = "_SC_PAGESIZE"
const m__SC_PASS_MAX = 131
const m__SC_PHYS_PAGES = 200
const m__SC_PRIORITIZED_IO = 34
const m__SC_PRIORITY_SCHEDULING = 35
const m__SC_RAW_SOCKETS = 119
const m__SC_READER_WRITER_LOCKS = 76
const m__SC_REALTIME_SIGNALS = 36
const m__SC_REGEXP = 77
const m__SC_RE_DUP_MAX = 16
const m__SC_RTSIG_MAX = 48
const m__SC_SAVED_IDS = 7
const m__SC_SEMAPHORES = 37
const m__SC_SEM_NSEMS_MAX = 49
const m__SC_SEM_VALUE_MAX = 50
const m__SC_SHARED_MEMORY_OBJECTS = 39
const m__SC_SHELL = 78
const m__SC_SIGQUEUE_MAX = 51
const m__SC_SPAWN = 79
const m__SC_SPIN_LOCKS = 80
const m__SC_SPORADIC_SERVER = 81
const m__SC_SS_REPL_MAX = 126
const m__SC_STREAM_MAX = 26
const m__SC_SYMLOOP_MAX = 120
const m__SC_SYNCHRONIZED_IO = 40
const m__SC_THREADS = 96
const m__SC_THREAD_ATTR_STACKADDR = 82
const m__SC_THREAD_ATTR_STACKSIZE = 83
const m__SC_THREAD_CPUTIME = 84
const m__SC_THREAD_DESTRUCTOR_ITERATIONS = 85
const m__SC_THREAD_KEYS_MAX = 86
const m__SC_THREAD_PRIORITY_SCHEDULING = 89
const m__SC_THREAD_PRIO_INHERIT = 87
const m__SC_THREAD_PRIO_PROTECT = 88
const m__SC_THREAD_PROCESS_SHARED = 90
const m__SC_THREAD_SAFE_FUNCTIONS = 91
const m__SC_THREAD_SPORADIC_SERVER = 92
const m__SC_THREAD_STACK_MIN = 93
const m__SC_THREAD_THREADS_MAX = 94
const m__SC_TIMEOUTS = 95
const m__SC_TIMERS = 41
const m__SC_TIMER_MAX = 52
const m__SC_TRACE = 97
const m__SC_TRACE_EVENT_FILTER = 98
const m__SC_TRACE_EVENT_NAME_MAX = 127
const m__SC_TRACE_INHERIT = 99
const m__SC_TRACE_LOG = 100
const m__SC_TRACE_NAME_MAX = 128
const m__SC_TRACE_SYS_MAX = 129
const m__SC_TRACE_USER_EVENT_MAX = 130
const m__SC_TTY_NAME_MAX = 101
const m__SC_TYPED_MEMORY_OBJECTS = 102
const m__SC_TZNAME_MAX = 27
const m__SC_V6_ILP32_OFF32 = 103
const m__SC_V6_ILP32_OFFBIG = 104
const m__SC_V6_LP64_OFF64 = 105
const m__SC_V6_LPBIG_OFFBIG = 106
const m__SC_VERSION = 8
const m__SC_XBS5_ILP32_OFF32 = 122
const m__SC_XBS5_ILP32_OFFBIG = 123
const m__SC_XBS5_LP64_OFF64 = 124
const m__SC_XBS5_LPBIG_OFFBIG = 125
const m__SC_XOPEN_CRYPT = 108
const m__SC_XOPEN_ENH_I18N = 109
const m__SC_XOPEN_LEGACY = 110
const m__SC_XOPEN_REALTIME = 111
const m__SC_XOPEN_REALTIME_THREADS = 112
const m__SC_XOPEN_SHM = 113
const m__SC_XOPEN_STREAMS = 114
const m__SC_XOPEN_UNIX = 115
const m__SC_XOPEN_VERSION = 116
const m__SC_XOPEN_XCU_VERSION = 121
const m__STDINT_HAVE_STDINT_H = 1
const m__STRUCT_MCONTEXT = "_STRUCT_MCONTEXT64"
const m__TANDEM_SOURCE = 1
const m__THREAD_SAFE = 1
const m__V6_ILP32_OFF32 = "__ILP32_OFF32"
const m__V6_ILP32_OFFBIG = "__ILP32_OFFBIG"
const m__V6_LP64_OFF64 = "__LP64_OFF64"
const m__V6_LPBIG_OFFBIG = "__LPBIG_OFFBIG"
const m__WSTOPPED = 0177
const m__X86_INSTRUCTION_STATE_CACHELINE_SIZE = 64
const m__XBS5_ILP32_OFF32 = "__ILP32_OFF32"
const m__XBS5_ILP32_OFFBIG = "__ILP32_OFFBIG"
const m__XBS5_LP64_OFF64 = "__LP64_OFF64"
const m__XBS5_LPBIG_OFFBIG = "__LPBIG_OFFBIG"
const m__XOPEN_CRYPT = 1
const m__XOPEN_ENH_I18N = 1
const m__XOPEN_SHM = 1
const m__XOPEN_UNIX = 1
const m__XOPEN_VERSION = 600
const m__XOPEN_XCU_VERSION = 4
const m___API_TO_BE_DEPRECATED = 100000
const m___API_TO_BE_DEPRECATED_DRIVERKIT = 100000
const m___API_TO_BE_DEPRECATED_IOS = 100000
const m___API_TO_BE_DEPRECATED_IOSAPPLICATIONEXTENSION = 100000
const m___API_TO_BE_DEPRECATED_KERNELKIT = 100000
const m___API_TO_BE_DEPRECATED_MACCATALYST = 100000
const m___API_TO_BE_DEPRECATED_MACCATALYSTAPPLICATIONEXTENSION = 100000
const m___API_TO_BE_DEPRECATED_MACOS = 100000
const m___API_TO_BE_DEPRECATED_MACOSAPPLICATIONEXTENSION = 100000
const m___API_TO_BE_DEPRECATED_TVOS = 100000
const m___API_TO_BE_DEPRECATED_TVOSAPPLICATIONEXTENSION = 100000
const m___API_TO_BE_DEPRECATED_VISIONOS = 100000
const m___API_TO_BE_DEPRECATED_VISIONOSAPPLICATIONEXTENSION = 100000
const m___API_TO_BE_DEPRECATED_WATCHOS = 100000
const m___API_TO_BE_DEPRECATED_WATCHOSAPPLICATIONEXTENSION = 100000
const m___APPLE_CC__ = 6000
const m___APPLE__ = 1
const m___ATOMIC_ACQUIRE = 2
const m___ATOMIC_ACQ_REL = 4
const m___ATOMIC_CONSUME = 1
const m___ATOMIC_RELAXED = 0
const m___ATOMIC_RELEASE = 3
const m___ATOMIC_SEQ_CST = 5
const m___AVAILABILITY_FILE = "AvailabilityVersions.h"
const m___AVAILABILITY_VERSIONS_VERSION_HASH = 93585900
const m___AVAILABILITY_VERSIONS_VERSION_STRING = "Local"
const m___BIGGEST_ALIGNMENT__ = 16
const m___BITINT_MAXWIDTH__ = 8388608
const m___BLOCKS__ = 1
const m___BOOL_WIDTH__ = 8
const m___BRIDGEOS_2_0 = 20000
const m___BRIDGEOS_3_0 = 30000
const m___BRIDGEOS_3_1 = 30100
const m___BRIDGEOS_3_4 = 30400
const m___BRIDGEOS_4_0 = 40000
const m___BRIDGEOS_4_1 = 40100
const m___BRIDGEOS_5_0 = 50000
const m___BRIDGEOS_5_1 = 50100
const m___BRIDGEOS_5_3 = 50300
const m___BRIDGEOS_6_0 = 60000
const m___BRIDGEOS_6_2 = 60200
const m___BRIDGEOS_6_4 = 60400
const m___BRIDGEOS_6_5 = 60500
const m___BRIDGEOS_6_6 = 60600
const m___BRIDGEOS_7_0 = 70000
const m___BRIDGEOS_7_1 = 70100
const m___BRIDGEOS_7_2 = 70200
const m___BRIDGEOS_7_3 = 70300
const m___BRIDGEOS_7_4 = 70400
const m___BRIDGEOS_7_6 = 70600
const m___BRIDGEOS_8_0 = 80000
const m___BRIDGEOS_8_1 = 80100
const m___BRIDGEOS_8_2 = 80200
const m___BRIDGEOS_8_3 = 80300
const m___BRIDGEOS_8_4 = 80400
const m___BRIDGEOS_8_5 = 80500
const m___BRIDGEOS_8_6 = 80600
const m___BRIDGEOS_9_0 = 90000
const m___BRIDGEOS_9_1 = 90100
const m___BRIDGEOS_9_2 = 90200
const m___BRIDGEOS_9_3 = 90300
const m___BRIDGEOS_9_4 = 90400
const m___BRIDGEOS_9_5 = 90500
const m___BYTE_ORDER__ = "__ORDER_LITTLE_ENDIAN__"
const m___CCGO__ = 1
const m___CHAR_BIT__ = 8
const m___CLANG_ATOMIC_BOOL_LOCK_FREE = 2
const m___CLANG_ATOMIC_CHAR16_T_LOCK_FREE = 2
const m___CLANG_ATOMIC_CHAR32_T_LOCK_FREE = 2
const m___CLANG_ATOMIC_CHAR_LOCK_FREE = 2
const m___CLANG_ATOMIC_INT_LOCK_FREE = 2
const m___CLANG_ATOMIC_LLONG_LOCK_FREE = 2
const m___CLANG_ATOMIC_LONG_LOCK_FREE = 2
const m___CLANG_ATOMIC_POINTER_LOCK_FREE = 2
const m___CLANG_ATOMIC_SHORT_LOCK_FREE = 2
const m___CLANG_ATOMIC_WCHAR_T_LOCK_FREE = 2
const m___CONSTANT_CFSTRINGS__ = 1
const m___DARWIN_64_BIT_INO_T = 1
const m___DARWIN_BIG_ENDIAN = 4321
const m___DARWIN_BYTE_ORDER = "__DARWIN_LITTLE_ENDIAN"
const m___DARWIN_CTYPE_TOP_inline = "__header_inline"
const m___DARWIN_CTYPE_inline = "__header_inline"
const m___DARWIN_C_ANSI = 010000
const m___DARWIN_C_FULL = 900000
const m___DARWIN_C_LEVEL = "__DARWIN_C_FULL"
const m___DARWIN_FD_SETSIZE = 1024
const m___DARWIN_LITTLE_ENDIAN = 1234
const m___DARWIN_NBBY = 8
const m___DARWIN_NON_CANCELABLE = 0
const m___DARWIN_NO_LONG_LONG = 0
const m___DARWIN_NSIG = 32
const m___DARWIN_ONLY_64_BIT_INO_T = 0
const m___DARWIN_ONLY_UNIX_CONFORMANCE = 1
const m___DARWIN_ONLY_VERS_1050 = 0
const m___DARWIN_PDP_ENDIAN = 3412
const m___DARWIN_SUF_1050 = "$1050"
const m___DARWIN_SUF_64_BIT_INO_T = "$INODE64"
const m___DARWIN_SUF_EXTSN = "$DARWIN_EXTSN"
const m___DARWIN_UNIX03 = 1
const m___DARWIN_VERS_1050 = 1
const m___DARWIN_WCHAR_MAX = "__WCHAR_MAX__"
const m___DBL_DECIMAL_DIG__ = 17
const m___DBL_DENORM_MIN__ = 4.9406564584124654e-324
const m___DBL_DIG__ = 15
const m___DBL_EPSILON__ = 2.2204460492503131e-16
const m___DBL_HAS_DENORM__ = 1
const m___DBL_HAS_INFINITY__ = 1
const m___DBL_HAS_QUIET_NAN__ = 1
const m___DBL_MANT_DIG__ = 53
const m___DBL_MAX_10_EXP__ = 308
const m___DBL_MAX_EXP__ = 1024
const m___DBL_MAX__ = 1.7976931348623157e+308
const m___DBL_MIN__ = 2.2250738585072014e-308
const m___DBL_NORM_MAX__ = 1.7976931348623157e+308
const m___DECIMAL_DIG__ = "__LDBL_DECIMAL_DIG__"
const m___DRIVERKIT_19_0 = 190000
const m___DRIVERKIT_20_0 = 200000
const m___DRIVERKIT_21_0 = 210000
const m___DRIVERKIT_22_0 = 220000
const m___DRIVERKIT_22_4 = 220400
const m___DRIVERKIT_22_5 = 220500
const m___DRIVERKIT_22_6 = 220600
const m___DRIVERKIT_23_0 = 230000
const m___DRIVERKIT_23_1 = 230100
const m___DRIVERKIT_23_2 = 230200
const m___DRIVERKIT_23_3 = 230300
const m___DRIVERKIT_23_4 = 230400
const m___DRIVERKIT_23_5 = 230500
const m___DRIVERKIT_23_6 = 230600
const m___DRIVERKIT_24_0 = 240000
const m___DRIVERKIT_24_1 = 240100
const m___DRIVERKIT_24_2 = 240200
const m___DRIVERKIT_24_3 = 240300
const m___DRIVERKIT_24_4 = 240400
const m___DRIVERKIT_24_5 = 240500
const m___DYNAMIC__ = 1
const m___ENABLE_LEGACY_MAC_AVAILABILITY = 1
const m___ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ = 150000
const m___ENVIRONMENT_OS_VERSION_MIN_REQUIRED__ = 150000
const m___EXTENSIONS__ = 1
const m___FINITE_MATH_ONLY__ = 0
const m___FLT16_DECIMAL_DIG__ = 5
const m___FLT16_DENORM_MIN__ = 5.9604644775390625e-8
const m___FLT16_DIG__ = 3
const m___FLT16_EPSILON__ = 9.765625e-4
const m___FLT16_HAS_DENORM__ = 1
const m___FLT16_HAS_INFINITY__ = 1
const m___FLT16_HAS_QUIET_NAN__ = 1
const m___FLT16_MANT_DIG__ = 11
const m___FLT16_MAX_10_EXP__ = 4
const m___FLT16_MAX_EXP__ = 16
const m___FLT16_MAX__ = 6.5504e+4
const m___FLT16_MIN__ = 6.103515625e-5
const m___FLT16_NORM_MAX__ = 6.5504e+4
const m___FLT_DECIMAL_DIG__ = 9
const m___FLT_DENORM_MIN__ = 1.40129846e-45
const m___FLT_DIG__ = 6
const m___FLT_EPSILON__ = 1.19209290e-7
const m___FLT_HAS_DENORM__ = 1
const m___FLT_HAS_INFINITY__ = 1
const m___FLT_HAS_QUIET_NAN__ = 1
const m___FLT_MANT_DIG__ = 24
const m___FLT_MAX_10_EXP__ = 38
const m___FLT_MAX_EXP__ = 128
const m___FLT_MAX__ = 3.40282347e+38
const m___FLT_MIN__ = 1.17549435e-38
const m___FLT_NORM_MAX__ = 3.40282347e+38
const m___FLT_RADIX__ = 2
const m___FPCLASS_NEGINF = 0x0004
const m___FPCLASS_NEGNORMAL = 0x0008
const m___FPCLASS_NEGSUBNORMAL = 0x0010
const m___FPCLASS_NEGZERO = 0x0020
const m___FPCLASS_POSINF = 0x0200
const m___FPCLASS_POSNORMAL = 0x0100
const m___FPCLASS_POSSUBNORMAL = 0x0080
const m___FPCLASS_POSZERO = 0x0040
const m___FPCLASS_QNAN = 0x0002
const m___FPCLASS_SNAN = 0x0001
const m___FUNCTION__ = "__func__"
const m___FXSR__ = 1
const m___GCC_ASM_FLAG_OUTPUTS__ = 1
const m___GCC_ATOMIC_BOOL_LOCK_FREE = 2
const m___GCC_ATOMIC_CHAR16_T_LOCK_FREE = 2
const m___GCC_ATOMIC_CHAR32_T_LOCK_FREE = 2
const m___GCC_ATOMIC_CHAR_LOCK_FREE = 2
const m___GCC_ATOMIC_INT_LOCK_FREE = 2
const m___GCC_ATOMIC_LLONG_LOCK_FREE = 2
const m___GCC_ATOMIC_LONG_LOCK_FREE = 2
const m___GCC_ATOMIC_POINTER_LOCK_FREE = 2
const m___GCC_ATOMIC_SHORT_LOCK_FREE = 2
const m___GCC_ATOMIC_TEST_AND_SET_TRUEVAL = 1
const m___GCC_ATOMIC_WCHAR_T_LOCK_FREE = 2
const m___GCC_CONSTRUCTIVE_SIZE = 64
const m___GCC_DESTRUCTIVE_SIZE = 64
const m___GCC_HAVE_DWARF2_CFI_ASM = 1
const m___GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = 1
const m___GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 = 1
const m___GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = 1
const m___GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = 1
const m___GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = 1
const m___GNUC_MINOR__ = 2
const m___GNUC_PATCHLEVEL__ = 1
const m___GNUC_STDC_INLINE__ = 1
const m___GNUC__ = 4
const m___GXX_ABI_VERSION = 1002
const m___INT16_FMTd__ = "hd"
const m___INT16_FMTi__ = "hi"
const m___INT16_MAX__ = 32767
const m___INT16_TYPE__ = "short"
const m___INT32_FMTd__ = "d"
const m___INT32_FMTi__ = "i"
const m___INT32_MAX__ = 2147483647
const m___INT32_TYPE__ = "int"
const m___INT64_C_SUFFIX__ = "LL"
const m___INT64_FMTd__ = "lld"
const m___INT64_FMTi__ = "lli"
const m___INT64_MAX__ = 9223372036854775807
const m___INT8_FMTd__ = "hhd"
const m___INT8_FMTi__ = "hhi"
const m___INT8_MAX__ = 127
const m___INTMAX_C_SUFFIX__ = "L"
const m___INTMAX_FMTd__ = "ld"
const m___INTMAX_FMTi__ = "li"
const m___INTMAX_MAX__ = 9223372036854775807
const m___INTMAX_WIDTH__ = 64
const m___INTPTR_FMTd__ = "ld"
const m___INTPTR_FMTi__ = "li"
const m___INTPTR_MAX__ = 9223372036854775807
const m___INTPTR_WIDTH__ = 64
const m___INT_FAST16_FMTd__ = "hd"
const m___INT_FAST16_FMTi__ = "hi"
const m___INT_FAST16_MAX__ = 32767
const m___INT_FAST16_TYPE__ = "short"
const m___INT_FAST16_WIDTH__ = 16
const m___INT_FAST32_FMTd__ = "d"
const m___INT_FAST32_FMTi__ = "i"
const m___INT_FAST32_MAX__ = 2147483647
const m___INT_FAST32_TYPE__ = "int"
const m___INT_FAST32_WIDTH__ = 32
const m___INT_FAST64_FMTd__ = "lld"
const m___INT_FAST64_FMTi__ = "lli"
const m___INT_FAST64_MAX__ = 9223372036854775807
const m___INT_FAST64_WIDTH__ = 64
const m___INT_FAST8_FMTd__ = "hhd"
const m___INT_FAST8_FMTi__ = "hhi"
const m___INT_FAST8_MAX__ = 127
const m___INT_FAST8_WIDTH__ = 8
const m___INT_LEAST16_FMTd__ = "hd"
const m___INT_LEAST16_FMTi__ = "hi"
const m___INT_LEAST16_MAX__ = 32767
const m___INT_LEAST16_TYPE__ = "short"
const m___INT_LEAST16_WIDTH__ = 16
const m___INT_LEAST32_FMTd__ = "d"
const m___INT_LEAST32_FMTi__ = "i"
const m___INT_LEAST32_MAX__ = 2147483647
const m___INT_LEAST32_TYPE__ = "int"
const m___INT_LEAST32_WIDTH__ = 32
const m___INT_LEAST64_FMTd__ = "lld"
const m___INT_LEAST64_FMTi__ = "lli"
const m___INT_LEAST64_MAX = "INT64_MAX"
const m___INT_LEAST64_MAX__ = 9223372036854775807
const m___INT_LEAST64_MIN = "INT64_MIN"
const m___INT_LEAST64_WIDTH__ = 64
const m___INT_LEAST8_FMTd__ = "hhd"
const m___INT_LEAST8_FMTi__ = "hhi"
const m___INT_LEAST8_MAX__ = 127
const m___INT_LEAST8_WIDTH__ = 8
const m___INT_MAX__ = 2147483647
const m___INT_WIDTH__ = 32
const m___IPHONE_10_0 = 100000
const m___IPHONE_10_1 = 100100
const m___IPHONE_10_2 = 100200
const m___IPHONE_10_3 = 100300
const m___IPHONE_11_0 = 110000
const m___IPHONE_11_1 = 110100
const m___IPHONE_11_2 = 110200
const m___IPHONE_11_3 = 110300
const m___IPHONE_11_4 = 110400
const m___IPHONE_12_0 = 120000
const m___IPHONE_12_1 = 120100
const m___IPHONE_12_2 = 120200
const m___IPHONE_12_3 = 120300
const m___IPHONE_12_4 = 120400
const m___IPHONE_13_0 = 130000
const m___IPHONE_13_1 = 130100
const m___IPHONE_13_2 = 130200
const m___IPHONE_13_3 = 130300
const m___IPHONE_13_4 = 130400
const m___IPHONE_13_5 = 130500
const m___IPHONE_13_6 = 130600
const m___IPHONE_13_7 = 130700
const m___IPHONE_14_0 = 140000
const m___IPHONE_14_1 = 140100
const m___IPHONE_14_2 = 140200
const m___IPHONE_14_3 = 140300
const m___IPHONE_14_4 = 140400
const m___IPHONE_14_5 = 140500
const m___IPHONE_14_6 = 140600
const m___IPHONE_14_7 = 140700
const m___IPHONE_14_8 = 140800
const m___IPHONE_15_0 = 150000
const m___IPHONE_15_1 = 150100
const m___IPHONE_15_2 = 150200
const m___IPHONE_15_3 = 150300
const m___IPHONE_15_4 = 150400
const m___IPHONE_15_5 = 150500
const m___IPHONE_15_6 = 150600
const m___IPHONE_15_7 = 150700
const m___IPHONE_15_8 = 150800
const m___IPHONE_16_0 = 160000
const m___IPHONE_16_1 = 160100
const m___IPHONE_16_2 = 160200
const m___IPHONE_16_3 = 160300
const m___IPHONE_16_4 = 160400
const m___IPHONE_16_5 = 160500
const m___IPHONE_16_6 = 160600
const m___IPHONE_16_7 = 160700
const m___IPHONE_17_0 = 170000
const m___IPHONE_17_1 = 170100
const m___IPHONE_17_2 = 170200
const m___IPHONE_17_3 = 170300
const m___IPHONE_17_4 = 170400
const m___IPHONE_17_5 = 170500
const m___IPHONE_17_6 = 170600
const m___IPHONE_17_7 = 170700
const m___IPHONE_18_0 = 180000
const m___IPHONE_18_1 = 180100
const m___IPHONE_18_2 = 180200
const m___IPHONE_18_3 = 180300
const m___IPHONE_18_4 = 180400
const m___IPHONE_18_5 = 180500
const m___IPHONE_2_0 = 20000
const m___IPHONE_2_1 = 20100
const m___IPHONE_2_2 = 20200
const m___IPHONE_3_0 = 30000
const m___IPHONE_3_1 = 30100
const m___IPHONE_3_2 = 30200
const m___IPHONE_4_0 = 40000
const m___IPHONE_4_1 = 40100
const m___IPHONE_4_2 = 40200
const m___IPHONE_4_3 = 40300
const m___IPHONE_5_0 = 50000
const m___IPHONE_5_1 = 50100
const m___IPHONE_6_0 = 60000
const m___IPHONE_6_1 = 60100
const m___IPHONE_7_0 = 70000
const m___IPHONE_7_1 = 70100
const m___IPHONE_8_0 = 80000
const m___IPHONE_8_1 = 80100
const m___IPHONE_8_2 = 80200
const m___IPHONE_8_3 = 80300
const m___IPHONE_8_4 = 80400
const m___IPHONE_9_0 = 90000
const m___IPHONE_9_1 = 90100
const m___IPHONE_9_2 = 90200
const m___IPHONE_9_3 = 90300
const m___LAHF_SAHF__ = 1
const m___LASTBRANCH_MAX = 32
const m___LDBL_DECIMAL_DIG__ = 17
const m___LDBL_DENORM_MIN__ = 4.9406564584124654e-324
const m___LDBL_DIG__ = 15
const m___LDBL_EPSILON__ = 2.2204460492503131e-16
const m___LDBL_HAS_DENORM__ = 1
const m___LDBL_HAS_INFINITY__ = 1
const m___LDBL_HAS_QUIET_NAN__ = 1
const m___LDBL_MANT_DIG__ = 53
const m___LDBL_MAX_10_EXP__ = 308
const m___LDBL_MAX_EXP__ = 1024
const m___LDBL_MAX__ = 1.7976931348623157e+308
const m___LDBL_MIN__ = 2.2250738585072014e-308
const m___LDBL_NORM_MAX__ = 1.7976931348623157e+308
const m___LITTLE_ENDIAN__ = 1
const m___LLONG_WIDTH__ = 64
const m___LONG_LONG_MAX__ = 9223372036854775807
const m___LONG_MAX__ = 9223372036854775807
const m___LONG_WIDTH__ = 64
const m___LP64_OFF64 = 1
const m___LP64__ = 1
const m___LPBIG_OFFBIG = 1
const m___MACH__ = 1
const m___MAC_10_0 = 1000
const m___MAC_10_1 = 1010
const m___MAC_10_10 = 101000
const m___MAC_10_10_2 = 101002
const m___MAC_10_10_3 = 101003
const m___MAC_10_11 = 101100
const m___MAC_10_11_2 = 101102
const m___MAC_10_11_3 = 101103
const m___MAC_10_11_4 = 101104
const m___MAC_10_12 = 101200
const m___MAC_10_12_1 = 101201
const m___MAC_10_12_2 = 101202
const m___MAC_10_12_4 = 101204
const m___MAC_10_13 = 101300
const m___MAC_10_13_1 = 101301
const m___MAC_10_13_2 = 101302
const m___MAC_10_13_4 = 101304
const m___MAC_10_14 = 101400
const m___MAC_10_14_1 = 101401
const m___MAC_10_14_4 = 101404
const m___MAC_10_14_5 = 101405
const m___MAC_10_14_6 = 101406
const m___MAC_10_15 = 101500
const m___MAC_10_15_1 = 101501
const m___MAC_10_15_4 = 101504
const m___MAC_10_16 = 101600
const m___MAC_10_2 = 1020
const m___MAC_10_3 = 1030
const m___MAC_10_4 = 1040
const m___MAC_10_5 = 1050
const m___MAC_10_6 = 1060
const m___MAC_10_7 = 1070
const m___MAC_10_8 = 1080
const m___MAC_10_9 = 1090
const m___MAC_11_0 = 110000
const m___MAC_11_1 = 110100
const m___MAC_11_3 = 110300
const m___MAC_11_4 = 110400
const m___MAC_11_5 = 110500
const m___MAC_11_6 = 110600
const m___MAC_12_0 = 120000
const m___MAC_12_1 = 120100
const m___MAC_12_2 = 120200
const m___MAC_12_3 = 120300
const m___MAC_12_4 = 120400
const m___MAC_12_5 = 120500
const m___MAC_12_6 = 120600
const m___MAC_12_7 = 120700
const m___MAC_13_0 = 130000
const m___MAC_13_1 = 130100
const m___MAC_13_2 = 130200
const m___MAC_13_3 = 130300
const m___MAC_13_4 = 130400
const m___MAC_13_5 = 130500
const m___MAC_13_6 = 130600
const m___MAC_13_7 = 130700
const m___MAC_14_0 = 140000
const m___MAC_14_1 = 140100
const m___MAC_14_2 = 140200
const m___MAC_14_3 = 140300
const m___MAC_14_4 = 140400
const m___MAC_14_5 = 140500
const m___MAC_14_6 = 140600
const m___MAC_14_7 = 140700
const m___MAC_15_0 = 150000
const m___MAC_15_1 = 150100
const m___MAC_15_2 = 150200
const m___MAC_15_3 = 150300
const m___MAC_15_4 = 150400
const m___MAC_15_5 = 150500
const m___MAC_OS_X_VERSION_MAX_ALLOWED = "__MAC_15_5"
const m___MAC_OS_X_VERSION_MIN_REQUIRED = "__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__"
const m___MEMORY_SCOPE_DEVICE = 1
const m___MEMORY_SCOPE_SINGLE = 4
const m___MEMORY_SCOPE_SYSTEM = 0
const m___MEMORY_SCOPE_WRKGRP = 2
const m___MEMORY_SCOPE_WVFRNT = 3
const m___MMX__ = 1
const m___NO_INLINE__ = 1
const m___NO_MATH_ERRNO__ = 1
const m___NO_MATH_INLINES = 1
const m___OBJC_BOOL_IS_BOOL = 0
const m___OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = 3
const m___OPENCL_MEMORY_SCOPE_DEVICE = 2
const m___OPENCL_MEMORY_SCOPE_SUB_GROUP = 4
const m___OPENCL_MEMORY_SCOPE_WORK_GROUP = 1
const m___OPENCL_MEMORY_SCOPE_WORK_ITEM = 0
const m___ORDER_BIG_ENDIAN__ = 4321
const m___ORDER_LITTLE_ENDIAN__ = 1234
const m___ORDER_PDP_ENDIAN__ = 3412
const m___PIC__ = 2
const m___POINTER_WIDTH__ = 64
const m___PRAGMA_REDEFINE_EXTNAME = 1
const m___PRETTY_FUNCTION__ = "__func__"
const m___PTHREAD_ATTR_SIZE__ = 56
const m___PTHREAD_CONDATTR_SIZE__ = 8
const m___PTHREAD_COND_SIZE__ = 40
const m___PTHREAD_MUTEXATTR_SIZE__ = 8
const m___PTHREAD_MUTEX_SIZE__ = 56
const m___PTHREAD_ONCE_SIZE__ = 8
const m___PTHREAD_RWLOCKATTR_SIZE__ = 16
const m___PTHREAD_RWLOCK_SIZE__ = 192
const m___PTHREAD_SIZE__ = 8176
const m___PTRDIFF_FMTd__ = "ld"
const m___PTRDIFF_FMTi__ = "li"
const m___PTRDIFF_MAX__ = 9223372036854775807
const m___PTRDIFF_WIDTH__ = 64
const m___SALC = 0x4000
const m___SAPP = 0x0100
const m___SCHAR_MAX__ = 127
const m___SEG_FS = 1
const m___SEG_GS = 1
const m___SEOF = 0x0020
const m___SERR = 0x0040
const m___SHRT_MAX__ = 32767
const m___SHRT_WIDTH__ = 16
const m___SIGN = 0x8000
const m___SIG_ATOMIC_MAX__ = 2147483647
const m___SIG_ATOMIC_WIDTH__ = 32
const m___SIZEOF_DOUBLE__ = 8
const m___SIZEOF_FLOAT__ = 4
const m___SIZEOF_INT128__ = 16
const m___SIZEOF_INT__ = 4
const m___SIZEOF_LONG_DOUBLE__ = 8
const m___SIZEOF_LONG_LONG__ = 8
const m___SIZEOF_LONG__ = 8
const m___SIZEOF_POINTER__ = 8
const m___SIZEOF_PTRDIFF_T__ = 8
const m___SIZEOF_SHORT__ = 2
const m___SIZEOF_SIZE_T__ = 8
const m___SIZEOF_WCHAR_T__ = 4
const m___SIZEOF_WINT_T__ = 4
const m___SIZE_FMTX__ = "lX"
const m___SIZE_FMTo__ = "lo"
const m___SIZE_FMTu__ = "lu"
const m___SIZE_FMTx__ = "lx"
const m___SIZE_MAX__ = 18446744073709551615
const m___SIZE_WIDTH__ = 64
const m___SLBF = 0x0001
const m___SMBF = 0x0080
const m___SMOD = 0x2000
const m___SNBF = 0x0002
const m___SNPT = 0x0800
const m___SOFF = 0x1000
const m___SOPT = 0x0400
const m___SRD = 0x0004
const m___SRW = 0x0010
const m___SSE2_MATH__ = 1
const m___SSE2__ = 1
const m___SSE3__ = 1
const m___SSE4_1__ = 1
const m___SSE_MATH__ = 1
const m___SSE__ = 1
const m___SSP__ = 1
const m___SSSE3__ = 1
const m___SSTR = 0x0200
const m___STDC_EMBED_EMPTY__ = 2
const m___STDC_EMBED_FOUND__ = 1
const m___STDC_EMBED_NOT_FOUND__ = 0
const m___STDC_HOSTED__ = 1
const m___STDC_NO_THREADS__ = 1
const m___STDC_UTF_16__ = 1
const m___STDC_UTF_32__ = 1
const m___STDC_VERSION__ = 201710
const m___STDC_WANT_IEC_60559_ATTRIBS_EXT__ = 1
const m___STDC_WANT_IEC_60559_BFP_EXT__ = 1
const m___STDC_WANT_IEC_60559_DFP_EXT__ = 1
const m___STDC_WANT_IEC_60559_FUNCS_EXT__ = 1
const m___STDC_WANT_IEC_60559_TYPES_EXT__ = 1
const m___STDC_WANT_LIB_EXT1__ = 1
const m___STDC_WANT_LIB_EXT2__ = 1
const m___STDC_WANT_MATH_SPEC_FUNCS__ = 1
const m___STDC__ = 1
const m___SWR = 0x0008
const m___TVOS_10_0 = 100000
const m___TVOS_10_0_1 = 100001
const m___TVOS_10_1 = 100100
const m___TVOS_10_2 = 100200
const m___TVOS_11_0 = 110000
const m___TVOS_11_1 = 110100
const m___TVOS_11_2 = 110200
const m___TVOS_11_3 = 110300
const m___TVOS_11_4 = 110400
const m___TVOS_12_0 = 120000
const m___TVOS_12_1 = 120100
const m___TVOS_12_2 = 120200
const m___TVOS_12_3 = 120300
const m___TVOS_12_4 = 120400
const m___TVOS_13_0 = 130000
const m___TVOS_13_2 = 130200
const m___TVOS_13_3 = 130300
const m___TVOS_13_4 = 130400
const m___TVOS_14_0 = 140000
const m___TVOS_14_1 = 140100
const m___TVOS_14_2 = 140200
const m___TVOS_14_3 = 140300
const m___TVOS_14_5 = 140500
const m___TVOS_14_6 = 140600
const m___TVOS_14_7 = 140700
const m___TVOS_15_0 = 150000
const m___TVOS_15_1 = 150100
const m___TVOS_15_2 = 150200
const m___TVOS_15_3 = 150300
const m___TVOS_15_4 = 150400
const m___TVOS_15_5 = 150500
const m___TVOS_15_6 = 150600
const m___TVOS_16_0 = 160000
const m___TVOS_16_1 = 160100
const m___TVOS_16_2 = 160200
const m___TVOS_16_3 = 160300
const m___TVOS_16_4 = 160400
const m___TVOS_16_5 = 160500
const m___TVOS_16_6 = 160600
const m___TVOS_17_0 = 170000
const m___TVOS_17_1 = 170100
const m___TVOS_17_2 = 170200
const m___TVOS_17_3 = 170300
const m___TVOS_17_4 = 170400
const m___TVOS_17_5 = 170500
const m___TVOS_17_6 = 170600
const m___TVOS_18_0 = 180000
const m___TVOS_18_1 = 180100
const m___TVOS_18_2 = 180200
const m___TVOS_18_3 = 180300
const m___TVOS_18_4 = 180400
const m___TVOS_18_5 = 180500
const m___TVOS_9_0 = 90000
const m___TVOS_9_1 = 90100
const m___TVOS_9_2 = 90200
const m___UINT16_FMTX__ = "hX"
const m___UINT16_FMTo__ = "ho"
const m___UINT16_FMTu__ = "hu"
const m___UINT16_FMTx__ = "hx"
const m___UINT16_MAX__ = 65535
const m___UINT32_C_SUFFIX__ = "U"
const m___UINT32_FMTX__ = "X"
const m___UINT32_FMTo__ = "o"
const m___UINT32_FMTu__ = "u"
const m___UINT32_FMTx__ = "x"
const m___UINT32_MAX__ = 4294967295
const m___UINT64_C_SUFFIX__ = "ULL"
const m___UINT64_FMTX__ = "llX"
const m___UINT64_FMTo__ = "llo"
const m___UINT64_FMTu__ = "llu"
const m___UINT64_FMTx__ = "llx"
const m___UINT64_MAX__ = "18446744073709551615U"
const m___UINT8_FMTX__ = "hhX"
const m___UINT8_FMTo__ = "hho"
const m___UINT8_FMTu__ = "hhu"
const m___UINT8_FMTx__ = "hhx"
const m___UINT8_MAX__ = 255
const m___UINTMAX_C_SUFFIX__ = "UL"
const m___UINTMAX_FMTX__ = "lX"
const m___UINTMAX_FMTo__ = "lo"
const m___UINTMAX_FMTu__ = "lu"
const m___UINTMAX_FMTx__ = "lx"
const m___UINTMAX_MAX__ = 18446744073709551615
const m___UINTMAX_WIDTH__ = 64
const m___UINTPTR_FMTX__ = "lX"
const m___UINTPTR_FMTo__ = "lo"
const m___UINTPTR_FMTu__ = "lu"
const m___UINTPTR_FMTx__ = "lx"
const m___UINTPTR_MAX__ = 18446744073709551615
const m___UINTPTR_WIDTH__ = 64
const m___UINT_FAST16_FMTX__ = "hX"
const m___UINT_FAST16_FMTo__ = "ho"
const m___UINT_FAST16_FMTu__ = "hu"
const m___UINT_FAST16_FMTx__ = "hx"
const m___UINT_FAST16_MAX__ = 65535
const m___UINT_FAST32_FMTX__ = "X"
const m___UINT_FAST32_FMTo__ = "o"
const m___UINT_FAST32_FMTu__ = "u"
const m___UINT_FAST32_FMTx__ = "x"
const m___UINT_FAST32_MAX__ = 4294967295
const m___UINT_FAST64_FMTX__ = "llX"
const m___UINT_FAST64_FMTo__ = "llo"
const m___UINT_FAST64_FMTu__ = "llu"
const m___UINT_FAST64_FMTx__ = "llx"
const m___UINT_FAST64_MAX__ = "18446744073709551615U"
const m___UINT_FAST8_FMTX__ = "hhX"
const m___UINT_FAST8_FMTo__ = "hho"
const m___UINT_FAST8_FMTu__ = "hhu"
const m___UINT_FAST8_FMTx__ = "hhx"
const m___UINT_FAST8_MAX__ = 255
const m___UINT_LEAST16_FMTX__ = "hX"
const m___UINT_LEAST16_FMTo__ = "ho"
const m___UINT_LEAST16_FMTu__ = "hu"
const m___UINT_LEAST16_FMTx__ = "hx"
const m___UINT_LEAST16_MAX__ = 65535
const m___UINT_LEAST32_FMTX__ = "X"
const m___UINT_LEAST32_FMTo__ = "o"
const m___UINT_LEAST32_FMTu__ = "u"
const m___UINT_LEAST32_FMTx__ = "x"
const m___UINT_LEAST32_MAX__ = 4294967295
const m___UINT_LEAST64_FMTX__ = "llX"
const m___UINT_LEAST64_FMTo__ = "llo"
const m___UINT_LEAST64_FMTu__ = "llu"
const m___UINT_LEAST64_FMTx__ = "llx"
const m___UINT_LEAST64_MAX = "UINT64_MAX"
const m___UINT_LEAST64_MAX__ = "18446744073709551615U"
const m___UINT_LEAST8_FMTX__ = "hhX"
const m___UINT_LEAST8_FMTo__ = "hho"
const m___UINT_LEAST8_FMTu__ = "hhu"
const m___UINT_LEAST8_FMTx__ = "hhx"
const m___UINT_LEAST8_MAX__ = 255
const m___USER_LABEL_PREFIX__ = "_"
const m___VERSION__ = "Apple LLVM 17.0.0 (clang-1700.0.13.5)"
const m___VISIONOS_1_0 = 10000
const m___VISIONOS_1_1 = 10100
const m___VISIONOS_1_2 = 10200
const m___VISIONOS_1_3 = 10300
const m___VISIONOS_2_0 = 20000
const m___VISIONOS_2_1 = 20100
const m___VISIONOS_2_2 = 20200
const m___VISIONOS_2_3 = 20300
const m___VISIONOS_2_4 = 20400
const m___VISIONOS_2_5 = 20500
const m___WATCHOS_10_0 = 100000
const m___WATCHOS_10_1 = 100100
const m___WATCHOS_10_2 = 100200
const m___WATCHOS_10_3 = 100300
const m___WATCHOS_10_4 = 100400
const m___WATCHOS_10_5 = 100500
const m___WATCHOS_10_6 = 100600
const m___WATCHOS_10_7 = 100700
const m___WATCHOS_11_0 = 110000
const m___WATCHOS_11_1 = 110100
const m___WATCHOS_11_2 = 110200
const m___WATCHOS_11_3 = 110300
const m___WATCHOS_11_4 = 110400
const m___WATCHOS_11_5 = 110500
const m___WATCHOS_1_0 = 10000
const m___WATCHOS_2_0 = 20000
const m___WATCHOS_2_1 = 20100
const m___WATCHOS_2_2 = 20200
const m___WATCHOS_3_0 = 30000
const m___WATCHOS_3_1 = 30100
const m___WATCHOS_3_1_1 = 30101
const m___WATCHOS_3_2 = 30200
const m___WATCHOS_4_0 = 40000
const m___WATCHOS_4_1 = 40100
const m___WATCHOS_4_2 = 40200
const m___WATCHOS_4_3 = 40300
const m___WATCHOS_5_0 = 50000
const m___WATCHOS_5_1 = 50100
const m___WATCHOS_5_2 = 50200
const m___WATCHOS_5_3 = 50300
const m___WATCHOS_6_0 = 60000
const m___WATCHOS_6_1 = 60100
const m___WATCHOS_6_2 = 60200
const m___WATCHOS_7_0 = 70000
const m___WATCHOS_7_1 = 70100
const m___WATCHOS_7_2 = 70200
const m___WATCHOS_7_3 = 70300
const m___WATCHOS_7_4 = 70400
const m___WATCHOS_7_5 = 70500
const m___WATCHOS_7_6 = 70600
const m___WATCHOS_8_0 = 80000
const m___WATCHOS_8_1 = 80100
const m___WATCHOS_8_3 = 80300
const m___WATCHOS_8_4 = 80400
const m___WATCHOS_8_5 = 80500
const m___WATCHOS_8_6 = 80600
const m___WATCHOS_8_7 = 80700
const m___WATCHOS_8_8 = 80800
const m___WATCHOS_9_0 = 90000
const m___WATCHOS_9_1 = 90100
const m___WATCHOS_9_2 = 90200
const m___WATCHOS_9_3 = 90300
const m___WATCHOS_9_4 = 90400
const m___WATCHOS_9_5 = 90500
const m___WATCHOS_9_6 = 90600
const m___WCHAR_MAX__ = 2147483647
const m___WCHAR_TYPE__ = "int"
const m___WCHAR_WIDTH__ = 32
const m___WINT_MAX__ = 2147483647
const m___WINT_TYPE__ = "int"
const m___WINT_WIDTH__ = 32
const m___amd64 = 1
const m___amd64__ = 1
const m___apple_build_version__ = 17000013
const m___clang__ = 1
const m___clang_literal_encoding__ = "UTF-8"
const m___clang_major__ = 17
const m___clang_minor__ = 0
const m___clang_patchlevel__ = 0
const m___clang_version__ = "17.0.0 (clang-1700.0.13.5)"
const m___clang_wide_literal_encoding__ = "UTF-32"
const m___code_model_small__ = 1
const m___const = "const"
const m___core2 = 1
const m___core2__ = 1
const m___has_bounds_safety_attributes = 0
const m___has_ptrcheck = 0
const m___has_safe_buffers = 0
const m___header_inline = "inline"
const m___llvm__ = 1
const m___nonnull = "_Nonnull"
const m___null_unspecified = "_Null_unspecified"
const m___nullable = "_Nullable"
const m___pic__ = 2
const m___restrict = "restrict"
const m___restrict_arr = "restrict"
const m___signed = "signed"
const m___tune_core2__ = 1
const m___volatile = "volatile"
const m___x86_64 = 1
const m___x86_64__ = 1
const m_ru_first = "ru_ixrss"
const m_ru_last = "ru_nivcsw"
const m_static_assert = "_Static_assert"
const m_stderr = "__stderrp"
const m_stdin = "__stdinp"
const m_stdout = "__stdoutp"
const m_sv_onstack = "sv_flags"

type t__builtin_va_list = uintptr

type t__predefined_size_t = uint64

type t__predefined_wchar_t = int32

type t__predefined_ptrdiff_t = int64

type t__int8_t = int8

type t__uint8_t = uint8

type t__int16_t = int16

type t__uint16_t = uint16

type t__int32_t = int32

type t__uint32_t = uint32

type t__int64_t = int64

type t__uint64_t = uint64

type t__darwin_intptr_t = int64

type t__darwin_natural_t = uint32

type t__darwin_ct_rune_t = int32

type t__mbstate_t = struct {
	F_mbstateL  [0]int64
	F__mbstate8 [128]int8
}

type t__darwin_mbstate_t = struct {
	F_mbstateL  [0]int64
	F__mbstate8 [128]int8
}

type t__darwin_ptrdiff_t = int64

type t__darwin_size_t = uint64

type t__darwin_va_list = uintptr

type t__darwin_wchar_t = int32

type t__darwin_rune_t = int32

type t__darwin_wint_t = int32

type t__darwin_clock_t = uint64

type t__darwin_socklen_t = uint32

type t__darwin_ssize_t = int64

type t__darwin_time_t = int64

type t__darwin_blkcnt_t = int64

type t__darwin_blksize_t = int32

type t__darwin_dev_t = int32

type t__darwin_fsblkcnt_t = uint32

type t__darwin_fsfilcnt_t = uint32

type t__darwin_gid_t = uint32

type t__darwin_id_t = uint32

type t__darwin_ino64_t = uint64

type t__darwin_ino_t = uint64

type t__darwin_mach_port_name_t = uint32

type t__darwin_mach_port_t = uint32

type t__darwin_mode_t = uint16

type t__darwin_off_t = int64

type t__darwin_pid_t = int32

type t__darwin_sigset_t = uint32

type t__darwin_suseconds_t = int32

type t__darwin_uid_t = uint32

type t__darwin_useconds_t = uint32

type t__darwin_uuid_t = [16]uint8

type t__darwin_uuid_string_t = [37]int8

type t__darwin_pthread_handler_rec = struct {
	F__routine uintptr
	F__arg     uintptr
	F__next    uintptr
}

type T_opaque_pthread_attr_t = struct {
	F__sig    int64
	F__opaque [56]int8
}

type T_opaque_pthread_cond_t = struct {
	F__sig    int64
	F__opaque [40]int8
}

type T_opaque_pthread_condattr_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type T_opaque_pthread_mutex_t = struct {
	F__sig    int64
	F__opaque [56]int8
}

type T_opaque_pthread_mutexattr_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type T_opaque_pthread_once_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type T_opaque_pthread_rwlock_t = struct {
	F__sig    int64
	F__opaque [192]int8
}

type T_opaque_pthread_rwlockattr_t = struct {
	F__sig    int64
	F__opaque [16]int8
}

type T_opaque_pthread_t = struct {
	F__sig           int64
	F__cleanup_stack uintptr
	F__opaque        [8176]int8
}

type t__darwin_pthread_attr_t = struct {
	F__sig    int64
	F__opaque [56]int8
}

type t__darwin_pthread_cond_t = struct {
	F__sig    int64
	F__opaque [40]int8
}

type t__darwin_pthread_condattr_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type t__darwin_pthread_key_t = uint64

type t__darwin_pthread_mutex_t = struct {
	F__sig    int64
	F__opaque [56]int8
}

type t__darwin_pthread_mutexattr_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type t__darwin_pthread_once_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type t__darwin_pthread_rwlock_t = struct {
	F__sig    int64
	F__opaque [192]int8
}

type t__darwin_pthread_rwlockattr_t = struct {
	F__sig    int64
	F__opaque [16]int8
}

type t__darwin_pthread_t = uintptr

type Tint64_t = int64

type Tuint64_t = uint64

type Tint_least64_t = int64

type Tuint_least64_t = uint64

type Tint_fast64_t = int64

type Tuint_fast64_t = uint64

type Tint32_t = int32

type Tuint32_t = uint32

type Tint_least32_t = int32

type Tuint_least32_t = uint32

type Tint_fast32_t = int32

type Tuint_fast32_t = uint32

type Tint16_t = int16

type Tuint16_t = uint16

type Tint_least16_t = int16

type Tuint_least16_t = uint16

type Tint_fast16_t = int16

type Tuint_fast16_t = uint16

type Tint8_t = int8

type Tuint8_t = uint8

type Tint_least8_t = int8

type Tuint_least8_t = uint8

type Tint_fast8_t = int8

type Tuint_fast8_t = uint8

type Tintptr_t = int64

type Tuintptr_t = uint64

type Tintmax_t = int64

type Tuintmax_t = uint64

type t__darwin_nl_item = int32

type t__darwin_wctrans_t = int32

type t__darwin_wctype_t = uint32

type Tidtype_t = int32

const _P_ALL = 0
const _P_PID = 1
const _P_PGID = 2

type Tpid_t = int32

type Tid_t = uint32

type Tsig_atomic_t = int32

type Tu_int8_t = uint8

type Tu_int16_t = uint16

type Tu_int32_t = uint32

type Tu_int64_t = uint64

type Tregister_t = int64

type Tuser_addr_t = uint64

type Tuser_size_t = uint64

type Tuser_ssize_t = int64

type Tuser_long_t = int64

type Tuser_ulong_t = uint64

type Tuser_time_t = int64

type Tuser_off_t = int64

type Tsyscall_arg_t = uint64

type t__darwin_i386_thread_state = struct {
	F__eax    uint32
	F__ebx    uint32
	F__ecx    uint32
	F__edx    uint32
	F__edi    uint32
	F__esi    uint32
	F__ebp    uint32
	F__esp    uint32
	F__ss     uint32
	F__eflags uint32
	F__eip    uint32
	F__cs     uint32
	F__ds     uint32
	F__es     uint32
	F__fs     uint32
	F__gs     uint32
}

type t__darwin_fp_control = struct {
	F__ccgo0 uint16
}

type t__darwin_fp_control_t = struct {
	F__ccgo0 uint16
}

type t__darwin_fp_status = struct {
	F__ccgo0 uint16
}

type t__darwin_fp_status_t = struct {
	F__ccgo0 uint16
}

type t__darwin_mmst_reg = struct {
	F__mmst_reg  [10]int8
	F__mmst_rsrv [6]int8
}

type t__darwin_xmm_reg = struct {
	F__xmm_reg [16]int8
}

type t__darwin_ymm_reg = struct {
	F__ymm_reg [32]int8
}

type t__darwin_zmm_reg = struct {
	F__zmm_reg [64]int8
}

type t__darwin_opmask_reg = struct {
	F__opmask_reg [8]int8
}

type t__darwin_i386_float_state = struct {
	F__fpu_reserved  [2]int32
	F__fpu_fcw       t__darwin_fp_control
	F__fpu_fsw       t__darwin_fp_status
	F__fpu_ftw       t__uint8_t
	F__fpu_rsrv1     t__uint8_t
	F__fpu_fop       t__uint16_t
	F__fpu_ip        t__uint32_t
	F__fpu_cs        t__uint16_t
	F__fpu_rsrv2     t__uint16_t
	F__fpu_dp        t__uint32_t
	F__fpu_ds        t__uint16_t
	F__fpu_rsrv3     t__uint16_t
	F__fpu_mxcsr     t__uint32_t
	F__fpu_mxcsrmask t__uint32_t
	F__fpu_stmm0     t__darwin_mmst_reg
	F__fpu_stmm1     t__darwin_mmst_reg
	F__fpu_stmm2     t__darwin_mmst_reg
	F__fpu_stmm3     t__darwin_mmst_reg
	F__fpu_stmm4     t__darwin_mmst_reg
	F__fpu_stmm5     t__darwin_mmst_reg
	F__fpu_stmm6     t__darwin_mmst_reg
	F__fpu_stmm7     t__darwin_mmst_reg
	F__fpu_xmm0      t__darwin_xmm_reg
	F__fpu_xmm1      t__darwin_xmm_reg
	F__fpu_xmm2      t__darwin_xmm_reg
	F__fpu_xmm3      t__darwin_xmm_reg
	F__fpu_xmm4      t__darwin_xmm_reg
	F__fpu_xmm5      t__darwin_xmm_reg
	F__fpu_xmm6      t__darwin_xmm_reg
	F__fpu_xmm7      t__darwin_xmm_reg
	F__fpu_rsrv4     [224]int8
	F__fpu_reserved1 int32
}

type t__darwin_i386_avx_state = struct {
	F__fpu_reserved  [2]int32
	F__fpu_fcw       t__darwin_fp_control
	F__fpu_fsw       t__darwin_fp_status
	F__fpu_ftw       t__uint8_t
	F__fpu_rsrv1     t__uint8_t
	F__fpu_fop       t__uint16_t
	F__fpu_ip        t__uint32_t
	F__fpu_cs        t__uint16_t
	F__fpu_rsrv2     t__uint16_t
	F__fpu_dp        t__uint32_t
	F__fpu_ds        t__uint16_t
	F__fpu_rsrv3     t__uint16_t
	F__fpu_mxcsr     t__uint32_t
	F__fpu_mxcsrmask t__uint32_t
	F__fpu_stmm0     t__darwin_mmst_reg
	F__fpu_stmm1     t__darwin_mmst_reg
	F__fpu_stmm2     t__darwin_mmst_reg
	F__fpu_stmm3     t__darwin_mmst_reg
	F__fpu_stmm4     t__darwin_mmst_reg
	F__fpu_stmm5     t__darwin_mmst_reg
	F__fpu_stmm6     t__darwin_mmst_reg
	F__fpu_stmm7     t__darwin_mmst_reg
	F__fpu_xmm0      t__darwin_xmm_reg
	F__fpu_xmm1      t__darwin_xmm_reg
	F__fpu_xmm2      t__darwin_xmm_reg
	F__fpu_xmm3      t__darwin_xmm_reg
	F__fpu_xmm4      t__darwin_xmm_reg
	F__fpu_xmm5      t__darwin_xmm_reg
	F__fpu_xmm6      t__darwin_xmm_reg
	F__fpu_xmm7      t__darwin_xmm_reg
	F__fpu_rsrv4     [224]int8
	F__fpu_reserved1 int32
	F__avx_reserved1 [64]int8
	F__fpu_ymmh0     t__darwin_xmm_reg
	F__fpu_ymmh1     t__darwin_xmm_reg
	F__fpu_ymmh2     t__darwin_xmm_reg
	F__fpu_ymmh3     t__darwin_xmm_reg
	F__fpu_ymmh4     t__darwin_xmm_reg
	F__fpu_ymmh5     t__darwin_xmm_reg
	F__fpu_ymmh6     t__darwin_xmm_reg
	F__fpu_ymmh7     t__darwin_xmm_reg
}

type t__darwin_i386_avx512_state = struct {
	F__fpu_reserved  [2]int32
	F__fpu_fcw       t__darwin_fp_control
	F__fpu_fsw       t__darwin_fp_status
	F__fpu_ftw       t__uint8_t
	F__fpu_rsrv1     t__uint8_t
	F__fpu_fop       t__uint16_t
	F__fpu_ip        t__uint32_t
	F__fpu_cs        t__uint16_t
	F__fpu_rsrv2     t__uint16_t
	F__fpu_dp        t__uint32_t
	F__fpu_ds        t__uint16_t
	F__fpu_rsrv3     t__uint16_t
	F__fpu_mxcsr     t__uint32_t
	F__fpu_mxcsrmask t__uint32_t
	F__fpu_stmm0     t__darwin_mmst_reg
	F__fpu_stmm1     t__darwin_mmst_reg
	F__fpu_stmm2     t__darwin_mmst_reg
	F__fpu_stmm3     t__darwin_mmst_reg
	F__fpu_stmm4     t__darwin_mmst_reg
	F__fpu_stmm5     t__darwin_mmst_reg
	F__fpu_stmm6     t__darwin_mmst_reg
	F__fpu_stmm7     t__darwin_mmst_reg
	F__fpu_xmm0      t__darwin_xmm_reg
	F__fpu_xmm1      t__darwin_xmm_reg
	F__fpu_xmm2      t__darwin_xmm_reg
	F__fpu_xmm3      t__darwin_xmm_reg
	F__fpu_xmm4      t__darwin_xmm_reg
	F__fpu_xmm5      t__darwin_xmm_reg
	F__fpu_xmm6      t__darwin_xmm_reg
	F__fpu_xmm7      t__darwin_xmm_reg
	F__fpu_rsrv4     [224]int8
	F__fpu_reserved1 int32
	F__avx_reserved1 [64]int8
	F__fpu_ymmh0     t__darwin_xmm_reg
	F__fpu_ymmh1     t__darwin_xmm_reg
	F__fpu_ymmh2     t__darwin_xmm_reg
	F__fpu_ymmh3     t__darwin_xmm_reg
	F__fpu_ymmh4     t__darwin_xmm_reg
	F__fpu_ymmh5     t__darwin_xmm_reg
	F__fpu_ymmh6     t__darwin_xmm_reg
	F__fpu_ymmh7     t__darwin_xmm_reg
	F__fpu_k0        t__darwin_opmask_reg
	F__fpu_k1        t__darwin_opmask_reg
	F__fpu_k2        t__darwin_opmask_reg
	F__fpu_k3        t__darwin_opmask_reg
	F__fpu_k4        t__darwin_opmask_reg
	F__fpu_k5        t__darwin_opmask_reg
	F__fpu_k6        t__darwin_opmask_reg
	F__fpu_k7        t__darwin_opmask_reg
	F__fpu_zmmh0     t__darwin_ymm_reg
	F__fpu_zmmh1     t__darwin_ymm_reg
	F__fpu_zmmh2     t__darwin_ymm_reg
	F__fpu_zmmh3     t__darwin_ymm_reg
	F__fpu_zmmh4     t__darwin_ymm_reg
	F__fpu_zmmh5     t__darwin_ymm_reg
	F__fpu_zmmh6     t__darwin_ymm_reg
	F__fpu_zmmh7     t__darwin_ymm_reg
}

type t__darwin_i386_exception_state = struct {
	F__trapno     t__uint16_t
	F__cpu        t__uint16_t
	F__err        t__uint32_t
	F__faultvaddr t__uint32_t
}

type t__darwin_x86_debug_state32 = struct {
	F__dr0 uint32
	F__dr1 uint32
	F__dr2 uint32
	F__dr3 uint32
	F__dr4 uint32
	F__dr5 uint32
	F__dr6 uint32
	F__dr7 uint32
}

type t__x86_instruction_state = struct {
	F__insn_stream_valid_bytes int32
	F__insn_offset             int32
	F__out_of_synch            int32
	F__insn_bytes              [2380]t__uint8_t
	F__insn_cacheline          [64]t__uint8_t
}

type t__last_branch_record = struct {
	F__from_ip t__uint64_t
	F__to_ip   t__uint64_t
	F__ccgo16  uint32
}

type t__last_branch_state = struct {
	F__lbr_count int32
	F__ccgo4     uint32
	F__lbrs      [32]t__last_branch_record
}

type t__x86_pagein_state = struct {
	F__pagein_error int32
}

type t__darwin_x86_thread_state64 = struct {
	F__rax    t__uint64_t
	F__rbx    t__uint64_t
	F__rcx    t__uint64_t
	F__rdx    t__uint64_t
	F__rdi    t__uint64_t
	F__rsi    t__uint64_t
	F__rbp    t__uint64_t
	F__rsp    t__uint64_t
	F__r8     t__uint64_t
	F__r9     t__uint64_t
	F__r10    t__uint64_t
	F__r11    t__uint64_t
	F__r12    t__uint64_t
	F__r13    t__uint64_t
	F__r14    t__uint64_t
	F__r15    t__uint64_t
	F__rip    t__uint64_t
	F__rflags t__uint64_t
	F__cs     t__uint64_t
	F__fs     t__uint64_t
	F__gs     t__uint64_t
}

type t__darwin_x86_thread_full_state64 = struct {
	F__ss64   t__darwin_x86_thread_state64
	F__ds     t__uint64_t
	F__es     t__uint64_t
	F__ss     t__uint64_t
	F__gsbase t__uint64_t
}

type t__darwin_x86_float_state64 = struct {
	F__fpu_reserved  [2]int32
	F__fpu_fcw       t__darwin_fp_control
	F__fpu_fsw       t__darwin_fp_status
	F__fpu_ftw       t__uint8_t
	F__fpu_rsrv1     t__uint8_t
	F__fpu_fop       t__uint16_t
	F__fpu_ip        t__uint32_t
	F__fpu_cs        t__uint16_t
	F__fpu_rsrv2     t__uint16_t
	F__fpu_dp        t__uint32_t
	F__fpu_ds        t__uint16_t
	F__fpu_rsrv3     t__uint16_t
	F__fpu_mxcsr     t__uint32_t
	F__fpu_mxcsrmask t__uint32_t
	F__fpu_stmm0     t__darwin_mmst_reg
	F__fpu_stmm1     t__darwin_mmst_reg
	F__fpu_stmm2     t__darwin_mmst_reg
	F__fpu_stmm3     t__darwin_mmst_reg
	F__fpu_stmm4     t__darwin_mmst_reg
	F__fpu_stmm5     t__darwin_mmst_reg
	F__fpu_stmm6     t__darwin_mmst_reg
	F__fpu_stmm7     t__darwin_mmst_reg
	F__fpu_xmm0      t__darwin_xmm_reg
	F__fpu_xmm1      t__darwin_xmm_reg
	F__fpu_xmm2      t__darwin_xmm_reg
	F__fpu_xmm3      t__darwin_xmm_reg
	F__fpu_xmm4      t__darwin_xmm_reg
	F__fpu_xmm5      t__darwin_xmm_reg
	F__fpu_xmm6      t__darwin_xmm_reg
	F__fpu_xmm7      t__darwin_xmm_reg
	F__fpu_xmm8      t__darwin_xmm_reg
	F__fpu_xmm9      t__darwin_xmm_reg
	F__fpu_xmm10     t__darwin_xmm_reg
	F__fpu_xmm11     t__darwin_xmm_reg
	F__fpu_xmm12     t__darwin_xmm_reg
	F__fpu_xmm13     t__darwin_xmm_reg
	F__fpu_xmm14     t__darwin_xmm_reg
	F__fpu_xmm15     t__darwin_xmm_reg
	F__fpu_rsrv4     [96]int8
	F__fpu_reserved1 int32
}

type t__darwin_x86_avx_state64 = struct {
	F__fpu_reserved  [2]int32
	F__fpu_fcw       t__darwin_fp_control
	F__fpu_fsw       t__darwin_fp_status
	F__fpu_ftw       t__uint8_t
	F__fpu_rsrv1     t__uint8_t
	F__fpu_fop       t__uint16_t
	F__fpu_ip        t__uint32_t
	F__fpu_cs        t__uint16_t
	F__fpu_rsrv2     t__uint16_t
	F__fpu_dp        t__uint32_t
	F__fpu_ds        t__uint16_t
	F__fpu_rsrv3     t__uint16_t
	F__fpu_mxcsr     t__uint32_t
	F__fpu_mxcsrmask t__uint32_t
	F__fpu_stmm0     t__darwin_mmst_reg
	F__fpu_stmm1     t__darwin_mmst_reg
	F__fpu_stmm2     t__darwin_mmst_reg
	F__fpu_stmm3     t__darwin_mmst_reg
	F__fpu_stmm4     t__darwin_mmst_reg
	F__fpu_stmm5     t__darwin_mmst_reg
	F__fpu_stmm6     t__darwin_mmst_reg
	F__fpu_stmm7     t__darwin_mmst_reg
	F__fpu_xmm0      t__darwin_xmm_reg
	F__fpu_xmm1      t__darwin_xmm_reg
	F__fpu_xmm2      t__darwin_xmm_reg
	F__fpu_xmm3      t__darwin_xmm_reg
	F__fpu_xmm4      t__darwin_xmm_reg
	F__fpu_xmm5      t__darwin_xmm_reg
	F__fpu_xmm6      t__darwin_xmm_reg
	F__fpu_xmm7      t__darwin_xmm_reg
	F__fpu_xmm8      t__darwin_xmm_reg
	F__fpu_xmm9      t__darwin_xmm_reg
	F__fpu_xmm10     t__darwin_xmm_reg
	F__fpu_xmm11     t__darwin_xmm_reg
	F__fpu_xmm12     t__darwin_xmm_reg
	F__fpu_xmm13     t__darwin_xmm_reg
	F__fpu_xmm14     t__darwin_xmm_reg
	F__fpu_xmm15     t__darwin_xmm_reg
	F__fpu_rsrv4     [96]int8
	F__fpu_reserved1 int32
	F__avx_reserved1 [64]int8
	F__fpu_ymmh0     t__darwin_xmm_reg
	F__fpu_ymmh1     t__darwin_xmm_reg
	F__fpu_ymmh2     t__darwin_xmm_reg
	F__fpu_ymmh3     t__darwin_xmm_reg
	F__fpu_ymmh4     t__darwin_xmm_reg
	F__fpu_ymmh5     t__darwin_xmm_reg
	F__fpu_ymmh6     t__darwin_xmm_reg
	F__fpu_ymmh7     t__darwin_xmm_reg
	F__fpu_ymmh8     t__darwin_xmm_reg
	F__fpu_ymmh9     t__darwin_xmm_reg
	F__fpu_ymmh10    t__darwin_xmm_reg
	F__fpu_ymmh11    t__darwin_xmm_reg
	F__fpu_ymmh12    t__darwin_xmm_reg
	F__fpu_ymmh13    t__darwin_xmm_reg
	F__fpu_ymmh14    t__darwin_xmm_reg
	F__fpu_ymmh15    t__darwin_xmm_reg
}

type t__darwin_x86_avx512_state64 = struct {
	F__fpu_reserved  [2]int32
	F__fpu_fcw       t__darwin_fp_control
	F__fpu_fsw       t__darwin_fp_status
	F__fpu_ftw       t__uint8_t
	F__fpu_rsrv1     t__uint8_t
	F__fpu_fop       t__uint16_t
	F__fpu_ip        t__uint32_t
	F__fpu_cs        t__uint16_t
	F__fpu_rsrv2     t__uint16_t
	F__fpu_dp        t__uint32_t
	F__fpu_ds        t__uint16_t
	F__fpu_rsrv3     t__uint16_t
	F__fpu_mxcsr     t__uint32_t
	F__fpu_mxcsrmask t__uint32_t
	F__fpu_stmm0     t__darwin_mmst_reg
	F__fpu_stmm1     t__darwin_mmst_reg
	F__fpu_stmm2     t__darwin_mmst_reg
	F__fpu_stmm3     t__darwin_mmst_reg
	F__fpu_stmm4     t__darwin_mmst_reg
	F__fpu_stmm5     t__darwin_mmst_reg
	F__fpu_stmm6     t__darwin_mmst_reg
	F__fpu_stmm7     t__darwin_mmst_reg
	F__fpu_xmm0      t__darwin_xmm_reg
	F__fpu_xmm1      t__darwin_xmm_reg
	F__fpu_xmm2      t__darwin_xmm_reg
	F__fpu_xmm3      t__darwin_xmm_reg
	F__fpu_xmm4      t__darwin_xmm_reg
	F__fpu_xmm5      t__darwin_xmm_reg
	F__fpu_xmm6      t__darwin_xmm_reg
	F__fpu_xmm7      t__darwin_xmm_reg
	F__fpu_xmm8      t__darwin_xmm_reg
	F__fpu_xmm9      t__darwin_xmm_reg
	F__fpu_xmm10     t__darwin_xmm_reg
	F__fpu_xmm11     t__darwin_xmm_reg
	F__fpu_xmm12     t__darwin_xmm_reg
	F__fpu_xmm13     t__darwin_xmm_reg
	F__fpu_xmm14     t__darwin_xmm_reg
	F__fpu_xmm15     t__darwin_xmm_reg
	F__fpu_rsrv4     [96]int8
	F__fpu_reserved1 int32
	F__avx_reserved1 [64]int8
	F__fpu_ymmh0     t__darwin_xmm_reg
	F__fpu_ymmh1     t__darwin_xmm_reg
	F__fpu_ymmh2     t__darwin_xmm_reg
	F__fpu_ymmh3     t__darwin_xmm_reg
	F__fpu_ymmh4     t__darwin_xmm_reg
	F__fpu_ymmh5     t__darwin_xmm_reg
	F__fpu_ymmh6     t__darwin_xmm_reg
	F__fpu_ymmh7     t__darwin_xmm_reg
	F__fpu_ymmh8     t__darwin_xmm_reg
	F__fpu_ymmh9     t__darwin_xmm_reg
	F__fpu_ymmh10    t__darwin_xmm_reg
	F__fpu_ymmh11    t__darwin_xmm_reg
	F__fpu_ymmh12    t__darwin_xmm_reg
	F__fpu_ymmh13    t__darwin_xmm_reg
	F__fpu_ymmh14    t__darwin_xmm_reg
	F__fpu_ymmh15    t__darwin_xmm_reg
	F__fpu_k0        t__darwin_opmask_reg
	F__fpu_k1        t__darwin_opmask_reg
	F__fpu_k2        t__darwin_opmask_reg
	F__fpu_k3        t__darwin_opmask_reg
	F__fpu_k4        t__darwin_opmask_reg
	F__fpu_k5        t__darwin_opmask_reg
	F__fpu_k6        t__darwin_opmask_reg
	F__fpu_k7        t__darwin_opmask_reg
	F__fpu_zmmh0     t__darwin_ymm_reg
	F__fpu_zmmh1     t__darwin_ymm_reg
	F__fpu_zmmh2     t__darwin_ymm_reg
	F__fpu_zmmh3     t__darwin_ymm_reg
	F__fpu_zmmh4     t__darwin_ymm_reg
	F__fpu_zmmh5     t__darwin_ymm_reg
	F__fpu_zmmh6     t__darwin_ymm_reg
	F__fpu_zmmh7     t__darwin_ymm_reg
	F__fpu_zmmh8     t__darwin_ymm_reg
	F__fpu_zmmh9     t__darwin_ymm_reg
	F__fpu_zmmh10    t__darwin_ymm_reg
	F__fpu_zmmh11    t__darwin_ymm_reg
	F__fpu_zmmh12    t__darwin_ymm_reg
	F__fpu_zmmh13    t__darwin_ymm_reg
	F__fpu_zmmh14    t__darwin_ymm_reg
	F__fpu_zmmh15    t__darwin_ymm_reg
	F__fpu_zmm16     t__darwin_zmm_reg
	F__fpu_zmm17     t__darwin_zmm_reg
	F__fpu_zmm18     t__darwin_zmm_reg
	F__fpu_zmm19     t__darwin_zmm_reg
	F__fpu_zmm20     t__darwin_zmm_reg
	F__fpu_zmm21     t__darwin_zmm_reg
	F__fpu_zmm22     t__darwin_zmm_reg
	F__fpu_zmm23     t__darwin_zmm_reg
	F__fpu_zmm24     t__darwin_zmm_reg
	F__fpu_zmm25     t__darwin_zmm_reg
	F__fpu_zmm26     t__darwin_zmm_reg
	F__fpu_zmm27     t__darwin_zmm_reg
	F__fpu_zmm28     t__darwin_zmm_reg
	F__fpu_zmm29     t__darwin_zmm_reg
	F__fpu_zmm30     t__darwin_zmm_reg
	F__fpu_zmm31     t__darwin_zmm_reg
}

type t__darwin_x86_exception_state64 = struct {
	F__trapno     t__uint16_t
	F__cpu        t__uint16_t
	F__err        t__uint32_t
	F__faultvaddr t__uint64_t
}

type t__darwin_x86_debug_state64 = struct {
	F__dr0 t__uint64_t
	F__dr1 t__uint64_t
	F__dr2 t__uint64_t
	F__dr3 t__uint64_t
	F__dr4 t__uint64_t
	F__dr5 t__uint64_t
	F__dr6 t__uint64_t
	F__dr7 t__uint64_t
}

type t__darwin_x86_cpmu_state64 = struct {
	F__ctrs [16]t__uint64_t
}

type t__darwin_mcontext32 = struct {
	F__es t__darwin_i386_exception_state
	F__ss t__darwin_i386_thread_state
	F__fs t__darwin_i386_float_state
}

type t__darwin_mcontext_avx32 = struct {
	F__es t__darwin_i386_exception_state
	F__ss t__darwin_i386_thread_state
	F__fs t__darwin_i386_avx_state
}

type t__darwin_mcontext_avx512_32 = struct {
	F__es t__darwin_i386_exception_state
	F__ss t__darwin_i386_thread_state
	F__fs t__darwin_i386_avx512_state
}

type t__darwin_mcontext64 = struct {
	F__es t__darwin_x86_exception_state64
	F__ss t__darwin_x86_thread_state64
	F__fs t__darwin_x86_float_state64
}

type t__darwin_mcontext64_full = struct {
	F__es t__darwin_x86_exception_state64
	F__ss t__darwin_x86_thread_full_state64
	F__fs t__darwin_x86_float_state64
}

type t__darwin_mcontext_avx64 = struct {
	F__es t__darwin_x86_exception_state64
	F__ss t__darwin_x86_thread_state64
	F__fs t__darwin_x86_avx_state64
}

type t__darwin_mcontext_avx64_full = struct {
	F__es t__darwin_x86_exception_state64
	F__ss t__darwin_x86_thread_full_state64
	F__fs t__darwin_x86_avx_state64
}

type t__darwin_mcontext_avx512_64 = struct {
	F__es t__darwin_x86_exception_state64
	F__ss t__darwin_x86_thread_state64
	F__fs t__darwin_x86_avx512_state64
}

type t__darwin_mcontext_avx512_64_full = struct {
	F__es t__darwin_x86_exception_state64
	F__ss t__darwin_x86_thread_full_state64
	F__fs t__darwin_x86_avx512_state64
}

type Tmcontext_t = uintptr

type Tpthread_attr_t = struct {
	F__sig    int64
	F__opaque [56]int8
}

type t__darwin_sigaltstack = struct {
	Fss_sp    uintptr
	Fss_size  t__darwin_size_t
	Fss_flags int32
}

type Tstack_t = struct {
	Fss_sp    uintptr
	Fss_size  t__darwin_size_t
	Fss_flags int32
}

type t__darwin_ucontext = struct {
	Fuc_onstack  int32
	Fuc_sigmask  t__darwin_sigset_t
	Fuc_stack    t__darwin_sigaltstack
	Fuc_link     uintptr
	Fuc_mcsize   t__darwin_size_t
	Fuc_mcontext uintptr
}

type Tucontext_t = struct {
	Fuc_onstack  int32
	Fuc_sigmask  t__darwin_sigset_t
	Fuc_stack    t__darwin_sigaltstack
	Fuc_link     uintptr
	Fuc_mcsize   t__darwin_size_t
	Fuc_mcontext uintptr
}

type Tsigset_t = uint32

type Tsize_t = uint64

type Tuid_t = uint32

type Tsigval = struct {
	Fsival_ptr   [0]uintptr
	Fsival_int   int32
	F__ccgo_pad2 [4]byte
}

type Tsigevent = struct {
	Fsigev_notify            int32
	Fsigev_signo             int32
	Fsigev_value             Tsigval
	Fsigev_notify_function   uintptr
	Fsigev_notify_attributes uintptr
}

type Tsiginfo_t = struct {
	Fsi_signo  int32
	Fsi_errno  int32
	Fsi_code   int32
	Fsi_pid    Tpid_t
	Fsi_uid    Tuid_t
	Fsi_status int32
	Fsi_addr   uintptr
	Fsi_value  Tsigval
	Fsi_band   int64
	F__pad     [7]uint64
}

type t__siginfo = Tsiginfo_t

type t__sigaction_u = struct {
	F__sa_sigaction [0]uintptr
	F__sa_handler   uintptr
}

type t__sigaction = struct {
	F__sigaction_u t__sigaction_u
	Fsa_tramp      uintptr
	Fsa_mask       Tsigset_t
	Fsa_flags      int32
}

type Tsigaction = struct {
	F__sigaction_u t__sigaction_u
	Fsa_mask       Tsigset_t
	Fsa_flags      int32
}

type Tsig_t = uintptr

type Tsigvec = struct {
	Fsv_handler uintptr
	Fsv_mask    int32
	Fsv_flags   int32
}

type Tsigstack = struct {
	Fss_sp      uintptr
	Fss_onstack int32
}

type Ttimeval = struct {
	Ftv_sec  t__darwin_time_t
	Ftv_usec t__darwin_suseconds_t
}

type Trlim_t = uint64

type Trusage = struct {
	Fru_utime    Ttimeval
	Fru_stime    Ttimeval
	Fru_maxrss   int64
	Fru_ixrss    int64
	Fru_idrss    int64
	Fru_isrss    int64
	Fru_minflt   int64
	Fru_majflt   int64
	Fru_nswap    int64
	Fru_inblock  int64
	Fru_oublock  int64
	Fru_msgsnd   int64
	Fru_msgrcv   int64
	Fru_nsignals int64
	Fru_nvcsw    int64
	Fru_nivcsw   int64
}

type Trusage_info_t = uintptr

type Trusage_info_v0 = struct {
	Fri_uuid               [16]Tuint8_t
	Fri_user_time          Tuint64_t
	Fri_system_time        Tuint64_t
	Fri_pkg_idle_wkups     Tuint64_t
	Fri_interrupt_wkups    Tuint64_t
	Fri_pageins            Tuint64_t
	Fri_wired_size         Tuint64_t
	Fri_resident_size      Tuint64_t
	Fri_phys_footprint     Tuint64_t
	Fri_proc_start_abstime Tuint64_t
	Fri_proc_exit_abstime  Tuint64_t
}

type Trusage_info_v1 = struct {
	Fri_uuid                  [16]Tuint8_t
	Fri_user_time             Tuint64_t
	Fri_system_time           Tuint64_t
	Fri_pkg_idle_wkups        Tuint64_t
	Fri_interrupt_wkups       Tuint64_t
	Fri_pageins               Tuint64_t
	Fri_wired_size            Tuint64_t
	Fri_resident_size         Tuint64_t
	Fri_phys_footprint        Tuint64_t
	Fri_proc_start_abstime    Tuint64_t
	Fri_proc_exit_abstime     Tuint64_t
	Fri_child_user_time       Tuint64_t
	Fri_child_system_time     Tuint64_t
	Fri_child_pkg_idle_wkups  Tuint64_t
	Fri_child_interrupt_wkups Tuint64_t
	Fri_child_pageins         Tuint64_t
	Fri_child_elapsed_abstime Tuint64_t
}

type Trusage_info_v2 = struct {
	Fri_uuid                  [16]Tuint8_t
	Fri_user_time             Tuint64_t
	Fri_system_time           Tuint64_t
	Fri_pkg_idle_wkups        Tuint64_t
	Fri_interrupt_wkups       Tuint64_t
	Fri_pageins               Tuint64_t
	Fri_wired_size            Tuint64_t
	Fri_resident_size         Tuint64_t
	Fri_phys_footprint        Tuint64_t
	Fri_proc_start_abstime    Tuint64_t
	Fri_proc_exit_abstime     Tuint64_t
	Fri_child_user_time       Tuint64_t
	Fri_child_system_time     Tuint64_t
	Fri_child_pkg_idle_wkups  Tuint64_t
	Fri_child_interrupt_wkups Tuint64_t
	Fri_child_pageins         Tuint64_t
	Fri_child_elapsed_abstime Tuint64_t
	Fri_diskio_bytesread      Tuint64_t
	Fri_diskio_byteswritten   Tuint64_t
}

type Trusage_info_v3 = struct {
	Fri_uuid                          [16]Tuint8_t
	Fri_user_time                     Tuint64_t
	Fri_system_time                   Tuint64_t
	Fri_pkg_idle_wkups                Tuint64_t
	Fri_interrupt_wkups               Tuint64_t
	Fri_pageins                       Tuint64_t
	Fri_wired_size                    Tuint64_t
	Fri_resident_size                 Tuint64_t
	Fri_phys_footprint                Tuint64_t
	Fri_proc_start_abstime            Tuint64_t
	Fri_proc_exit_abstime             Tuint64_t
	Fri_child_user_time               Tuint64_t
	Fri_child_system_time             Tuint64_t
	Fri_child_pkg_idle_wkups          Tuint64_t
	Fri_child_interrupt_wkups         Tuint64_t
	Fri_child_pageins                 Tuint64_t
	Fri_child_elapsed_abstime         Tuint64_t
	Fri_diskio_bytesread              Tuint64_t
	Fri_diskio_byteswritten           Tuint64_t
	Fri_cpu_time_qos_default          Tuint64_t
	Fri_cpu_time_qos_maintenance      Tuint64_t
	Fri_cpu_time_qos_background       Tuint64_t
	Fri_cpu_time_qos_utility          Tuint64_t
	Fri_cpu_time_qos_legacy           Tuint64_t
	Fri_cpu_time_qos_user_initiated   Tuint64_t
	Fri_cpu_time_qos_user_interactive Tuint64_t
	Fri_billed_system_time            Tuint64_t
	Fri_serviced_system_time          Tuint64_t
}

type Trusage_info_v4 = struct {
	Fri_uuid                          [16]Tuint8_t
	Fri_user_time                     Tuint64_t
	Fri_system_time                   Tuint64_t
	Fri_pkg_idle_wkups                Tuint64_t
	Fri_interrupt_wkups               Tuint64_t
	Fri_pageins                       Tuint64_t
	Fri_wired_size                    Tuint64_t
	Fri_resident_size                 Tuint64_t
	Fri_phys_footprint                Tuint64_t
	Fri_proc_start_abstime            Tuint64_t
	Fri_proc_exit_abstime             Tuint64_t
	Fri_child_user_time               Tuint64_t
	Fri_child_system_time             Tuint64_t
	Fri_child_pkg_idle_wkups          Tuint64_t
	Fri_child_interrupt_wkups         Tuint64_t
	Fri_child_pageins                 Tuint64_t
	Fri_child_elapsed_abstime         Tuint64_t
	Fri_diskio_bytesread              Tuint64_t
	Fri_diskio_byteswritten           Tuint64_t
	Fri_cpu_time_qos_default          Tuint64_t
	Fri_cpu_time_qos_maintenance      Tuint64_t
	Fri_cpu_time_qos_background       Tuint64_t
	Fri_cpu_time_qos_utility          Tuint64_t
	Fri_cpu_time_qos_legacy           Tuint64_t
	Fri_cpu_time_qos_user_initiated   Tuint64_t
	Fri_cpu_time_qos_user_interactive Tuint64_t
	Fri_billed_system_time            Tuint64_t
	Fri_serviced_system_time          Tuint64_t
	Fri_logical_writes                Tuint64_t
	Fri_lifetime_max_phys_footprint   Tuint64_t
	Fri_instructions                  Tuint64_t
	Fri_cycles                        Tuint64_t
	Fri_billed_energy                 Tuint64_t
	Fri_serviced_energy               Tuint64_t
	Fri_interval_max_phys_footprint   Tuint64_t
	Fri_runnable_time                 Tuint64_t
}

type Trusage_info_v5 = struct {
	Fri_uuid                          [16]Tuint8_t
	Fri_user_time                     Tuint64_t
	Fri_system_time                   Tuint64_t
	Fri_pkg_idle_wkups                Tuint64_t
	Fri_interrupt_wkups               Tuint64_t
	Fri_pageins                       Tuint64_t
	Fri_wired_size                    Tuint64_t
	Fri_resident_size                 Tuint64_t
	Fri_phys_footprint                Tuint64_t
	Fri_proc_start_abstime            Tuint64_t
	Fri_proc_exit_abstime             Tuint64_t
	Fri_child_user_time               Tuint64_t
	Fri_child_system_time             Tuint64_t
	Fri_child_pkg_idle_wkups          Tuint64_t
	Fri_child_interrupt_wkups         Tuint64_t
	Fri_child_pageins                 Tuint64_t
	Fri_child_elapsed_abstime         Tuint64_t
	Fri_diskio_bytesread              Tuint64_t
	Fri_diskio_byteswritten           Tuint64_t
	Fri_cpu_time_qos_default          Tuint64_t
	Fri_cpu_time_qos_maintenance      Tuint64_t
	Fri_cpu_time_qos_background       Tuint64_t
	Fri_cpu_time_qos_utility          Tuint64_t
	Fri_cpu_time_qos_legacy           Tuint64_t
	Fri_cpu_time_qos_user_initiated   Tuint64_t
	Fri_cpu_time_qos_user_interactive Tuint64_t
	Fri_billed_system_time            Tuint64_t
	Fri_serviced_system_time          Tuint64_t
	Fri_logical_writes                Tuint64_t
	Fri_lifetime_max_phys_footprint   Tuint64_t
	Fri_instructions                  Tuint64_t
	Fri_cycles                        Tuint64_t
	Fri_billed_energy                 Tuint64_t
	Fri_serviced_energy               Tuint64_t
	Fri_interval_max_phys_footprint   Tuint64_t
	Fri_runnable_time                 Tuint64_t
	Fri_flags                         Tuint64_t
}

type Trusage_info_v6 = struct {
	Fri_uuid                          [16]Tuint8_t
	Fri_user_time                     Tuint64_t
	Fri_system_time                   Tuint64_t
	Fri_pkg_idle_wkups                Tuint64_t
	Fri_interrupt_wkups               Tuint64_t
	Fri_pageins                       Tuint64_t
	Fri_wired_size                    Tuint64_t
	Fri_resident_size                 Tuint64_t
	Fri_phys_footprint                Tuint64_t
	Fri_proc_start_abstime            Tuint64_t
	Fri_proc_exit_abstime             Tuint64_t
	Fri_child_user_time               Tuint64_t
	Fri_child_system_time             Tuint64_t
	Fri_child_pkg_idle_wkups          Tuint64_t
	Fri_child_interrupt_wkups         Tuint64_t
	Fri_child_pageins                 Tuint64_t
	Fri_child_elapsed_abstime         Tuint64_t
	Fri_diskio_bytesread              Tuint64_t
	Fri_diskio_byteswritten           Tuint64_t
	Fri_cpu_time_qos_default          Tuint64_t
	Fri_cpu_time_qos_maintenance      Tuint64_t
	Fri_cpu_time_qos_background       Tuint64_t
	Fri_cpu_time_qos_utility          Tuint64_t
	Fri_cpu_time_qos_legacy           Tuint64_t
	Fri_cpu_time_qos_user_initiated   Tuint64_t
	Fri_cpu_time_qos_user_interactive Tuint64_t
	Fri_billed_system_time            Tuint64_t
	Fri_serviced_system_time          Tuint64_t
	Fri_logical_writes                Tuint64_t
	Fri_lifetime_max_phys_footprint   Tuint64_t
	Fri_instructions                  Tuint64_t
	Fri_cycles                        Tuint64_t
	Fri_billed_energy                 Tuint64_t
	Fri_serviced_energy               Tuint64_t
	Fri_interval_max_phys_footprint   Tuint64_t
	Fri_runnable_time                 Tuint64_t
	Fri_flags                         Tuint64_t
	Fri_user_ptime                    Tuint64_t
	Fri_system_ptime                  Tuint64_t
	Fri_pinstructions                 Tuint64_t
	Fri_pcycles                       Tuint64_t
	Fri_energy_nj                     Tuint64_t
	Fri_penergy_nj                    Tuint64_t
	Fri_secure_time_in_system         Tuint64_t
	Fri_secure_ptime_in_system        Tuint64_t
	Fri_neural_footprint              Tuint64_t
	Fri_lifetime_max_neural_footprint Tuint64_t
	Fri_interval_max_neural_footprint Tuint64_t
	Fri_reserved                      [9]Tuint64_t
}

type Trusage_info_current = struct {
	Fri_uuid                          [16]Tuint8_t
	Fri_user_time                     Tuint64_t
	Fri_system_time                   Tuint64_t
	Fri_pkg_idle_wkups                Tuint64_t
	Fri_interrupt_wkups               Tuint64_t
	Fri_pageins                       Tuint64_t
	Fri_wired_size                    Tuint64_t
	Fri_resident_size                 Tuint64_t
	Fri_phys_footprint                Tuint64_t
	Fri_proc_start_abstime            Tuint64_t
	Fri_proc_exit_abstime             Tuint64_t
	Fri_child_user_time               Tuint64_t
	Fri_child_system_time             Tuint64_t
	Fri_child_pkg_idle_wkups          Tuint64_t
	Fri_child_interrupt_wkups         Tuint64_t
	Fri_child_pageins                 Tuint64_t
	Fri_child_elapsed_abstime         Tuint64_t
	Fri_diskio_bytesread              Tuint64_t
	Fri_diskio_byteswritten           Tuint64_t
	Fri_cpu_time_qos_default          Tuint64_t
	Fri_cpu_time_qos_maintenance      Tuint64_t
	Fri_cpu_time_qos_background       Tuint64_t
	Fri_cpu_time_qos_utility          Tuint64_t
	Fri_cpu_time_qos_legacy           Tuint64_t
	Fri_cpu_time_qos_user_initiated   Tuint64_t
	Fri_cpu_time_qos_user_interactive Tuint64_t
	Fri_billed_system_time            Tuint64_t
	Fri_serviced_system_time          Tuint64_t
	Fri_logical_writes                Tuint64_t
	Fri_lifetime_max_phys_footprint   Tuint64_t
	Fri_instructions                  Tuint64_t
	Fri_cycles                        Tuint64_t
	Fri_billed_energy                 Tuint64_t
	Fri_serviced_energy               Tuint64_t
	Fri_interval_max_phys_footprint   Tuint64_t
	Fri_runnable_time                 Tuint64_t
	Fri_flags                         Tuint64_t
	Fri_user_ptime                    Tuint64_t
	Fri_system_ptime                  Tuint64_t
	Fri_pinstructions                 Tuint64_t
	Fri_pcycles                       Tuint64_t
	Fri_energy_nj                     Tuint64_t
	Fri_penergy_nj                    Tuint64_t
	Fri_secure_time_in_system         Tuint64_t
	Fri_secure_ptime_in_system        Tuint64_t
	Fri_neural_footprint              Tuint64_t
	Fri_lifetime_max_neural_footprint Tuint64_t
	Fri_interval_max_neural_footprint Tuint64_t
	Fri_reserved                      [9]Tuint64_t
}

type Trlimit = struct {
	Frlim_cur Trlim_t
	Frlim_max Trlim_t
}

type Tproc_rlimit_control_wakeupmon = struct {
	Fwm_flags Tuint32_t
	Fwm_rate  Tint32_t
}

type Twait = struct {
	Fw_T [0]struct {
		F__ccgo0 uint32
	}
	Fw_S [0]struct {
		F__ccgo0 uint32
	}
	Fw_status int32
}

type Tct_rune_t = int32

type Trune_t = int32

type Twchar_t = int32

type Tdiv_t = struct {
	Fquot int32
	Frem  int32
}

type Tldiv_t = struct {
	Fquot int64
	Frem  int64
}

type Tlldiv_t = struct {
	Fquot int64
	Frem  int64
}

type Tmalloc_type_id_t = uint64

type Tdev_t = int32

type Tmode_t = uint16

type Tva_list = uintptr

type Tfpos_t = int64

type t__sbuf = struct {
	F_base uintptr
	F_size int32
}

type TFILE = struct {
	F_p       uintptr
	F_r       int32
	F_w       int32
	F_flags   int16
	F_file    int16
	F_bf      t__sbuf
	F_lbfsize int32
	F_cookie  uintptr
	F_close   uintptr
	F_read    uintptr
	F_seek    uintptr
	F_write   uintptr
	F_ub      t__sbuf
	F_extra   uintptr
	F_ur      int32
	F_ubuf    [3]uint8
	F_nbuf    [1]uint8
	F_lb      t__sbuf
	F_blksize int32
	F_offset  Tfpos_t
}

type t__sFILE = TFILE

type Toff_t = int64

type Tssize_t = int64

type Trsize_t = uint64

type Terrno_t = int32

type Twint_t = int32

type T_RuneEntry = struct {
	F__min   t__darwin_rune_t
	F__max   t__darwin_rune_t
	F__map   t__darwin_rune_t
	F__types uintptr
}

type T_RuneRange = struct {
	F__nranges int32
	F__ranges  uintptr
}

type T_RuneCharClass = struct {
	F__name [14]int8
	F__mask t__uint32_t
}

type T_RuneLocale = struct {
	F__magic        [8]int8
	F__encoding     [32]int8
	F__sgetrune     uintptr
	F__sputrune     uintptr
	F__invalid_rune t__darwin_rune_t
	F__runetype     [256]t__uint32_t
	F__maplower     [256]t__darwin_rune_t
	F__mapupper     [256]t__darwin_rune_t
	F__runetype_ext T_RuneRange
	F__maplower_ext T_RuneRange
	F__mapupper_ext T_RuneRange
	F__variable     uintptr
	F__variable_len int32
	F__ncharclasses int32
	F__charclasses  uintptr
}

type Tfloat_t = float32

type Tdouble_t = float64

type t__float2 = struct {
	F__sinval float32
	F__cosval float32
}

type t__double2 = struct {
	F__sinval float64
	F__cosval float64
}

type Texception = struct {
	Ftype1  int32
	Fname   uintptr
	Farg1   float64
	Farg2   float64
	Fretval float64
}

type Taccessx_descriptor = struct {
	Fad_name_offset uint32
	Fad_flags       int32
	Fad_pad         [2]int32
}

type Tgid_t = uint32

type Tuseconds_t = uint32

type Tfd_set = struct {
	Ffds_bits [32]t__int32_t
}

type Ttimespec = struct {
	Ftv_sec  t__darwin_time_t
	Ftv_nsec int64
}

type Ttime_t = int64

type Tsuseconds_t = int32

type Tuuid_t = [16]uint8

type Tptrdiff_t = int64

type Tmax_align_t = float64

type Tu_char = uint8

type Tu_short = uint16

type Tu_int = uint32

type Tu_long = uint64

type Tushort = uint16

type Tuint = uint32

type Tu_quad_t = uint64

type Tquad_t = int64

type Tqaddr_t = uintptr

type Tcaddr_t = uintptr

type Tdaddr_t = int32

type Tfixpt_t = uint32

type Tblkcnt_t = int64

type Tblksize_t = int32

type Tin_addr_t = uint32

type Tin_port_t = uint16

type Tino_t = uint64

type Tino64_t = uint64

type Tkey_t = int32

type Tnlink_t = uint16

type Tsegsz_t = int32

type Tswblk_t = int32

type Tclock_t = uint64

type Tfd_mask = int32

type Tpthread_cond_t = struct {
	F__sig    int64
	F__opaque [40]int8
}

type Tpthread_condattr_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type Tpthread_mutex_t = struct {
	F__sig    int64
	F__opaque [56]int8
}

type Tpthread_mutexattr_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type Tpthread_once_t = struct {
	F__sig    int64
	F__opaque [8]int8
}

type Tpthread_rwlock_t = struct {
	F__sig    int64
	F__opaque [192]int8
}

type Tpthread_rwlockattr_t = struct {
	F__sig    int64
	F__opaque [16]int8
}

type Tpthread_t = uintptr

type Tpthread_key_t = uint64

type Tfsblkcnt_t = uint32

type Tfsfilcnt_t = uint32

type Tostat = struct {
	Fst_dev       t__uint16_t
	Fst_ino       Tino_t
	Fst_mode      Tmode_t
	Fst_nlink     Tnlink_t
	Fst_uid       t__uint16_t
	Fst_gid       t__uint16_t
	Fst_rdev      t__uint16_t
	Fst_size      t__int32_t
	Fst_atimespec Ttimespec
	Fst_mtimespec Ttimespec
	Fst_ctimespec Ttimespec
	Fst_blksize   t__int32_t
	Fst_blocks    t__int32_t
	Fst_flags     t__uint32_t
	Fst_gen       t__uint32_t
}

type Tstat = struct {
	Fst_dev           Tdev_t
	Fst_mode          Tmode_t
	Fst_nlink         Tnlink_t
	Fst_ino           t__darwin_ino64_t
	Fst_uid           Tuid_t
	Fst_gid           Tgid_t
	Fst_rdev          Tdev_t
	Fst_atimespec     Ttimespec
	Fst_mtimespec     Ttimespec
	Fst_ctimespec     Ttimespec
	Fst_birthtimespec Ttimespec
	Fst_size          Toff_t
	Fst_blocks        Tblkcnt_t
	Fst_blksize       Tblksize_t
	Fst_flags         t__uint32_t
	Fst_gen           t__uint32_t
	Fst_lspare        t__int32_t
	Fst_qspare        [2]t__int64_t
}

type Tstat64 = struct {
	Fst_dev           Tdev_t
	Fst_mode          Tmode_t
	Fst_nlink         Tnlink_t
	Fst_ino           t__darwin_ino64_t
	Fst_uid           Tuid_t
	Fst_gid           Tgid_t
	Fst_rdev          Tdev_t
	Fst_atimespec     Ttimespec
	Fst_mtimespec     Ttimespec
	Fst_ctimespec     Ttimespec
	Fst_birthtimespec Ttimespec
	Fst_size          Toff_t
	Fst_blocks        Tblkcnt_t
	Fst_blksize       Tblksize_t
	Fst_flags         t__uint32_t
	Fst_gen           t__uint32_t
	Fst_lspare        t__int32_t
	Fst_qspare        [2]t__int64_t
}

type Tfilesec_t = uintptr

type Ttm = struct {
	Ftm_sec    int32
	Ftm_min    int32
	Ftm_hour   int32
	Ftm_mday   int32
	Ftm_mon    int32
	Ftm_year   int32
	Ftm_wday   int32
	Ftm_yday   int32
	Ftm_isdst  int32
	Ftm_gmtoff int64
	Ftm_zone   uintptr
} //TODO "timezone" // _time.h:106:13:

type Tclockid_t = int32

const __CLOCK_REALTIME = 0
const __CLOCK_MONOTONIC = 6
const __CLOCK_MONOTONIC_RAW = 4
const __CLOCK_MONOTONIC_RAW_APPROX = 5
const __CLOCK_UPTIME_RAW = 8
const __CLOCK_UPTIME_RAW_APPROX = 9
const __CLOCK_PROCESS_CPUTIME_ID = 12
const __CLOCK_THREAD_CPUTIME_ID = 16

type t__gnuc_va_list = uintptr

type TFcChar8 = uint8

type TFcChar16 = uint16

type TFcChar32 = uint32

type TFcBool = int32

type TFcType = int32

type __FcType = int32

const _FcTypeUnknown = -1
const _FcTypeVoid = 0
const _FcTypeInteger = 1
const _FcTypeDouble = 2
const _FcTypeString = 3
const _FcTypeBool = 4
const _FcTypeMatrix = 5
const _FcTypeCharSet = 6
const _FcTypeFTFace = 7
const _FcTypeLangSet = 8
const _FcTypeRange = 9

type TFcMatrix = struct {
	Fxx float64
	Fxy float64
	Fyx float64
	Fyy float64
}

type T_FcMatrix = TFcMatrix

type TFcCharSet = struct {
	Fref            TFcRef
	Fnum            int32
	Fleaves_offset  Tintptr_t
	Fnumbers_offset Tintptr_t
}

type T_FcCharSet = TFcCharSet

type TFcObjectType = struct {
	Fobject uintptr
	Ftype1  TFcType
}

type T_FcObjectType = TFcObjectType

type TFcConstant = struct {
	Fname   uintptr
	Fobject uintptr
	Fvalue  int32
}

type T_FcConstant = TFcConstant

type TFcResult = int32

type __FcResult = int32

const _FcResultMatch = 0
const _FcResultNoMatch = 1
const _FcResultTypeMismatch = 2
const _FcResultNoId = 3
const _FcResultOutOfMemory = 4

type TFcValueBinding = int32

type __FcValueBinding = int32

const _FcValueBindingWeak = 0
const _FcValueBindingStrong = 1
const _FcValueBindingSame = 2
const _FcValueBindingEnd = 2147483647

type TFcPattern = struct {
	Fnum         int32
	Fsize        int32
	Felts_offset Tintptr_t
	Fref         TFcRef
}

type T_FcPattern = TFcPattern

type TFcPatternIter = struct {
	Fdummy1 uintptr
	Fdummy2 uintptr
}

type T_FcPatternIter = TFcPatternIter

type TFcRange = struct {
	Fbegin float64
	Fend   float64
}

type T_FcRange = TFcRange

type TFcValue = struct {
	Ftype1 TFcType
	Fu     struct {
		Fi [0]int32
		Fb [0]TFcBool
		Fd [0]float64
		Fm [0]uintptr
		Fc [0]uintptr
		Ff [0]uintptr
		Fl [0]uintptr
		Fr [0]uintptr
		Fs uintptr
	}
}

type T_FcValue = TFcValue

type TFcFontSet = struct {
	Fnfont int32
	Fsfont int32
	Ffonts uintptr
}

type T_FcFontSet = TFcFontSet

type TFcObjectSet = struct {
	Fnobject int32
	Fsobject int32
	Fobjects uintptr
}

type T_FcObjectSet = TFcObjectSet

type TFcMatchKind = int32

type __FcMatchKind = int32

const _FcMatchPattern = 0
const _FcMatchFont = 1
const _FcMatchScan = 2
const _FcMatchKindEnd = 3
const _FcMatchKindBegin = 0

type TFcLangResult = int32

type __FcLangResult = int32

const _FcLangEqual = 0
const _FcLangDifferentCountry = 1
const _FcLangDifferentTerritory = 1
const _FcLangDifferentLang = 2

type TFcSetName = int32

type __FcSetName = int32

const _FcSetSystem = 0
const _FcSetApplication = 1

type TFcConfigFileInfoIter = struct {
	Fdummy1 uintptr
	Fdummy2 uintptr
	Fdummy3 uintptr
}

type T_FcConfigFileInfoIter = TFcConfigFileInfoIter

type TFcAtomic = struct {
	Ffile uintptr
	Fnew1 uintptr
	Flck  uintptr
	Ftmp  uintptr
}

type T_FcAtomic = TFcAtomic

type TFcEndian = int32

const _FcEndianBig = 0
const _FcEndianLittle = 1

type TFcConfig = struct {
	FconfigDirs       uintptr
	FconfigMapDirs    uintptr
	FfontDirs         uintptr
	FcacheDirs        uintptr
	FconfigFiles      uintptr
	Fsubst            [3]uintptr
	FmaxObjects       int32
	FacceptGlobs      uintptr
	FrejectGlobs      uintptr
	FacceptPatterns   uintptr
	FrejectPatterns   uintptr
	Ffonts            [2]uintptr
	FrescanTime       Ttime_t
	FrescanInterval   int32
	Fref              TFcRef
	Fexpr_pool        uintptr
	FsysRoot          uintptr
	FavailConfigFiles uintptr
	FrulesetList      uintptr
}

type T_FcConfig = TFcConfig

type TFcStrList = struct {
	Fset uintptr
	Fn   int32
}

type T_FcStrList = TFcStrList

type TFcStrSet = struct {
	Fref     TFcRef
	Fnum     int32
	Fsize    int32
	Fstrs    uintptr
	Fcontrol uint32
}

type T_FcStrSet = TFcStrSet

type TFcCache = struct {
	Fmagic         uint32
	Fversion       int32
	Fsize          Tintptr_t
	Fdir           Tintptr_t
	Fdirs          Tintptr_t
	Fdirs_count    int32
	Fset           Tintptr_t
	Fchecksum      int32
	Fchecksum_nano Tint64_t
}

type T_FcCache = TFcCache

type Tfc_mutex_impl_t = int32

type TFcMutex = int32

type Tfc_atomic_int_t = int32

type TFcRef = struct {
	Fcount Tfc_atomic_int_t
}

type T_FcRef = TFcRef

type T_static_assert_on_line_141_failed = [1]int32

type TFcValueListPtr = uintptr

type T_FcValueList = struct {
	Fnext    uintptr
	Fvalue   TFcValue
	Fbinding TFcValueBinding
}

type TFcValueList = struct {
	Fnext    uintptr
	Fvalue   TFcValue
	Fbinding TFcValueBinding
}

type TFcObject = int32

type TFcPatternEltPtr = uintptr

type T_FcPatternElt = struct {
	Fobject TFcObject
	Fvalues uintptr
}

type TFcPatternElt = struct {
	Fobject TFcObject
	Fvalues uintptr
}

type TFcOp = int32

type __FcOp = int32

const _FcOpInteger = 0
const _FcOpDouble = 1
const _FcOpString = 2
const _FcOpMatrix = 3
const _FcOpRange = 4
const _FcOpBool = 5
const _FcOpCharSet = 6
const _FcOpLangSet = 7
const _FcOpNil = 8
const _FcOpField = 9
const _FcOpConst = 10
const _FcOpAssign = 11
const _FcOpAssignReplace = 12
const _FcOpPrependFirst = 13
const _FcOpPrepend = 14
const _FcOpAppend = 15
const _FcOpAppendLast = 16
const _FcOpDelete = 17
const _FcOpDeleteAll = 18
const _FcOpQuest = 19
const _FcOpOr = 20
const _FcOpAnd = 21
const _FcOpEqual = 22
const _FcOpNotEqual = 23
const _FcOpContains = 24
const _FcOpListing = 25
const _FcOpNotContains = 26
const _FcOpLess = 27
const _FcOpLessEqual = 28
const _FcOpMore = 29
const _FcOpMoreEqual = 30
const _FcOpPlus = 31
const _FcOpMinus = 32
const _FcOpTimes = 33
const _FcOpDivide = 34
const _FcOpNot = 35
const _FcOpComma = 36
const _FcOpFloor = 37
const _FcOpCeil = 38
const _FcOpRound = 39
const _FcOpTrunc = 40
const _FcOpInvalid = 41

type TFcOpFlags = int32

type __FcOpFlags = int32

const _FcOpFlagIgnoreBlanks = 1

type TFcExprMatrix = struct {
	Fxx uintptr
	Fxy uintptr
	Fyx uintptr
	Fyy uintptr
}

type T_FcExprMatrix = TFcExprMatrix

type TFcExprName = struct {
	Fobject TFcObject
	Fkind   TFcMatchKind
}

type T_FcExprName = TFcExprName

type TFcExpr = struct {
	Fop TFcOp
	Fu  struct {
		Fdval     [0]float64
		Fsval     [0]uintptr
		Fmexpr    [0]uintptr
		Fbval     [0]TFcBool
		Fcval     [0]uintptr
		Flval     [0]uintptr
		Frval     [0]uintptr
		Fname     [0]TFcExprName
		Fconstant [0]uintptr
		Ftree     [0]struct {
			Fleft  uintptr
			Fright uintptr
		}
		Fival         int32
		F__ccgo_pad11 [12]byte
	}
}

type T_FcExpr = TFcExpr

type TFcExprPage = struct {
	Fnext_page uintptr
	Fnext      uintptr
	Fexprs     [340]TFcExpr
}

type T_FcExprPage = TFcExprPage

type TFcQual = int32

type __FcQual = int32

const _FcQualAny = 0
const _FcQualAll = 1
const _FcQualFirst = 2
const _FcQualNotFirst = 3

type TFcTest = struct {
	Fkind   TFcMatchKind
	Fqual   TFcQual
	Fobject TFcObject
	Fop     TFcOp
	Fexpr   uintptr
}

type T_FcTest = TFcTest

type TFcEdit = struct {
	Fobject  TFcObject
	Fop      TFcOp
	Fexpr    uintptr
	Fbinding TFcValueBinding
}

type T_FcEdit = TFcEdit

type TFcDestroyFunc = uintptr

type TFcPtrListIter = struct {
	Fdummy1 uintptr
	Fdummy2 uintptr
	Fdummy3 uintptr
}

type T_FcPtrListIter = TFcPtrListIter

type TFcRuleType = int32

type __FcRuleType = int32

const _FcRuleUnknown = 0
const _FcRuleTest = 1
const _FcRuleEdit = 2

type TFcRule = struct {
	Fnext  uintptr
	Ftype1 TFcRuleType
	Fu     struct {
		Fedit [0]uintptr
		Ftest uintptr
	}
}

type T_FcRule = TFcRule

type TFcRuleSet = struct {
	Fref         TFcRef
	Fname        uintptr
	Fdescription uintptr
	Fdomain      uintptr
	Fenabled     TFcBool
	Fsubst       [3]uintptr
}

type T_FcRuleSet = TFcRuleSet

type TFcCharLeaf = struct {
	Fmap1 [8]TFcChar32
}

type T_FcCharLeaf = TFcCharLeaf

type TFcStrBuf = struct {
	Fbuf        uintptr
	Fallocated  TFcBool
	Ffailed     TFcBool
	Flen1       int32
	Fsize       int32
	Fbuf_static [128]TFcChar8
}

type T_FcStrBuf = TFcStrBuf

type TFcHashFunc = uintptr

type TFcCompareFunc = uintptr

type TFcCopyFunc = uintptr

type TFcAlign = struct {
	Fi  [0]int32
	Fip [0]Tintptr_t
	Fb  [0]TFcBool
	Fp  [0]uintptr
	Fd  float64
}

type T_FcAlign = TFcAlign

type TFcSerializeBucket = struct {
	Fobject uintptr
	Fhash   Tuintptr_t
	Foffset Tintptr_t
}

type T_FcSerializeBucket = TFcSerializeBucket

type TFcSerialize = struct {
	Fsize             Tintptr_t
	Fcs_freezer       uintptr
	Flinear           uintptr
	Fbuckets          uintptr
	Fbuckets_count    Tsize_t
	Fbuckets_used     Tsize_t
	Fbuckets_used_max Tsize_t
}

type T_FcSerialize = TFcSerialize

type TFcGlyphName = struct {
	Fucs  TFcChar32
	Fname [1]TFcChar8
}

type T_FcGlyphName = TFcGlyphName

type TFcCaseFold = struct {
	Fupper   TFcChar32
	F__ccgo4 uint16
	Foffset  int16
}

type T_FcCaseFold = TFcCaseFold

type TFcFileTime = struct {
	Ftime Ttime_t
	Fset  TFcBool
}

type T_FcFileTime = TFcFileTime

type TFcStatFS = struct {
	Fis_remote_fs    TFcBool
	Fis_mtime_broken TFcBool
}

type T_FcStatFS = TFcStatFS

type TFcValuePromotionBuffer = struct {
	Fu struct {
		Fi           [0]int32
		Fl           [0]int64
		Fc           [0][256]int8
		Fd           float64
		F__ccgo_pad4 [248]byte
	}
}

type T_FcValuePromotionBuffer = TFcValuePromotionBuffer

const _FC_INVALID_OBJECT = 0
const _FC_FAMILY_OBJECT = 1
const _FC_FAMILYLANG_OBJECT = 2
const _FC_STYLE_OBJECT = 3
const _FC_STYLELANG_OBJECT = 4
const _FC_FULLNAME_OBJECT = 5
const _FC_FULLNAMELANG_OBJECT = 6
const _FC_SLANT_OBJECT = 7
const _FC_WEIGHT_OBJECT = 8
const _FC_WIDTH_OBJECT = 9
const _FC_SIZE_OBJECT = 10
const _FC_ASPECT_OBJECT = 11
const _FC_PIXEL_SIZE_OBJECT = 12
const _FC_SPACING_OBJECT = 13
const _FC_FOUNDRY_OBJECT = 14
const _FC_ANTIALIAS_OBJECT = 15
const _FC_HINT_STYLE_OBJECT = 16
const _FC_HINTING_OBJECT = 17
const _FC_VERTICAL_LAYOUT_OBJECT = 18
const _FC_AUTOHINT_OBJECT = 19
const _FC_GLOBAL_ADVANCE_OBJECT = 20
const _FC_FILE_OBJECT = 21
const _FC_INDEX_OBJECT = 22
const _FC_RASTERIZER_OBJECT = 23
const _FC_OUTLINE_OBJECT = 24
const _FC_SCALABLE_OBJECT = 25
const _FC_DPI_OBJECT = 26
const _FC_RGBA_OBJECT = 27
const _FC_SCALE_OBJECT = 28
const _FC_MINSPACE_OBJECT = 29
const _FC_CHARWIDTH_OBJECT = 30
const _FC_CHAR_HEIGHT_OBJECT = 31
const _FC_MATRIX_OBJECT = 32
const _FC_CHARSET_OBJECT = 33
const _FC_LANG_OBJECT = 34
const _FC_FONTVERSION_OBJECT = 35
const _FC_CAPABILITY_OBJECT = 36
const _FC_FONTFORMAT_OBJECT = 37
const _FC_EMBOLDEN_OBJECT = 38
const _FC_EMBEDDED_BITMAP_OBJECT = 39
const _FC_DECORATIVE_OBJECT = 40
const _FC_LCD_FILTER_OBJECT = 41
const _FC_NAMELANG_OBJECT = 42
const _FC_FONT_FEATURES_OBJECT = 43
const _FC_PRGNAME_OBJECT = 44
const _FC_HASH_OBJECT = 45
const _FC_POSTSCRIPT_NAME_OBJECT = 46
const _FC_COLOR_OBJECT = 47
const _FC_SYMBOL_OBJECT = 48
const _FC_FONT_VARIATIONS_OBJECT = 49
const _FC_VARIABLE_OBJECT = 50
const _FC_FONT_HAS_HINT_OBJECT = 51
const _FC_ORDER_OBJECT = 52
const _FC_ONE_AFTER_MAX_BASE_OBJECT = 53

/*
 * Copyright (c) 2000-2021 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)types.h	8.4 (Berkeley) 1/21/94
 */

/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*-
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stat.h	8.9 (Berkeley) 8/17/94
 */

/*
 * Copyright (c) 2000, 2002 - 2008, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2000, 2023 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.3 (Berkeley) 1/21/94
 */

/*
 * Copyright (c) 2023 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.3 (Berkeley) 1/21/94
 */

/*
 * Copyright (c) 2000, 2002-2006, 2008-2010, 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1998-1999 Apple Computer, Inc. All Rights Reserved
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)unistd.h	8.12 (Berkeley) 4/27/95
 *
 *  Copyright (c)  1998 Apple Compter, Inc.
 *  All Rights Reserved
 */

/* History:
      7/14/99 EKN at Apple fixed getdirentriesattr from getdirentryattr
      3/26/98 CHW at Apple added real interface to searchfs call
	3/5/98  CHW at Apple added hfs semantic system calls headers
*/

func XFcAtomicCreate(tls *libc.TLS, file uintptr) (r uintptr) {
	var atomic uintptr
	var file_len, lck_len, new_len, tmp_len, total_len int32
	_, _, _, _, _, _ = atomic, file_len, lck_len, new_len, tmp_len, total_len
	file_len = libc.Int32FromUint64(libc.Xstrlen(tls, file))
	new_len = libc.Int32FromUint64(libc.Uint64FromInt32(file_len) + uint64(5))
	lck_len = libc.Int32FromUint64(libc.Uint64FromInt32(file_len) + uint64(5))
	tmp_len = libc.Int32FromUint64(libc.Uint64FromInt32(file_len) + uint64(12))
	total_len = libc.Int32FromUint64(libc.Uint64FromInt64(32) + libc.Uint64FromInt32(file_len) + libc.Uint64FromInt32(1) + libc.Uint64FromInt32(new_len) + libc.Uint64FromInt32(1) + libc.Uint64FromInt32(lck_len) + libc.Uint64FromInt32(1) + libc.Uint64FromInt32(tmp_len) + libc.Uint64FromInt32(1))
	atomic = libc.Xmalloc(tls, libc.Uint64FromInt32(total_len))
	if !(atomic != 0) {
		return uintptr(0)
	}
	(*TFcAtomic)(unsafe.Pointer(atomic)).Ffile = atomic + libc.UintptrFromInt32(1)*32
	libc.X__builtin___strcpy_chk(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Ffile, file, ^t__predefined_size_t(0))
	(*TFcAtomic)(unsafe.Pointer(atomic)).Fnew1 = (*TFcAtomic)(unsafe.Pointer(atomic)).Ffile + uintptr(file_len) + uintptr(1)
	libc.X__builtin___strcpy_chk(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Fnew1, file, ^t__predefined_size_t(0))
	libc.X__builtin___strcat_chk(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Fnew1, __ccgo_ts, ^t__predefined_size_t(0))
	(*TFcAtomic)(unsafe.Pointer(atomic)).Flck = (*TFcAtomic)(unsafe.Pointer(atomic)).Fnew1 + uintptr(new_len) + uintptr(1)
	libc.X__builtin___strcpy_chk(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Flck, file, ^t__predefined_size_t(0))
	libc.X__builtin___strcat_chk(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Flck, __ccgo_ts+5, ^t__predefined_size_t(0))
	(*TFcAtomic)(unsafe.Pointer(atomic)).Ftmp = (*TFcAtomic)(unsafe.Pointer(atomic)).Flck + uintptr(lck_len) + uintptr(1)
	return atomic
}

func XFcAtomicLock(tls *libc.TLS, atomic uintptr) (r TFcBool) {
	bp := tls.Alloc(160)
	defer tls.Free(160)
	var f uintptr
	var fd, ret int32
	var no_link TFcBool
	var now Ttime_t
	var _ /* lck_stat at bp+0 */ Tstat
	_, _, _, _, _ = f, fd, no_link, now, ret
	fd = -int32(1)
	f = uintptr(0)
	no_link = m_FcFalse
	libc.X__builtin___strcpy_chk(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Ftmp, (*TFcAtomic)(unsafe.Pointer(atomic)).Ffile, ^t__predefined_size_t(0))
	libc.X__builtin___strcat_chk(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Ftmp, __ccgo_ts+10, ^t__predefined_size_t(0))
	fd = XFcMakeTempfile(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Ftmp)
	if fd < 0 {
		return m_FcFalse
	}
	f = libc.Xfdopen(tls, fd, __ccgo_ts+22)
	if !(f != 0) {
		libc.Xclose(tls, fd)
		libc.Xunlink(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Ftmp)
		return m_FcFalse
	}
	ret = libc.Xfprintf(tls, f, __ccgo_ts+24, libc.VaList(bp+152, int64(libc.Xgetpid(tls))))
	if ret <= 0 {
		libc.Xfclose(tls, f)
		libc.Xunlink(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Ftmp)
		return m_FcFalse
	}
	if libc.Xfclose(tls, f) == -int32(1) {
		libc.Xunlink(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Ftmp)
		return m_FcFalse
	}
	ret = libc.Xlink(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Ftmp, (*TFcAtomic)(unsafe.Pointer(atomic)).Flck)
	if ret < 0 && (*(*int32)(unsafe.Pointer(libc.X__error(tls))) == int32(m_EPERM) || *(*int32)(unsafe.Pointer(libc.X__error(tls))) == int32(m_ENOTSUP) || *(*int32)(unsafe.Pointer(libc.X__error(tls))) == int32(m_EACCES)) {
		/* the filesystem where atomic->lck points to may not supports
		 * the hard link. so better try to fallback
		 */
		ret = libc.Xmkdir(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Flck, uint16(0600))
		no_link = int32(m_FcTrue)
	}
	libc.Xunlink(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Ftmp)
	if ret < 0 {
		/*
		 * If the file is around and old (> 10 minutes),
		 * assume the lock is stale.  This assumes that any
		 * machines sharing the same filesystem will have clocks
		 * reasonably close to each other.
		 */
		if XFcStat(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Flck, bp) >= 0 {
			now = libc.Xtime(tls, uintptr(0))
			if now-(*(*Tstat)(unsafe.Pointer(bp))).Fst_mtimespec.Ftv_sec > int64(libc.Int32FromInt32(10)*libc.Int32FromInt32(60)) {
				if no_link != 0 {
					if libc.Xrmdir(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Flck) == 0 {
						return XFcAtomicLock(tls, atomic)
					}
				} else {
					if libc.Xunlink(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Flck) == 0 {
						return XFcAtomicLock(tls, atomic)
					}
				}
			}
		}
		return m_FcFalse
	}
	libc.Xunlink(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Fnew1)
	return int32(m_FcTrue)
}

func XFcAtomicNewFile(tls *libc.TLS, atomic uintptr) (r uintptr) {
	return (*TFcAtomic)(unsafe.Pointer(atomic)).Fnew1
}

func XFcAtomicOrigFile(tls *libc.TLS, atomic uintptr) (r uintptr) {
	return (*TFcAtomic)(unsafe.Pointer(atomic)).Ffile
}

func XFcAtomicReplaceOrig(tls *libc.TLS, atomic uintptr) (r TFcBool) {
	if libc.Xrename(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Fnew1, (*TFcAtomic)(unsafe.Pointer(atomic)).Ffile) < 0 {
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

func XFcAtomicDeleteNew(tls *libc.TLS, atomic uintptr) {
	libc.Xunlink(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Fnew1)
}

func XFcAtomicUnlock(tls *libc.TLS, atomic uintptr) {
	if libc.Xunlink(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Flck) == -int32(1) {
		libc.Xrmdir(tls, (*TFcAtomic)(unsafe.Pointer(atomic)).Flck)
	}
}

func XFcAtomicDestroy(tls *libc.TLS, atomic uintptr) {
	libc.Xfree(tls, atomic)
}

const m_ATTRIBUTION_NAME_MAX = 255
const m_AT_EACCESS = 0x0010
const m_AT_FDONLY = 0x0400
const m_AT_REALDEV = 0x0200
const m_AT_REMOVEDIR = 0x0080
const m_AT_SYMLINK_FOLLOW = 0x0040
const m_AT_SYMLINK_NOFOLLOW = 0x0020
const m_AT_SYMLINK_NOFOLLOW_ANY = 0x0800
const m_CPF_IGNORE_MODE = 0x0002
const m_CPF_OVERWRITE = 0x0001
const m_DIRBLKSIZ = 1024
const m_DST_AUST = 2
const m_DST_CAN = 6
const m_DST_EET = 5
const m_DST_MET = 4
const m_DST_NONE = 0
const m_DST_USA = 1
const m_DST_WET = 3
const m_DTF_HIDEW = 0x0001
const m_DTF_NODUP = 0x0002
const m_DTF_REWIND = 0x0004
const m_DT_BLK = 6
const m_DT_CHR = 2
const m_DT_DIR = 4
const m_DT_FIFO = 1
const m_DT_LNK = 10
const m_DT_REG = 8
const m_DT_SOCK = 12
const m_DT_UNKNOWN = 0
const m_DT_WHT = 14
const m_FAPPEND = "O_APPEND"
const m_FASYNC = "O_ASYNC"
const m_FCNTL_FS_SPECIFIC_BASE = 0x00010000
const m_FC_ARCH_ENDIAN = "le64"
const m_FC_ARCH_SIZE_ALIGN = "64"
const m_FC_CACHE_MAGIC_ALLOC1 = 4228054021
const m_FC_CACHE_MAGIC_MMAP1 = 4228054020
const m_FC_CACHE_MAX_LEVEL = 16
const m_FC_CACHE_MIN_MMAP = 1024
const m_FD_CLOEXEC = 1
const m_FFDSYNC = "O_DSYNC"
const m_FFSYNC = "O_FSYNC"
const m_FILESEC_GUID = "FILESEC_UUID"
const m_FNDELAY = "O_NONBLOCK"
const m_FNONBLOCK = "O_NONBLOCK"
const m_FREAD = 0x00000001
const m_FWRITE = 0x00000002
const m_F_ADDFILESIGS = 61
const m_F_ADDFILESIGS_FOR_DYLD_SIM = 83
const m_F_ADDFILESIGS_INFO = 103
const m_F_ADDFILESIGS_RETURN = 97
const m_F_ADDFILESUPPL = 104
const m_F_ADDSIGS = 59
const m_F_ADDSIGS_MAIN_BINARY = 113
const m_F_ALLOCATEALL = 0x00000004
const m_F_ALLOCATECONTIG = 0x00000002
const m_F_ALLOCATEPERSIST = 0x00000008
const m_F_ATTRIBUTION_TAG = 111
const m_F_BARRIERFSYNC = 85
const m_F_CHECK_LV = 98
const m_F_CHKCLEAN = 41
const m_F_CREATE_TAG = 0x00000001
const m_F_DELETE_TAG = 0x00000002
const m_F_DUPFD = 0
const m_F_DUPFD_CLOEXEC = 67
const m_F_FINDSIGS = 78
const m_F_FLUSH_DATA = 40
const m_F_FREEZE_FS = 53
const m_F_FULLFSYNC = 51
const m_F_GETCODEDIR = 72
const m_F_GETFD = 1
const m_F_GETFL = 3
const m_F_GETLEASE = 107
const m_F_GETLK = 7
const m_F_GETLKPID = 66
const m_F_GETNOSIGPIPE = 74
const m_F_GETOWN = 5
const m_F_GETPATH = 50
const m_F_GETPATH_MTMINFO = 71
const m_F_GETPATH_NOFIRMLINK = 102
const m_F_GETPROTECTIONCLASS = 63
const m_F_GETPROTECTIONLEVEL = 77
const m_F_GETSIGSINFO = 105
const m_F_GLOBAL_NOCACHE = 55
const m_F_LOG2PHYS = 49
const m_F_LOG2PHYS_EXT = 65
const m_F_NOCACHE = 48
const m_F_NODIRECT = 62
const m_F_OFD_GETLK = 92
const m_F_OFD_SETLK = 90
const m_F_OFD_SETLKW = 91
const m_F_OFD_SETLKWTIMEOUT = 93
const m_F_PATHPKG_CHECK = 52
const m_F_PEOFPOSMODE = 3
const m_F_PREALLOCATE = 42
const m_F_PUNCHHOLE = 99
const m_F_QUERY_TAG = 0x00000004
const m_F_RDADVISE = 44
const m_F_RDAHEAD = 45
const m_F_RDLCK = 1
const m_F_SETBACKINGSTORE = 70
const m_F_SETFD = 2
const m_F_SETFL = 4
const m_F_SETLEASE = 106
const m_F_SETLK = 8
const m_F_SETLKW = 9
const m_F_SETLKWTIMEOUT = 10
const m_F_SETNOSIGPIPE = 73
const m_F_SETOWN = 6
const m_F_SETPROTECTIONCLASS = 64
const m_F_SETSIZE = 43
const m_F_SINGLE_WRITER = 76
const m_F_SPECULATIVE_READ = 101
const m_F_THAW_FS = 54
const m_F_TRANSCODEKEY = 75
const m_F_TRANSFEREXTENTS = 110
const m_F_TRIM_ACTIVE_FILE = 100
const m_F_UNLCK = 2
const m_F_VOLPOSMODE = 4
const m_F_WRLCK = 3
const m_GETSIGSINFO_PLATFORM_BINARY = 1
const m_ITIMER_PROF = 2
const m_ITIMER_REAL = 0
const m_ITIMER_VIRTUAL = 1
const m_LOCK_EX = 0x02
const m_LOCK_NB = 0x04
const m_LOCK_SH = 0x01
const m_LOCK_UN = 0x08
const m_MADV_CAN_REUSE = 9
const m_MADV_DONTNEED = "POSIX_MADV_DONTNEED"
const m_MADV_FREE = 5
const m_MADV_FREE_REUSABLE = 7
const m_MADV_FREE_REUSE = 8
const m_MADV_NORMAL = "POSIX_MADV_NORMAL"
const m_MADV_PAGEOUT = 10
const m_MADV_RANDOM = "POSIX_MADV_RANDOM"
const m_MADV_SEQUENTIAL = "POSIX_MADV_SEQUENTIAL"
const m_MADV_WILLNEED = "POSIX_MADV_WILLNEED"
const m_MADV_ZERO = 11
const m_MADV_ZERO_WIRED_PAGES = 6
const m_MAP_32BIT = 0x8000
const m_MAP_ANON = 0x1000
const m_MAP_ANONYMOUS = "MAP_ANON"
const m_MAP_COPY = "MAP_PRIVATE"
const m_MAP_FILE = 0x0000
const m_MAP_FIXED = 0x0010
const m_MAP_HASSEMAPHORE = 0x0200
const m_MAP_JIT = 0x0800
const m_MAP_NOCACHE = 0x0400
const m_MAP_NOEXTEND = 0x0100
const m_MAP_NORESERVE = 0x0040
const m_MAP_PRIVATE = 0x0002
const m_MAP_RENAME = 0x0020
const m_MAP_RESERVED0080 = 0x0080
const m_MAP_RESILIENT_CODESIGN = 0x2000
const m_MAP_RESILIENT_MEDIA = 0x4000
const m_MAP_SHARED = 1
const m_MAP_TPRO = 0x80000
const m_MAP_TRANSLATED_ALLOW_EXECUTE = 0x20000
const m_MAP_UNIX03 = 0x40000
const m_MAXNAMLEN = "__DARWIN_MAXNAMLEN"
const m_MCL_CURRENT = 0x0001
const m_MCL_FUTURE = 0x0002
const m_MINCORE_ANONYMOUS = 0x80
const m_MINCORE_COPIED = 0x40
const m_MINCORE_INCORE = 0x1
const m_MINCORE_MODIFIED = 0x4
const m_MINCORE_MODIFIED_OTHER = 0x10
const m_MINCORE_PAGED_OUT = 0x20
const m_MINCORE_REFERENCED = 0x2
const m_MINCORE_REFERENCED_OTHER = 0x8
const m_MS_ASYNC = 0x0001
const m_MS_DEACTIVATE = 0x0008
const m_MS_INVALIDATE = 0x0002
const m_MS_KILLPAGES = 0x0004
const m_MS_SYNC = 0x0010
const m_O_ACCMODE = 0x0003
const m_O_ALERT = 0x20000000
const m_O_APPEND = 0x00000008
const m_O_ASYNC = 0x00000040
const m_O_BINARY = 0
const m_O_CLOEXEC = 0x01000000
const m_O_CREAT = 512
const m_O_DIRECTORY = 0x00100000
const m_O_DP_AUTHENTICATE = 0x0004
const m_O_DP_GETRAWENCRYPTED = 0x0001
const m_O_DP_GETRAWUNENCRYPTED = 0x0002
const m_O_DSYNC = 0x400000
const m_O_EVTONLY = 0x00008000
const m_O_EXCL = 0x00000800
const m_O_EXEC = 0x40000000
const m_O_EXLOCK = 0x00000020
const m_O_FSYNC = "O_SYNC"
const m_O_NDELAY = "O_NONBLOCK"
const m_O_NOCTTY = 0x00020000
const m_O_NOFOLLOW = 0x00000100
const m_O_NOFOLLOW_ANY = 0x20000000
const m_O_NONBLOCK = 0x00000004
const m_O_POPUP = 0x80000000
const m_O_RDONLY = 0
const m_O_RDWR = 2
const m_O_RESOLVE_BENEATH = 0x00001000
const m_O_SHLOCK = 0x00000010
const m_O_SYMLINK = 0x00200000
const m_O_SYNC = 0x0080
const m_O_TRUNC = 0x00000400
const m_O_WRONLY = 0x0001
const m_POSIX_MADV_DONTNEED = 4
const m_POSIX_MADV_NORMAL = 0
const m_POSIX_MADV_RANDOM = 1
const m_POSIX_MADV_SEQUENTIAL = 2
const m_POSIX_MADV_WILLNEED = 3
const m_PROT_EXEC = 0x04
const m_PROT_NONE = 0x00
const m_PROT_READ = 1
const m_PROT_WRITE = 0x02
const m_USER_FSIGNATURES_CDHASH_LEN = 20
const m___DARWIN_MAXNAMLEN = 255
const m___DARWIN_MAXPATHLEN = 1024
const m___DTF_ATEND = 0x0020
const m___DTF_READALL = 0x0008
const m___DTF_SKIPREAD = 0x0010
const m_d_fileno = "d_ino"

type TMD5Context = struct {
	Fbuf  [4]TFcChar32
	Fbits [2]TFcChar32
	Fin   [64]uint8
}

func _MD5Init(tls *libc.TLS, ctx uintptr) {
	*(*TFcChar32)(unsafe.Pointer(ctx)) = uint32(0x67452301)
	*(*TFcChar32)(unsafe.Pointer(ctx + 1*4)) = uint32(0xefcdab89)
	*(*TFcChar32)(unsafe.Pointer(ctx + 2*4)) = uint32(0x98badcfe)
	*(*TFcChar32)(unsafe.Pointer(ctx + 3*4)) = uint32(0x10325476)
	*(*TFcChar32)(unsafe.Pointer(ctx + 16)) = uint32(0)
	*(*TFcChar32)(unsafe.Pointer(ctx + 16 + 1*4)) = uint32(0)
}

func _MD5Update(tls *libc.TLS, ctx uintptr, buf uintptr, len1 uint32) {
	var p uintptr
	var t, v1 TFcChar32
	_, _, _ = p, t, v1
	t = *(*TFcChar32)(unsafe.Pointer(ctx + 16))
	v1 = t + len1<<libc.Int32FromInt32(3)
	*(*TFcChar32)(unsafe.Pointer(ctx + 16)) = v1
	if v1 < t {
		*(*TFcChar32)(unsafe.Pointer(ctx + 16 + 1*4))++
	}
	*(*TFcChar32)(unsafe.Pointer(ctx + 16 + 1*4)) += len1 >> int32(29)
	t = t >> libc.Int32FromInt32(3) & uint32(0x3f)
	if t != 0 {
		p = ctx + 24 + uintptr(t)
		t = uint32(64) - t
		if len1 < t {
			libc.X__builtin___memcpy_chk(tls, p, buf, uint64(len1), ^t__predefined_size_t(0))
			return
		}
		libc.X__builtin___memcpy_chk(tls, p, buf, uint64(t), ^t__predefined_size_t(0))
		_MD5Transform(tls, ctx, ctx+24)
		buf += uintptr(t)
		len1 -= t
	}
	for len1 >= uint32(64) {
		libc.X__builtin___memcpy_chk(tls, ctx+24, buf, uint64(64), ^t__predefined_size_t(0))
		_MD5Transform(tls, ctx, ctx+24)
		buf += uintptr(64)
		len1 -= uint32(64)
	}
	libc.X__builtin___memcpy_chk(tls, ctx+24, buf, uint64(len1), ^t__predefined_size_t(0))
}

func _MD5Final(tls *libc.TLS, digest uintptr, ctx uintptr) {
	var count uint32
	var p, v1 uintptr
	_, _, _ = count, p, v1
	count = *(*TFcChar32)(unsafe.Pointer(ctx + 16)) >> libc.Int32FromInt32(3) & uint32(0x3F)
	p = ctx + 24 + uintptr(count)
	v1 = p
	p++
	*(*uint8)(unsafe.Pointer(v1)) = uint8(0x80)
	count = libc.Uint32FromInt32(libc.Int32FromInt32(64)-libc.Int32FromInt32(1)) - count
	if count < uint32(8) {
		libc.X__builtin___memset_chk(tls, p, 0, uint64(count), ^t__predefined_size_t(0))
		_MD5Transform(tls, ctx, ctx+24)
		libc.X__builtin___memset_chk(tls, ctx+24, 0, uint64(56), ^t__predefined_size_t(0))
	} else {
		libc.X__builtin___memset_chk(tls, p, 0, uint64(count-uint32(8)), ^t__predefined_size_t(0))
	}
	*(*TFcChar32)(unsafe.Pointer(ctx + 24 + 14*4)) = *(*TFcChar32)(unsafe.Pointer(ctx + 16))
	*(*TFcChar32)(unsafe.Pointer(ctx + 24 + 15*4)) = *(*TFcChar32)(unsafe.Pointer(ctx + 16 + 1*4))
	_MD5Transform(tls, ctx, ctx+24)
	libc.X__builtin___memcpy_chk(tls, digest, ctx, uint64(16), ^t__predefined_size_t(0))
	libc.X__builtin___memset_chk(tls, ctx, 0, uint64(88), ^t__predefined_size_t(0))
}

func _MD5Transform(tls *libc.TLS, buf uintptr, in uintptr) {
	var a, b, c, d TFcChar32
	_, _, _, _ = a, b, c, d
	a = *(*TFcChar32)(unsafe.Pointer(buf))
	b = *(*TFcChar32)(unsafe.Pointer(buf + 1*4))
	c = *(*TFcChar32)(unsafe.Pointer(buf + 2*4))
	d = *(*TFcChar32)(unsafe.Pointer(buf + 3*4))
	a += d ^ b&(c^d) + *(*TFcChar32)(unsafe.Pointer(in)) + uint32(0xd76aa478)
	a = a<<int32(7) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(7))
	a += b
	d += c ^ a&(b^c) + *(*TFcChar32)(unsafe.Pointer(in + 1*4)) + uint32(0xe8c7b756)
	d = d<<int32(12) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(12))
	d += a
	c += b ^ d&(a^b) + *(*TFcChar32)(unsafe.Pointer(in + 2*4)) + uint32(0x242070db)
	c = c<<int32(17) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(17))
	c += d
	b += a ^ c&(d^a) + *(*TFcChar32)(unsafe.Pointer(in + 3*4)) + uint32(0xc1bdceee)
	b = b<<int32(22) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(22))
	b += c
	a += d ^ b&(c^d) + *(*TFcChar32)(unsafe.Pointer(in + 4*4)) + uint32(0xf57c0faf)
	a = a<<int32(7) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(7))
	a += b
	d += c ^ a&(b^c) + *(*TFcChar32)(unsafe.Pointer(in + 5*4)) + uint32(0x4787c62a)
	d = d<<int32(12) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(12))
	d += a
	c += b ^ d&(a^b) + *(*TFcChar32)(unsafe.Pointer(in + 6*4)) + uint32(0xa8304613)
	c = c<<int32(17) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(17))
	c += d
	b += a ^ c&(d^a) + *(*TFcChar32)(unsafe.Pointer(in + 7*4)) + uint32(0xfd469501)
	b = b<<int32(22) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(22))
	b += c
	a += d ^ b&(c^d) + *(*TFcChar32)(unsafe.Pointer(in + 8*4)) + uint32(0x698098d8)
	a = a<<int32(7) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(7))
	a += b
	d += c ^ a&(b^c) + *(*TFcChar32)(unsafe.Pointer(in + 9*4)) + uint32(0x8b44f7af)
	d = d<<int32(12) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(12))
	d += a
	c += b ^ d&(a^b) + *(*TFcChar32)(unsafe.Pointer(in + 10*4)) + uint32(0xffff5bb1)
	c = c<<int32(17) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(17))
	c += d
	b += a ^ c&(d^a) + *(*TFcChar32)(unsafe.Pointer(in + 11*4)) + uint32(0x895cd7be)
	b = b<<int32(22) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(22))
	b += c
	a += d ^ b&(c^d) + *(*TFcChar32)(unsafe.Pointer(in + 12*4)) + uint32(0x6b901122)
	a = a<<int32(7) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(7))
	a += b
	d += c ^ a&(b^c) + *(*TFcChar32)(unsafe.Pointer(in + 13*4)) + uint32(0xfd987193)
	d = d<<int32(12) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(12))
	d += a
	c += b ^ d&(a^b) + *(*TFcChar32)(unsafe.Pointer(in + 14*4)) + uint32(0xa679438e)
	c = c<<int32(17) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(17))
	c += d
	b += a ^ c&(d^a) + *(*TFcChar32)(unsafe.Pointer(in + 15*4)) + uint32(0x49b40821)
	b = b<<int32(22) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(22))
	b += c
	a += c ^ d&(b^c) + *(*TFcChar32)(unsafe.Pointer(in + 1*4)) + uint32(0xf61e2562)
	a = a<<int32(5) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(5))
	a += b
	d += b ^ c&(a^b) + *(*TFcChar32)(unsafe.Pointer(in + 6*4)) + uint32(0xc040b340)
	d = d<<int32(9) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(9))
	d += a
	c += a ^ b&(d^a) + *(*TFcChar32)(unsafe.Pointer(in + 11*4)) + uint32(0x265e5a51)
	c = c<<int32(14) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(14))
	c += d
	b += d ^ a&(c^d) + *(*TFcChar32)(unsafe.Pointer(in)) + uint32(0xe9b6c7aa)
	b = b<<int32(20) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(20))
	b += c
	a += c ^ d&(b^c) + *(*TFcChar32)(unsafe.Pointer(in + 5*4)) + uint32(0xd62f105d)
	a = a<<int32(5) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(5))
	a += b
	d += b ^ c&(a^b) + *(*TFcChar32)(unsafe.Pointer(in + 10*4)) + uint32(0x02441453)
	d = d<<int32(9) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(9))
	d += a
	c += a ^ b&(d^a) + *(*TFcChar32)(unsafe.Pointer(in + 15*4)) + uint32(0xd8a1e681)
	c = c<<int32(14) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(14))
	c += d
	b += d ^ a&(c^d) + *(*TFcChar32)(unsafe.Pointer(in + 4*4)) + uint32(0xe7d3fbc8)
	b = b<<int32(20) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(20))
	b += c
	a += c ^ d&(b^c) + *(*TFcChar32)(unsafe.Pointer(in + 9*4)) + uint32(0x21e1cde6)
	a = a<<int32(5) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(5))
	a += b
	d += b ^ c&(a^b) + *(*TFcChar32)(unsafe.Pointer(in + 14*4)) + uint32(0xc33707d6)
	d = d<<int32(9) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(9))
	d += a
	c += a ^ b&(d^a) + *(*TFcChar32)(unsafe.Pointer(in + 3*4)) + uint32(0xf4d50d87)
	c = c<<int32(14) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(14))
	c += d
	b += d ^ a&(c^d) + *(*TFcChar32)(unsafe.Pointer(in + 8*4)) + uint32(0x455a14ed)
	b = b<<int32(20) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(20))
	b += c
	a += c ^ d&(b^c) + *(*TFcChar32)(unsafe.Pointer(in + 13*4)) + uint32(0xa9e3e905)
	a = a<<int32(5) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(5))
	a += b
	d += b ^ c&(a^b) + *(*TFcChar32)(unsafe.Pointer(in + 2*4)) + uint32(0xfcefa3f8)
	d = d<<int32(9) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(9))
	d += a
	c += a ^ b&(d^a) + *(*TFcChar32)(unsafe.Pointer(in + 7*4)) + uint32(0x676f02d9)
	c = c<<int32(14) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(14))
	c += d
	b += d ^ a&(c^d) + *(*TFcChar32)(unsafe.Pointer(in + 12*4)) + uint32(0x8d2a4c8a)
	b = b<<int32(20) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(20))
	b += c
	a += b ^ c ^ d + *(*TFcChar32)(unsafe.Pointer(in + 5*4)) + uint32(0xfffa3942)
	a = a<<int32(4) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(4))
	a += b
	d += a ^ b ^ c + *(*TFcChar32)(unsafe.Pointer(in + 8*4)) + uint32(0x8771f681)
	d = d<<int32(11) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(11))
	d += a
	c += d ^ a ^ b + *(*TFcChar32)(unsafe.Pointer(in + 11*4)) + uint32(0x6d9d6122)
	c = c<<int32(16) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(16))
	c += d
	b += c ^ d ^ a + *(*TFcChar32)(unsafe.Pointer(in + 14*4)) + uint32(0xfde5380c)
	b = b<<int32(23) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(23))
	b += c
	a += b ^ c ^ d + *(*TFcChar32)(unsafe.Pointer(in + 1*4)) + uint32(0xa4beea44)
	a = a<<int32(4) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(4))
	a += b
	d += a ^ b ^ c + *(*TFcChar32)(unsafe.Pointer(in + 4*4)) + uint32(0x4bdecfa9)
	d = d<<int32(11) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(11))
	d += a
	c += d ^ a ^ b + *(*TFcChar32)(unsafe.Pointer(in + 7*4)) + uint32(0xf6bb4b60)
	c = c<<int32(16) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(16))
	c += d
	b += c ^ d ^ a + *(*TFcChar32)(unsafe.Pointer(in + 10*4)) + uint32(0xbebfbc70)
	b = b<<int32(23) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(23))
	b += c
	a += b ^ c ^ d + *(*TFcChar32)(unsafe.Pointer(in + 13*4)) + uint32(0x289b7ec6)
	a = a<<int32(4) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(4))
	a += b
	d += a ^ b ^ c + *(*TFcChar32)(unsafe.Pointer(in)) + uint32(0xeaa127fa)
	d = d<<int32(11) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(11))
	d += a
	c += d ^ a ^ b + *(*TFcChar32)(unsafe.Pointer(in + 3*4)) + uint32(0xd4ef3085)
	c = c<<int32(16) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(16))
	c += d
	b += c ^ d ^ a + *(*TFcChar32)(unsafe.Pointer(in + 6*4)) + uint32(0x04881d05)
	b = b<<int32(23) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(23))
	b += c
	a += b ^ c ^ d + *(*TFcChar32)(unsafe.Pointer(in + 9*4)) + uint32(0xd9d4d039)
	a = a<<int32(4) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(4))
	a += b
	d += a ^ b ^ c + *(*TFcChar32)(unsafe.Pointer(in + 12*4)) + uint32(0xe6db99e5)
	d = d<<int32(11) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(11))
	d += a
	c += d ^ a ^ b + *(*TFcChar32)(unsafe.Pointer(in + 15*4)) + uint32(0x1fa27cf8)
	c = c<<int32(16) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(16))
	c += d
	b += c ^ d ^ a + *(*TFcChar32)(unsafe.Pointer(in + 2*4)) + uint32(0xc4ac5665)
	b = b<<int32(23) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(23))
	b += c
	a += c ^ (b | ^d) + *(*TFcChar32)(unsafe.Pointer(in)) + uint32(0xf4292244)
	a = a<<int32(6) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(6))
	a += b
	d += b ^ (a | ^c) + *(*TFcChar32)(unsafe.Pointer(in + 7*4)) + uint32(0x432aff97)
	d = d<<int32(10) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(10))
	d += a
	c += a ^ (d | ^b) + *(*TFcChar32)(unsafe.Pointer(in + 14*4)) + uint32(0xab9423a7)
	c = c<<int32(15) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(15))
	c += d
	b += d ^ (c | ^a) + *(*TFcChar32)(unsafe.Pointer(in + 5*4)) + uint32(0xfc93a039)
	b = b<<int32(21) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(21))
	b += c
	a += c ^ (b | ^d) + *(*TFcChar32)(unsafe.Pointer(in + 12*4)) + uint32(0x655b59c3)
	a = a<<int32(6) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(6))
	a += b
	d += b ^ (a | ^c) + *(*TFcChar32)(unsafe.Pointer(in + 3*4)) + uint32(0x8f0ccc92)
	d = d<<int32(10) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(10))
	d += a
	c += a ^ (d | ^b) + *(*TFcChar32)(unsafe.Pointer(in + 10*4)) + uint32(0xffeff47d)
	c = c<<int32(15) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(15))
	c += d
	b += d ^ (c | ^a) + *(*TFcChar32)(unsafe.Pointer(in + 1*4)) + uint32(0x85845dd1)
	b = b<<int32(21) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(21))
	b += c
	a += c ^ (b | ^d) + *(*TFcChar32)(unsafe.Pointer(in + 8*4)) + uint32(0x6fa87e4f)
	a = a<<int32(6) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(6))
	a += b
	d += b ^ (a | ^c) + *(*TFcChar32)(unsafe.Pointer(in + 15*4)) + uint32(0xfe2ce6e0)
	d = d<<int32(10) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(10))
	d += a
	c += a ^ (d | ^b) + *(*TFcChar32)(unsafe.Pointer(in + 6*4)) + uint32(0xa3014314)
	c = c<<int32(15) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(15))
	c += d
	b += d ^ (c | ^a) + *(*TFcChar32)(unsafe.Pointer(in + 13*4)) + uint32(0x4e0811a1)
	b = b<<int32(21) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(21))
	b += c
	a += c ^ (b | ^d) + *(*TFcChar32)(unsafe.Pointer(in + 4*4)) + uint32(0xf7537e82)
	a = a<<int32(6) | a>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(6))
	a += b
	d += b ^ (a | ^c) + *(*TFcChar32)(unsafe.Pointer(in + 11*4)) + uint32(0xbd3af235)
	d = d<<int32(10) | d>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(10))
	d += a
	c += a ^ (d | ^b) + *(*TFcChar32)(unsafe.Pointer(in + 2*4)) + uint32(0x2ad7d2bb)
	c = c<<int32(15) | c>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(15))
	c += d
	b += d ^ (c | ^a) + *(*TFcChar32)(unsafe.Pointer(in + 9*4)) + uint32(0xeb86d391)
	b = b<<int32(21) | b>>(libc.Int32FromInt32(32)-libc.Int32FromInt32(21))
	b += c
	*(*TFcChar32)(unsafe.Pointer(buf)) += a
	*(*TFcChar32)(unsafe.Pointer(buf + 1*4)) += b
	*(*TFcChar32)(unsafe.Pointer(buf + 2*4)) += c
	*(*TFcChar32)(unsafe.Pointer(buf + 3*4)) += d
}

type Tflock = struct {
	Fl_start  Toff_t
	Fl_len    Toff_t
	Fl_pid    Tpid_t
	Fl_type   int16
	Fl_whence int16
}

type Tflocktimeout = struct {
	Ffl      Tflock
	Ftimeout Ttimespec
}

type Tradvisory = struct {
	Fra_offset Toff_t
	Fra_count  int32
}

type Tfsignatures_t = struct {
	Ffs_file_start       Toff_t
	Ffs_blob_start       uintptr
	Ffs_blob_size        Tsize_t
	Ffs_fsignatures_size Tsize_t
	Ffs_cdhash           [20]int8
	Ffs_hash_type        int32
}

type Tfsignatures = Tfsignatures_t

type Tfsupplement_t = struct {
	Ffs_file_start Toff_t
	Ffs_blob_start Toff_t
	Ffs_blob_size  Tsize_t
	Ffs_orig_fd    int32
}

type Tfsupplement = Tfsupplement_t

type Tfchecklv_t = struct {
	Flv_file_start         Toff_t
	Flv_error_message_size Tsize_t
	Flv_error_message      uintptr
}

type Tfchecklv = Tfchecklv_t

type Tfgetsigsinfo_t = struct {
	Ffg_file_start      Toff_t
	Ffg_info_request    int32
	Ffg_sig_is_platform int32
}

type Tfgetsigsinfo = Tfgetsigsinfo_t

type Tfstore_t = struct {
	Ffst_flags      uint32
	Ffst_posmode    int32
	Ffst_offset     Toff_t
	Ffst_length     Toff_t
	Ffst_bytesalloc Toff_t
}

type Tfstore = Tfstore_t

type Tfpunchhole_t = struct {
	Ffp_flags  uint32
	Freserved  uint32
	Ffp_offset Toff_t
	Ffp_length Toff_t
}

type Tfpunchhole = Tfpunchhole_t

type Tftrimactivefile_t = struct {
	Ffta_offset Toff_t
	Ffta_length Toff_t
}

type Tftrimactivefile = Tftrimactivefile_t

type Tfspecread_t = struct {
	Ffsr_flags  uint32
	Freserved   uint32
	Ffsr_offset Toff_t
	Ffsr_length Toff_t
}

type Tfspecread = Tfspecread_t

type Tfattributiontag_t = struct {
	Fft_flags            uint32
	Fft_hash             uint64
	Fft_attribution_name [255]int8
}

type Tfattributiontag = Tfattributiontag_t

type Tlog2phys = struct {
	Fl2p_flags       uint32
	Fl2p_contigbytes Toff_t
	Fl2p_devoffset   Toff_t
}

type Tfilesec_property_t = int32

const _FILESEC_OWNER = 1
const _FILESEC_GROUP = 2
const _FILESEC_UUID = 3
const _FILESEC_MODE = 4
const _FILESEC_ACL = 5
const _FILESEC_GRPUUID = 6
const _FILESEC_ACL_RAW = 100
const _FILESEC_ACL_ALLOCSIZE = 101

type Tdirent = struct {
	Fd_ino     t__uint64_t
	Fd_seekoff t__uint64_t
	Fd_reclen  t__uint16_t
	Fd_namlen  t__uint16_t
	Fd_type    t__uint8_t
	Fd_name    [1024]int8
}

type TDIR = struct {
	F__dd_fd    int32
	F__dd_loc   int64
	F__dd_size  int64
	F__dd_buf   uintptr
	F__dd_len   int32
	F__dd_seek  int64
	F__padding  int64
	F__dd_flags int32
	F__dd_lock  t__darwin_pthread_mutex_t
	F__dd_td    uintptr
}

type Ttimeval64 = struct {
	Ftv_sec  t__int64_t
	Ftv_usec t__int64_t
}

type Titimerval = struct {
	Fit_interval Ttimeval
	Fit_value    Ttimeval
}

type Ttimezone = struct {
	Ftz_minuteswest int32
	Ftz_dsttime     int32
}

type Tclockinfo = struct {
	Fhz      int32
	Ftick    int32
	Ftickadj int32
	Fstathz  int32
	Fprofhz  int32
}

func XFcDirCacheCreateUUID(tls *libc.TLS, dir uintptr, force TFcBool, config uintptr) (r TFcBool) {
	return int32(m_FcTrue)
}

func XFcDirCacheDeleteUUID(tls *libc.TLS, dir uintptr, config uintptr) (r TFcBool) {
	bp := tls.Alloc(208)
	defer tls.Free(208)
	var d, sysroot, target uintptr
	var ret TFcBool
	var _ /* statb at bp+0 */ Tstat
	var _ /* times at bp+144 */ [2]Ttimeval
	_, _, _, _ = d, ret, sysroot, target
	ret = int32(m_FcTrue)
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return m_FcFalse
	}
	sysroot = XFcConfigGetSysRoot(tls, config)
	if sysroot != 0 {
		d = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+184, dir, libc.UintptrFromInt32(0)))
	} else {
		d = XFcStrBuildFilename(tls, dir, libc.VaList(bp+184, libc.UintptrFromInt32(0)))
	}
	if XFcStat(tls, d, bp) != 0 {
		ret = m_FcFalse
		goto bail
	}
	target = XFcStrBuildFilename(tls, d, libc.VaList(bp+184, __ccgo_ts+29, libc.UintptrFromInt32(0)))
	ret = libc.BoolInt32(libc.Xunlink(tls, target) == 0)
	if ret != 0 {
		(*(*[2]Ttimeval)(unsafe.Pointer(bp + 144)))[0].Ftv_sec = (*(*Tstat)(unsafe.Pointer(bp))).Fst_atimespec.Ftv_sec
		(*(*[2]Ttimeval)(unsafe.Pointer(bp + 144)))[int32(1)].Ftv_sec = (*(*Tstat)(unsafe.Pointer(bp))).Fst_mtimespec.Ftv_sec
		(*(*[2]Ttimeval)(unsafe.Pointer(bp + 144)))[0].Ftv_usec = 0
		(*(*[2]Ttimeval)(unsafe.Pointer(bp + 144)))[int32(1)].Ftv_usec = 0
		if libc.Xutimes(tls, d, bp+144) != 0 {
			libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+35, libc.VaList(bp+184, d))
		}
	}
	XFcStrFree(tls, target)
	goto bail
bail:
	;
	XFcStrFree(tls, d)
	XFcConfigDestroy(tls, config)
	return ret
}

func _FcCacheIsMmapSafe(tls *libc.TLS, fd int32) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var env uintptr
	var status, v1 int32
	var _ /* use at bp+0 */ TFcBool
	_, _, _ = env, status, v1
	status = int32(int64(*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_static_status))))))
	if status == 0 {
		env = libc.Xgetenv(tls, __ccgo_ts+63)
		if env != 0 && XFcNameBool(tls, env, bp) != 0 {
			if *(*TFcBool)(unsafe.Pointer(bp)) != 0 {
				v1 = 1
			} else {
				v1 = 2
			}
			status = v1
		} else {
			status = 3
		}
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_static_status)))) == libc.UintptrFromInt32(0) {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_static_status)))) = uintptr(int64(status))
			_ = libc.Int32FromInt32(m_FcTrue)
		}
	}
	if status == 3 {
		return XFcIsFsMmapSafe(tls, fd)
	} else {
		return libc.BoolInt32(status == 1)
	}
	return r
}

var _static_status uintptr

var _bin2hex = [16]int8{
	0:  int8('0'),
	1:  int8('1'),
	2:  int8('2'),
	3:  int8('3'),
	4:  int8('4'),
	5:  int8('5'),
	6:  int8('6'),
	7:  int8('7'),
	8:  int8('8'),
	9:  int8('9'),
	10: int8('a'),
	11: int8('b'),
	12: int8('c'),
	13: int8('d'),
	14: int8('e'),
	15: int8('f'),
}

func _FcDirCacheBasenameMD5(tls *libc.TLS, config uintptr, dir uintptr, cache_base uintptr) (r uintptr) {
	bp := tls.Alloc(176)
	defer tls.Free(176)
	var cnt int32
	var dl, sl Tsize_t
	var hex_hash, key, mapped_dir, orig_dir, salt, v2, v3, v4, v5, v6, v7 uintptr
	var _ /* ctx at bp+16 */ TMD5Context
	var _ /* hash at bp+0 */ [16]uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = cnt, dl, hex_hash, key, mapped_dir, orig_dir, salt, sl, v2, v3, v4, v5, v6, v7
	mapped_dir = libc.UintptrFromInt32(0)
	key = libc.UintptrFromInt32(0)
	orig_dir = libc.UintptrFromInt32(0)
	salt = XFcConfigMapSalt(tls, config, dir)
	/* Obtain a path where "dir" is mapped to.
	 * In case:
	 * <remap-dir as-path="/usr/share/fonts">/run/host/fonts</remap-dir>
	 *
	 * FcConfigMapFontPath (config, "/run/host/fonts") will returns "/usr/share/fonts".
	 */
	mapped_dir = XFcConfigMapFontPath(tls, config, dir)
	if mapped_dir != 0 {
		orig_dir = dir
		dir = mapped_dir
	}
	if salt != 0 {
		dl = libc.Xstrlen(tls, dir)
		sl = libc.Xstrlen(tls, salt)
		key = libc.Xmalloc(tls, dl+sl+uint64(1))
		libc.X__builtin___memcpy_chk(tls, key, dir, dl, ^t__predefined_size_t(0))
		libc.X__builtin___memcpy_chk(tls, key+uintptr(dl), salt, sl+uint64(1), ^t__predefined_size_t(0))
		*(*TFcChar8)(unsafe.Pointer(key + uintptr(dl+sl))) = uint8(0)
		if !(orig_dir != 0) {
			orig_dir = dir
		}
		dir = key
	}
	_MD5Init(tls, bp+16)
	_MD5Update(tls, bp+16, dir, uint32(libc.Xstrlen(tls, dir)))
	_MD5Final(tls, bp, bp+16)
	if key != 0 {
		XFcStrFree(tls, key)
	}
	*(*TFcChar8)(unsafe.Pointer(cache_base)) = uint8('/')
	hex_hash = cache_base + uintptr(1)
	cnt = 0
	for {
		if !(cnt < int32(16)) {
			break
		}
		*(*TFcChar8)(unsafe.Pointer(hex_hash + uintptr(int32(2)*cnt))) = libc.Uint8FromInt8(_bin2hex[libc.Int32FromUint8((*(*[16]uint8)(unsafe.Pointer(bp)))[cnt])>>int32(4)])
		*(*TFcChar8)(unsafe.Pointer(hex_hash + uintptr(int32(2)*cnt+int32(1)))) = libc.Uint8FromInt8(_bin2hex[libc.Int32FromUint8((*(*[16]uint8)(unsafe.Pointer(bp)))[cnt])&int32(0xf)])
		goto _1
	_1:
		;
		cnt++
	}
	*(*TFcChar8)(unsafe.Pointer(hex_hash + uintptr(int32(2)*cnt))) = uint8(0)
	libc.X__builtin___strcat_chk(tls, cache_base, __ccgo_ts+83, ^t__predefined_size_t(0))
	if XFcDebugVal&int32(m_FC_DBG_CACHE) != 0 {
		if orig_dir != 0 {
			v2 = orig_dir
		} else {
			v2 = dir
		}
		if mapped_dir != 0 {
			v3 = __ccgo_ts + 97
		} else {
			v3 = __ccgo_ts + 110
		}
		if mapped_dir != 0 {
			v4 = mapped_dir
		} else {
			v4 = __ccgo_ts + 110
		}
		if mapped_dir != 0 {
			v5 = __ccgo_ts + 111
		} else {
			v5 = __ccgo_ts + 110
		}
		if salt != 0 {
			v6 = __ccgo_ts + 113
		} else {
			v6 = __ccgo_ts + 110
		}
		if salt != 0 {
			v7 = salt
		} else {
			v7 = __ccgo_ts + 110
		}
		libc.Xprintf(tls, __ccgo_ts+122, libc.VaList(bp+112, cache_base, v2, v3, v4, v5, v6, v7))
	}
	if mapped_dir != 0 {
		XFcStrFree(tls, mapped_dir)
	}
	return cache_base
}

func _FcDirCacheBasenameUUID(tls *libc.TLS, config uintptr, dir uintptr, cache_base uintptr) (r uintptr) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var fd, v1 int32
	var fuuid, sysroot, target uintptr
	var len1 Tssize_t
	var _ /* suuid at bp+0 */ [37]int8
	_, _, _, _, _, _ = fd, fuuid, len1, sysroot, target, v1
	sysroot = XFcConfigGetSysRoot(tls, config)
	/* We don't need to apply remapping here. because .uuid was created at that very directory
	 * to determine the cache name no matter where it was mapped to.
	 */
	*(*TFcChar8)(unsafe.Pointer(cache_base)) = uint8(0)
	if sysroot != 0 {
		target = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+48, dir, libc.UintptrFromInt32(0)))
	} else {
		target = libc.Xstrdup(tls, dir)
	}
	fuuid = XFcStrBuildFilename(tls, target, libc.VaList(bp+48, __ccgo_ts+29, libc.UintptrFromInt32(0)))
	v1 = XFcOpen(tls, fuuid, m_O_RDONLY, 0)
	fd = v1
	if v1 != -int32(1) {
		libc.X__builtin___memset_chk(tls, bp, 0, uint64(37), ^t__predefined_size_t(0))
		len1 = libc.Xread(tls, fd, bp, uint64(36))
		(*(*[37]int8)(unsafe.Pointer(bp)))[int32(36)] = 0
		libc.Xclose(tls, fd)
		if len1 < 0 {
			goto bail
		}
		*(*TFcChar8)(unsafe.Pointer(cache_base)) = uint8('/')
		libc.X__builtin___strcpy_chk(tls, cache_base+1, bp, ^t__predefined_size_t(0))
		libc.X__builtin___strcat_chk(tls, cache_base, __ccgo_ts+83, ^t__predefined_size_t(0))
		if XFcDebugVal&int32(m_FC_DBG_CACHE) != 0 {
			libc.Xprintf(tls, __ccgo_ts+153, libc.VaList(bp+48, cache_base, dir))
		}
	}
	goto bail
bail:
	;
	XFcStrFree(tls, fuuid)
	XFcStrFree(tls, target)
	return cache_base
}

func XFcDirCacheUnlink(tls *libc.TLS, dir uintptr, config uintptr) (r TFcBool) {
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var cache_dir, cache_hashed, list, sysroot, v1 uintptr
	var ret TFcBool
	var _ /* cache_base at bp+0 */ [52]TFcChar8
	var _ /* uuid_cache_base at bp+52 */ [52]TFcChar8
	_, _, _, _, _, _ = cache_dir, cache_hashed, list, ret, sysroot, v1
	cache_hashed = libc.UintptrFromInt32(0)
	ret = int32(m_FcTrue)
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return m_FcFalse
	}
	sysroot = XFcConfigGetSysRoot(tls, config)
	_FcDirCacheBasenameMD5(tls, config, dir, bp)
	_FcDirCacheBasenameUUID(tls, config, dir, bp+52)
	list = XFcStrListCreate(tls, (*TFcConfig)(unsafe.Pointer(config)).FcacheDirs)
	if !(list != 0) {
		ret = m_FcFalse
		goto bail
	}
	for {
		v1 = XFcStrListNext(tls, list)
		cache_dir = v1
		if !(v1 != 0) {
			break
		}
		if sysroot != 0 {
			cache_hashed = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+112, cache_dir, bp, libc.UintptrFromInt32(0)))
		} else {
			cache_hashed = XFcStrBuildFilename(tls, cache_dir, libc.VaList(bp+112, bp, libc.UintptrFromInt32(0)))
		}
		if !(cache_hashed != 0) {
			break
		}
		libc.Xunlink(tls, cache_hashed)
		XFcStrFree(tls, cache_hashed)
		if libc.Int32FromUint8((*(*[52]TFcChar8)(unsafe.Pointer(bp + 52)))[0]) != 0 {
			if sysroot != 0 {
				cache_hashed = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+112, cache_dir, bp+52, libc.UintptrFromInt32(0)))
			} else {
				cache_hashed = XFcStrBuildFilename(tls, cache_dir, libc.VaList(bp+112, bp+52, libc.UintptrFromInt32(0)))
			}
			if !(cache_hashed != 0) {
				break
			}
			libc.Xunlink(tls, cache_hashed)
			XFcStrFree(tls, cache_hashed)
		}
	}
	XFcStrListDone(tls, list)
	XFcDirCacheDeleteUUID(tls, dir, config)
	/* return FcFalse if something went wrong */
	if cache_dir != 0 {
		ret = m_FcFalse
	}
	goto bail
bail:
	;
	XFcConfigDestroy(tls, config)
	return ret
}

func _FcDirCacheOpenFile(tls *libc.TLS, cache_file uintptr, file_stat uintptr) (r int32) {
	var fd int32
	_ = fd
	fd = XFcOpen(tls, cache_file, libc.Int32FromInt32(m_O_RDONLY)|libc.Int32FromInt32(m_O_BINARY), 0)
	if fd < 0 {
		return fd
	}
	if libc.Xfstat(tls, fd, file_stat) < 0 {
		libc.Xclose(tls, fd)
		return -int32(1)
	}
	return fd
}

// C documentation
//
//	/*
//	 * Look for a cache file for the specified dir. Attempt
//	 * to use each one we find, stopping when the callback
//	 * indicates success
//	 */
func _FcDirCacheProcess(tls *libc.TLS, config uintptr, dir uintptr, __ccgo_fp_callback uintptr, closure uintptr, cache_file_ret uintptr) (r TFcBool) {
	bp := tls.Alloc(448)
	defer tls.Free(448)
	var cache_dir, cache_hashed, d, list, sysroot, v1 uintptr
	var fd int32
	var ret, retried TFcBool
	var _ /* cache_base at bp+0 */ [52]TFcChar8
	var _ /* dir_stat at bp+200 */ Tstat
	var _ /* file_stat at bp+56 */ Tstat
	var _ /* latest_mtime at bp+344 */ Ttimeval
	var _ /* uuid_cache_base at bp+360 */ [52]TFcChar8
	_, _, _, _, _, _, _, _, _ = cache_dir, cache_hashed, d, fd, list, ret, retried, sysroot, v1
	fd = -int32(1)
	ret = m_FcFalse
	sysroot = XFcConfigGetSysRoot(tls, config)
	*(*Ttimeval)(unsafe.Pointer(bp + 344)) = Ttimeval{}
	if sysroot != 0 {
		d = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+424, dir, libc.UintptrFromInt32(0)))
	} else {
		d = libc.Xstrdup(tls, dir)
	}
	if XFcStatChecksum(tls, d, bp+200) < 0 {
		XFcStrFree(tls, d)
		return m_FcFalse
	}
	XFcStrFree(tls, d)
	_FcDirCacheBasenameMD5(tls, config, dir, bp)
	list = XFcStrListCreate(tls, (*TFcConfig)(unsafe.Pointer(config)).FcacheDirs)
	if !(list != 0) {
		return m_FcFalse
	}
	for {
		v1 = XFcStrListNext(tls, list)
		cache_dir = v1
		if !(v1 != 0) {
			break
		}
		retried = m_FcFalse
		if sysroot != 0 {
			cache_hashed = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+424, cache_dir, bp, libc.UintptrFromInt32(0)))
		} else {
			cache_hashed = XFcStrBuildFilename(tls, cache_dir, libc.VaList(bp+424, bp, libc.UintptrFromInt32(0)))
		}
		if !(cache_hashed != 0) {
			break
		}
		goto retry
	retry:
		;
		fd = _FcDirCacheOpenFile(tls, cache_hashed, bp+56)
		if fd >= 0 {
			ret = (*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr, uintptr) TFcBool)(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_callback})))(tls, config, fd, bp+56, bp+200, bp+344, closure)
			libc.Xclose(tls, fd)
			if ret != 0 {
				if cache_file_ret != 0 {
					if *(*uintptr)(unsafe.Pointer(cache_file_ret)) != 0 {
						XFcStrFree(tls, *(*uintptr)(unsafe.Pointer(cache_file_ret)))
					}
					*(*uintptr)(unsafe.Pointer(cache_file_ret)) = cache_hashed
				} else {
					XFcStrFree(tls, cache_hashed)
				}
			} else {
				XFcStrFree(tls, cache_hashed)
			}
		} else {
			if !(retried != 0) {
				retried = int32(m_FcTrue)
				_FcDirCacheBasenameUUID(tls, config, dir, bp+360)
				if libc.Int32FromUint8((*(*[52]TFcChar8)(unsafe.Pointer(bp + 360)))[0]) != 0 {
					XFcStrFree(tls, cache_hashed)
					if sysroot != 0 {
						cache_hashed = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+424, cache_dir, bp+360, libc.UintptrFromInt32(0)))
					} else {
						cache_hashed = XFcStrBuildFilename(tls, cache_dir, libc.VaList(bp+424, bp+360, libc.UintptrFromInt32(0)))
					}
					if !(cache_hashed != 0) {
						break
					}
					goto retry
				} else {
					XFcStrFree(tls, cache_hashed)
				}
			} else {
				XFcStrFree(tls, cache_hashed)
			}
		}
	}
	XFcStrListDone(tls, list)
	if closure != 0 {
		return libc.BoolInt32(!!(*(*uintptr)(unsafe.Pointer(closure)) != libc.UintptrFromInt32(0)))
	}
	return ret
}

/*
 * Skip list element, make sure the 'next' pointer is the last thing
 * in the structure, it will be allocated large enough to hold all
 * of the necessary pointers
 */

type TFcCacheSkip = struct {
	Fcache            uintptr
	Fref              TFcRef
	Fsize             Tintptr_t
	Fallocated        uintptr
	Fcache_dev        Tdev_t
	Fcache_ino        Tino_t
	Fcache_mtime      Ttime_t
	Fcache_mtime_nano int64
	Fnext             [1]uintptr
}

/*
 * Skip list element, make sure the 'next' pointer is the last thing
 * in the structure, it will be allocated large enough to hold all
 * of the necessary pointers
 */

type T_FcCacheSkip = TFcCacheSkip

/*
 * The head of the skip list; pointers for every possible level
 * in the skip list, plus the largest level in the list
 */

// C documentation
//
//	/* Protected by cache_lock below */
var _fcCacheChains [16]uintptr
var _fcCacheMaxLevel int32

var _cache_lock uintptr

func _lock_cache(tls *libc.TLS) {
	var lock uintptr
	var v1 int32
	_, _ = lock, v1
	goto retry
retry:
	;
	lock = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_cache_lock))))
	if !(lock != 0) {
		lock = libc.Xmalloc(tls, uint64(4))
		_ = lock
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_cache_lock)))) == libc.UintptrFromInt32(0) {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_cache_lock)))) = lock
			v1 = libc.Int32FromInt32(m_FcTrue)
		} else {
			v1 = m_FcFalse
		}
		if !(v1 != 0) {
			_ = lock
			libc.Xfree(tls, lock)
			goto retry
		}
		_ = lock
		/* Initialize random state */
		XFcRandom(tls)
		return
	}
	_ = lock
}

func _unlock_cache(tls *libc.TLS) {
	var lock uintptr
	_ = lock
	lock = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_cache_lock))))
	_ = lock
}

func _free_lock(tls *libc.TLS) {
	var lock uintptr
	var v1 int32
	var v2 bool
	_, _, _ = lock, v1, v2
	lock = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_cache_lock))))
	if v2 = lock != 0; v2 {
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_cache_lock)))) == lock {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_cache_lock)))) = libc.UintptrFromInt32(0)
			v1 = libc.Int32FromInt32(m_FcTrue)
		} else {
			v1 = m_FcFalse
		}
	}
	if v2 && v1 != 0 {
		_ = lock
		libc.Xfree(tls, lock)
	}
}

// C documentation
//
//	/*
//	 * Generate a random level number, distributed
//	 * so that each level is 1/4 as likely as the one before
//	 *
//	 * Note that level numbers run 1 <= level <= MAX_LEVEL
//	 */
func _random_level(tls *libc.TLS) (r int32) {
	var bits int64
	var level, v1 int32
	_, _, _ = bits, level, v1
	/* tricky bit -- each bit is '1' 75% of the time */
	bits = int64(XFcRandom(tls) | XFcRandom(tls))
	level = 0
	for {
		level++
		v1 = level
		if !(v1 < int32(m_FC_CACHE_MAX_LEVEL)) {
			break
		}
		if bits&int64(1) != 0 {
			break
		}
		bits >>= int64(1)
	}
	return level
}

// C documentation
//
//	/*
//	 * Insert cache into the list
//	 */
func _FcCacheInsert(tls *libc.TLS, cache uintptr, cache_stat uintptr) (r TFcBool) {
	var i, level, v2 int32
	var next, s, v4 uintptr
	var update [16]uintptr
	_, _, _, _, _, _, _ = i, level, next, s, update, v2, v4
	_lock_cache(tls)
	/*
	 * Find links along each chain
	 */
	next = uintptr(unsafe.Pointer(&_fcCacheChains))
	i = _fcCacheMaxLevel
	for {
		i--
		v2 = i
		if !(v2 >= 0) {
			break
		}
		for {
			v4 = *(*uintptr)(unsafe.Pointer(next + uintptr(i)*8))
			s = v4
			if !(v4 != 0) {
				break
			}
			if (*TFcCacheSkip)(unsafe.Pointer(s)).Fcache > cache {
				break
			}
			goto _3
		_3:
			;
			next = s + 64
		}
		update[i] = next + uintptr(i)*8
		goto _1
	_1:
	}
	/*
	 * Create new list element
	 */
	level = _random_level(tls)
	if level > _fcCacheMaxLevel {
		level = _fcCacheMaxLevel + int32(1)
		update[_fcCacheMaxLevel] = uintptr(unsafe.Pointer(&_fcCacheChains)) + uintptr(_fcCacheMaxLevel)*8
		_fcCacheMaxLevel = level
	}
	s = libc.Xmalloc(tls, uint64(72)+libc.Uint64FromInt32(level-libc.Int32FromInt32(1))*uint64(8))
	if !(s != 0) {
		return m_FcFalse
	}
	(*TFcCacheSkip)(unsafe.Pointer(s)).Fcache = cache
	(*TFcCacheSkip)(unsafe.Pointer(s)).Fsize = (*TFcCache)(unsafe.Pointer(cache)).Fsize
	(*TFcCacheSkip)(unsafe.Pointer(s)).Fallocated = libc.UintptrFromInt32(0)
	(*TFcRef)(unsafe.Pointer(s + 8)).Fcount = int32(1)
	if cache_stat != 0 {
		(*TFcCacheSkip)(unsafe.Pointer(s)).Fcache_dev = (*Tstat)(unsafe.Pointer(cache_stat)).Fst_dev
		(*TFcCacheSkip)(unsafe.Pointer(s)).Fcache_ino = (*Tstat)(unsafe.Pointer(cache_stat)).Fst_ino
		(*TFcCacheSkip)(unsafe.Pointer(s)).Fcache_mtime = (*Tstat)(unsafe.Pointer(cache_stat)).Fst_mtimespec.Ftv_sec
		(*TFcCacheSkip)(unsafe.Pointer(s)).Fcache_mtime_nano = 0
	} else {
		(*TFcCacheSkip)(unsafe.Pointer(s)).Fcache_dev = 0
		(*TFcCacheSkip)(unsafe.Pointer(s)).Fcache_ino = uint64(0)
		(*TFcCacheSkip)(unsafe.Pointer(s)).Fcache_mtime = 0
		(*TFcCacheSkip)(unsafe.Pointer(s)).Fcache_mtime_nano = 0
	}
	/*
	 * Insert into all fcCacheChains
	 */
	i = 0
	for {
		if !(i < level) {
			break
		}
		*(*uintptr)(unsafe.Pointer(s + 64 + uintptr(i)*8)) = *(*uintptr)(unsafe.Pointer(update[i]))
		*(*uintptr)(unsafe.Pointer(update[i])) = s
		goto _5
	_5:
		;
		i++
	}
	_unlock_cache(tls)
	return int32(m_FcTrue)
}

func _FcCacheFindByAddrUnlocked(tls *libc.TLS, object uintptr) (r uintptr) {
	var i, v2 int32
	var next, s uintptr
	_, _, _, _ = i, next, s, v2
	next = uintptr(unsafe.Pointer(&_fcCacheChains))
	if !(object != 0) {
		return libc.UintptrFromInt32(0)
	}
	/*
	 * Walk chain pointers one level at a time
	 */
	i = _fcCacheMaxLevel
	for {
		i--
		v2 = i
		if !(v2 >= 0) {
			break
		}
		for *(*uintptr)(unsafe.Pointer(next + uintptr(i)*8)) != 0 && object >= (*TFcCacheSkip)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(next + uintptr(i)*8)))).Fcache+uintptr((*TFcCacheSkip)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(next + uintptr(i)*8)))).Fsize) {
			next = *(*uintptr)(unsafe.Pointer(next + uintptr(i)*8)) + 64
		}
		goto _1
	_1:
	}
	/*
	 * Here we are
	 */
	s = *(*uintptr)(unsafe.Pointer(next))
	if s != 0 && object < (*TFcCacheSkip)(unsafe.Pointer(s)).Fcache+uintptr((*TFcCacheSkip)(unsafe.Pointer(s)).Fsize) {
		return s
	}
	return libc.UintptrFromInt32(0)
}

func _FcCacheFindByAddr(tls *libc.TLS, object uintptr) (r uintptr) {
	var ret uintptr
	_ = ret
	_lock_cache(tls)
	ret = _FcCacheFindByAddrUnlocked(tls, object)
	_unlock_cache(tls)
	return ret
}

func _FcCacheRemoveUnlocked(tls *libc.TLS, cache uintptr) {
	var allocated, next, s, v4 uintptr
	var i, v2 int32
	var update [16]uintptr
	_, _, _, _, _, _, _ = allocated, i, next, s, update, v2, v4
	/*
	 * Find links along each chain
	 */
	next = uintptr(unsafe.Pointer(&_fcCacheChains))
	i = _fcCacheMaxLevel
	for {
		i--
		v2 = i
		if !(v2 >= 0) {
			break
		}
		for {
			v4 = *(*uintptr)(unsafe.Pointer(next + uintptr(i)*8))
			s = v4
			if !(v4 != 0) {
				break
			}
			if (*TFcCacheSkip)(unsafe.Pointer(s)).Fcache >= cache {
				break
			}
			goto _3
		_3:
			;
			next = s + 64
		}
		update[i] = next + uintptr(i)*8
		goto _1
	_1:
	}
	s = *(*uintptr)(unsafe.Pointer(next))
	i = 0
	for {
		if !(i < _fcCacheMaxLevel && *(*uintptr)(unsafe.Pointer(update[i])) == s) {
			break
		}
		*(*uintptr)(unsafe.Pointer(update[i])) = *(*uintptr)(unsafe.Pointer(s + 64 + uintptr(i)*8))
		goto _5
	_5:
		;
		i++
	}
	for _fcCacheMaxLevel > 0 && _fcCacheChains[_fcCacheMaxLevel-int32(1)] == libc.UintptrFromInt32(0) {
		_fcCacheMaxLevel--
	}
	if s != 0 {
		allocated = (*TFcCacheSkip)(unsafe.Pointer(s)).Fallocated
		for allocated != 0 {
			/* First element in allocated chunk is the free list */
			next = *(*uintptr)(unsafe.Pointer(allocated))
			libc.Xfree(tls, allocated)
			allocated = next
		}
		libc.Xfree(tls, s)
	}
}

func _FcCacheFindByStat(tls *libc.TLS, cache_stat uintptr) (r uintptr) {
	var s, p3 uintptr
	_, _ = s, p3
	_lock_cache(tls)
	s = _fcCacheChains[0]
	for {
		if !(s != 0) {
			break
		}
		if (*TFcCacheSkip)(unsafe.Pointer(s)).Fcache_dev == (*Tstat)(unsafe.Pointer(cache_stat)).Fst_dev && (*TFcCacheSkip)(unsafe.Pointer(s)).Fcache_ino == (*Tstat)(unsafe.Pointer(cache_stat)).Fst_ino && (*TFcCacheSkip)(unsafe.Pointer(s)).Fcache_mtime == (*Tstat)(unsafe.Pointer(cache_stat)).Fst_mtimespec.Ftv_sec {
			p3 = s + 8
			*(*Tfc_atomic_int_t)(unsafe.Pointer(p3)) += +libc.Int32FromInt32(1)
			_ = *(*Tfc_atomic_int_t)(unsafe.Pointer(p3)) - +libc.Int32FromInt32(1)
			goto _2
		_2:
			;
			_unlock_cache(tls)
			return (*TFcCacheSkip)(unsafe.Pointer(s)).Fcache
		}
		goto _1
	_1:
		;
		s = *(*uintptr)(unsafe.Pointer(s + 64))
	}
	_unlock_cache(tls)
	return libc.UintptrFromInt32(0)
}

func _FcDirCacheDisposeUnlocked(tls *libc.TLS, cache uintptr) {
	_FcCacheRemoveUnlocked(tls, cache)
	switch (*TFcCache)(unsafe.Pointer(cache)).Fmagic {
	case uint32(m_FC_CACHE_MAGIC_ALLOC1):
		libc.Xfree(tls, cache)
	case uint32(m_FC_CACHE_MAGIC_MMAP1):
		libc.Xmunmap(tls, cache, libc.Uint64FromInt64((*TFcCache)(unsafe.Pointer(cache)).Fsize))
		break
	}
}

func XFcCacheObjectReference(tls *libc.TLS, object uintptr) {
	var skip, p2 uintptr
	_, _ = skip, p2
	skip = _FcCacheFindByAddr(tls, object)
	if skip != 0 {
		p2 = skip + 8
		*(*Tfc_atomic_int_t)(unsafe.Pointer(p2)) += +libc.Int32FromInt32(1)
		_ = *(*Tfc_atomic_int_t)(unsafe.Pointer(p2)) - +libc.Int32FromInt32(1)
		goto _1
	_1:
	}
}

func XFcCacheObjectDereference(tls *libc.TLS, object uintptr) {
	var skip, p3 uintptr
	var v1 int32
	_, _, _ = skip, v1, p3
	_lock_cache(tls)
	skip = _FcCacheFindByAddrUnlocked(tls, object)
	if skip != 0 {
		p3 = skip + 8
		*(*Tfc_atomic_int_t)(unsafe.Pointer(p3)) += -int32(1)
		v1 = *(*Tfc_atomic_int_t)(unsafe.Pointer(p3)) - -int32(1)
		goto _2
	_2:
		if v1 == int32(1) {
			_FcDirCacheDisposeUnlocked(tls, (*TFcCacheSkip)(unsafe.Pointer(skip)).Fcache)
		}
	}
	_unlock_cache(tls)
}

func XFcCacheAllocate(tls *libc.TLS, cache uintptr, len1 Tsize_t) (r uintptr) {
	var allocated, chunk, skip uintptr
	_, _, _ = allocated, chunk, skip
	allocated = libc.UintptrFromInt32(0)
	_lock_cache(tls)
	skip = _FcCacheFindByAddrUnlocked(tls, cache)
	if skip != 0 {
		chunk = libc.Xmalloc(tls, uint64(8)+len1)
		if chunk != 0 {
			/* First element in allocated chunk is the free list */
			*(*uintptr)(unsafe.Pointer(chunk)) = (*TFcCacheSkip)(unsafe.Pointer(skip)).Fallocated
			(*TFcCacheSkip)(unsafe.Pointer(skip)).Fallocated = chunk
			/* Return the rest */
			allocated = chunk + uintptr(8)
		}
	}
	_unlock_cache(tls)
	return allocated
}

func XFcCacheFini(tls *libc.TLS) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var i int32
	var s uintptr
	_, _ = i, s
	i = 0
	for {
		if !(i < int32(m_FC_CACHE_MAX_LEVEL)) {
			break
		}
		if XFcDebugVal&int32(m_FC_DBG_CACHE) != 0 {
			if _fcCacheChains[i] != libc.UintptrFromInt32(0) {
				s = _fcCacheChains[i]
				libc.Xprintf(tls, __ccgo_ts+187, libc.VaList(bp+8, (*TFcCacheSkip)(unsafe.Pointer(s)).Fcache, uintptr(int64((*TFcCacheSkip)(unsafe.Pointer(s)).Fcache)+(*TFcCache)(unsafe.Pointer((*TFcCacheSkip)(unsafe.Pointer(s)).Fcache)).Fdir), (*TFcCacheSkip)(unsafe.Pointer(s)).Fref.Fcount))
			}
		} else {
		}
		goto _1
	_1:
		;
		i++
	}
	_free_lock(tls)
}

func _FcCacheTimeValid(tls *libc.TLS, config uintptr, cache uintptr, dir_stat uintptr) (r TFcBool) {
	bp := tls.Alloc(176)
	defer tls.Free(176)
	var d, sysroot uintptr
	var fnano TFcBool
	var _ /* dir_static at bp+0 */ Tstat
	_, _, _ = d, fnano, sysroot
	fnano = int32(m_FcTrue)
	if !(dir_stat != 0) {
		sysroot = XFcConfigGetSysRoot(tls, config)
		if sysroot != 0 {
			d = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+152, uintptr(int64(cache)+(*TFcCache)(unsafe.Pointer(cache)).Fdir), libc.UintptrFromInt32(0)))
		} else {
			d = libc.Xstrdup(tls, uintptr(int64(cache)+(*TFcCache)(unsafe.Pointer(cache)).Fdir))
		}
		if XFcStatChecksum(tls, d, bp) < 0 {
			XFcStrFree(tls, d)
			return m_FcFalse
		}
		XFcStrFree(tls, d)
		dir_stat = bp
	}
	if XFcDebugVal&int32(m_FC_DBG_CACHE) != 0 {
		libc.Xprintf(tls, __ccgo_ts+242, libc.VaList(bp+152, uintptr(int64(cache)+(*TFcCache)(unsafe.Pointer(cache)).Fdir), (*TFcCache)(unsafe.Pointer(cache)).Fchecksum, int32((*Tstat)(unsafe.Pointer(dir_stat)).Fst_mtimespec.Ftv_sec)))
	}
	return libc.BoolInt32((*Tstat)(unsafe.Pointer(dir_stat)).Fst_mtimespec.Ftv_sec == 0 || (*TFcCache)(unsafe.Pointer(cache)).Fchecksum == int32((*Tstat)(unsafe.Pointer(dir_stat)).Fst_mtimespec.Ftv_sec) && fnano != 0)
}

func _FcCacheOffsetsValid(tls *libc.TLS, cache uintptr) (r TFcBool) {
	var base, dir, dirs, e, end, font, fs, last_offset, v10, v11, v3, v4 uintptr
	var i, j int32
	var l TFcValueListPtr
	var v5 TFcBool
	var v7 bool
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = base, dir, dirs, e, end, font, fs, i, j, l, last_offset, v10, v11, v3, v4, v5, v7
	base = cache
	end = base + uintptr((*TFcCache)(unsafe.Pointer(cache)).Fsize)
	if (*TFcCache)(unsafe.Pointer(cache)).Fdir < 0 || libc.Uint64FromInt64((*TFcCache)(unsafe.Pointer(cache)).Fdir) > libc.Uint64FromInt64((*TFcCache)(unsafe.Pointer(cache)).Fsize)-uint64(8) || libc.Xmemchr(tls, base+uintptr((*TFcCache)(unsafe.Pointer(cache)).Fdir), int32('\000'), libc.Uint64FromInt64((*TFcCache)(unsafe.Pointer(cache)).Fsize-(*TFcCache)(unsafe.Pointer(cache)).Fdir)) == libc.UintptrFromInt32(0) {
		return m_FcFalse
	}
	if (*TFcCache)(unsafe.Pointer(cache)).Fdirs < 0 || (*TFcCache)(unsafe.Pointer(cache)).Fdirs >= (*TFcCache)(unsafe.Pointer(cache)).Fsize || (*TFcCache)(unsafe.Pointer(cache)).Fdirs_count < 0 || libc.Uint64FromInt32((*TFcCache)(unsafe.Pointer(cache)).Fdirs_count) > libc.Uint64FromInt64((*TFcCache)(unsafe.Pointer(cache)).Fsize-(*TFcCache)(unsafe.Pointer(cache)).Fdirs)/uint64(8) {
		return m_FcFalse
	}
	dirs = uintptr(int64(cache) + (*TFcCache)(unsafe.Pointer(cache)).Fdirs)
	if dirs != 0 {
		i = 0
		for {
			if !(i < (*TFcCache)(unsafe.Pointer(cache)).Fdirs_count) {
				break
			}
			if *(*Tintptr_t)(unsafe.Pointer(dirs + uintptr(i)*8)) < 0 || libc.Uint64FromInt64(*(*Tintptr_t)(unsafe.Pointer(dirs + uintptr(i)*8))) > libc.Uint64FromInt64(int64(end)-int64(dirs))-uint64(8) {
				return m_FcFalse
			}
			dir = uintptr(int64(dirs) + *(*Tintptr_t)(unsafe.Pointer(dirs + uintptr(i)*8)))
			if libc.Xmemchr(tls, dir, int32('\000'), libc.Uint64FromInt64(int64(end)-int64(dir))) == libc.UintptrFromInt32(0) {
				return m_FcFalse
			}
			goto _1
		_1:
			;
			i++
		}
	}
	if (*TFcCache)(unsafe.Pointer(cache)).Fset < 0 || libc.Uint64FromInt64((*TFcCache)(unsafe.Pointer(cache)).Fset) > libc.Uint64FromInt64((*TFcCache)(unsafe.Pointer(cache)).Fsize)-uint64(16) {
		return m_FcFalse
	}
	fs = uintptr(int64(cache) + (*TFcCache)(unsafe.Pointer(cache)).Fset)
	if fs != 0 {
		if libc.Uint64FromInt32((*TFcFontSet)(unsafe.Pointer(fs)).Fnfont) > libc.Uint64FromInt64(int64(end)-int64(fs))/uint64(24) {
			return m_FcFalse
		}
		if !(int64((*TFcFontSet)(unsafe.Pointer(fs)).Ffonts)&libc.Int64FromInt32(1) != libc.Int64FromInt32(0)) {
			return m_FcFalse
		}
		i = 0
		for {
			if !(i < (*TFcFontSet)(unsafe.Pointer(fs)).Fnfont) {
				break
			}
			if int64((*TFcFontSet)(unsafe.Pointer(fs)).Ffonts)&int64(1) != 0 {
				if int64((*TFcFontSet)(unsafe.Pointer(fs)).Ffonts)&int64(1) != 0 {
					v4 = uintptr(int64(fs) + int64((*TFcFontSet)(unsafe.Pointer(fs)).Ffonts)&int64(^libc.Int32FromInt32(1)))
				} else {
					v4 = (*TFcFontSet)(unsafe.Pointer(fs)).Ffonts
				}
				v3 = uintptr(int64(fs) + int64(*(*uintptr)(unsafe.Pointer(v4 + uintptr(i)*8)))&int64(^libc.Int32FromInt32(1)))
			} else {
				v3 = *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(fs)).Ffonts + uintptr(i)*8))
			}
			font = v3
			if v7 = font < base || font > end-uintptr(16) || (*TFcPattern)(unsafe.Pointer(font)).Felts_offset < 0 || (*TFcPattern)(unsafe.Pointer(font)).Felts_offset > int64(end)-int64(font) || libc.Uint64FromInt32((*TFcPattern)(unsafe.Pointer(font)).Fnum) > libc.Uint64FromInt64(int64(end)-int64(font)-(*TFcPattern)(unsafe.Pointer(font)).Felts_offset)/uint64(16); !v7 {
				v5 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(font+16)).Fcount == -libc.Int32FromInt32(1))
				goto _6
			_6:
			}
			if v7 || !(v5 != 0) {
				return m_FcFalse
			}
			e = uintptr(int64(font) + (*TFcPattern)(unsafe.Pointer(font)).Felts_offset)
			if (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues != uintptr(0) && !(int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&libc.Int64FromInt32(1) != libc.Int64FromInt32(0)) {
				return m_FcFalse
			}
			j = 0
			for {
				if !(j < (*TFcPattern)(unsafe.Pointer(font)).Fnum) {
					break
				}
				last_offset = font + uintptr((*TFcPattern)(unsafe.Pointer(font)).Felts_offset)
				if int64((*TFcPatternElt)(unsafe.Pointer(e+uintptr(j)*16)).Fvalues)&int64(1) != 0 {
					v10 = uintptr(Tintptr_t(e+uintptr(j)*16) + int64((*TFcPatternElt)(unsafe.Pointer(e+uintptr(j)*16)).Fvalues)&int64(^libc.Int32FromInt32(1)))
				} else {
					v10 = (*TFcPatternElt)(unsafe.Pointer(e + uintptr(j)*16)).Fvalues
				}
				l = v10
				for {
					if !(l != 0) {
						break
					}
					if l < last_offset || l > end-uintptr(32) || (*T_FcValueList)(unsafe.Pointer(l)).Fnext != libc.UintptrFromInt32(0) && !(int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&libc.Int64FromInt32(1) != libc.Int64FromInt32(0)) {
						return m_FcFalse
					}
					last_offset = l + uintptr(1)
					goto _9
				_9:
					;
					if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
						v11 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
					} else {
						v11 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
					}
					l = v11
				}
				goto _8
			_8:
				;
				j++
			}
			goto _2
		_2:
			;
			i++
		}
	}
	return int32(m_FcTrue)
}

// C documentation
//
//	/*
//	 * Map a cache file into memory
//	 */
func _FcDirCacheMapFd(tls *libc.TLS, config uintptr, fd int32, fd_stat uintptr, dir_stat uintptr) (r uintptr) {
	var allocated TFcBool
	var cache uintptr
	_, _ = allocated, cache
	allocated = m_FcFalse
	if (*Tstat)(unsafe.Pointer(fd_stat)).Fst_size > int64(9223372036854775807) || (*Tstat)(unsafe.Pointer(fd_stat)).Fst_size < int64(libc.Int32FromInt64(64)) {
		return libc.UintptrFromInt32(0)
	}
	cache = _FcCacheFindByStat(tls, fd_stat)
	if cache != 0 {
		if _FcCacheTimeValid(tls, config, cache, dir_stat) != 0 {
			return cache
		}
		XFcDirCacheUnload(tls, cache)
		cache = libc.UintptrFromInt32(0)
	}
	/*
	 * Large cache files are mmap'ed, smaller cache files are read. This
	 * balances the system cost of mmap against per-process memory usage.
	 */
	if _FcCacheIsMmapSafe(tls, fd) != 0 && (*Tstat)(unsafe.Pointer(fd_stat)).Fst_size >= int64(m_FC_CACHE_MIN_MMAP) {
		cache = libc.Xmmap(tls, uintptr(0), libc.Uint64FromInt64((*Tstat)(unsafe.Pointer(fd_stat)).Fst_size), int32(m_PROT_READ), int32(m_MAP_SHARED), fd, 0)
		if cache == uintptr(-libc.Int32FromInt32(1)) {
			cache = libc.UintptrFromInt32(0)
		}
	}
	if !(cache != 0) {
		cache = libc.Xmalloc(tls, libc.Uint64FromInt64((*Tstat)(unsafe.Pointer(fd_stat)).Fst_size))
		if !(cache != 0) {
			return libc.UintptrFromInt32(0)
		}
		if int64(libc.Xread(tls, fd, cache, libc.Uint64FromInt64((*Tstat)(unsafe.Pointer(fd_stat)).Fst_size))) != (*Tstat)(unsafe.Pointer(fd_stat)).Fst_size {
			libc.Xfree(tls, cache)
			return libc.UintptrFromInt32(0)
		}
		allocated = int32(m_FcTrue)
	}
	if (*TFcCache)(unsafe.Pointer(cache)).Fmagic != uint32(m_FC_CACHE_MAGIC_MMAP1) || (*TFcCache)(unsafe.Pointer(cache)).Fversion < int32(m_FC_CACHE_VERSION_NUMBER) || (*TFcCache)(unsafe.Pointer(cache)).Fsize != (*Tstat)(unsafe.Pointer(fd_stat)).Fst_size || !(_FcCacheOffsetsValid(tls, cache) != 0) || !(_FcCacheTimeValid(tls, config, cache, dir_stat) != 0) || !(_FcCacheInsert(tls, cache, fd_stat) != 0) {
		if allocated != 0 {
			libc.Xfree(tls, cache)
		} else {
			libc.Xmunmap(tls, cache, libc.Uint64FromInt64((*Tstat)(unsafe.Pointer(fd_stat)).Fst_size))
		}
		return libc.UintptrFromInt32(0)
	}
	/* Mark allocated caches so they're freed rather than unmapped */
	if allocated != 0 {
		(*TFcCache)(unsafe.Pointer(cache)).Fmagic = uint32(m_FC_CACHE_MAGIC_ALLOC1)
	}
	return cache
}

func XFcDirCacheReference(tls *libc.TLS, cache uintptr, nref int32) {
	var skip, p3 uintptr
	var v1 int32
	_, _, _ = skip, v1, p3
	skip = _FcCacheFindByAddr(tls, cache)
	if skip != 0 {
		v1 = nref
		p3 = skip + 8
		*(*Tfc_atomic_int_t)(unsafe.Pointer(p3)) += v1
		_ = *(*Tfc_atomic_int_t)(unsafe.Pointer(p3)) - v1
		goto _2
	_2:
	}
}

func XFcDirCacheUnload(tls *libc.TLS, cache uintptr) {
	XFcCacheObjectDereference(tls, cache)
}

func _FcDirCacheMapHelper(tls *libc.TLS, config uintptr, fd int32, fd_stat uintptr, dir_stat uintptr, latest_cache_mtime uintptr, closure uintptr) (r TFcBool) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var cache uintptr
	var v1, v2, v3, v5, v6 int32
	var v4 bool
	var _ /* cache_mtime at bp+0 */ Ttimeval
	var _ /* dir_mtime at bp+32 */ Ttimeval
	var _ /* zero_mtime at bp+16 */ Ttimeval
	_, _, _, _, _, _, _ = cache, v1, v2, v3, v4, v5, v6
	cache = _FcDirCacheMapFd(tls, config, fd, fd_stat, dir_stat)
	*(*Ttimeval)(unsafe.Pointer(bp + 16)) = Ttimeval{}
	if !(cache != 0) {
		return m_FcFalse
	}
	(*(*Ttimeval)(unsafe.Pointer(bp))).Ftv_sec = (*Tstat)(unsafe.Pointer(fd_stat)).Fst_mtimespec.Ftv_sec
	(*(*Ttimeval)(unsafe.Pointer(bp + 32))).Ftv_sec = (*Tstat)(unsafe.Pointer(dir_stat)).Fst_mtimespec.Ftv_sec
	(*(*Ttimeval)(unsafe.Pointer(bp))).Ftv_usec = 0
	(*(*Ttimeval)(unsafe.Pointer(bp + 32))).Ftv_usec = 0
	/* special take care of OSTree */
	if (*Ttimeval)(unsafe.Pointer(bp+16)).Ftv_sec == (*Ttimeval)(unsafe.Pointer(bp+32)).Ftv_sec {
		v1 = libc.BoolInt32((*Ttimeval)(unsafe.Pointer(bp+16)).Ftv_usec != (*Ttimeval)(unsafe.Pointer(bp+32)).Ftv_usec)
	} else {
		v1 = libc.BoolInt32((*Ttimeval)(unsafe.Pointer(bp+16)).Ftv_sec != (*Ttimeval)(unsafe.Pointer(bp+32)).Ftv_sec)
	}
	if !(v1 != 0) {
		if (*Ttimeval)(unsafe.Pointer(bp+16)).Ftv_sec == (*Ttimeval)(unsafe.Pointer(bp)).Ftv_sec {
			v2 = libc.BoolInt32((*Ttimeval)(unsafe.Pointer(bp+16)).Ftv_usec != (*Ttimeval)(unsafe.Pointer(bp)).Ftv_usec)
		} else {
			v2 = libc.BoolInt32((*Ttimeval)(unsafe.Pointer(bp+16)).Ftv_sec != (*Ttimeval)(unsafe.Pointer(bp)).Ftv_sec)
		}
		if !(v2 != 0) {
			if *(*uintptr)(unsafe.Pointer(closure)) != 0 {
				XFcDirCacheUnload(tls, *(*uintptr)(unsafe.Pointer(closure)))
			}
		} else {
			if v4 = *(*uintptr)(unsafe.Pointer(closure)) != 0; v4 {
				if (*Ttimeval)(unsafe.Pointer(bp+16)).Ftv_sec == (*Ttimeval)(unsafe.Pointer(latest_cache_mtime)).Ftv_sec {
					v3 = libc.BoolInt32((*Ttimeval)(unsafe.Pointer(bp+16)).Ftv_usec != (*Ttimeval)(unsafe.Pointer(latest_cache_mtime)).Ftv_usec)
				} else {
					v3 = libc.BoolInt32((*Ttimeval)(unsafe.Pointer(bp+16)).Ftv_sec != (*Ttimeval)(unsafe.Pointer(latest_cache_mtime)).Ftv_sec)
				}
			}
			if v4 && !(v3 != 0) {
				XFcDirCacheUnload(tls, cache)
				return m_FcFalse
			} else {
				if (*Ttimeval)(unsafe.Pointer(latest_cache_mtime)).Ftv_sec == (*Ttimeval)(unsafe.Pointer(bp)).Ftv_sec {
					v5 = libc.BoolInt32((*Ttimeval)(unsafe.Pointer(latest_cache_mtime)).Ftv_usec < (*Ttimeval)(unsafe.Pointer(bp)).Ftv_usec)
				} else {
					v5 = libc.BoolInt32((*Ttimeval)(unsafe.Pointer(latest_cache_mtime)).Ftv_sec < (*Ttimeval)(unsafe.Pointer(bp)).Ftv_sec)
				}
				if v5 != 0 {
					if *(*uintptr)(unsafe.Pointer(closure)) != 0 {
						XFcDirCacheUnload(tls, *(*uintptr)(unsafe.Pointer(closure)))
					}
				}
			}
		}
	} else {
		if (*Ttimeval)(unsafe.Pointer(latest_cache_mtime)).Ftv_sec == (*Ttimeval)(unsafe.Pointer(bp)).Ftv_sec {
			v6 = libc.BoolInt32((*Ttimeval)(unsafe.Pointer(latest_cache_mtime)).Ftv_usec < (*Ttimeval)(unsafe.Pointer(bp)).Ftv_usec)
		} else {
			v6 = libc.BoolInt32((*Ttimeval)(unsafe.Pointer(latest_cache_mtime)).Ftv_sec < (*Ttimeval)(unsafe.Pointer(bp)).Ftv_sec)
		}
		if v6 != 0 {
			if *(*uintptr)(unsafe.Pointer(closure)) != 0 {
				XFcDirCacheUnload(tls, *(*uintptr)(unsafe.Pointer(closure)))
			}
		} else {
			XFcDirCacheUnload(tls, cache)
			return m_FcFalse
		}
	}
	(*Ttimeval)(unsafe.Pointer(latest_cache_mtime)).Ftv_sec = (*(*Ttimeval)(unsafe.Pointer(bp))).Ftv_sec
	(*Ttimeval)(unsafe.Pointer(latest_cache_mtime)).Ftv_usec = (*(*Ttimeval)(unsafe.Pointer(bp))).Ftv_usec
	*(*uintptr)(unsafe.Pointer(closure)) = cache
	return int32(m_FcTrue)
}

func XFcDirCacheLoad(tls *libc.TLS, dir uintptr, config uintptr, cache_file uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* cache at bp+0 */ uintptr
	*(*uintptr)(unsafe.Pointer(bp)) = libc.UintptrFromInt32(0)
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return libc.UintptrFromInt32(0)
	}
	if !(_FcDirCacheProcess(tls, config, dir, __ccgo_fp(_FcDirCacheMapHelper), bp, cache_file) != 0) {
		*(*uintptr)(unsafe.Pointer(bp)) = libc.UintptrFromInt32(0)
	}
	XFcConfigDestroy(tls, config)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func XFcDirCacheLoadFile(tls *libc.TLS, cache_file uintptr, file_stat uintptr) (r uintptr) {
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var cache, config uintptr
	var fd int32
	var _ /* my_file_stat at bp+0 */ Tstat
	_, _, _ = cache, config, fd
	cache = libc.UintptrFromInt32(0)
	if !(file_stat != 0) {
		file_stat = bp
	}
	config = XFcConfigReference(tls, libc.UintptrFromInt32(0))
	if !(config != 0) {
		return libc.UintptrFromInt32(0)
	}
	fd = _FcDirCacheOpenFile(tls, cache_file, file_stat)
	if fd >= 0 {
		cache = _FcDirCacheMapFd(tls, config, fd, file_stat, libc.UintptrFromInt32(0))
		libc.Xclose(tls, fd)
	}
	XFcConfigDestroy(tls, config)
	return cache
}

func _FcDirChecksum(tls *libc.TLS, statb uintptr) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var epoch uint64
	var ret int32
	var source_date_epoch uintptr
	var _ /* endptr at bp+0 */ uintptr
	_, _, _ = epoch, ret, source_date_epoch
	ret = int32((*Tstat)(unsafe.Pointer(statb)).Fst_mtimespec.Ftv_sec)
	source_date_epoch = libc.Xgetenv(tls, __ccgo_ts+303)
	if source_date_epoch != 0 {
		*(*int32)(unsafe.Pointer(libc.X__error(tls))) = 0
		epoch = libc.Xstrtoull(tls, source_date_epoch, bp, int32(10))
		if *(*uintptr)(unsafe.Pointer(bp)) == source_date_epoch {
			libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+321, 0)
		} else {
			if *(*int32)(unsafe.Pointer(libc.X__error(tls))) == int32(m_ERANGE) && (epoch == libc.Uint64FromInt64(9223372036854775807)*libc.Uint64FromUint64(2)+libc.Uint64FromUint64(1) || epoch == uint64(0)) || *(*int32)(unsafe.Pointer(libc.X__error(tls))) != 0 && epoch == uint64(0) {
				libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+360, libc.VaList(bp+16, libc.Xstrerror(tls, *(*int32)(unsafe.Pointer(libc.X__error(tls)))), epoch))
			} else {
				if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32('\000') {
					libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+411, 0)
				} else {
					if epoch > uint64(libc.Uint64FromInt64(9223372036854775807)*libc.Uint64FromUint64(2)+libc.Uint64FromUint64(1)) {
						libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+463, libc.VaList(bp+16, libc.Uint64FromInt64(9223372036854775807)*libc.Uint64FromUint64(2)+libc.Uint64FromUint64(1), epoch))
					} else {
						if epoch < libc.Uint64FromInt32(ret) {
							/* Only override if directory is newer */
							ret = libc.Int32FromUint64(epoch)
						}
					}
				}
			}
		}
	}
	return ret
}

func _FcDirChecksumNano(tls *libc.TLS, statb uintptr) (r Tint64_t) {
	return 0
}

// C documentation
//
//	/*
//	 * Validate a cache file by reading the header and checking
//	 * the magic number and the size field
//	 */
func _FcDirCacheValidateHelper(tls *libc.TLS, config uintptr, fd int32, fd_stat uintptr, dir_stat uintptr, latest_cache_mtime uintptr, closure uintptr) (r TFcBool) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var ret TFcBool
	var _ /* c at bp+0 */ TFcCache
	_ = ret
	ret = int32(m_FcTrue)
	if libc.Uint64FromInt64(libc.Xread(tls, fd, bp, uint64(64))) != uint64(64) {
		ret = m_FcFalse
	} else {
		if (*(*TFcCache)(unsafe.Pointer(bp))).Fmagic != uint32(m_FC_CACHE_MAGIC_MMAP1) {
			ret = m_FcFalse
		} else {
			if (*(*TFcCache)(unsafe.Pointer(bp))).Fversion < int32(m_FC_CACHE_VERSION_NUMBER) {
				ret = m_FcFalse
			} else {
				if (*Tstat)(unsafe.Pointer(fd_stat)).Fst_size != (*(*TFcCache)(unsafe.Pointer(bp))).Fsize {
					ret = m_FcFalse
				} else {
					if (*(*TFcCache)(unsafe.Pointer(bp))).Fchecksum != _FcDirChecksum(tls, dir_stat) {
						ret = m_FcFalse
					}
				}
			}
		}
	}
	return ret
}

func _FcDirCacheValidConfig(tls *libc.TLS, dir uintptr, config uintptr) (r TFcBool) {
	return _FcDirCacheProcess(tls, config, dir, __ccgo_fp(_FcDirCacheValidateHelper), libc.UintptrFromInt32(0), libc.UintptrFromInt32(0))
}

func XFcDirCacheValid(tls *libc.TLS, dir uintptr) (r TFcBool) {
	var config uintptr
	var ret TFcBool
	_, _ = config, ret
	config = XFcConfigReference(tls, libc.UintptrFromInt32(0))
	if !(config != 0) {
		return m_FcFalse
	}
	ret = _FcDirCacheValidConfig(tls, dir, config)
	XFcConfigDestroy(tls, config)
	return ret
}

// C documentation
//
//	/*
//	 * Build a cache structure from the given contents
//	 */
func XFcDirCacheBuild(tls *libc.TLS, set uintptr, dir uintptr, dir_stat uintptr, dirs uintptr) (r uintptr) {
	var cache, d_serialize, dir_serialize, dirs_serialize, serialize, set_serialize uintptr
	var i int32
	_, _, _, _, _, _, _ = cache, d_serialize, dir_serialize, dirs_serialize, i, serialize, set_serialize
	serialize = XFcSerializeCreate(tls)
	if !(serialize != 0) {
		return libc.UintptrFromInt32(0)
	}
	/*
	 * Space for cache structure
	 */
	XFcSerializeReserve(tls, serialize, int32(64))
	/*
	 * Directory name
	 */
	if !(XFcStrSerializeAlloc(tls, serialize, dir) != 0) {
		goto bail1
	}
	/*
	 * Subdirs
	 */
	XFcSerializeAlloc(tls, serialize, dirs, libc.Int32FromUint64(libc.Uint64FromInt32((*TFcStrSet)(unsafe.Pointer(dirs)).Fnum)*uint64(8)))
	i = 0
	for {
		if !(i < (*TFcStrSet)(unsafe.Pointer(dirs)).Fnum) {
			break
		}
		if !(XFcStrSerializeAlloc(tls, serialize, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(dirs)).Fstrs + uintptr(i)*8))) != 0) {
			goto bail1
		}
		goto _1
	_1:
		;
		i++
	}
	/*
	 * Patterns
	 */
	if !(XFcFontSetSerializeAlloc(tls, serialize, set) != 0) {
		goto bail1
	}
	/* Serialize layout complete. Now allocate space and fill it */
	cache = libc.Xmalloc(tls, libc.Uint64FromInt64((*TFcSerialize)(unsafe.Pointer(serialize)).Fsize))
	if !(cache != 0) {
		goto bail1
	}
	/* shut up valgrind */
	libc.X__builtin___memset_chk(tls, cache, 0, libc.Uint64FromInt64((*TFcSerialize)(unsafe.Pointer(serialize)).Fsize), ^t__predefined_size_t(0))
	(*TFcSerialize)(unsafe.Pointer(serialize)).Flinear = cache
	(*TFcCache)(unsafe.Pointer(cache)).Fmagic = uint32(m_FC_CACHE_MAGIC_ALLOC1)
	(*TFcCache)(unsafe.Pointer(cache)).Fversion = int32(m_FC_CACHE_VERSION_NUMBER)
	(*TFcCache)(unsafe.Pointer(cache)).Fsize = (*TFcSerialize)(unsafe.Pointer(serialize)).Fsize
	(*TFcCache)(unsafe.Pointer(cache)).Fchecksum = _FcDirChecksum(tls, dir_stat)
	(*TFcCache)(unsafe.Pointer(cache)).Fchecksum_nano = _FcDirChecksumNano(tls, dir_stat)
	/*
	 * Serialize directory name
	 */
	dir_serialize = XFcStrSerialize(tls, serialize, dir)
	if !(dir_serialize != 0) {
		goto bail2
	}
	(*TFcCache)(unsafe.Pointer(cache)).Fdir = int64(dir_serialize) - int64(cache)
	/*
	 * Serialize sub dirs
	 */
	dirs_serialize = XFcSerializePtr(tls, serialize, dirs)
	if !(dirs_serialize != 0) {
		goto bail2
	}
	(*TFcCache)(unsafe.Pointer(cache)).Fdirs = int64(dirs_serialize) - int64(cache)
	(*TFcCache)(unsafe.Pointer(cache)).Fdirs_count = (*TFcStrSet)(unsafe.Pointer(dirs)).Fnum
	i = 0
	for {
		if !(i < (*TFcStrSet)(unsafe.Pointer(dirs)).Fnum) {
			break
		}
		d_serialize = XFcStrSerialize(tls, serialize, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(dirs)).Fstrs + uintptr(i)*8)))
		if !(d_serialize != 0) {
			goto bail2
		}
		*(*Tintptr_t)(unsafe.Pointer(dirs_serialize + uintptr(i)*8)) = int64(d_serialize) - int64(dirs_serialize)
		goto _2
	_2:
		;
		i++
	}
	/*
	 * Serialize font set
	 */
	set_serialize = XFcFontSetSerialize(tls, serialize, set)
	if !(set_serialize != 0) {
		goto bail2
	}
	(*TFcCache)(unsafe.Pointer(cache)).Fset = int64(set_serialize) - int64(cache)
	XFcSerializeDestroy(tls, serialize)
	_FcCacheInsert(tls, cache, libc.UintptrFromInt32(0))
	return cache
	goto bail2
bail2:
	;
	libc.Xfree(tls, cache)
	goto bail1
bail1:
	;
	XFcSerializeDestroy(tls, serialize)
	return libc.UintptrFromInt32(0)
}

func XFcDirCacheRebuild(tls *libc.TLS, cache uintptr, dir_stat uintptr, dirs uintptr) (r uintptr) {
	var dir, new1, set uintptr
	_, _, _ = dir, new1, set
	set = XFcFontSetDeserialize(tls, uintptr(int64(cache)+(*TFcCache)(unsafe.Pointer(cache)).Fset))
	dir = uintptr(int64(cache) + (*TFcCache)(unsafe.Pointer(cache)).Fdir)
	new1 = XFcDirCacheBuild(tls, set, dir, dir_stat, dirs)
	XFcFontSetDestroy(tls, set)
	return new1
}

// C documentation
//
//	/* write serialized state to the cache file */
func XFcDirCacheWrite(tls *libc.TLS, cache uintptr, config uintptr) (r TFcBool) {
	bp := tls.Alloc(224)
	defer tls.Free(224)
	var atomic, cache_dir, cache_hashed, d, dir, list, skip, sysroot, test_dir, v1, v2 uintptr
	var fd, written int32
	var magic uint32
	var _ /* cache_base at bp+0 */ [52]TFcChar8
	var _ /* cache_stat at bp+56 */ Tstat
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = atomic, cache_dir, cache_hashed, d, dir, fd, list, magic, skip, sysroot, test_dir, written, v1, v2
	dir = uintptr(int64(cache) + (*TFcCache)(unsafe.Pointer(cache)).Fdir)
	cache_dir = libc.UintptrFromInt32(0)
	d = libc.UintptrFromInt32(0)
	sysroot = XFcConfigGetSysRoot(tls, config)
	/*
	 * Write it to the first directory in the list which is writable
	 */
	list = XFcStrListCreate(tls, (*TFcConfig)(unsafe.Pointer(config)).FcacheDirs)
	if !(list != 0) {
		return m_FcFalse
	}
	for {
		v1 = XFcStrListNext(tls, list)
		test_dir = v1
		if !(v1 != 0) {
			break
		}
		if d != 0 {
			XFcStrFree(tls, d)
		}
		if sysroot != 0 {
			d = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+208, test_dir, libc.UintptrFromInt32(0)))
		} else {
			d = XFcStrCopyFilename(tls, test_dir)
		}
		if libc.Xaccess(tls, d, libc.Int32FromInt32(1)<<libc.Int32FromInt32(1)) == 0 {
			cache_dir = XFcStrCopyFilename(tls, d)
			break
		} else {
			/*
			 * If the directory doesn't exist, try to create it
			 */
			if libc.Xaccess(tls, d, m_F_OK) == -int32(1) {
				if XFcMakeDirectory(tls, d) != 0 {
					cache_dir = XFcStrCopyFilename(tls, d)
					/* Create CACHEDIR.TAG */
					XFcDirCacheCreateTagFile(tls, d)
					break
				}
			} else {
				if libc.Xchmod(tls, d, uint16(0755)) == 0 {
					cache_dir = XFcStrCopyFilename(tls, d)
					/* Try to create CACHEDIR.TAG too */
					XFcDirCacheCreateTagFile(tls, d)
					break
				}
			}
		}
	}
	if !(test_dir != 0) {
		libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+523, 0)
	}
	if d != 0 {
		XFcStrFree(tls, d)
	}
	XFcStrListDone(tls, list)
	if !(cache_dir != 0) {
		return m_FcFalse
	}
	_FcDirCacheBasenameMD5(tls, config, dir, bp)
	cache_hashed = XFcStrBuildFilename(tls, cache_dir, libc.VaList(bp+208, bp, libc.UintptrFromInt32(0)))
	XFcStrFree(tls, cache_dir)
	if !(cache_hashed != 0) {
		return m_FcFalse
	}
	if XFcDebugVal&int32(m_FC_DBG_CACHE) != 0 {
		libc.Xprintf(tls, __ccgo_ts+572, libc.VaList(bp+208, dir, cache_hashed))
	}
	atomic = XFcAtomicCreate(tls, cache_hashed)
	if !(atomic != 0) {
		goto bail1
	}
	if !(XFcAtomicLock(tls, atomic) != 0) {
		goto bail3
	}
	fd = XFcOpen(tls, XFcAtomicNewFile(tls, atomic), libc.Int32FromInt32(m_O_RDWR)|libc.Int32FromInt32(m_O_CREAT)|libc.Int32FromInt32(m_O_BINARY), libc.VaList(bp+208, int32(0666)))
	if fd == -int32(1) {
		goto bail4
	}
	/* Temporarily switch magic to MMAP while writing to file */
	magic = (*TFcCache)(unsafe.Pointer(cache)).Fmagic
	if magic != uint32(m_FC_CACHE_MAGIC_MMAP1) {
		(*TFcCache)(unsafe.Pointer(cache)).Fmagic = uint32(m_FC_CACHE_MAGIC_MMAP1)
	}
	/*
	 * Write cache contents to file
	 */
	written = int32(libc.Xwrite(tls, fd, cache, libc.Uint64FromInt64((*TFcCache)(unsafe.Pointer(cache)).Fsize)))
	/* Switch magic back */
	if magic != uint32(m_FC_CACHE_MAGIC_MMAP1) {
		(*TFcCache)(unsafe.Pointer(cache)).Fmagic = magic
	}
	if int64(written) != (*TFcCache)(unsafe.Pointer(cache)).Fsize {
		libc.Xperror(tls, __ccgo_ts+611)
		goto bail5
	}
	libc.Xclose(tls, fd)
	if !(XFcAtomicReplaceOrig(tls, atomic) != 0) {
		goto bail4
	}
	/* If the file is small, update the cache chain entry such that the
	 * new cache file is not read again.  If it's large, we don't do that
	 * such that we reload it, using mmap, which is shared across processes.
	 */
	if (*TFcCache)(unsafe.Pointer(cache)).Fsize < int64(m_FC_CACHE_MIN_MMAP) && XFcStat(tls, cache_hashed, bp+56) != 0 {
		_lock_cache(tls)
		v2 = _FcCacheFindByAddrUnlocked(tls, cache)
		skip = v2
		if v2 != 0 {
			(*TFcCacheSkip)(unsafe.Pointer(skip)).Fcache_dev = (*(*Tstat)(unsafe.Pointer(bp + 56))).Fst_dev
			(*TFcCacheSkip)(unsafe.Pointer(skip)).Fcache_ino = (*(*Tstat)(unsafe.Pointer(bp + 56))).Fst_ino
			(*TFcCacheSkip)(unsafe.Pointer(skip)).Fcache_mtime = (*(*Tstat)(unsafe.Pointer(bp + 56))).Fst_mtimespec.Ftv_sec
			(*TFcCacheSkip)(unsafe.Pointer(skip)).Fcache_mtime_nano = 0
		}
		_unlock_cache(tls)
	}
	XFcStrFree(tls, cache_hashed)
	XFcAtomicUnlock(tls, atomic)
	XFcAtomicDestroy(tls, atomic)
	return int32(m_FcTrue)
	goto bail5
bail5:
	;
	libc.Xclose(tls, fd)
	goto bail4
bail4:
	;
	XFcAtomicUnlock(tls, atomic)
	goto bail3
bail3:
	;
	XFcAtomicDestroy(tls, atomic)
	goto bail1
bail1:
	;
	XFcStrFree(tls, cache_hashed)
	return m_FcFalse
}

func XFcDirCacheClean(tls *libc.TLS, cache_dir uintptr, verbose TFcBool) (r TFcBool) {
	bp := tls.Alloc(176)
	defer tls.Free(176)
	var cache, config, d, dir, ent, file_name, s, sysroot, target_dir, v1, v2 uintptr
	var remove, ret TFcBool
	var _ /* target_stat at bp+0 */ Tstat
	_, _, _, _, _, _, _, _, _, _, _, _, _ = cache, config, d, dir, ent, file_name, remove, ret, s, sysroot, target_dir, v1, v2
	ret = int32(m_FcTrue)
	config = XFcConfigReference(tls, libc.UintptrFromInt32(0))
	if !(config != 0) {
		return m_FcFalse
	}
	/* FIXME: this API needs to support non-current FcConfig */
	sysroot = XFcConfigGetSysRoot(tls, config)
	if sysroot != 0 {
		dir = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+152, cache_dir, libc.UintptrFromInt32(0)))
	} else {
		dir = XFcStrCopyFilename(tls, cache_dir)
	}
	if !(dir != 0) {
		libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+623, libc.VaList(bp+152, cache_dir))
		ret = m_FcFalse
		goto bail
	}
	if libc.Xaccess(tls, dir, libc.Int32FromInt32(1)<<libc.Int32FromInt32(1)) != 0 {
		if verbose != 0 || XFcDebugVal&int32(m_FC_DBG_CACHE) != 0 {
			if libc.Xaccess(tls, dir, m_F_OK) == 0 {
				v1 = __ccgo_ts + 660
			} else {
				v1 = __ccgo_ts + 671
			}
			libc.Xprintf(tls, __ccgo_ts+684, libc.VaList(bp+152, dir, v1))
		}
		goto bail0
	}
	if verbose != 0 || XFcDebugVal&int32(m_FC_DBG_CACHE) != 0 {
		libc.Xprintf(tls, __ccgo_ts+721, libc.VaList(bp+152, dir))
	}
	d = libc.Xopendir(tls, dir)
	if !(d != 0) {
		libc.Xperror(tls, dir)
		ret = m_FcFalse
		goto bail0
	}
	for {
		v2 = libc.Xreaddir(tls, d)
		ent = v2
		if !(v2 != 0) {
			break
		}
		if int32(*(*int8)(unsafe.Pointer(ent + 21))) == int32('.') {
			continue
		}
		/* skip cache files for different architectures and */
		/* files which are not cache files at all */
		if libc.Xstrlen(tls, ent+21) != uint64(32)+libc.Xstrlen(tls, __ccgo_ts+83) || libc.Xstrcmp(tls, ent+21+uintptr(32), __ccgo_ts+83) != 0 {
			continue
		}
		file_name = XFcStrBuildFilename(tls, dir, libc.VaList(bp+152, ent+21, libc.UintptrFromInt32(0)))
		if !(file_name != 0) {
			libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+751, libc.VaList(bp+152, dir))
			ret = m_FcFalse
			break
		}
		remove = m_FcFalse
		cache = XFcDirCacheLoadFile(tls, file_name, libc.UintptrFromInt32(0))
		if !(cache != 0) {
			if verbose != 0 || XFcDebugVal&int32(m_FC_DBG_CACHE) != 0 {
				libc.Xprintf(tls, __ccgo_ts+793, libc.VaList(bp+152, dir, ent+21))
			}
			remove = int32(m_FcTrue)
		} else {
			target_dir = uintptr(int64(cache) + (*TFcCache)(unsafe.Pointer(cache)).Fdir)
			if sysroot != 0 {
				s = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+152, target_dir, libc.UintptrFromInt32(0)))
			} else {
				s = libc.Xstrdup(tls, target_dir)
			}
			if libc.Xstat(tls, s, bp) < 0 {
				if verbose != 0 || XFcDebugVal&int32(m_FC_DBG_CACHE) != 0 {
					libc.Xprintf(tls, __ccgo_ts+821, libc.VaList(bp+152, dir, ent+21, s))
				}
				remove = int32(m_FcTrue)
			}
			XFcDirCacheUnload(tls, cache)
			XFcStrFree(tls, s)
		}
		if remove != 0 {
			if libc.Xunlink(tls, file_name) < 0 {
				libc.Xperror(tls, file_name)
				ret = m_FcFalse
			}
		}
		XFcStrFree(tls, file_name)
	}
	libc.Xclosedir(tls, d)
	goto bail0
bail0:
	;
	XFcStrFree(tls, dir)
	goto bail
bail:
	;
	XFcConfigDestroy(tls, config)
	return ret
}

func XFcDirCacheLock(tls *libc.TLS, dir uintptr, config uintptr) (r int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var cache_dir, cache_hashed, list, sysroot, v1 uintptr
	var fd int32
	var _ /* cache_base at bp+0 */ [52]TFcChar8
	var _ /* fl at bp+56 */ Tflock
	_, _, _, _, _, _ = cache_dir, cache_hashed, fd, list, sysroot, v1
	cache_hashed = libc.UintptrFromInt32(0)
	sysroot = XFcConfigGetSysRoot(tls, config)
	fd = -int32(1)
	_FcDirCacheBasenameMD5(tls, config, dir, bp)
	list = XFcStrListCreate(tls, (*TFcConfig)(unsafe.Pointer(config)).FcacheDirs)
	if !(list != 0) {
		return -int32(1)
	}
	for {
		v1 = XFcStrListNext(tls, list)
		cache_dir = v1
		if !(v1 != 0) {
			break
		}
		if sysroot != 0 {
			cache_hashed = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+88, cache_dir, bp, libc.UintptrFromInt32(0)))
		} else {
			cache_hashed = XFcStrBuildFilename(tls, cache_dir, libc.VaList(bp+88, bp, libc.UintptrFromInt32(0)))
		}
		if !(cache_hashed != 0) {
			break
		}
		fd = XFcOpen(tls, cache_hashed, int32(m_O_RDWR), 0)
		XFcStrFree(tls, cache_hashed)
		/* No caches in that directory. simply retry with another one */
		if fd != -int32(1) {
			(*(*Tflock)(unsafe.Pointer(bp + 56))).Fl_type = int16(m_F_WRLCK)
			(*(*Tflock)(unsafe.Pointer(bp + 56))).Fl_whence = m_SEEK_SET
			(*(*Tflock)(unsafe.Pointer(bp + 56))).Fl_start = 0
			(*(*Tflock)(unsafe.Pointer(bp + 56))).Fl_len = 0
			(*(*Tflock)(unsafe.Pointer(bp + 56))).Fl_pid = libc.Xgetpid(tls)
			if libc.Xfcntl(tls, fd, int32(m_F_SETLKW), libc.VaList(bp+88, bp+56)) == -int32(1) {
				goto bail
			}
			break
		}
	}
	XFcStrListDone(tls, list)
	return fd
	goto bail
bail:
	;
	XFcStrListDone(tls, list)
	if fd != -int32(1) {
		libc.Xclose(tls, fd)
	}
	return -int32(1)
}

func XFcDirCacheUnlock(tls *libc.TLS, fd int32) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var _ /* fl at bp+0 */ Tflock
	if fd != -int32(1) {
		(*(*Tflock)(unsafe.Pointer(bp))).Fl_type = int16(m_F_UNLCK)
		(*(*Tflock)(unsafe.Pointer(bp))).Fl_whence = m_SEEK_SET
		(*(*Tflock)(unsafe.Pointer(bp))).Fl_start = 0
		(*(*Tflock)(unsafe.Pointer(bp))).Fl_len = 0
		(*(*Tflock)(unsafe.Pointer(bp))).Fl_pid = libc.Xgetpid(tls)
		libc.Xfcntl(tls, fd, int32(m_F_SETLK), libc.VaList(bp+32, bp))
		libc.Xclose(tls, fd)
	}
}

/*
 * Hokey little macro trick to permit the definitions of C functions
 * with the same name as CPP macros
 */

func XFcCacheDir(tls *libc.TLS, c uintptr) (r uintptr) {
	return uintptr(int64(c) + (*TFcCache)(unsafe.Pointer(c)).Fdir)
}

func XFcCacheCopySet(tls *libc.TLS, c uintptr) (r uintptr) {
	var font, new1, old, v2, v3 uintptr
	var i int32
	_, _, _, _, _, _ = font, i, new1, old, v2, v3
	old = uintptr(int64(c) + (*TFcCache)(unsafe.Pointer(c)).Fset)
	new1 = XFcFontSetCreate(tls)
	if !(new1 != 0) {
		return libc.UintptrFromInt32(0)
	}
	i = 0
	for {
		if !(i < (*TFcFontSet)(unsafe.Pointer(old)).Fnfont) {
			break
		}
		if int64((*TFcFontSet)(unsafe.Pointer(old)).Ffonts)&int64(1) != 0 {
			if int64((*TFcFontSet)(unsafe.Pointer(old)).Ffonts)&int64(1) != 0 {
				v3 = uintptr(int64(old) + int64((*TFcFontSet)(unsafe.Pointer(old)).Ffonts)&int64(^libc.Int32FromInt32(1)))
			} else {
				v3 = (*TFcFontSet)(unsafe.Pointer(old)).Ffonts
			}
			v2 = uintptr(int64(old) + int64(*(*uintptr)(unsafe.Pointer(v3 + uintptr(i)*8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(old)).Ffonts + uintptr(i)*8))
		}
		font = v2
		XFcPatternReference(tls, font)
		if !(XFcFontSetAdd(tls, new1, font) != 0) {
			XFcFontSetDestroy(tls, new1)
			return libc.UintptrFromInt32(0)
		}
		goto _1
	_1:
		;
		i++
	}
	return new1
}

func XFcCacheSubdir(tls *libc.TLS, c uintptr, i int32) (r uintptr) {
	return uintptr(int64(uintptr(int64(c)+(*TFcCache)(unsafe.Pointer(c)).Fdirs)) + *(*Tintptr_t)(unsafe.Pointer(uintptr(int64(c)+(*TFcCache)(unsafe.Pointer(c)).Fdirs) + uintptr(i)*8)))
}

func XFcCacheNumSubdir(tls *libc.TLS, c uintptr) (r int32) {
	return (*TFcCache)(unsafe.Pointer(c)).Fdirs_count
}

func XFcCacheNumFont(tls *libc.TLS, c uintptr) (r int32) {
	return (*TFcFontSet)(unsafe.Pointer(uintptr(int64(c) + (*TFcCache)(unsafe.Pointer(c)).Fset))).Fnfont
}

func XFcDirCacheCreateTagFile(tls *libc.TLS, cache_dir uintptr) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var atomic, cache_tag, fp uintptr
	var fd int32
	var ret TFcBool
	_, _, _, _, _ = atomic, cache_tag, fd, fp, ret
	ret = m_FcFalse
	if !(cache_dir != 0) {
		return m_FcFalse
	}
	if libc.Xaccess(tls, cache_dir, libc.Int32FromInt32(1)<<libc.Int32FromInt32(1)) == 0 {
		/* Create CACHEDIR.TAG */
		cache_tag = XFcStrBuildFilename(tls, cache_dir, libc.VaList(bp+8, __ccgo_ts+853, libc.UintptrFromInt32(0)))
		if !(cache_tag != 0) {
			return m_FcFalse
		}
		atomic = XFcAtomicCreate(tls, cache_tag)
		if !(atomic != 0) {
			goto bail1
		}
		if !(XFcAtomicLock(tls, atomic) != 0) {
			goto bail2
		}
		fd = XFcOpen(tls, XFcAtomicNewFile(tls, atomic), libc.Int32FromInt32(m_O_RDWR)|libc.Int32FromInt32(m_O_CREAT), libc.VaList(bp+8, int32(0644)))
		if fd == -int32(1) {
			goto bail3
		}
		fp = libc.Xfdopen(tls, fd, __ccgo_ts+866)
		if fp == libc.UintptrFromInt32(0) {
			goto bail3
		}
		libc.Xfwrite(tls, uintptr(unsafe.Pointer(&_cache_tag_contents)), _cache_tag_contents_size, uint64(1), fp)
		libc.Xfclose(tls, fp)
		if !(XFcAtomicReplaceOrig(tls, atomic) != 0) {
			goto bail3
		}
		ret = int32(m_FcTrue)
		goto bail3
	bail3:
		;
		XFcAtomicUnlock(tls, atomic)
		goto bail2
	bail2:
		;
		XFcAtomicDestroy(tls, atomic)
		goto bail1
	bail1:
		;
		XFcStrFree(tls, cache_tag)
	}
	if XFcDebugVal&int32(m_FC_DBG_CACHE) != 0 {
		if ret != 0 {
			libc.Xprintf(tls, __ccgo_ts+869, libc.VaList(bp+8, cache_dir))
		} else {
			libc.Xprintf(tls, __ccgo_ts+897, libc.VaList(bp+8, cache_dir))
		}
	}
	return ret
}

var _cache_tag_contents = [201]TFcChar8{'S', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', ':', ' ', '8', 'a', '4', '7', '7', 'f', '5', '9', '7', 'd', '2', '8', 'd', '1', '7', '2', '7', '8', '9', 'f', '0', '6', '8', '8', '6', '8', '0', '6', 'b', 'c', '5', '5', 10, '#', ' ', 'T', 'h', 'i', 's', ' ', 'f', 'i', 'l', 'e', ' ', 'i', 's', ' ', 'a', ' ', 'c', 'a', 'c', 'h', 'e', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', ' ', 't', 'a', 'g', ' ', 'c', 'r', 'e', 'a', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'f', 'o', 'n', 't', 'c', 'o', 'n', 'f', 'i', 'g', '.', 10, '#', ' ', 'F', 'o', 'r', ' ', 'i', 'n', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n', ' ', 'a', 'b', 'o', 'u', 't', ' ', 'c', 'a', 'c', 'h', 'e', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', ' ', 't', 'a', 'g', 's', ',', ' ', 's', 'e', 'e', ':', 10, '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'b', 'r', 'y', 'n', 'o', 's', 'a', 'u', 'r', 'u', 's', '.', 'c', 'o', 'm', '/', 'c', 'a', 'c', 'h', 'e', 'd', 'i', 'r', '/', 10}

var _cache_tag_contents_size = libc.Uint64FromInt64(201) - libc.Uint64FromInt32(1)

func XFcCacheCreateTagFile(tls *libc.TLS, config uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var cache_dir, d, list, sysroot, v1 uintptr
	_, _, _, _, _ = cache_dir, d, list, sysroot, v1
	cache_dir = libc.UintptrFromInt32(0)
	d = libc.UintptrFromInt32(0)
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return
	}
	sysroot = XFcConfigGetSysRoot(tls, config)
	list = XFcConfigGetCacheDirs(tls, config)
	if !(list != 0) {
		goto bail
	}
	for {
		v1 = XFcStrListNext(tls, list)
		cache_dir = v1
		if !(v1 != 0) {
			break
		}
		if d != 0 {
			XFcStrFree(tls, d)
		}
		if sysroot != 0 {
			d = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+8, cache_dir, libc.UintptrFromInt32(0)))
		} else {
			d = XFcStrCopyFilename(tls, cache_dir)
		}
		if XFcDirCacheCreateTagFile(tls, d) != 0 {
			break
		}
	}
	if d != 0 {
		XFcStrFree(tls, d)
	}
	XFcStrListDone(tls, list)
	goto bail
bail:
	;
	XFcConfigDestroy(tls, config)
}

const m_FC_CACHE_MAGIC_ALLOC2 = 0xFC02FC05
const m_FC_CACHE_MAGIC_MMAP2 = 0xFC02FC04
const m_FC_DIR_SEPARATOR1 = 47
const m_FC_DIR_SEPARATOR_S1 = "/.cache"
const m_FC_SEARCH_PATH_SEPARATOR1 = 58
const m_FONTCONFIG_FILE = "fonts.conf"
const m_S_IFIFO1 = 4096
const m_S_IFMT1 = 61440

/*
 * Copyright (c) 2000-2021 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)types.h	8.4 (Berkeley) 1/21/94
 */

var __fcConfig uintptr /* MT-safe */
var __lock uintptr

func _lock_config(tls *libc.TLS) {
	var lock uintptr
	var v1 int32
	_, _ = lock, v1
	goto retry
retry:
	;
	lock = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__lock))))
	if !(lock != 0) {
		lock = libc.Xmalloc(tls, uint64(4))
		_ = lock
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__lock)))) == libc.UintptrFromInt32(0) {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__lock)))) = lock
			v1 = libc.Int32FromInt32(m_FcTrue)
		} else {
			v1 = m_FcFalse
		}
		if !(v1 != 0) {
			_ = lock
			libc.Xfree(tls, lock)
			goto retry
		}
		_ = lock
		/* Initialize random state */
		XFcRandom(tls)
		return
	}
	_ = lock
}

func _unlock_config(tls *libc.TLS) {
	var lock uintptr
	_ = lock
	lock = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__lock))))
	_ = lock
}

func _free_lock1(tls *libc.TLS) {
	var lock uintptr
	var v1 int32
	var v2 bool
	_, _, _ = lock, v1, v2
	lock = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__lock))))
	if v2 = lock != 0; v2 {
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__lock)))) == lock {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__lock)))) = libc.UintptrFromInt32(0)
			v1 = libc.Int32FromInt32(m_FcTrue)
		} else {
			v1 = m_FcFalse
		}
	}
	if v2 && v1 != 0 {
		_ = lock
		libc.Xfree(tls, lock)
	}
}

func _FcConfigEnsure(tls *libc.TLS) (r uintptr) {
	var config uintptr
	var v1 int32
	var v2 bool
	_, _, _ = config, v1, v2
	goto retry
retry:
	;
	config = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig))))
	if !(config != 0) {
		config = XFcInitLoadConfigAndFonts(tls)
		if v2 = !(config != 0); !v2 {
			if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig)))) == libc.UintptrFromInt32(0) {
				*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig)))) = config
				v1 = libc.Int32FromInt32(m_FcTrue)
			} else {
				v1 = m_FcFalse
			}
		}
		if v2 || !(v1 != 0) {
			if config != 0 {
				XFcConfigDestroy(tls, config)
			}
			goto retry
		}
	}
	return config
}

func _FcDestroyAsRule(tls *libc.TLS, data uintptr) {
	XFcRuleDestroy(tls, data)
}

func _FcDestroyAsRuleSet(tls *libc.TLS, data uintptr) {
	XFcRuleSetDestroy(tls, data)
}

func XFcConfigInit(tls *libc.TLS) (r TFcBool) {
	var v1 int32
	_ = v1
	if _FcConfigEnsure(tls) != 0 {
		v1 = int32(m_FcTrue)
	} else {
		v1 = m_FcFalse
	}
	return v1
}

func XFcConfigFini(tls *libc.TLS) {
	var cfg uintptr
	var v1 int32
	var v2 bool
	_, _, _ = cfg, v1, v2
	cfg = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig))))
	if v2 = cfg != 0; v2 {
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig)))) == cfg {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig)))) = libc.UintptrFromInt32(0)
			v1 = libc.Int32FromInt32(m_FcTrue)
		} else {
			v1 = m_FcFalse
		}
	}
	if v2 && v1 != 0 {
		XFcConfigDestroy(tls, cfg)
	}
	_free_lock1(tls)
}

func XFcConfigCreate(tls *libc.TLS) (r uintptr) {
	var config uintptr
	var err TFcBool
	var k TFcMatchKind
	var set TFcSetName
	_, _, _, _ = config, err, k, set
	err = m_FcFalse
	config = libc.Xmalloc(tls, uint64(168))
	if !(config != 0) {
		goto bail0
	}
	(*TFcConfig)(unsafe.Pointer(config)).FconfigDirs = XFcStrSetCreate(tls)
	if !((*TFcConfig)(unsafe.Pointer(config)).FconfigDirs != 0) {
		goto bail1
	}
	(*TFcConfig)(unsafe.Pointer(config)).FconfigMapDirs = XFcStrSetCreate(tls)
	if !((*TFcConfig)(unsafe.Pointer(config)).FconfigMapDirs != 0) {
		goto bail1_5
	}
	(*TFcConfig)(unsafe.Pointer(config)).FconfigFiles = XFcStrSetCreate(tls)
	if !((*TFcConfig)(unsafe.Pointer(config)).FconfigFiles != 0) {
		goto bail2
	}
	(*TFcConfig)(unsafe.Pointer(config)).FfontDirs = XFcStrSetCreate(tls)
	if !((*TFcConfig)(unsafe.Pointer(config)).FfontDirs != 0) {
		goto bail3
	}
	(*TFcConfig)(unsafe.Pointer(config)).FacceptGlobs = XFcStrSetCreate(tls)
	if !((*TFcConfig)(unsafe.Pointer(config)).FacceptGlobs != 0) {
		goto bail4
	}
	(*TFcConfig)(unsafe.Pointer(config)).FrejectGlobs = XFcStrSetCreate(tls)
	if !((*TFcConfig)(unsafe.Pointer(config)).FrejectGlobs != 0) {
		goto bail5
	}
	(*TFcConfig)(unsafe.Pointer(config)).FacceptPatterns = XFcFontSetCreate(tls)
	if !((*TFcConfig)(unsafe.Pointer(config)).FacceptPatterns != 0) {
		goto bail6
	}
	(*TFcConfig)(unsafe.Pointer(config)).FrejectPatterns = XFcFontSetCreate(tls)
	if !((*TFcConfig)(unsafe.Pointer(config)).FrejectPatterns != 0) {
		goto bail7
	}
	(*TFcConfig)(unsafe.Pointer(config)).FcacheDirs = XFcStrSetCreate(tls)
	if !((*TFcConfig)(unsafe.Pointer(config)).FcacheDirs != 0) {
		goto bail8
	}
	k = int32(_FcMatchKindBegin)
	for {
		if !(k < int32(_FcMatchKindEnd)) {
			break
		}
		*(*uintptr)(unsafe.Pointer(config + 40 + uintptr(k)*8)) = XFcPtrListCreate(tls, __ccgo_fp(_FcDestroyAsRuleSet))
		if !(*(*uintptr)(unsafe.Pointer(config + 40 + uintptr(k)*8)) != 0) {
			err = int32(m_FcTrue)
		}
		goto _1
	_1:
		;
		k++
	}
	if err != 0 {
		goto bail9
	}
	(*TFcConfig)(unsafe.Pointer(config)).FmaxObjects = 0
	set = int32(_FcSetSystem)
	for {
		if !(set <= int32(_FcSetApplication)) {
			break
		}
		*(*uintptr)(unsafe.Pointer(config + 104 + uintptr(set)*8)) = uintptr(0)
		goto _2
	_2:
		;
		set++
	}
	(*TFcConfig)(unsafe.Pointer(config)).FrescanTime = libc.Xtime(tls, uintptr(0))
	(*TFcConfig)(unsafe.Pointer(config)).FrescanInterval = int32(30)
	(*TFcConfig)(unsafe.Pointer(config)).Fexpr_pool = libc.UintptrFromInt32(0)
	(*TFcConfig)(unsafe.Pointer(config)).FsysRoot = XFcStrRealPath(tls, libc.Xgetenv(tls, __ccgo_ts+934))
	(*TFcConfig)(unsafe.Pointer(config)).FrulesetList = XFcPtrListCreate(tls, __ccgo_fp(_FcDestroyAsRuleSet))
	if !((*TFcConfig)(unsafe.Pointer(config)).FrulesetList != 0) {
		goto bail9
	}
	(*TFcConfig)(unsafe.Pointer(config)).FavailConfigFiles = XFcStrSetCreate(tls)
	if !((*TFcConfig)(unsafe.Pointer(config)).FavailConfigFiles != 0) {
		goto bail10
	}
	(*TFcRef)(unsafe.Pointer(config + 132)).Fcount = int32(1)
	return config
	goto bail10
bail10:
	;
	XFcPtrListDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FrulesetList)
	goto bail9
bail9:
	;
	k = int32(_FcMatchKindBegin)
	for {
		if !(k < int32(_FcMatchKindEnd)) {
			break
		}
		if *(*uintptr)(unsafe.Pointer(config + 40 + uintptr(k)*8)) != 0 {
			XFcPtrListDestroy(tls, *(*uintptr)(unsafe.Pointer(config + 40 + uintptr(k)*8)))
		}
		goto _3
	_3:
		;
		k++
	}
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FcacheDirs)
	goto bail8
bail8:
	;
	XFcFontSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FrejectPatterns)
	goto bail7
bail7:
	;
	XFcFontSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FacceptPatterns)
	goto bail6
bail6:
	;
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FrejectGlobs)
	goto bail5
bail5:
	;
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FacceptGlobs)
	goto bail4
bail4:
	;
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FfontDirs)
	goto bail3
bail3:
	;
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FconfigFiles)
	goto bail2
bail2:
	;
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FconfigMapDirs)
	goto bail1_5
bail1_5:
	;
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FconfigDirs)
	goto bail1
bail1:
	;
	libc.Xfree(tls, config)
	goto bail0
bail0:
	;
	return uintptr(0)
	return r
}

func _FcConfigNewestFile(tls *libc.TLS, files uintptr) (r TFcFileTime) {
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var file, list, v1 uintptr
	var newest TFcFileTime
	var _ /* statb at bp+0 */ Tstat
	_, _, _, _ = file, list, newest, v1
	list = XFcStrListCreate(tls, files)
	newest = TFcFileTime{}
	if list != 0 {
		for {
			v1 = XFcStrListNext(tls, list)
			file = v1
			if !(v1 != 0) {
				break
			}
			if XFcStat(tls, file, bp) == 0 {
				if !(newest.Fset != 0) || (*(*Tstat)(unsafe.Pointer(bp))).Fst_mtimespec.Ftv_sec-newest.Ftime > 0 {
					newest.Fset = int32(m_FcTrue)
					newest.Ftime = (*(*Tstat)(unsafe.Pointer(bp))).Fst_mtimespec.Ftv_sec
				}
			}
		}
		XFcStrListDone(tls, list)
	}
	return newest
}

func XFcConfigUptoDate(tls *libc.TLS, config uintptr) (r TFcBool) {
	var config_dir_time, config_time, font_time TFcFileTime
	var now Ttime_t
	var ret TFcBool
	_, _, _, _, _ = config_dir_time, config_time, font_time, now, ret
	now = libc.Xtime(tls, uintptr(0))
	ret = int32(m_FcTrue)
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return m_FcFalse
	}
	config_time = _FcConfigNewestFile(tls, (*TFcConfig)(unsafe.Pointer(config)).FconfigFiles)
	config_dir_time = _FcConfigNewestFile(tls, (*TFcConfig)(unsafe.Pointer(config)).FconfigDirs)
	font_time = _FcConfigNewestFile(tls, (*TFcConfig)(unsafe.Pointer(config)).FfontDirs)
	if config_time.Fset != 0 && config_time.Ftime-(*TFcConfig)(unsafe.Pointer(config)).FrescanTime > 0 || config_dir_time.Fset != 0 && config_dir_time.Ftime-(*TFcConfig)(unsafe.Pointer(config)).FrescanTime > 0 || font_time.Fset != 0 && font_time.Ftime-(*TFcConfig)(unsafe.Pointer(config)).FrescanTime > 0 {
		/* We need to check for potential clock problems here (OLPC ticket #6046) */
		if config_time.Fset != 0 && config_time.Ftime-now > 0 || config_dir_time.Fset != 0 && config_dir_time.Ftime-now > 0 || font_time.Fset != 0 && font_time.Ftime-now > 0 {
			libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+953, 0)
			(*TFcConfig)(unsafe.Pointer(config)).FrescanTime = now
			goto bail
		} else {
			ret = m_FcFalse
			goto bail
		}
	}
	(*TFcConfig)(unsafe.Pointer(config)).FrescanTime = now
	goto bail
bail:
	;
	XFcConfigDestroy(tls, config)
	return ret
}

func XFcConfigAllocExpr(tls *libc.TLS, config uintptr) (r uintptr) {
	var new_page, v1, v2 uintptr
	_, _, _ = new_page, v1, v2
	if !((*TFcConfig)(unsafe.Pointer(config)).Fexpr_pool != 0) || (*TFcExprPage)(unsafe.Pointer((*TFcConfig)(unsafe.Pointer(config)).Fexpr_pool)).Fnext == (*TFcConfig)(unsafe.Pointer(config)).Fexpr_pool+8176 {
		new_page = libc.Xmalloc(tls, uint64(8176))
		if !(new_page != 0) {
			return uintptr(0)
		}
		(*TFcExprPage)(unsafe.Pointer(new_page)).Fnext_page = (*TFcConfig)(unsafe.Pointer(config)).Fexpr_pool
		(*TFcExprPage)(unsafe.Pointer(new_page)).Fnext = new_page + 16
		(*TFcConfig)(unsafe.Pointer(config)).Fexpr_pool = new_page
	}
	v2 = (*TFcConfig)(unsafe.Pointer(config)).Fexpr_pool + 8
	v1 = *(*uintptr)(unsafe.Pointer(v2))
	*(*uintptr)(unsafe.Pointer(v2)) += 24
	return v1
}

func XFcConfigReference(tls *libc.TLS, config uintptr) (r uintptr) {
	var v1 int32
	var p3, p5 uintptr
	_, _, _ = v1, p3, p5
	if !(config != 0) {
		/* lock during obtaining the value from _fcConfig and count up refcount there,
		 * there are the race between them.
		 */
		_lock_config(tls)
		goto retry
	retry:
		;
		config = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig))))
		if !(config != 0) {
			_unlock_config(tls)
			config = XFcInitLoadConfigAndFonts(tls)
			if !(config != 0) {
				goto retry
			}
			_lock_config(tls)
			if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig)))) == libc.UintptrFromInt32(0) {
				*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig)))) = config
				v1 = libc.Int32FromInt32(m_FcTrue)
			} else {
				v1 = m_FcFalse
			}
			if !(v1 != 0) {
				XFcConfigDestroy(tls, config)
				goto retry
			}
		}
		p3 = config + 132
		*(*Tfc_atomic_int_t)(unsafe.Pointer(p3)) += +libc.Int32FromInt32(1)
		_ = *(*Tfc_atomic_int_t)(unsafe.Pointer(p3)) - +libc.Int32FromInt32(1)
		goto _2
	_2:
		;
		_unlock_config(tls)
	} else {
		p5 = config + 132
		*(*Tfc_atomic_int_t)(unsafe.Pointer(p5)) += +libc.Int32FromInt32(1)
		_ = *(*Tfc_atomic_int_t)(unsafe.Pointer(p5)) - +libc.Int32FromInt32(1)
		goto _4
	_4:
	}
	return config
}

func XFcConfigDestroy(tls *libc.TLS, config uintptr) {
	var k TFcMatchKind
	var next, page, p3 uintptr
	var set TFcSetName
	var v1 int32
	_, _, _, _, _, _ = k, next, page, set, v1, p3
	p3 = config + 132
	*(*Tfc_atomic_int_t)(unsafe.Pointer(p3)) += -int32(1)
	v1 = *(*Tfc_atomic_int_t)(unsafe.Pointer(p3)) - -int32(1)
	goto _2
_2:
	if v1 != int32(1) {
		return
	}
	if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig)))) == config {
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig)))) = libc.UintptrFromInt32(0)
		_ = libc.Int32FromInt32(m_FcTrue)
	}
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FconfigDirs)
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FconfigMapDirs)
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FfontDirs)
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FcacheDirs)
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FconfigFiles)
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FacceptGlobs)
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FrejectGlobs)
	XFcFontSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FacceptPatterns)
	XFcFontSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FrejectPatterns)
	k = int32(_FcMatchKindBegin)
	for {
		if !(k < int32(_FcMatchKindEnd)) {
			break
		}
		XFcPtrListDestroy(tls, *(*uintptr)(unsafe.Pointer(config + 40 + uintptr(k)*8)))
		goto _5
	_5:
		;
		k++
	}
	XFcPtrListDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FrulesetList)
	XFcStrSetDestroy(tls, (*TFcConfig)(unsafe.Pointer(config)).FavailConfigFiles)
	set = int32(_FcSetSystem)
	for {
		if !(set <= int32(_FcSetApplication)) {
			break
		}
		if *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(set)*8)) != 0 {
			XFcFontSetDestroy(tls, *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(set)*8)))
		}
		goto _6
	_6:
		;
		set++
	}
	page = (*TFcConfig)(unsafe.Pointer(config)).Fexpr_pool
	for page != 0 {
		next = (*TFcExprPage)(unsafe.Pointer(page)).Fnext_page
		libc.Xfree(tls, page)
		page = next
	}
	if (*TFcConfig)(unsafe.Pointer(config)).FsysRoot != 0 {
		XFcStrFree(tls, (*TFcConfig)(unsafe.Pointer(config)).FsysRoot)
	}
	libc.Xfree(tls, config)
}

/*
 * Add cache to configuration, adding fonts and directories
 */

func XFcConfigAddCache(tls *libc.TLS, config uintptr, cache uintptr, set TFcSetName, dirSet uintptr, forDir uintptr) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var base, dir, dirs, font, fs, relocated_font_file, s, slash, v2, v3, v5 uintptr
	var i, nref int32
	var relocated TFcBool
	var _ /* font_file at bp+0 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = base, dir, dirs, font, fs, i, nref, relocated, relocated_font_file, s, slash, v2, v3, v5
	relocated = m_FcFalse
	if libc.Xstrcmp(tls, uintptr(int64(cache)+(*TFcCache)(unsafe.Pointer(cache)).Fdir), forDir) != 0 {
		relocated = int32(m_FcTrue)
	}
	/*
	 * Add fonts
	 */
	fs = uintptr(int64(cache) + (*TFcCache)(unsafe.Pointer(cache)).Fset)
	if fs != 0 {
		nref = 0
		i = 0
		for {
			if !(i < (*TFcFontSet)(unsafe.Pointer(fs)).Fnfont) {
				break
			}
			if int64((*TFcFontSet)(unsafe.Pointer(fs)).Ffonts)&int64(1) != 0 {
				if int64((*TFcFontSet)(unsafe.Pointer(fs)).Ffonts)&int64(1) != 0 {
					v3 = uintptr(int64(fs) + int64((*TFcFontSet)(unsafe.Pointer(fs)).Ffonts)&int64(^libc.Int32FromInt32(1)))
				} else {
					v3 = (*TFcFontSet)(unsafe.Pointer(fs)).Ffonts
				}
				v2 = uintptr(int64(fs) + int64(*(*uintptr)(unsafe.Pointer(v3 + uintptr(i)*8)))&int64(^libc.Int32FromInt32(1)))
			} else {
				v2 = *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(fs)).Ffonts + uintptr(i)*8))
			}
			font = v2
			relocated_font_file = libc.UintptrFromInt32(0)
			if XFcPatternObjectGetString(tls, font, int32(_FC_FILE_OBJECT), 0, bp) == int32(_FcResultMatch) {
				if relocated != 0 {
					slash = XFcStrLastSlash(tls, *(*uintptr)(unsafe.Pointer(bp)))
					relocated_font_file = XFcStrBuildFilename(tls, forDir, libc.VaList(bp+16, slash+uintptr(1), libc.UintptrFromInt32(0)))
					*(*uintptr)(unsafe.Pointer(bp)) = relocated_font_file
				}
				/*
				 * Check to see if font is banned by filename
				 */
				if !(XFcConfigAcceptFilename(tls, config, *(*uintptr)(unsafe.Pointer(bp))) != 0) {
					libc.Xfree(tls, relocated_font_file)
					goto _1
				}
			}
			/*
			 * Check to see if font is banned by pattern
			 */
			if !(XFcConfigAcceptFont(tls, config, font) != 0) {
				libc.Xfree(tls, relocated_font_file)
				goto _1
			}
			if relocated_font_file != 0 {
				font = XFcPatternCacheRewriteFile(tls, font, cache, relocated_font_file)
				libc.Xfree(tls, relocated_font_file)
			}
			if XFcFontSetAdd(tls, *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(set)*8)), font) != 0 {
				nref++
			}
			goto _1
		_1:
			;
			i++
		}
		XFcDirCacheReference(tls, cache, nref)
	}
	/*
	 * Add directories
	 */
	dirs = uintptr(int64(cache) + (*TFcCache)(unsafe.Pointer(cache)).Fdirs)
	if dirs != 0 {
		i = 0
		for {
			if !(i < (*TFcCache)(unsafe.Pointer(cache)).Fdirs_count) {
				break
			}
			dir = uintptr(int64(uintptr(int64(cache)+(*TFcCache)(unsafe.Pointer(cache)).Fdirs)) + *(*Tintptr_t)(unsafe.Pointer(uintptr(int64(cache)+(*TFcCache)(unsafe.Pointer(cache)).Fdirs) + uintptr(i)*8)))
			s = libc.UintptrFromInt32(0)
			if relocated != 0 {
				base = XFcStrBasename(tls, dir)
				v5 = XFcStrBuildFilename(tls, forDir, libc.VaList(bp+16, base, libc.UintptrFromInt32(0)))
				s = v5
				dir = v5
				XFcStrFree(tls, base)
			}
			if XFcConfigAcceptFilename(tls, config, dir) != 0 {
				XFcStrSetAddFilename(tls, dirSet, dir)
			}
			if s != 0 {
				XFcStrFree(tls, s)
			}
			goto _4
		_4:
			;
			i++
		}
	}
	return int32(m_FcTrue)
}

func _FcConfigAddDirList(tls *libc.TLS, config uintptr, set TFcSetName, dirSet uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var cache, dir, dirlist, v1 uintptr
	_, _, _, _ = cache, dir, dirlist, v1
	dirlist = XFcStrListCreate(tls, dirSet)
	if !(dirlist != 0) {
		return m_FcFalse
	}
	for {
		v1 = XFcStrListNext(tls, dirlist)
		dir = v1
		if !(v1 != 0) {
			break
		}
		if XFcDebugVal&int32(m_FC_DBG_FONTSET) != 0 {
			libc.Xprintf(tls, __ccgo_ts+1041, libc.VaList(bp+8, dir))
		}
		cache = XFcDirCacheRead(tls, dir, m_FcFalse, config)
		if !(cache != 0) {
			continue
		}
		XFcConfigAddCache(tls, config, cache, set, dirSet, dir)
		XFcDirCacheUnload(tls, cache)
	}
	XFcStrListDone(tls, dirlist)
	return int32(m_FcTrue)
}

/*
 * Scan the current list of directories in the configuration
 * and build the set of available fonts.
 */

func XFcConfigBuildFonts(tls *libc.TLS, config uintptr) (r TFcBool) {
	var fonts uintptr
	var ret TFcBool
	_, _ = fonts, ret
	ret = int32(m_FcTrue)
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return m_FcFalse
	}
	fonts = XFcFontSetCreate(tls)
	if !(fonts != 0) {
		ret = m_FcFalse
		goto bail
	}
	XFcConfigSetFonts(tls, config, fonts, int32(_FcSetSystem))
	if !(_FcConfigAddDirList(tls, config, int32(_FcSetSystem), (*TFcConfig)(unsafe.Pointer(config)).FfontDirs) != 0) {
		ret = m_FcFalse
		goto bail
	}
	if XFcDebugVal&int32(m_FC_DBG_FONTSET) != 0 {
		XFcFontSetPrint(tls, fonts)
	}
	goto bail
bail:
	;
	XFcConfigDestroy(tls, config)
	return ret
}

func XFcConfigSetCurrent(tls *libc.TLS, config uintptr) (r TFcBool) {
	var cfg, p2 uintptr
	var v3 int32
	_, _, _ = cfg, v3, p2
	if config != 0 {
		if !(*(*uintptr)(unsafe.Pointer(config + 104 + uintptr(_FcSetSystem)*8)) != 0) {
			if !(XFcConfigBuildFonts(tls, config) != 0) {
				return m_FcFalse
			}
		}
		p2 = config + 132
		*(*Tfc_atomic_int_t)(unsafe.Pointer(p2)) += +libc.Int32FromInt32(1)
		_ = *(*Tfc_atomic_int_t)(unsafe.Pointer(p2)) - +libc.Int32FromInt32(1)
		goto _1
	_1:
	}
	_lock_config(tls)
	goto retry
retry:
	;
	cfg = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig))))
	if config == cfg {
		_unlock_config(tls)
		if config != 0 {
			XFcConfigDestroy(tls, config)
		}
		return int32(m_FcTrue)
	}
	if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig)))) == cfg {
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig)))) = config
		v3 = libc.Int32FromInt32(m_FcTrue)
	} else {
		v3 = m_FcFalse
	}
	if !(v3 != 0) {
		goto retry
	}
	_unlock_config(tls)
	if cfg != 0 {
		XFcConfigDestroy(tls, cfg)
	}
	return int32(m_FcTrue)
}

func XFcConfigGetCurrent(tls *libc.TLS) (r uintptr) {
	return _FcConfigEnsure(tls)
}

func XFcConfigAddConfigDir(tls *libc.TLS, config uintptr, d uintptr) (r TFcBool) {
	return XFcStrSetAddFilename(tls, (*TFcConfig)(unsafe.Pointer(config)).FconfigDirs, d)
}

func XFcConfigGetConfigDirs(tls *libc.TLS, config uintptr) (r uintptr) {
	var ret uintptr
	_ = ret
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return libc.UintptrFromInt32(0)
	}
	ret = XFcStrListCreate(tls, (*TFcConfig)(unsafe.Pointer(config)).FconfigDirs)
	XFcConfigDestroy(tls, config)
	return ret
}

func XFcConfigAddFontDir(tls *libc.TLS, config uintptr, d uintptr, m uintptr, salt uintptr) (r TFcBool) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var v1, v2, v3, v4, v5, v6 uintptr
	_, _, _, _, _, _ = v1, v2, v3, v4, v5, v6
	if XFcDebugVal&int32(m_FC_DBG_CACHE) != 0 {
		if m != 0 {
			if salt != 0 {
				v1 = __ccgo_ts + 1063
			} else {
				v1 = __ccgo_ts + 110
			}
			if salt != 0 {
				v2 = salt
			} else {
				v2 = __ccgo_ts + 110
			}
			if salt != 0 {
				v3 = __ccgo_ts + 111
			} else {
				v3 = __ccgo_ts + 110
			}
			libc.Xprintf(tls, __ccgo_ts+1072, libc.VaList(bp+8, d, m, v1, v2, v3))
		} else {
			if salt != 0 {
				if salt != 0 {
					v4 = __ccgo_ts + 1063
				} else {
					v4 = __ccgo_ts + 110
				}
				if salt != 0 {
					v5 = salt
				} else {
					v5 = __ccgo_ts + 110
				}
				if salt != 0 {
					v6 = __ccgo_ts + 111
				} else {
					v6 = __ccgo_ts + 110
				}
				libc.Xprintf(tls, __ccgo_ts+1088, libc.VaList(bp+8, d, v4, v5, v6))
			}
		}
	}
	return XFcStrSetAddFilenamePairWithSalt(tls, (*TFcConfig)(unsafe.Pointer(config)).FfontDirs, d, m, salt)
}

func XFcConfigResetFontDirs(tls *libc.TLS, config uintptr) (r TFcBool) {
	if XFcDebugVal&int32(m_FC_DBG_CACHE) != 0 {
		libc.Xprintf(tls, __ccgo_ts+1098, 0)
	}
	return XFcStrSetDeleteAll(tls, (*TFcConfig)(unsafe.Pointer(config)).FfontDirs)
}

func XFcConfigGetFontDirs(tls *libc.TLS, config uintptr) (r uintptr) {
	var ret uintptr
	_ = ret
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return libc.UintptrFromInt32(0)
	}
	ret = XFcStrListCreate(tls, (*TFcConfig)(unsafe.Pointer(config)).FfontDirs)
	XFcConfigDestroy(tls, config)
	return ret
}

func _FcConfigPathStartsWith(tls *libc.TLS, path uintptr, start uintptr) (r TFcBool) {
	var len1 int32
	_ = len1
	len1 = libc.Int32FromUint64(libc.Xstrlen(tls, start))
	if libc.Xstrncmp(tls, path, start, libc.Uint64FromInt32(len1)) != 0 {
		return m_FcFalse
	}
	switch libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(path + uintptr(len1)))) {
	case int32('\000'):
		fallthrough
	case int32('/'):
		return int32(m_FcTrue)
	default:
		return m_FcFalse
	}
	return r
}

func XFcConfigMapFontPath(tls *libc.TLS, config uintptr, path uintptr) (r uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var dir, list, map1, retval, rpath, v1 uintptr
	var len1 Tsize_t
	_, _, _, _, _, _, _ = dir, len1, list, map1, retval, rpath, v1
	list = XFcConfigGetFontDirs(tls, config)
	if !(list != 0) {
		return uintptr(0)
	}
	for {
		v1 = XFcStrListNext(tls, list)
		dir = v1
		if !(v1 != 0) {
			break
		}
		if _FcConfigPathStartsWith(tls, path, dir) != 0 {
			break
		}
	}
	XFcStrListDone(tls, list)
	if !(dir != 0) {
		return uintptr(0)
	}
	map1 = XFcStrTripleSecond(tls, dir)
	if !(map1 != 0) {
		return uintptr(0)
	}
	rpath = path + uintptr(libc.Xstrlen(tls, dir))
	for libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(rpath))) == int32('/') {
		rpath++
	}
	retval = XFcStrBuildFilename(tls, map1, libc.VaList(bp+8, rpath, libc.UintptrFromInt32(0)))
	if retval != 0 {
		len1 = libc.Xstrlen(tls, retval)
		for len1 > uint64(0) && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(retval + uintptr(len1-uint64(1))))) == int32('/') {
			len1--
		}
		/* trim the last slash */
		*(*TFcChar8)(unsafe.Pointer(retval + uintptr(len1))) = uint8(0)
	}
	return retval
}

func XFcConfigMapSalt(tls *libc.TLS, config uintptr, path uintptr) (r uintptr) {
	var dir, list, v1 uintptr
	_, _, _ = dir, list, v1
	list = XFcConfigGetFontDirs(tls, config)
	if !(list != 0) {
		return libc.UintptrFromInt32(0)
	}
	for {
		v1 = XFcStrListNext(tls, list)
		dir = v1
		if !(v1 != 0) {
			break
		}
		if _FcConfigPathStartsWith(tls, path, dir) != 0 {
			break
		}
	}
	XFcStrListDone(tls, list)
	if !(dir != 0) {
		return libc.UintptrFromInt32(0)
	}
	return XFcStrTripleThird(tls, dir)
}

func XFcConfigAddCacheDir(tls *libc.TLS, config uintptr, d uintptr) (r TFcBool) {
	return XFcStrSetAddFilename(tls, (*TFcConfig)(unsafe.Pointer(config)).FcacheDirs, d)
}

func XFcConfigGetCacheDirs(tls *libc.TLS, config uintptr) (r uintptr) {
	var ret uintptr
	_ = ret
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return libc.UintptrFromInt32(0)
	}
	ret = XFcStrListCreate(tls, (*TFcConfig)(unsafe.Pointer(config)).FcacheDirs)
	XFcConfigDestroy(tls, config)
	return ret
}

func XFcConfigAddConfigFile(tls *libc.TLS, config uintptr, f uintptr) (r TFcBool) {
	var file uintptr
	var ret TFcBool
	_, _ = file, ret
	file = XFcConfigGetFilename(tls, config, f)
	if !(file != 0) {
		return m_FcFalse
	}
	ret = XFcStrSetAdd(tls, (*TFcConfig)(unsafe.Pointer(config)).FconfigFiles, file)
	XFcStrFree(tls, file)
	return ret
}

func XFcConfigGetConfigFiles(tls *libc.TLS, config uintptr) (r uintptr) {
	var ret uintptr
	_ = ret
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return libc.UintptrFromInt32(0)
	}
	ret = XFcStrListCreate(tls, (*TFcConfig)(unsafe.Pointer(config)).FconfigFiles)
	XFcConfigDestroy(tls, config)
	return ret
}

func XFcConfigGetCache(tls *libc.TLS, config uintptr) (r uintptr) {
	return libc.UintptrFromInt32(0)
}

func XFcConfigGetFonts(tls *libc.TLS, config uintptr, set TFcSetName) (r uintptr) {
	if !(config != 0) {
		config = XFcConfigGetCurrent(tls)
		if !(config != 0) {
			return uintptr(0)
		}
	}
	return *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(set)*8))
}

func XFcConfigSetFonts(tls *libc.TLS, config uintptr, fonts uintptr, set TFcSetName) {
	if *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(set)*8)) != 0 {
		XFcFontSetDestroy(tls, *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(set)*8)))
	}
	*(*uintptr)(unsafe.Pointer(config + 104 + uintptr(set)*8)) = fonts
}

func XFcBlanksCreate(tls *libc.TLS) (r uintptr) {
	/* Deprecated. */
	return libc.UintptrFromInt32(0)
}

func XFcBlanksDestroy(tls *libc.TLS, b uintptr) {
	/* Deprecated. */
}

func XFcBlanksAdd(tls *libc.TLS, b uintptr, ucs4 TFcChar32) (r TFcBool) {
	/* Deprecated. */
	return m_FcFalse
}

func XFcBlanksIsMember(tls *libc.TLS, b uintptr, ucs4 TFcChar32) (r TFcBool) {
	/* Deprecated. */
	return m_FcFalse
}

func XFcConfigGetBlanks(tls *libc.TLS, config uintptr) (r uintptr) {
	/* Deprecated. */
	return libc.UintptrFromInt32(0)
}

func XFcConfigAddBlank(tls *libc.TLS, config uintptr, blank TFcChar32) (r TFcBool) {
	/* Deprecated. */
	return m_FcFalse
}

func XFcConfigGetRescanInterval(tls *libc.TLS, config uintptr) (r int32) {
	var ret int32
	_ = ret
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return 0
	}
	ret = (*TFcConfig)(unsafe.Pointer(config)).FrescanInterval
	XFcConfigDestroy(tls, config)
	return ret
}

func XFcConfigSetRescanInterval(tls *libc.TLS, config uintptr, rescanInterval int32) (r TFcBool) {
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return m_FcFalse
	}
	(*TFcConfig)(unsafe.Pointer(config)).FrescanInterval = rescanInterval
	XFcConfigDestroy(tls, config)
	return int32(m_FcTrue)
}

// C documentation
//
//	/*
//	 * A couple of typos escaped into the library
//	 */
func XFcConfigGetRescanInverval(tls *libc.TLS, config uintptr) (r int32) {
	return XFcConfigGetRescanInterval(tls, config)
}

func XFcConfigSetRescanInverval(tls *libc.TLS, config uintptr, rescanInterval int32) (r TFcBool) {
	return XFcConfigSetRescanInterval(tls, config, rescanInterval)
}

func XFcConfigAddRule(tls *libc.TLS, config uintptr, rule uintptr, kind TFcMatchKind) (r TFcBool) {
	/* deprecated */
	return m_FcFalse
}

func _FcConfigPromote(tls *libc.TLS, _v TFcValue, u TFcValue, buf uintptr) (r TFcValue) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*TFcValue)(unsafe.Pointer(bp)) = _v
	switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
	case int32(_FcTypeInteger):
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeDouble)
		*(*float64)(unsafe.Pointer(bp + 8)) = float64(*(*int32)(unsafe.Pointer(bp + 8)))
		/* Fallthrough */
		fallthrough
	case int32(_FcTypeDouble):
		if u.Ftype1 == int32(_FcTypeRange) && buf != 0 {
			*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcRangePromote(tls, *(*float64)(unsafe.Pointer(bp + 8)), buf)
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeRange)
		}
	case int32(_FcTypeVoid):
		if u.Ftype1 == int32(_FcTypeMatrix) {
			*(*uintptr)(unsafe.Pointer(bp + 8)) = uintptr(unsafe.Pointer(&XFcIdentityMatrix))
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeMatrix)
		} else {
			if u.Ftype1 == int32(_FcTypeLangSet) && buf != 0 {
				*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcLangSetPromote(tls, libc.UintptrFromInt32(0), buf)
				(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeLangSet)
			} else {
				if u.Ftype1 == int32(_FcTypeCharSet) && buf != 0 {
					*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcCharSetPromote(tls, buf)
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeCharSet)
				}
			}
		}
	case int32(_FcTypeString):
		if u.Ftype1 == int32(_FcTypeLangSet) && buf != 0 {
			*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcLangSetPromote(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), buf)
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeLangSet)
		}
	default:
		break
	}
	return *(*TFcValue)(unsafe.Pointer(bp))
}

func XFcConfigCompareValue(tls *libc.TLS, left_o uintptr, op_ uint32, right_o uintptr) (r7 TFcBool) {
	bp := tls.Alloc(544)
	defer tls.Free(544)
	var flags, l, r int32
	var l1, r1 float64
	var l2, r2, ret TFcBool
	var l3, l4, l5, l6, r3, r4, r5, r6, v1, v2, v3, v4, v5, v6, v7, v8 uintptr
	var op TFcOp
	var _ /* buf1 at bp+32 */ TFcValuePromotionBuffer
	var _ /* buf2 at bp+288 */ TFcValuePromotionBuffer
	var _ /* left at bp+0 */ TFcValue
	var _ /* right at bp+16 */ TFcValue
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = flags, l, l1, l2, l3, l4, l5, l6, op, r, r1, r2, r3, r4, r5, r6, ret, v1, v2, v3, v4, v5, v6, v7, v8
	ret = m_FcFalse
	op = libc.Int32FromUint32(op_ & libc.Uint32FromInt32(0xffff))
	flags = libc.Int32FromUint32(op_ & libc.Uint32FromUint32(0xffff0000) >> libc.Int32FromInt32(16))
	if (*TFcValue)(unsafe.Pointer(left_o)).Ftype1 != (*TFcValue)(unsafe.Pointer(right_o)).Ftype1 {
		*(*TFcValue)(unsafe.Pointer(bp)) = XFcValueCanonicalize(tls, left_o)
		*(*TFcValue)(unsafe.Pointer(bp + 16)) = XFcValueCanonicalize(tls, right_o)
		*(*TFcValue)(unsafe.Pointer(bp)) = _FcConfigPromote(tls, *(*TFcValue)(unsafe.Pointer(bp)), *(*TFcValue)(unsafe.Pointer(bp + 16)), bp+32)
		*(*TFcValue)(unsafe.Pointer(bp + 16)) = _FcConfigPromote(tls, *(*TFcValue)(unsafe.Pointer(bp + 16)), *(*TFcValue)(unsafe.Pointer(bp)), bp+288)
		left_o = bp
		right_o = bp + 16
		if (*TFcValue)(unsafe.Pointer(left_o)).Ftype1 != (*TFcValue)(unsafe.Pointer(right_o)).Ftype1 {
			if op == int32(_FcOpNotEqual) || op == int32(_FcOpNotContains) {
				ret = int32(m_FcTrue)
			}
			return ret
		}
	}
	switch (*TFcValue)(unsafe.Pointer(left_o)).Ftype1 {
	case int32(_FcTypeUnknown):
	case int32(_FcTypeInteger):
		l = *(*int32)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(left_o)).Fu))
		r = *(*int32)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(right_o)).Fu))
		switch op {
		case int32(_FcOpEqual):
			fallthrough
		case int32(_FcOpContains):
			fallthrough
		case int32(_FcOpListing):
			ret = libc.BoolInt32(l == r)
		case int32(_FcOpNotEqual):
			fallthrough
		case int32(_FcOpNotContains):
			ret = libc.BoolInt32(l != r)
		case int32(_FcOpLess):
			ret = libc.BoolInt32(l < r)
		case int32(_FcOpLessEqual):
			ret = libc.BoolInt32(l <= r)
		case int32(_FcOpMore):
			ret = libc.BoolInt32(l > r)
		case int32(_FcOpMoreEqual):
			ret = libc.BoolInt32(l >= r)
		default:
			break
		}
	case int32(_FcTypeDouble):
		l1 = *(*float64)(unsafe.Pointer(left_o + 8))
		r1 = *(*float64)(unsafe.Pointer(right_o + 8))
		switch op {
		case int32(_FcOpEqual):
			fallthrough
		case int32(_FcOpContains):
			fallthrough
		case int32(_FcOpListing):
			ret = libc.BoolInt32(l1 == r1)
		case int32(_FcOpNotEqual):
			fallthrough
		case int32(_FcOpNotContains):
			ret = libc.BoolInt32(l1 != r1)
		case int32(_FcOpLess):
			ret = libc.BoolInt32(l1 < r1)
		case int32(_FcOpLessEqual):
			ret = libc.BoolInt32(l1 <= r1)
		case int32(_FcOpMore):
			ret = libc.BoolInt32(l1 > r1)
		case int32(_FcOpMoreEqual):
			ret = libc.BoolInt32(l1 >= r1)
		default:
			break
		}
	case int32(_FcTypeBool):
		l2 = *(*TFcBool)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(left_o)).Fu))
		r2 = *(*TFcBool)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(right_o)).Fu))
		switch op {
		case int32(_FcOpEqual):
			ret = libc.BoolInt32(l2 == r2)
		case int32(_FcOpContains):
			fallthrough
		case int32(_FcOpListing):
			ret = libc.BoolInt32(l2 == r2 || l2 >= int32(m_FcDontCare))
		case int32(_FcOpNotEqual):
			ret = libc.BoolInt32(l2 != r2)
		case int32(_FcOpNotContains):
			ret = libc.BoolInt32(!(l2 == r2 || l2 >= int32(m_FcDontCare)))
		case int32(_FcOpLess):
			ret = libc.BoolInt32(l2 != r2 && r2 >= int32(m_FcDontCare))
		case int32(_FcOpLessEqual):
			ret = libc.BoolInt32(l2 == r2 || r2 >= int32(m_FcDontCare))
		case int32(_FcOpMore):
			ret = libc.BoolInt32(l2 != r2 && l2 >= int32(m_FcDontCare))
		case int32(_FcOpMoreEqual):
			ret = libc.BoolInt32(l2 == r2 || l2 >= int32(m_FcDontCare))
		default:
			break
		}
	case int32(_FcTypeString):
		if int64(*(*uintptr)(unsafe.Pointer(left_o + 8)))&int64(1) != 0 {
			v1 = uintptr(int64(left_o) + int64(*(*uintptr)(unsafe.Pointer(left_o + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v1 = *(*uintptr)(unsafe.Pointer(left_o + 8))
		}
		l3 = v1
		if int64(*(*uintptr)(unsafe.Pointer(right_o + 8)))&int64(1) != 0 {
			v2 = uintptr(int64(right_o) + int64(*(*uintptr)(unsafe.Pointer(right_o + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = *(*uintptr)(unsafe.Pointer(right_o + 8))
		}
		r3 = v2
		switch op {
		case int32(_FcOpEqual):
			fallthrough
		case int32(_FcOpListing):
			if flags&int32(_FcOpFlagIgnoreBlanks) != 0 {
				ret = libc.BoolInt32(XFcStrCmpIgnoreBlanksAndCase(tls, l3, r3) == 0)
			} else {
				ret = libc.BoolInt32(XFcStrCmpIgnoreCase(tls, l3, r3) == 0)
			}
		case int32(_FcOpContains):
			ret = libc.BoolInt32(XFcStrStrIgnoreCase(tls, l3, r3) != uintptr(0))
		case int32(_FcOpNotEqual):
			if flags&int32(_FcOpFlagIgnoreBlanks) != 0 {
				ret = libc.BoolInt32(XFcStrCmpIgnoreBlanksAndCase(tls, l3, r3) != 0)
			} else {
				ret = libc.BoolInt32(XFcStrCmpIgnoreCase(tls, l3, r3) != 0)
			}
		case int32(_FcOpNotContains):
			ret = libc.BoolInt32(XFcStrStrIgnoreCase(tls, l3, r3) == uintptr(0))
		default:
			break
		}
	case int32(_FcTypeMatrix):
		switch op {
		case int32(_FcOpEqual):
			fallthrough
		case int32(_FcOpContains):
			fallthrough
		case int32(_FcOpListing):
			ret = XFcMatrixEqual(tls, *(*uintptr)(unsafe.Pointer(left_o + 8)), *(*uintptr)(unsafe.Pointer(right_o + 8)))
		case int32(_FcOpNotEqual):
			fallthrough
		case int32(_FcOpNotContains):
			ret = libc.BoolInt32(!(XFcMatrixEqual(tls, *(*uintptr)(unsafe.Pointer(left_o + 8)), *(*uintptr)(unsafe.Pointer(right_o + 8))) != 0))
		default:
			break
		}
	case int32(_FcTypeCharSet):
		if int64(*(*uintptr)(unsafe.Pointer(left_o + 8)))&int64(1) != 0 {
			v3 = uintptr(int64(left_o) + int64(*(*uintptr)(unsafe.Pointer(left_o + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v3 = *(*uintptr)(unsafe.Pointer(left_o + 8))
		}
		l4 = v3
		if int64(*(*uintptr)(unsafe.Pointer(right_o + 8)))&int64(1) != 0 {
			v4 = uintptr(int64(right_o) + int64(*(*uintptr)(unsafe.Pointer(right_o + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v4 = *(*uintptr)(unsafe.Pointer(right_o + 8))
		}
		r4 = v4
		switch op {
		case int32(_FcOpContains):
			fallthrough
		case int32(_FcOpListing):
			/* left contains right if right is a subset of left */
			ret = XFcCharSetIsSubset(tls, r4, l4)
		case int32(_FcOpNotContains):
			/* left contains right if right is a subset of left */
			ret = libc.BoolInt32(!(XFcCharSetIsSubset(tls, r4, l4) != 0))
		case int32(_FcOpEqual):
			ret = XFcCharSetEqual(tls, l4, r4)
		case int32(_FcOpNotEqual):
			ret = libc.BoolInt32(!(XFcCharSetEqual(tls, l4, r4) != 0))
		default:
			break
		}
	case int32(_FcTypeLangSet):
		if int64(*(*uintptr)(unsafe.Pointer(left_o + 8)))&int64(1) != 0 {
			v5 = uintptr(int64(left_o) + int64(*(*uintptr)(unsafe.Pointer(left_o + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v5 = *(*uintptr)(unsafe.Pointer(left_o + 8))
		}
		l5 = v5
		if int64(*(*uintptr)(unsafe.Pointer(right_o + 8)))&int64(1) != 0 {
			v6 = uintptr(int64(right_o) + int64(*(*uintptr)(unsafe.Pointer(right_o + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v6 = *(*uintptr)(unsafe.Pointer(right_o + 8))
		}
		r5 = v6
		switch op {
		case int32(_FcOpContains):
			fallthrough
		case int32(_FcOpListing):
			ret = XFcLangSetContains(tls, l5, r5)
		case int32(_FcOpNotContains):
			ret = libc.BoolInt32(!(XFcLangSetContains(tls, l5, r5) != 0))
		case int32(_FcOpEqual):
			ret = XFcLangSetEqual(tls, l5, r5)
		case int32(_FcOpNotEqual):
			ret = libc.BoolInt32(!(XFcLangSetEqual(tls, l5, r5) != 0))
		default:
			break
		}
	case int32(_FcTypeVoid):
		switch op {
		case int32(_FcOpEqual):
			fallthrough
		case int32(_FcOpContains):
			fallthrough
		case int32(_FcOpListing):
			ret = int32(m_FcTrue)
		default:
			break
		}
	case int32(_FcTypeFTFace):
		switch op {
		case int32(_FcOpEqual):
			fallthrough
		case int32(_FcOpContains):
			fallthrough
		case int32(_FcOpListing):
			ret = libc.BoolInt32(*(*uintptr)(unsafe.Pointer(left_o + 8)) == *(*uintptr)(unsafe.Pointer(right_o + 8)))
		case int32(_FcOpNotEqual):
			fallthrough
		case int32(_FcOpNotContains):
			ret = libc.BoolInt32(*(*uintptr)(unsafe.Pointer(left_o + 8)) != *(*uintptr)(unsafe.Pointer(right_o + 8)))
		default:
			break
		}
	case int32(_FcTypeRange):
		if int64(*(*uintptr)(unsafe.Pointer(left_o + 8)))&int64(1) != 0 {
			v7 = uintptr(int64(left_o) + int64(*(*uintptr)(unsafe.Pointer(left_o + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v7 = *(*uintptr)(unsafe.Pointer(left_o + 8))
		}
		l6 = v7
		if int64(*(*uintptr)(unsafe.Pointer(right_o + 8)))&int64(1) != 0 {
			v8 = uintptr(int64(right_o) + int64(*(*uintptr)(unsafe.Pointer(right_o + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v8 = *(*uintptr)(unsafe.Pointer(right_o + 8))
		}
		r6 = v8
		ret = XFcRangeCompare(tls, op, l6, r6)
		break
	}
	return ret
}

func _FcConfigEvaluate(tls *libc.TLS, p uintptr, p_pat uintptr, kind TFcMatchKind, e uintptr) (r TFcValue) {
	bp := tls.Alloc(688)
	defer tls.Free(688)
	var m, str uintptr
	var op TFcOp
	var v1, v2, v3, v4, v5, v6, v7 int32
	var _ /* buf1 at bp+80 */ TFcValuePromotionBuffer
	var _ /* buf2 at bp+336 */ TFcValuePromotionBuffer
	var _ /* m at bp+592 */ TFcMatrix
	var _ /* v at bp+0 */ TFcValue
	var _ /* vl at bp+16 */ TFcValue
	var _ /* vle at bp+48 */ TFcValue
	var _ /* vr at bp+32 */ TFcValue
	var _ /* vre at bp+64 */ TFcValue
	var _ /* xx at bp+624 */ TFcValue
	var _ /* xy at bp+640 */ TFcValue
	var _ /* yx at bp+656 */ TFcValue
	var _ /* yy at bp+672 */ TFcValue
	_, _, _, _, _, _, _, _, _, _ = m, op, str, v1, v2, v3, v4, v5, v6, v7
	op = (*TFcExpr)(unsafe.Pointer(e)).Fop & libc.Int32FromInt32(0xffff)
	switch op {
	case int32(_FcOpInteger):
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeInteger)
		*(*int32)(unsafe.Pointer(bp + 8)) = (*TFcExpr)(unsafe.Pointer(e)).Fu.Fival
	case int32(_FcOpDouble):
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeDouble)
		*(*float64)(unsafe.Pointer(bp + 8)) = *(*float64)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu))
	case int32(_FcOpString):
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeString)
		*(*uintptr)(unsafe.Pointer(bp + 8)) = *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu))
		*(*TFcValue)(unsafe.Pointer(bp)) = XFcValueSave(tls, *(*TFcValue)(unsafe.Pointer(bp)))
	case int32(_FcOpMatrix):
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeMatrix)
		*(*TFcValue)(unsafe.Pointer(bp + 624)) = _FcConfigPromote(tls, _FcConfigEvaluate(tls, p, p_pat, kind, (*TFcExprMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)))).Fxx), *(*TFcValue)(unsafe.Pointer(bp)), libc.UintptrFromInt32(0))
		*(*TFcValue)(unsafe.Pointer(bp + 640)) = _FcConfigPromote(tls, _FcConfigEvaluate(tls, p, p_pat, kind, (*TFcExprMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)))).Fxy), *(*TFcValue)(unsafe.Pointer(bp)), libc.UintptrFromInt32(0))
		*(*TFcValue)(unsafe.Pointer(bp + 656)) = _FcConfigPromote(tls, _FcConfigEvaluate(tls, p, p_pat, kind, (*TFcExprMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)))).Fyx), *(*TFcValue)(unsafe.Pointer(bp)), libc.UintptrFromInt32(0))
		*(*TFcValue)(unsafe.Pointer(bp + 672)) = _FcConfigPromote(tls, _FcConfigEvaluate(tls, p, p_pat, kind, (*TFcExprMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)))).Fyy), *(*TFcValue)(unsafe.Pointer(bp)), libc.UintptrFromInt32(0))
		if (*(*TFcValue)(unsafe.Pointer(bp + 624))).Ftype1 == int32(_FcTypeDouble) && (*(*TFcValue)(unsafe.Pointer(bp + 640))).Ftype1 == int32(_FcTypeDouble) && (*(*TFcValue)(unsafe.Pointer(bp + 656))).Ftype1 == int32(_FcTypeDouble) && (*(*TFcValue)(unsafe.Pointer(bp + 672))).Ftype1 == int32(_FcTypeDouble) {
			(*(*TFcMatrix)(unsafe.Pointer(bp + 592))).Fxx = *(*float64)(unsafe.Pointer(bp + 624 + 8))
			(*(*TFcMatrix)(unsafe.Pointer(bp + 592))).Fxy = *(*float64)(unsafe.Pointer(bp + 640 + 8))
			(*(*TFcMatrix)(unsafe.Pointer(bp + 592))).Fyx = *(*float64)(unsafe.Pointer(bp + 656 + 8))
			(*(*TFcMatrix)(unsafe.Pointer(bp + 592))).Fyy = *(*float64)(unsafe.Pointer(bp + 672 + 8))
			*(*uintptr)(unsafe.Pointer(bp + 8)) = bp + 592
		} else {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
		}
		*(*TFcValue)(unsafe.Pointer(bp)) = XFcValueSave(tls, *(*TFcValue)(unsafe.Pointer(bp)))
	case int32(_FcOpCharSet):
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeCharSet)
		*(*uintptr)(unsafe.Pointer(bp + 8)) = *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu))
		*(*TFcValue)(unsafe.Pointer(bp)) = XFcValueSave(tls, *(*TFcValue)(unsafe.Pointer(bp)))
	case int32(_FcOpLangSet):
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeLangSet)
		*(*uintptr)(unsafe.Pointer(bp + 8)) = *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu))
		*(*TFcValue)(unsafe.Pointer(bp)) = XFcValueSave(tls, *(*TFcValue)(unsafe.Pointer(bp)))
	case int32(_FcOpRange):
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeRange)
		*(*uintptr)(unsafe.Pointer(bp + 8)) = *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu))
		*(*TFcValue)(unsafe.Pointer(bp)) = XFcValueSave(tls, *(*TFcValue)(unsafe.Pointer(bp)))
	case int32(_FcOpBool):
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeBool)
		*(*TFcBool)(unsafe.Pointer(bp + 8)) = *(*TFcBool)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu))
	case int32(_FcOpField):
		if kind == int32(_FcMatchFont) && (*(*TFcExprName)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu))).Fkind == int32(_FcMatchPattern) {
			if int32(_FcResultMatch) != XFcPatternObjectGet(tls, p_pat, (*(*TFcExprName)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu))).Fobject, 0, bp) {
				(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
			}
		} else {
			if kind == int32(_FcMatchPattern) && (*(*TFcExprName)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu))).Fkind == int32(_FcMatchFont) {
				libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+1123, 0)
				(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
			} else {
				if int32(_FcResultMatch) != XFcPatternObjectGet(tls, p, (*(*TFcExprName)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu))).Fobject, 0, bp) {
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
				}
			}
		}
		*(*TFcValue)(unsafe.Pointer(bp)) = XFcValueSave(tls, *(*TFcValue)(unsafe.Pointer(bp)))
	case int32(_FcOpConst):
		if XFcNameConstant(tls, *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)), bp+8) != 0 {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeInteger)
		} else {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
		}
	case int32(_FcOpQuest):
		*(*TFcValue)(unsafe.Pointer(bp + 16)) = _FcConfigEvaluate(tls, p, p_pat, kind, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fleft)
		if (*(*TFcValue)(unsafe.Pointer(bp + 16))).Ftype1 == int32(_FcTypeBool) {
			if *(*TFcBool)(unsafe.Pointer(bp + 16 + 8)) != 0 {
				*(*TFcValue)(unsafe.Pointer(bp)) = _FcConfigEvaluate(tls, p, p_pat, kind, (*(*struct {
					Fleft  uintptr
					Fright uintptr
				})(unsafe.Pointer((*(*struct {
					Fleft  uintptr
					Fright uintptr
				})(unsafe.Pointer(e + 8))).Fright + 8))).Fleft)
			} else {
				*(*TFcValue)(unsafe.Pointer(bp)) = _FcConfigEvaluate(tls, p, p_pat, kind, (*(*struct {
					Fleft  uintptr
					Fright uintptr
				})(unsafe.Pointer((*(*struct {
					Fleft  uintptr
					Fright uintptr
				})(unsafe.Pointer(e + 8))).Fright + 8))).Fright)
			}
		} else {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
		}
		XFcValueDestroy(tls, *(*TFcValue)(unsafe.Pointer(bp + 16)))
	case int32(_FcOpEqual):
		fallthrough
	case int32(_FcOpNotEqual):
		fallthrough
	case int32(_FcOpLess):
		fallthrough
	case int32(_FcOpLessEqual):
		fallthrough
	case int32(_FcOpMore):
		fallthrough
	case int32(_FcOpMoreEqual):
		fallthrough
	case int32(_FcOpContains):
		fallthrough
	case int32(_FcOpNotContains):
		fallthrough
	case int32(_FcOpListing):
		*(*TFcValue)(unsafe.Pointer(bp + 16)) = _FcConfigEvaluate(tls, p, p_pat, kind, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fleft)
		*(*TFcValue)(unsafe.Pointer(bp + 32)) = _FcConfigEvaluate(tls, p, p_pat, kind, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fright)
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeBool)
		*(*TFcBool)(unsafe.Pointer(bp + 8)) = XFcConfigCompareValue(tls, bp+16, libc.Uint32FromInt32((*TFcExpr)(unsafe.Pointer(e)).Fop), bp+32)
		XFcValueDestroy(tls, *(*TFcValue)(unsafe.Pointer(bp + 16)))
		XFcValueDestroy(tls, *(*TFcValue)(unsafe.Pointer(bp + 32)))
	case int32(_FcOpOr):
		fallthrough
	case int32(_FcOpAnd):
		fallthrough
	case int32(_FcOpPlus):
		fallthrough
	case int32(_FcOpMinus):
		fallthrough
	case int32(_FcOpTimes):
		fallthrough
	case int32(_FcOpDivide):
		*(*TFcValue)(unsafe.Pointer(bp + 16)) = _FcConfigEvaluate(tls, p, p_pat, kind, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fleft)
		*(*TFcValue)(unsafe.Pointer(bp + 32)) = _FcConfigEvaluate(tls, p, p_pat, kind, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fright)
		*(*TFcValue)(unsafe.Pointer(bp + 48)) = _FcConfigPromote(tls, *(*TFcValue)(unsafe.Pointer(bp + 16)), *(*TFcValue)(unsafe.Pointer(bp + 32)), bp+80)
		*(*TFcValue)(unsafe.Pointer(bp + 64)) = _FcConfigPromote(tls, *(*TFcValue)(unsafe.Pointer(bp + 32)), *(*TFcValue)(unsafe.Pointer(bp + 48)), bp+336)
		if (*(*TFcValue)(unsafe.Pointer(bp + 48))).Ftype1 == (*(*TFcValue)(unsafe.Pointer(bp + 64))).Ftype1 {
			switch (*(*TFcValue)(unsafe.Pointer(bp + 48))).Ftype1 {
			case int32(_FcTypeDouble):
				switch op {
				case int32(_FcOpPlus):
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeDouble)
					*(*float64)(unsafe.Pointer(bp + 8)) = *(*float64)(unsafe.Pointer(bp + 48 + 8)) + *(*float64)(unsafe.Pointer(bp + 64 + 8))
				case int32(_FcOpMinus):
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeDouble)
					*(*float64)(unsafe.Pointer(bp + 8)) = *(*float64)(unsafe.Pointer(bp + 48 + 8)) - *(*float64)(unsafe.Pointer(bp + 64 + 8))
				case int32(_FcOpTimes):
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeDouble)
					*(*float64)(unsafe.Pointer(bp + 8)) = float64(*(*float64)(unsafe.Pointer(bp + 48 + 8)) * *(*float64)(unsafe.Pointer(bp + 64 + 8)))
				case int32(_FcOpDivide):
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeDouble)
					*(*float64)(unsafe.Pointer(bp + 8)) = *(*float64)(unsafe.Pointer(bp + 48 + 8)) / *(*float64)(unsafe.Pointer(bp + 64 + 8))
				default:
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
					break
				}
				if (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 == int32(_FcTypeDouble) && *(*float64)(unsafe.Pointer(bp + 8)) == float64(int32(*(*float64)(unsafe.Pointer(bp + 8)))) {
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeInteger)
					*(*int32)(unsafe.Pointer(bp + 8)) = int32(*(*float64)(unsafe.Pointer(bp + 8)))
				}
			case int32(_FcTypeBool):
				switch op {
				case int32(_FcOpOr):
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeBool)
					*(*TFcBool)(unsafe.Pointer(bp + 8)) = libc.BoolInt32(*(*TFcBool)(unsafe.Pointer(bp + 48 + 8)) != 0 || *(*TFcBool)(unsafe.Pointer(bp + 64 + 8)) != 0)
				case int32(_FcOpAnd):
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeBool)
					*(*TFcBool)(unsafe.Pointer(bp + 8)) = libc.BoolInt32(*(*TFcBool)(unsafe.Pointer(bp + 48 + 8)) != 0 && *(*TFcBool)(unsafe.Pointer(bp + 64 + 8)) != 0)
				default:
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
					break
				}
			case int32(_FcTypeString):
				switch op {
				case int32(_FcOpPlus):
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeString)
					str = XFcStrPlus(tls, *(*uintptr)(unsafe.Pointer(bp + 48 + 8)), *(*uintptr)(unsafe.Pointer(bp + 64 + 8)))
					*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.Xstrdup(tls, str)
					XFcStrFree(tls, str)
					if !(*(*uintptr)(unsafe.Pointer(bp + 8)) != 0) {
						(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
					}
				default:
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
					break
				}
			case int32(_FcTypeMatrix):
				switch op {
				case int32(_FcOpTimes):
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeMatrix)
					m = libc.Xmalloc(tls, uint64(32))
					if m != 0 {
						XFcMatrixMultiply(tls, m, *(*uintptr)(unsafe.Pointer(bp + 48 + 8)), *(*uintptr)(unsafe.Pointer(bp + 64 + 8)))
						*(*uintptr)(unsafe.Pointer(bp + 8)) = m
					} else {
						(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
					}
				default:
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
					break
				}
			case int32(_FcTypeCharSet):
				switch op {
				case int32(_FcOpPlus):
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeCharSet)
					*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcCharSetUnion(tls, *(*uintptr)(unsafe.Pointer(bp + 48 + 8)), *(*uintptr)(unsafe.Pointer(bp + 64 + 8)))
					if !(*(*uintptr)(unsafe.Pointer(bp + 8)) != 0) {
						(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
					}
				case int32(_FcOpMinus):
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeCharSet)
					*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcCharSetSubtract(tls, *(*uintptr)(unsafe.Pointer(bp + 48 + 8)), *(*uintptr)(unsafe.Pointer(bp + 64 + 8)))
					if !(*(*uintptr)(unsafe.Pointer(bp + 8)) != 0) {
						(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
					}
				default:
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
					break
				}
			case int32(_FcTypeLangSet):
				switch op {
				case int32(_FcOpPlus):
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeLangSet)
					*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcLangSetUnion(tls, *(*uintptr)(unsafe.Pointer(bp + 48 + 8)), *(*uintptr)(unsafe.Pointer(bp + 64 + 8)))
					if !(*(*uintptr)(unsafe.Pointer(bp + 8)) != 0) {
						(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
					}
				case int32(_FcOpMinus):
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeLangSet)
					*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcLangSetSubtract(tls, *(*uintptr)(unsafe.Pointer(bp + 48 + 8)), *(*uintptr)(unsafe.Pointer(bp + 64 + 8)))
					if !(*(*uintptr)(unsafe.Pointer(bp + 8)) != 0) {
						(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
					}
				default:
					(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
					break
				}
			default:
				(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
				break
			}
		} else {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
		}
		XFcValueDestroy(tls, *(*TFcValue)(unsafe.Pointer(bp + 16)))
		XFcValueDestroy(tls, *(*TFcValue)(unsafe.Pointer(bp + 32)))
	case int32(_FcOpNot):
		*(*TFcValue)(unsafe.Pointer(bp + 16)) = _FcConfigEvaluate(tls, p, p_pat, kind, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fleft)
		switch (*(*TFcValue)(unsafe.Pointer(bp + 16))).Ftype1 {
		case int32(_FcTypeBool):
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeBool)
			*(*TFcBool)(unsafe.Pointer(bp + 8)) = libc.BoolInt32(!(*(*TFcBool)(unsafe.Pointer(bp + 16 + 8)) != 0))
		default:
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
			break
		}
		XFcValueDestroy(tls, *(*TFcValue)(unsafe.Pointer(bp + 16)))
	case int32(_FcOpFloor):
		*(*TFcValue)(unsafe.Pointer(bp + 16)) = _FcConfigEvaluate(tls, p, p_pat, kind, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fleft)
		switch (*(*TFcValue)(unsafe.Pointer(bp + 16))).Ftype1 {
		case int32(_FcTypeInteger):
			*(*TFcValue)(unsafe.Pointer(bp)) = *(*TFcValue)(unsafe.Pointer(bp + 16))
		case int32(_FcTypeDouble):
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeInteger)
			if *(*float64)(unsafe.Pointer(bp + 16 + 8)) >= libc.Float64FromInt32(0) {
				v1 = int32(*(*float64)(unsafe.Pointer(bp + 16 + 8)))
			} else {
				if float64(int32(-*(*float64)(unsafe.Pointer(bp + 16 + 8)))) == -*(*float64)(unsafe.Pointer(bp + 16 + 8)) {
					v2 = int32(-*(*float64)(unsafe.Pointer(bp + 16 + 8)))
				} else {
					v2 = int32(-*(*float64)(unsafe.Pointer(bp + 16 + 8)) + libc.Float64FromInt32(1))
				}
				v1 = -v2
			}
			*(*int32)(unsafe.Pointer(bp + 8)) = v1
		default:
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
			break
		}
		XFcValueDestroy(tls, *(*TFcValue)(unsafe.Pointer(bp + 16)))
	case int32(_FcOpCeil):
		*(*TFcValue)(unsafe.Pointer(bp + 16)) = _FcConfigEvaluate(tls, p, p_pat, kind, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fleft)
		switch (*(*TFcValue)(unsafe.Pointer(bp + 16))).Ftype1 {
		case int32(_FcTypeInteger):
			*(*TFcValue)(unsafe.Pointer(bp)) = *(*TFcValue)(unsafe.Pointer(bp + 16))
		case int32(_FcTypeDouble):
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeInteger)
			if *(*float64)(unsafe.Pointer(bp + 16 + 8)) >= libc.Float64FromInt32(0) {
				if float64(int32(*(*float64)(unsafe.Pointer(bp + 16 + 8)))) == *(*float64)(unsafe.Pointer(bp + 16 + 8)) {
					v4 = int32(*(*float64)(unsafe.Pointer(bp + 16 + 8)))
				} else {
					v4 = int32(*(*float64)(unsafe.Pointer(bp + 16 + 8)) + libc.Float64FromInt32(1))
				}
				v3 = v4
			} else {
				v3 = -int32(-*(*float64)(unsafe.Pointer(bp + 16 + 8)))
			}
			*(*int32)(unsafe.Pointer(bp + 8)) = v3
		default:
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
			break
		}
		XFcValueDestroy(tls, *(*TFcValue)(unsafe.Pointer(bp + 16)))
	case int32(_FcOpRound):
		*(*TFcValue)(unsafe.Pointer(bp + 16)) = _FcConfigEvaluate(tls, p, p_pat, kind, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fleft)
		switch (*(*TFcValue)(unsafe.Pointer(bp + 16))).Ftype1 {
		case int32(_FcTypeInteger):
			*(*TFcValue)(unsafe.Pointer(bp)) = *(*TFcValue)(unsafe.Pointer(bp + 16))
		case int32(_FcTypeDouble):
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeInteger)
			if *(*float64)(unsafe.Pointer(bp + 16 + 8))+float64(0.5) >= libc.Float64FromInt32(0) {
				v5 = int32(*(*float64)(unsafe.Pointer(bp + 16 + 8)) + libc.Float64FromFloat64(0.5))
			} else {
				if float64(int32(-(*(*float64)(unsafe.Pointer(bp + 16 + 8)) + libc.Float64FromFloat64(0.5)))) == -(*(*float64)(unsafe.Pointer(bp + 16 + 8)) + libc.Float64FromFloat64(0.5)) {
					v6 = int32(-(*(*float64)(unsafe.Pointer(bp + 16 + 8)) + libc.Float64FromFloat64(0.5)))
				} else {
					v6 = int32(-(*(*float64)(unsafe.Pointer(bp + 16 + 8)) + libc.Float64FromFloat64(0.5)) + libc.Float64FromInt32(1))
				}
				v5 = -v6
			}
			*(*int32)(unsafe.Pointer(bp + 8)) = v5
		default:
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
			break
		}
		XFcValueDestroy(tls, *(*TFcValue)(unsafe.Pointer(bp + 16)))
	case int32(_FcOpTrunc):
		*(*TFcValue)(unsafe.Pointer(bp + 16)) = _FcConfigEvaluate(tls, p, p_pat, kind, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fleft)
		switch (*(*TFcValue)(unsafe.Pointer(bp + 16))).Ftype1 {
		case int32(_FcTypeInteger):
			*(*TFcValue)(unsafe.Pointer(bp)) = *(*TFcValue)(unsafe.Pointer(bp + 16))
		case int32(_FcTypeDouble):
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeInteger)
			if *(*float64)(unsafe.Pointer(bp + 16 + 8)) >= libc.Float64FromInt32(0) {
				v7 = int32(*(*float64)(unsafe.Pointer(bp + 16 + 8)))
			} else {
				v7 = -int32(-*(*float64)(unsafe.Pointer(bp + 16 + 8)))
			}
			*(*int32)(unsafe.Pointer(bp + 8)) = v7
		default:
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
			break
		}
		XFcValueDestroy(tls, *(*TFcValue)(unsafe.Pointer(bp + 16)))
	default:
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
		break
	}
	return *(*TFcValue)(unsafe.Pointer(bp))
}

// C documentation
//
//	/* The bulk of the time in FcConfigSubstitute is spent walking
//	 * lists of family names. We speed this up with a hash table.
//	 * Since we need to take the ignore-blanks option into account,
//	 * we use two separate hash tables.
//	 */
type TFamilyTableEntry = struct {
	Fcount int32
}

type TFamilyTable = struct {
	Ffamily_blank_hash uintptr
	Ffamily_hash       uintptr
}

func _FamilyTableLookup(tls *libc.TLS, table uintptr, _op TFcOp, s uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var flags int32
	var hash uintptr
	var _ /* fe at bp+0 */ uintptr
	_, _ = flags, hash
	flags = libc.Int32FromUint32(libc.Uint32FromInt32(_op) & libc.Uint32FromUint32(0xffff0000) >> libc.Int32FromInt32(16))
	if flags&int32(_FcOpFlagIgnoreBlanks) != 0 {
		hash = (*TFamilyTable)(unsafe.Pointer(table)).Ffamily_blank_hash
	} else {
		hash = (*TFamilyTable)(unsafe.Pointer(table)).Ffamily_hash
	}
	return XFcHashTableFind(tls, hash, s, bp)
}

func _FamilyTableAdd(tls *libc.TLS, table uintptr, values TFcValueListPtr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ll TFcValueListPtr
	var s, v2, v3 uintptr
	var _ /* fe at bp+0 */ uintptr
	_, _, _, _ = ll, s, v2, v3
	ll = values
	for {
		if !(ll != 0) {
			break
		}
		if int64(*(*uintptr)(unsafe.Pointer(ll + 8 + 8)))&int64(1) != 0 {
			v2 = uintptr(Tintptr_t(ll+8) + int64(*(*uintptr)(unsafe.Pointer(ll + 8 + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = *(*uintptr)(unsafe.Pointer(ll + 8 + 8))
		}
		s = v2
		if !(XFcHashTableFind(tls, (*TFamilyTable)(unsafe.Pointer(table)).Ffamily_hash, s, bp) != 0) {
			*(*uintptr)(unsafe.Pointer(bp)) = libc.Xmalloc(tls, uint64(4))
			(*TFamilyTableEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fcount = 0
			XFcHashTableAdd(tls, (*TFamilyTable)(unsafe.Pointer(table)).Ffamily_hash, s, *(*uintptr)(unsafe.Pointer(bp)))
		}
		(*TFamilyTableEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fcount++
		if !(XFcHashTableFind(tls, (*TFamilyTable)(unsafe.Pointer(table)).Ffamily_blank_hash, s, bp) != 0) {
			*(*uintptr)(unsafe.Pointer(bp)) = libc.Xmalloc(tls, uint64(4))
			(*TFamilyTableEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fcount = 0
			XFcHashTableAdd(tls, (*TFamilyTable)(unsafe.Pointer(table)).Ffamily_blank_hash, s, *(*uintptr)(unsafe.Pointer(bp)))
		}
		(*TFamilyTableEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fcount++
		goto _1
	_1:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(ll)).Fnext)&int64(1) != 0 {
			v3 = uintptr(int64(ll) + int64((*T_FcValueList)(unsafe.Pointer(ll)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v3 = (*T_FcValueList)(unsafe.Pointer(ll)).Fnext
		}
		ll = v3
	}
}

func _FamilyTableDel(tls *libc.TLS, table uintptr, s uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* fe at bp+0 */ uintptr
	if XFcHashTableFind(tls, (*TFamilyTable)(unsafe.Pointer(table)).Ffamily_hash, s, bp) != 0 {
		(*TFamilyTableEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fcount--
		if (*TFamilyTableEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fcount == 0 {
			XFcHashTableRemove(tls, (*TFamilyTable)(unsafe.Pointer(table)).Ffamily_hash, s)
		}
	}
	if XFcHashTableFind(tls, (*TFamilyTable)(unsafe.Pointer(table)).Ffamily_blank_hash, s, bp) != 0 {
		(*TFamilyTableEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fcount--
		if (*TFamilyTableEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fcount == 0 {
			XFcHashTableRemove(tls, (*TFamilyTable)(unsafe.Pointer(table)).Ffamily_blank_hash, s)
		}
	}
}

func _copy_string(tls *libc.TLS, src uintptr, dest uintptr) (r TFcBool) {
	*(*uintptr)(unsafe.Pointer(dest)) = libc.Xstrdup(tls, src)
	return int32(m_FcTrue)
}

func _FamilyTableInit(tls *libc.TLS, table uintptr, p uintptr) {
	var e, v1 uintptr
	_, _ = e, v1
	(*TFamilyTable)(unsafe.Pointer(table)).Ffamily_blank_hash = XFcHashTableCreate(tls, __ccgo_fp(XFcStrHashIgnoreBlanksAndCase), __ccgo_fp(XFcStrCmpIgnoreBlanksAndCase), __ccgo_fp(_copy_string), libc.UintptrFromInt32(0), __ccgo_fp(libc.Xfree), __ccgo_fp(libc.Xfree))
	(*TFamilyTable)(unsafe.Pointer(table)).Ffamily_hash = XFcHashTableCreate(tls, __ccgo_fp(XFcStrHashIgnoreCase), __ccgo_fp(XFcStrCmpIgnoreCase), __ccgo_fp(_copy_string), libc.UintptrFromInt32(0), __ccgo_fp(libc.Xfree), __ccgo_fp(libc.Xfree))
	e = XFcPatternObjectFindElt(tls, p, int32(_FC_FAMILY_OBJECT))
	if e != 0 {
		if int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(1) != 0 {
			v1 = uintptr(int64(e) + int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v1 = (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues
		}
		_FamilyTableAdd(tls, table, v1)
	}
}

func _FamilyTableClear(tls *libc.TLS, table uintptr) {
	if (*TFamilyTable)(unsafe.Pointer(table)).Ffamily_blank_hash != 0 {
		XFcHashTableDestroy(tls, (*TFamilyTable)(unsafe.Pointer(table)).Ffamily_blank_hash)
	}
	if (*TFamilyTable)(unsafe.Pointer(table)).Ffamily_hash != 0 {
		XFcHashTableDestroy(tls, (*TFamilyTable)(unsafe.Pointer(table)).Ffamily_hash)
	}
}

func _FcConfigMatchValueList(tls *libc.TLS, p uintptr, p_pat uintptr, kind TFcMatchKind, t uintptr, values uintptr, table uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e, ret, v, v1, v2, v4 uintptr
	var op TFcOp
	var _ /* value at bp+0 */ TFcValue
	_, _, _, _, _, _, _ = e, op, ret, v, v1, v2, v4
	ret = uintptr(0)
	e = (*TFcTest)(unsafe.Pointer(t)).Fexpr
	for e != 0 {
		/* Compute the value of the match expression */
		if (*TFcExpr)(unsafe.Pointer(e)).Fop&int32(0xffff) == int32(_FcOpComma) {
			*(*TFcValue)(unsafe.Pointer(bp)) = _FcConfigEvaluate(tls, p, p_pat, kind, (*(*struct {
				Fleft  uintptr
				Fright uintptr
			})(unsafe.Pointer(e + 8))).Fleft)
			e = (*(*struct {
				Fleft  uintptr
				Fright uintptr
			})(unsafe.Pointer(e + 8))).Fright
		} else {
			*(*TFcValue)(unsafe.Pointer(bp)) = _FcConfigEvaluate(tls, p, p_pat, kind, e)
			e = uintptr(0)
		}
		if (*TFcTest)(unsafe.Pointer(t)).Fobject == int32(_FC_FAMILY_OBJECT) && table != 0 {
			op = (*TFcTest)(unsafe.Pointer(t)).Fop & libc.Int32FromInt32(0xffff)
			if op == int32(_FcOpEqual) || op == int32(_FcOpListing) {
				if int64(*(*uintptr)(unsafe.Pointer(bp + 8)))&int64(1) != 0 {
					v1 = uintptr(Tintptr_t(bp) + int64(*(*uintptr)(unsafe.Pointer(bp + 8)))&int64(^libc.Int32FromInt32(1)))
				} else {
					v1 = *(*uintptr)(unsafe.Pointer(bp + 8))
				}
				if !(_FamilyTableLookup(tls, table, (*TFcTest)(unsafe.Pointer(t)).Fop, v1) != 0) {
					ret = uintptr(0)
					goto done
				}
			}
			if op == int32(_FcOpNotEqual) && (*TFcTest)(unsafe.Pointer(t)).Fqual == int32(_FcQualAll) {
				ret = uintptr(0)
				if int64(*(*uintptr)(unsafe.Pointer(bp + 8)))&int64(1) != 0 {
					v2 = uintptr(Tintptr_t(bp) + int64(*(*uintptr)(unsafe.Pointer(bp + 8)))&int64(^libc.Int32FromInt32(1)))
				} else {
					v2 = *(*uintptr)(unsafe.Pointer(bp + 8))
				}
				if !(_FamilyTableLookup(tls, table, (*TFcTest)(unsafe.Pointer(t)).Fop, v2) != 0) {
					ret = values
				}
				goto done
			}
		}
		v = values
		for {
			if !(v != 0) {
				break
			}
			/* Compare the pattern value to the match expression value */
			if XFcConfigCompareValue(tls, v+8, libc.Uint32FromInt32((*TFcTest)(unsafe.Pointer(t)).Fop), bp) != 0 {
				if !(ret != 0) {
					ret = v
				}
				if (*TFcTest)(unsafe.Pointer(t)).Fqual != int32(_FcQualAll) {
					break
				}
			} else {
				if (*TFcTest)(unsafe.Pointer(t)).Fqual == int32(_FcQualAll) {
					ret = uintptr(0)
					break
				}
			}
			goto _3
		_3:
			;
			if int64((*TFcValueList)(unsafe.Pointer(v)).Fnext)&int64(1) != 0 {
				v4 = uintptr(int64(v) + int64((*TFcValueList)(unsafe.Pointer(v)).Fnext)&int64(^libc.Int32FromInt32(1)))
			} else {
				v4 = (*TFcValueList)(unsafe.Pointer(v)).Fnext
			}
			v = v4
		}
		goto done
	done:
		;
		XFcValueDestroy(tls, *(*TFcValue)(unsafe.Pointer(bp)))
	}
	return ret
}

func _FcConfigValues(tls *libc.TLS, p uintptr, p_pat uintptr, kind TFcMatchKind, e uintptr, binding TFcValueBinding) (r uintptr) {
	var l, next, v1 uintptr
	_, _, _ = l, next, v1
	if !(e != 0) {
		return uintptr(0)
	}
	l = libc.Xmalloc(tls, uint64(32))
	if !(l != 0) {
		return uintptr(0)
	}
	if (*TFcExpr)(unsafe.Pointer(e)).Fop&int32(0xffff) == int32(_FcOpComma) {
		(*TFcValueList)(unsafe.Pointer(l)).Fvalue = _FcConfigEvaluate(tls, p, p_pat, kind, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fleft)
		(*TFcValueList)(unsafe.Pointer(l)).Fnext = _FcConfigValues(tls, p, p_pat, kind, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fright, binding)
	} else {
		(*TFcValueList)(unsafe.Pointer(l)).Fvalue = _FcConfigEvaluate(tls, p, p_pat, kind, e)
		(*TFcValueList)(unsafe.Pointer(l)).Fnext = libc.UintptrFromInt32(0)
	}
	(*TFcValueList)(unsafe.Pointer(l)).Fbinding = binding
	if (*TFcValueList)(unsafe.Pointer(l)).Fvalue.Ftype1 == int32(_FcTypeVoid) {
		if int64((*TFcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
			v1 = uintptr(int64(l) + int64((*TFcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v1 = (*TFcValueList)(unsafe.Pointer(l)).Fnext
		}
		next = v1
		libc.Xfree(tls, l)
		l = next
	}
	return l
}

func _FcConfigAdd(tls *libc.TLS, head uintptr, position uintptr, append1 TFcBool, new1 uintptr, object TFcObject, table uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var l, last, v TFcValueListPtr
	var prev, v2, v4, v7, v8 uintptr
	var sameBinding TFcValueBinding
	_, _, _, _, _, _, _, _, _ = l, last, prev, sameBinding, v, v2, v4, v7, v8
	/*
	 * Make sure the stored type is valid for built-in objects
	 */
	l = new1
	for {
		if !(l != libc.UintptrFromInt32(0)) {
			break
		}
		if !(XFcObjectValidType(tls, object, (*T_FcValueList)(unsafe.Pointer(l)).Fvalue.Ftype1) != 0) {
			libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+1204, libc.VaList(bp+8, XFcObjectName(tls, object)))
			XFcValuePrintFile(tls, libc.X__stderrp, (*T_FcValueList)(unsafe.Pointer(l)).Fvalue)
			libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+1266, 0)
			if XFcDebugVal&int32(m_FC_DBG_EDIT) != 0 {
				libc.Xprintf(tls, __ccgo_ts+1268, 0)
			}
			return m_FcFalse
		}
		goto _1
	_1:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
			v2 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
		}
		l = v2
	}
	if object == int32(_FC_FAMILY_OBJECT) && table != 0 {
		_FamilyTableAdd(tls, table, new1)
	}
	if position != 0 {
		sameBinding = (*TFcValueList)(unsafe.Pointer(position)).Fbinding
	} else {
		sameBinding = int32(_FcValueBindingWeak)
	}
	v = new1
	for {
		if !(v != libc.UintptrFromInt32(0)) {
			break
		}
		if (*T_FcValueList)(unsafe.Pointer(v)).Fbinding == int32(_FcValueBindingSame) {
			(*T_FcValueList)(unsafe.Pointer(v)).Fbinding = sameBinding
		}
		goto _3
	_3:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(v)).Fnext)&int64(1) != 0 {
			v4 = uintptr(int64(v) + int64((*T_FcValueList)(unsafe.Pointer(v)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v4 = (*T_FcValueList)(unsafe.Pointer(v)).Fnext
		}
		v = v4
	}
	if append1 != 0 {
		if position != 0 {
			prev = position
		} else {
			prev = head
			for {
				if !(*(*TFcValueListPtr)(unsafe.Pointer(prev)) != libc.UintptrFromInt32(0)) {
					break
				}
				goto _5
			_5:
				;
				prev = *(*TFcValueListPtr)(unsafe.Pointer(prev))
			}
		}
	} else {
		if position != 0 {
			prev = head
			for {
				if !(*(*TFcValueListPtr)(unsafe.Pointer(prev)) != libc.UintptrFromInt32(0)) {
					break
				}
				if *(*TFcValueListPtr)(unsafe.Pointer(prev)) == position {
					break
				}
				goto _6
			_6:
				;
				prev = *(*TFcValueListPtr)(unsafe.Pointer(prev))
			}
		} else {
			prev = head
		}
		if XFcDebugVal&int32(m_FC_DBG_EDIT) != 0 {
			if *(*TFcValueListPtr)(unsafe.Pointer(prev)) == libc.UintptrFromInt32(0) {
				libc.Xprintf(tls, __ccgo_ts+1280, 0)
			}
		}
	}
	if XFcDebugVal&int32(m_FC_DBG_EDIT) != 0 {
		if append1 != 0 {
			v7 = __ccgo_ts + 1302
		} else {
			v7 = __ccgo_ts + 1309
		}
		libc.Xprintf(tls, __ccgo_ts+1317, libc.VaList(bp+8, v7))
		XFcValueListPrintWithPosition(tls, *(*TFcValueListPtr)(unsafe.Pointer(head)), *(*TFcValueListPtr)(unsafe.Pointer(prev)))
		libc.Xprintf(tls, __ccgo_ts+1266, 0)
	}
	if new1 != 0 {
		last = new1
		for (*T_FcValueList)(unsafe.Pointer(last)).Fnext != libc.UintptrFromInt32(0) {
			last = (*T_FcValueList)(unsafe.Pointer(last)).Fnext
		}
		(*T_FcValueList)(unsafe.Pointer(last)).Fnext = *(*TFcValueListPtr)(unsafe.Pointer(prev))
		*(*TFcValueListPtr)(unsafe.Pointer(prev)) = new1
	}
	if XFcDebugVal&int32(m_FC_DBG_EDIT) != 0 {
		if append1 != 0 {
			v8 = __ccgo_ts + 1302
		} else {
			v8 = __ccgo_ts + 1309
		}
		libc.Xprintf(tls, __ccgo_ts+1333, libc.VaList(bp+8, v8))
		XFcValueListPrint(tls, *(*TFcValueListPtr)(unsafe.Pointer(head)))
		libc.Xprintf(tls, __ccgo_ts+1266, 0)
	}
	return int32(m_FcTrue)
}

func _FcConfigDel(tls *libc.TLS, head uintptr, position uintptr, object TFcObject, table uintptr) {
	var prev, v1 uintptr
	_, _ = prev, v1
	if object == int32(_FC_FAMILY_OBJECT) && table != 0 {
		if int64(*(*uintptr)(unsafe.Pointer(position + 8 + 8)))&int64(1) != 0 {
			v1 = uintptr(Tintptr_t(position+8) + int64(*(*uintptr)(unsafe.Pointer(position + 8 + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v1 = *(*uintptr)(unsafe.Pointer(position + 8 + 8))
		}
		_FamilyTableDel(tls, table, v1)
	}
	prev = head
	for {
		if !(*(*TFcValueListPtr)(unsafe.Pointer(prev)) != libc.UintptrFromInt32(0)) {
			break
		}
		if *(*TFcValueListPtr)(unsafe.Pointer(prev)) == position {
			*(*TFcValueListPtr)(unsafe.Pointer(prev)) = (*TFcValueList)(unsafe.Pointer(position)).Fnext
			(*TFcValueList)(unsafe.Pointer(position)).Fnext = libc.UintptrFromInt32(0)
			XFcValueListDestroy(tls, position)
			break
		}
		goto _2
	_2:
		;
		prev = *(*TFcValueListPtr)(unsafe.Pointer(prev))
	}
}

func _FcConfigPatternAdd(tls *libc.TLS, p uintptr, object TFcObject, list uintptr, append1 TFcBool, table uintptr) {
	var e uintptr
	_ = e
	if list != 0 {
		e = XFcPatternObjectInsertElt(tls, p, object)
		if !(e != 0) {
			return
		}
		_FcConfigAdd(tls, e+8, uintptr(0), append1, list, object, table)
	}
}

// C documentation
//
//	/*
//	 * Delete all values associated with a field
//	 */
func _FcConfigPatternDel(tls *libc.TLS, p uintptr, object TFcObject, table uintptr) {
	var e uintptr
	_ = e
	e = XFcPatternObjectFindElt(tls, p, object)
	if !(e != 0) {
		return
	}
	for (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues != libc.UintptrFromInt32(0) {
		_FcConfigDel(tls, e+8, (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues, object, table)
	}
}

func _FcConfigPatternCanon(tls *libc.TLS, p uintptr, object TFcObject) {
	var e uintptr
	_ = e
	e = XFcPatternObjectFindElt(tls, p, object)
	if !(e != 0) {
		return
	}
	if (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues == libc.UintptrFromInt32(0) {
		XFcPatternObjectDel(tls, p, object)
	}
}

func XFcConfigSubstituteWithPat(tls *libc.TLS, config uintptr, p uintptr, p_pat uintptr, kind TFcMatchKind) (r1 TFcBool) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var b, retval TFcBool
	var e, e1, elt, l, l1, lang, ls, lsund, m, nextValue, prgname, r, rs, s, strs, table, thisValue, tst, value, vl, v1, v4, v5 uintptr
	var i, nobjs int32
	var ll TFcValueListPtr
	var object TFcObject
	var v2 bool
	var _ /* data at bp+64 */ TFamilyTable
	var _ /* iter at bp+16 */ TFcPtrListIter
	var _ /* iter2 at bp+40 */ TFcPtrListIter
	var _ /* v at bp+0 */ TFcValue
	var _ /* v at bp+80 */ TFcValue
	var _ /* vv at bp+96 */ TFcValue
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = b, e, e1, elt, i, l, l1, lang, ll, ls, lsund, m, nextValue, nobjs, object, prgname, r, retval, rs, s, strs, table, thisValue, tst, value, vl, v1, v2, v4, v5
	value = libc.UintptrFromInt32(0)
	object = int32(_FC_INVALID_OBJECT)
	elt = libc.UintptrFromInt32(0)
	retval = int32(m_FcTrue)
	tst = libc.UintptrFromInt32(0)
	table = bp + 64
	if kind < int32(_FcMatchKindBegin) || kind >= int32(_FcMatchKindEnd) {
		return m_FcFalse
	}
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return m_FcFalse
	}
	s = *(*uintptr)(unsafe.Pointer(config + 40 + uintptr(kind)*8))
	if kind == int32(_FcMatchPattern) {
		strs = XFcGetDefaultLangs(tls)
		if strs != 0 {
			l1 = XFcStrListCreate(tls, strs)
			lsund = XFcLangSetCreate(tls)
			XFcLangSetAdd(tls, lsund, __ccgo_ts+1348)
			XFcStrSetDestroy(tls, strs)
			for {
				if v2 = l1 != 0; v2 {
					v1 = XFcStrListNext(tls, l1)
					lang = v1
				}
				if !(v2 && v1 != 0) {
					break
				}
				e1 = XFcPatternObjectFindElt(tls, p, int32(_FC_LANG_OBJECT))
				if e1 != 0 {
					if int64((*TFcPatternElt)(unsafe.Pointer(e1)).Fvalues)&int64(1) != 0 {
						v4 = uintptr(int64(e1) + int64((*TFcPatternElt)(unsafe.Pointer(e1)).Fvalues)&int64(^libc.Int32FromInt32(1)))
					} else {
						v4 = (*TFcPatternElt)(unsafe.Pointer(e1)).Fvalues
					}
					ll = v4
					for {
						if !(ll != 0) {
							break
						}
						*(*TFcValue)(unsafe.Pointer(bp + 96)) = TFcValue{}
						*(*T_FcValue)(unsafe.Pointer(bp + 96)) = XFcValueCanonicalize(tls, ll+8)
						if (*(*TFcValue)(unsafe.Pointer(bp + 96))).Ftype1 == int32(_FcTypeLangSet) {
							ls = XFcLangSetCreate(tls)
							XFcLangSetAdd(tls, ls, lang)
							b = XFcLangSetContains(tls, *(*uintptr)(unsafe.Pointer(bp + 96 + 8)), ls)
							XFcLangSetDestroy(tls, ls)
							if b != 0 {
								goto bail_lang
							}
							if XFcLangSetContains(tls, *(*uintptr)(unsafe.Pointer(bp + 96 + 8)), lsund) != 0 {
								goto bail_lang
							}
						} else {
							if XFcStrCmpIgnoreCase(tls, *(*uintptr)(unsafe.Pointer(bp + 96 + 8)), lang) == 0 {
								goto bail_lang
							}
							if XFcStrCmpIgnoreCase(tls, *(*uintptr)(unsafe.Pointer(bp + 96 + 8)), __ccgo_ts+1348) == 0 {
								goto bail_lang
							}
						}
						goto _3
					_3:
						;
						if int64((*T_FcValueList)(unsafe.Pointer(ll)).Fnext)&int64(1) != 0 {
							v5 = uintptr(int64(ll) + int64((*T_FcValueList)(unsafe.Pointer(ll)).Fnext)&int64(^libc.Int32FromInt32(1)))
						} else {
							v5 = (*T_FcValueList)(unsafe.Pointer(ll)).Fnext
						}
						ll = v5
					}
				}
				(*(*TFcValue)(unsafe.Pointer(bp + 80))).Ftype1 = int32(_FcTypeString)
				*(*uintptr)(unsafe.Pointer(bp + 80 + 8)) = lang
				XFcPatternObjectAddWithBinding(tls, p, int32(_FC_LANG_OBJECT), *(*TFcValue)(unsafe.Pointer(bp + 80)), int32(_FcValueBindingWeak), int32(m_FcTrue))
			}
			goto bail_lang
		bail_lang:
			;
			XFcStrListDone(tls, l1)
			XFcLangSetDestroy(tls, lsund)
		}
		if XFcPatternObjectGet(tls, p, int32(_FC_PRGNAME_OBJECT), 0, bp) == int32(_FcResultNoMatch) {
			prgname = XFcGetPrgname(tls)
			if prgname != 0 {
				XFcPatternObjectAddString(tls, p, int32(_FC_PRGNAME_OBJECT), prgname)
			}
		}
	}
	nobjs = int32(_FC_ONE_AFTER_MAX_BASE_OBJECT) - libc.Int32FromInt32(1) + (*TFcConfig)(unsafe.Pointer(config)).FmaxObjects + int32(2)
	value = libc.Xmalloc(tls, libc.Uint64FromInt32(int32(8)*nobjs))
	if !(value != 0) {
		retval = m_FcFalse
		goto bail1
	}
	elt = libc.Xmalloc(tls, libc.Uint64FromInt32(int32(8)*nobjs))
	if !(elt != 0) {
		retval = m_FcFalse
		goto bail1
	}
	tst = libc.Xmalloc(tls, libc.Uint64FromInt32(int32(8)*nobjs))
	if !(tst != 0) {
		retval = m_FcFalse
		goto bail1
	}
	if XFcDebugVal&int32(m_FC_DBG_EDIT) != 0 {
		libc.Xprintf(tls, __ccgo_ts+1352, 0)
		XFcPatternPrint(tls, p)
	}
	_FamilyTableInit(tls, bp+64, p)
	XFcPtrListIterInit(tls, s, bp+16)
	for {
		if !(XFcPtrListIterIsValid(tls, s, bp+16) != 0) {
			break
		}
		rs = XFcPtrListIterGetValue(tls, s, bp+16)
		if XFcDebugVal&int32(m_FC_DBG_EDIT) != 0 {
			libc.Xprintf(tls, __ccgo_ts+1372, libc.VaList(bp+120, (*TFcRuleSet)(unsafe.Pointer(rs)).Fname))
		}
		XFcPtrListIterInit(tls, *(*uintptr)(unsafe.Pointer(rs + 40 + uintptr(kind)*8)), bp+40)
		for {
			if !(XFcPtrListIterIsValid(tls, *(*uintptr)(unsafe.Pointer(rs + 40 + uintptr(kind)*8)), bp+40) != 0) {
				break
			}
			r = XFcPtrListIterGetValue(tls, *(*uintptr)(unsafe.Pointer(rs + 40 + uintptr(kind)*8)), bp+40)
			i = 0
			for {
				if !(i < nobjs) {
					break
				}
				*(*uintptr)(unsafe.Pointer(elt + uintptr(i)*8)) = libc.UintptrFromInt32(0)
				*(*uintptr)(unsafe.Pointer(value + uintptr(i)*8)) = libc.UintptrFromInt32(0)
				*(*uintptr)(unsafe.Pointer(tst + uintptr(i)*8)) = libc.UintptrFromInt32(0)
				goto _8
			_8:
				;
				i++
			}
			for {
				if !(r != 0) {
					break
				}
				switch (*TFcRule)(unsafe.Pointer(r)).Ftype1 {
				case int32(_FcRuleUnknown):
					/* shouldn't be reached */
				case int32(_FcRuleTest):
					object = (*TFcTest)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject & ^libc.Int32FromInt32(m_FC_EXT_OBJ_INDEX)
					/*
					 * Check the tests to see if
					 * they all match the pattern
					 */
					if XFcDebugVal&int32(m_FC_DBG_EDIT) != 0 {
						libc.Xprintf(tls, __ccgo_ts+1387, 0)
						XFcTestPrint(tls, *(*uintptr)(unsafe.Pointer(r + 16)))
					}
					if kind == int32(_FcMatchFont) && (*TFcTest)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fkind == int32(_FcMatchPattern) {
						m = p_pat
						table = libc.UintptrFromInt32(0)
					} else {
						m = p
						table = bp + 64
					}
					if m != 0 {
						e = XFcPatternObjectFindElt(tls, m, (*TFcTest)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject)
					} else {
						e = libc.UintptrFromInt32(0)
					}
					/* different 'kind' won't be the target of edit */
					if !(*(*uintptr)(unsafe.Pointer(elt + uintptr(object)*8)) != 0) && kind == (*TFcTest)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fkind {
						*(*uintptr)(unsafe.Pointer(elt + uintptr(object)*8)) = e
						*(*uintptr)(unsafe.Pointer(tst + uintptr(object)*8)) = *(*uintptr)(unsafe.Pointer(r + 16))
					}
					/*
					 * If there's no such field in the font,
					 * then FcQualAll matches while FcQualAny does not
					 */
					if !(e != 0) {
						if (*TFcTest)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fqual == int32(_FcQualAll) {
							*(*uintptr)(unsafe.Pointer(value + uintptr(object)*8)) = libc.UintptrFromInt32(0)
							goto _9
						} else {
							if XFcDebugVal&int32(m_FC_DBG_EDIT) != 0 {
								libc.Xprintf(tls, __ccgo_ts+1412, 0)
							}
							goto bail
						}
					}
					/*
					 * Check to see if there is a match, mark the location
					 * to apply match-relative edits
					 */
					vl = _FcConfigMatchValueList(tls, m, p_pat, kind, *(*uintptr)(unsafe.Pointer(r + 16)), (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues, table)
					/* different 'kind' won't be the target of edit */
					if !(*(*uintptr)(unsafe.Pointer(value + uintptr(object)*8)) != 0) && kind == (*TFcTest)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fkind {
						*(*uintptr)(unsafe.Pointer(value + uintptr(object)*8)) = vl
					}
					if !(vl != 0) || (*TFcTest)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fqual == int32(_FcQualFirst) && vl != (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues || (*TFcTest)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fqual == int32(_FcQualNotFirst) && vl == (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues {
						if XFcDebugVal&int32(m_FC_DBG_EDIT) != 0 {
							libc.Xprintf(tls, __ccgo_ts+1412, 0)
						}
						goto bail
					}
				case int32(_FcRuleEdit):
					object = (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject & ^libc.Int32FromInt32(m_FC_EXT_OBJ_INDEX)
					if XFcDebugVal&int32(m_FC_DBG_EDIT) != 0 {
						libc.Xprintf(tls, __ccgo_ts+1422, 0)
						XFcEditPrint(tls, *(*uintptr)(unsafe.Pointer(r + 16)))
						libc.Xprintf(tls, __ccgo_ts+1434, 0)
					}
					/*
					 * Evaluate the list of expressions
					 */
					l = _FcConfigValues(tls, p, p_pat, kind, (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fexpr, (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fbinding)
					if *(*uintptr)(unsafe.Pointer(tst + uintptr(object)*8)) != 0 && ((*TFcTest)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(tst + uintptr(object)*8)))).Fkind == int32(_FcMatchFont) || kind == int32(_FcMatchPattern)) {
						*(*uintptr)(unsafe.Pointer(elt + uintptr(object)*8)) = XFcPatternObjectFindElt(tls, p, (*TFcTest)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(tst + uintptr(object)*8)))).Fobject)
					}
					switch (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fop & libc.Int32FromInt32(0xffff) {
					case int32(_FcOpAssign):
						/*
						 * If there was a test, then replace the matched
						 * value with the new list of values
						 */
						if *(*uintptr)(unsafe.Pointer(value + uintptr(object)*8)) != 0 {
							thisValue = *(*uintptr)(unsafe.Pointer(value + uintptr(object)*8))
							nextValue = l
							/*
							 * Append the new list of values after the current value
							 */
							_FcConfigAdd(tls, *(*uintptr)(unsafe.Pointer(elt + uintptr(object)*8))+8, thisValue, int32(m_FcTrue), l, (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject, table)
							/*
							 * Delete the marked value
							 */
							if thisValue != 0 {
								_FcConfigDel(tls, *(*uintptr)(unsafe.Pointer(elt + uintptr(object)*8))+8, thisValue, object, table)
							}
							/*
							 * Adjust a pointer into the value list to ensure
							 * future edits occur at the same place
							 */
							*(*uintptr)(unsafe.Pointer(value + uintptr(object)*8)) = nextValue
							break
						}
						/* fall through ... */
						fallthrough
					case int32(_FcOpAssignReplace):
						/*
						 * Delete all of the values and insert
						 * the new set
						 */
						_FcConfigPatternDel(tls, p, (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject, table)
						_FcConfigPatternAdd(tls, p, (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject, l, int32(m_FcTrue), table)
						/*
						 * Adjust a pointer into the value list as they no
						 * longer point to anything valid
						 */
						*(*uintptr)(unsafe.Pointer(value + uintptr(object)*8)) = libc.UintptrFromInt32(0)
					case int32(_FcOpPrepend):
						if *(*uintptr)(unsafe.Pointer(value + uintptr(object)*8)) != 0 {
							_FcConfigAdd(tls, *(*uintptr)(unsafe.Pointer(elt + uintptr(object)*8))+8, *(*uintptr)(unsafe.Pointer(value + uintptr(object)*8)), m_FcFalse, l, (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject, table)
							break
						}
						/* fall through ... */
						fallthrough
					case int32(_FcOpPrependFirst):
						_FcConfigPatternAdd(tls, p, (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject, l, m_FcFalse, table)
					case int32(_FcOpAppend):
						if *(*uintptr)(unsafe.Pointer(value + uintptr(object)*8)) != 0 {
							_FcConfigAdd(tls, *(*uintptr)(unsafe.Pointer(elt + uintptr(object)*8))+8, *(*uintptr)(unsafe.Pointer(value + uintptr(object)*8)), int32(m_FcTrue), l, (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject, table)
							break
						}
						/* fall through ... */
						fallthrough
					case int32(_FcOpAppendLast):
						_FcConfigPatternAdd(tls, p, (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject, l, int32(m_FcTrue), table)
					case int32(_FcOpDelete):
						if *(*uintptr)(unsafe.Pointer(value + uintptr(object)*8)) != 0 {
							_FcConfigDel(tls, *(*uintptr)(unsafe.Pointer(elt + uintptr(object)*8))+8, *(*uintptr)(unsafe.Pointer(value + uintptr(object)*8)), object, table)
							XFcValueListDestroy(tls, l)
							break
						}
						/* fall through ... */
						fallthrough
					case int32(_FcOpDeleteAll):
						_FcConfigPatternDel(tls, p, (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject, table)
						XFcValueListDestroy(tls, l)
					default:
						XFcValueListDestroy(tls, l)
						break
					}
					/*
					 * Now go through the pattern and eliminate
					 * any properties without data
					 */
					_FcConfigPatternCanon(tls, p, (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject)
					if XFcDebugVal&int32(m_FC_DBG_EDIT) != 0 {
						libc.Xprintf(tls, __ccgo_ts+1437, 0)
						XFcPatternPrint(tls, p)
					}
					break
				}
				goto _9
			_9:
				;
				r = (*TFcRule)(unsafe.Pointer(r)).Fnext
			}
			goto bail
		bail:
			;
			goto _7
		_7:
			;
			XFcPtrListIterNext(tls, *(*uintptr)(unsafe.Pointer(rs + 40 + uintptr(kind)*8)), bp+40)
		}
		goto _6
	_6:
		;
		XFcPtrListIterNext(tls, s, bp+16)
	}
	if XFcDebugVal&int32(m_FC_DBG_EDIT) != 0 {
		libc.Xprintf(tls, __ccgo_ts+1461, 0)
		XFcPatternPrint(tls, p)
	}
	goto bail1
bail1:
	;
	_FamilyTableClear(tls, bp+64)
	if elt != 0 {
		libc.Xfree(tls, elt)
	}
	if value != 0 {
		libc.Xfree(tls, value)
	}
	if tst != 0 {
		libc.Xfree(tls, tst)
	}
	XFcConfigDestroy(tls, config)
	return retval
}

func XFcConfigSubstitute(tls *libc.TLS, config uintptr, p uintptr, kind TFcMatchKind) (r TFcBool) {
	return XFcConfigSubstituteWithPat(tls, config, p, uintptr(0), kind)
}

func _FcConfigFileExists(tls *libc.TLS, dir uintptr, file uintptr) (r uintptr) {
	var osize, size int32
	var path uintptr
	_, _, _ = osize, path, size
	if !(dir != 0) {
		dir = __ccgo_ts + 110
	}
	osize = libc.Int32FromUint64(libc.Xstrlen(tls, dir) + uint64(1) + libc.Xstrlen(tls, file) + uint64(1))
	/*
	 * workaround valgrind warning because glibc takes advantage of how it knows memory is
	 * allocated to implement strlen by reading in groups of 4
	 */
	size = (osize + int32(3)) & ^libc.Int32FromInt32(3)
	path = libc.Xmalloc(tls, libc.Uint64FromInt32(size))
	if !(path != 0) {
		return uintptr(0)
	}
	libc.X__builtin___strcpy_chk(tls, path, dir, ^t__predefined_size_t(0))
	/* make sure there's a single separator */
	if (!(*(*TFcChar8)(unsafe.Pointer(path)) != 0) || libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(path + uintptr(libc.Xstrlen(tls, path)-uint64(1))))) != int32('/')) && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(file))) != int32('/') {
		libc.X__builtin___strcat_chk(tls, path, __ccgo_ts+1485, ^t__predefined_size_t(0))
	} else {
		osize--
	}
	libc.X__builtin___strcat_chk(tls, path, file, ^t__predefined_size_t(0))
	if libc.Xaccess(tls, path, libc.Int32FromInt32(1)<<libc.Int32FromInt32(2)) == 0 {
		return path
	}
	XFcStrFree(tls, path)
	return uintptr(0)
}

func _FcConfigGetPath(tls *libc.TLS) (r uintptr) {
	var colon, dir, e, env, path, v1 uintptr
	var i, npath int32
	_, _, _, _, _, _, _, _ = colon, dir, e, env, i, npath, path, v1
	npath = int32(2) /* default dir + null */
	env = libc.Xgetenv(tls, __ccgo_ts+1487)
	if env != 0 {
		e = env
		npath++
		for *(*TFcChar8)(unsafe.Pointer(e)) != 0 {
			v1 = e
			e++
			if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v1))) == int32(':') {
				npath++
			}
		}
	}
	path = libc.Xcalloc(tls, libc.Uint64FromInt32(npath), uint64(8))
	if !(path != 0) {
		goto bail0
	}
	i = 0
	if env != 0 {
		e = env
		for *(*TFcChar8)(unsafe.Pointer(e)) != 0 {
			colon = libc.Xstrchr(tls, e, int32(':'))
			if !(colon != 0) {
				colon = e + uintptr(libc.Xstrlen(tls, e))
			}
			*(*uintptr)(unsafe.Pointer(path + uintptr(i)*8)) = libc.Xmalloc(tls, libc.Uint64FromInt64(int64(colon)-int64(e)+int64(1)))
			if !(*(*uintptr)(unsafe.Pointer(path + uintptr(i)*8)) != 0) {
				goto bail1
			}
			libc.X__builtin___strncpy_chk(tls, *(*uintptr)(unsafe.Pointer(path + uintptr(i)*8)), e, libc.Uint64FromInt64(int64(colon)-int64(e)), ^t__predefined_size_t(0))
			*(*TFcChar8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(path + uintptr(i)*8)) + uintptr(int64(colon)-int64(e)))) = uint8('\000')
			if *(*TFcChar8)(unsafe.Pointer(colon)) != 0 {
				e = colon + uintptr(1)
			} else {
				e = colon
			}
			i++
		}
	}
	dir = __ccgo_ts + 1503
	*(*uintptr)(unsafe.Pointer(path + uintptr(i)*8)) = libc.Xmalloc(tls, libc.Xstrlen(tls, dir)+uint64(1))
	if !(*(*uintptr)(unsafe.Pointer(path + uintptr(i)*8)) != 0) {
		goto bail1
	}
	libc.X__builtin___strcpy_chk(tls, *(*uintptr)(unsafe.Pointer(path + uintptr(i)*8)), dir, ^t__predefined_size_t(0))
	return path
	goto bail1
bail1:
	;
	i = 0
	for {
		if !(*(*uintptr)(unsafe.Pointer(path + uintptr(i)*8)) != 0) {
			break
		}
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(path + uintptr(i)*8)))
		goto _2
	_2:
		;
		i++
	}
	libc.Xfree(tls, path)
	goto bail0
bail0:
	;
	return uintptr(0)
	return r
}

func _FcConfigFreePath(tls *libc.TLS, path uintptr) {
	var p uintptr
	_ = p
	p = path
	for {
		if !(*(*uintptr)(unsafe.Pointer(p)) != 0) {
			break
		}
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(p)))
		goto _1
	_1:
		;
		p += 8
	}
	libc.Xfree(tls, path)
}

var __FcConfigHomeEnabled = int32(m_FcTrue) /* MT-goodenough */

func XFcConfigHome(tls *libc.TLS) (r uintptr) {
	var home uintptr
	_ = home
	if __FcConfigHomeEnabled != 0 {
		home = libc.Xgetenv(tls, __ccgo_ts+1514)
		return home
	}
	return uintptr(0)
}

func XFcConfigXdgCacheHome(tls *libc.TLS) (r uintptr) {
	var env, home, ret uintptr
	var len1 Tsize_t
	var v1 uint64
	_, _, _, _, _ = env, home, len1, ret, v1
	env = libc.Xgetenv(tls, __ccgo_ts+1519)
	ret = libc.UintptrFromInt32(0)
	if !(__FcConfigHomeEnabled != 0) {
		return libc.UintptrFromInt32(0)
	}
	if env != 0 && *(*int8)(unsafe.Pointer(env)) != 0 {
		ret = XFcStrCopy(tls, env)
	} else {
		home = XFcConfigHome(tls)
		if home != 0 {
			v1 = libc.Xstrlen(tls, home)
		} else {
			v1 = uint64(0)
		}
		len1 = v1
		ret = libc.Xmalloc(tls, len1+uint64(7)+uint64(1))
		if ret != 0 {
			if home != 0 {
				libc.X__builtin___memcpy_chk(tls, ret, home, len1, ^t__predefined_size_t(0))
			}
			libc.X__builtin___memcpy_chk(tls, ret+uintptr(len1), __ccgo_ts+1534, uint64(7), ^t__predefined_size_t(0))
			*(*TFcChar8)(unsafe.Pointer(ret + uintptr(len1+uint64(7)))) = uint8(0)
		}
	}
	return ret
}

func XFcConfigXdgConfigHome(tls *libc.TLS) (r uintptr) {
	var env, home, ret uintptr
	var len1 Tsize_t
	var v1 uint64
	_, _, _, _, _ = env, home, len1, ret, v1
	env = libc.Xgetenv(tls, __ccgo_ts+1542)
	ret = libc.UintptrFromInt32(0)
	if !(__FcConfigHomeEnabled != 0) {
		return libc.UintptrFromInt32(0)
	}
	if env != 0 {
		ret = XFcStrCopy(tls, env)
	} else {
		home = XFcConfigHome(tls)
		if home != 0 {
			v1 = libc.Xstrlen(tls, home)
		} else {
			v1 = uint64(0)
		}
		len1 = v1
		ret = libc.Xmalloc(tls, len1+uint64(8)+uint64(1))
		if ret != 0 {
			if home != 0 {
				libc.X__builtin___memcpy_chk(tls, ret, home, len1, ^t__predefined_size_t(0))
			}
			libc.X__builtin___memcpy_chk(tls, ret+uintptr(len1), __ccgo_ts+1558, uint64(8), ^t__predefined_size_t(0))
			*(*TFcChar8)(unsafe.Pointer(ret + uintptr(len1+uint64(8)))) = uint8(0)
		}
	}
	return ret
}

func XFcConfigXdgDataHome(tls *libc.TLS) (r uintptr) {
	var env, home, ret uintptr
	var len1 Tsize_t
	var v1 uint64
	_, _, _, _, _ = env, home, len1, ret, v1
	env = libc.Xgetenv(tls, __ccgo_ts+1567)
	ret = libc.UintptrFromInt32(0)
	if !(__FcConfigHomeEnabled != 0) {
		return libc.UintptrFromInt32(0)
	}
	if env != 0 {
		ret = XFcStrCopy(tls, env)
	} else {
		home = XFcConfigHome(tls)
		if home != 0 {
			v1 = libc.Xstrlen(tls, home)
		} else {
			v1 = uint64(0)
		}
		len1 = v1
		ret = libc.Xmalloc(tls, len1+uint64(13)+uint64(1))
		if ret != 0 {
			if home != 0 {
				libc.X__builtin___memcpy_chk(tls, ret, home, len1, ^t__predefined_size_t(0))
			}
			libc.X__builtin___memcpy_chk(tls, ret+uintptr(len1), __ccgo_ts+1581, uint64(13), ^t__predefined_size_t(0))
			*(*TFcChar8)(unsafe.Pointer(ret + uintptr(len1+uint64(13)))) = uint8(0)
		}
	}
	return ret
}

func XFcConfigXdgDataDirs(tls *libc.TLS) (r uintptr) {
	var e, ee, env, p, ret, s, v1 uintptr
	var len1 Tsize_t
	_, _, _, _, _, _, _, _ = e, ee, env, len1, p, ret, s, v1
	env = libc.Xgetenv(tls, __ccgo_ts+1595)
	ret = XFcStrSetCreate(tls)
	if env != 0 {
		v1 = XFcStrCopy(tls, env)
		ee = v1
		e = v1
		/* We don't intentionally use FC_SEARCH_PATH_SEPARATOR here because of:
		 *   The directories in $XDG_DATA_DIRS should be seperated with a colon ':'.
		 * in doc.
		 */
		for e != 0 {
			p = libc.Xstrchr(tls, e, int32(':'))
			if !(p != 0) {
				s = XFcStrCopy(tls, e)
				e = libc.UintptrFromInt32(0)
			} else {
				*(*TFcChar8)(unsafe.Pointer(p)) = uint8(0)
				s = XFcStrCopy(tls, e)
				e = p + uintptr(1)
			}
			len1 = libc.Xstrlen(tls, s)
			if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s + uintptr(len1-uint64(1))))) == int32('/') {
				for cond := true; cond; cond = len1 > uint64(1) && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s + uintptr(len1-uint64(1))))) == int32('/') {
					len1--
				}
				*(*TFcChar8)(unsafe.Pointer(s + uintptr(len1))) = uint8(0)
			}
			XFcStrSetAdd(tls, ret, s)
			XFcStrFree(tls, s)
		}
		XFcStrFree(tls, ee)
	} else {
		/* From spec doc at https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html#variables
		 *
		 * If $XDG_DATA_DIRS is either not set or empty, a value equal to /usr/local/share/:/usr/share/ should be used.
		 */
		XFcStrSetAdd(tls, ret, __ccgo_ts+1609)
		XFcStrSetAdd(tls, ret, __ccgo_ts+1626)
	}
	return ret
}

func XFcConfigEnableHome(tls *libc.TLS, enable TFcBool) (r TFcBool) {
	var prev TFcBool
	_ = prev
	prev = __FcConfigHomeEnabled
	__FcConfigHomeEnabled = enable
	return prev
}

func XFcConfigGetFilename(tls *libc.TLS, config uintptr, url uintptr) (r uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var dir, file, p, path, s, s1, sysroot uintptr
	var len1 Tsize_t
	_, _, _, _, _, _, _, _ = dir, file, len1, p, path, s, s1, sysroot
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return libc.UintptrFromInt32(0)
	}
	sysroot = XFcConfigGetSysRoot(tls, config)
	if !(url != 0) || !(*(*TFcChar8)(unsafe.Pointer(url)) != 0) {
		url = libc.Xgetenv(tls, __ccgo_ts+1637)
		if !(url != 0) {
			url = __ccgo_ts + 1653
		}
	}
	file = uintptr(0)
	if XFcStrIsAbsoluteFilename(tls, url) != 0 {
		if sysroot != 0 {
			len1 = libc.Xstrlen(tls, sysroot)
			/* Workaround to avoid adding sysroot repeatedly */
			if libc.Xstrncmp(tls, url, sysroot, len1) == 0 {
				sysroot = libc.UintptrFromInt32(0)
			}
		}
		file = _FcConfigFileExists(tls, sysroot, url)
		goto bail
	}
	if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(url))) == int32('~') {
		dir = XFcConfigHome(tls)
		if dir != 0 {
			if sysroot != 0 {
				s = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+8, dir, libc.UintptrFromInt32(0)))
			} else {
				s = dir
			}
			file = _FcConfigFileExists(tls, s, url+uintptr(1))
			if sysroot != 0 {
				XFcStrFree(tls, s)
			}
		} else {
			file = uintptr(0)
		}
	} else {
		path = _FcConfigGetPath(tls)
		if !(path != 0) {
			file = libc.UintptrFromInt32(0)
			goto bail
		}
		p = path
		for {
			if !(*(*uintptr)(unsafe.Pointer(p)) != 0) {
				break
			}
			if sysroot != 0 {
				s1 = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(p)), libc.UintptrFromInt32(0)))
			} else {
				s1 = *(*uintptr)(unsafe.Pointer(p))
			}
			file = _FcConfigFileExists(tls, s1, url)
			if sysroot != 0 {
				XFcStrFree(tls, s1)
			}
			if file != 0 {
				break
			}
			goto _1
		_1:
			;
			p += 8
		}
		_FcConfigFreePath(tls, path)
	}
	goto bail
bail:
	;
	XFcConfigDestroy(tls, config)
	return file
}

func XFcConfigFilename(tls *libc.TLS, url uintptr) (r uintptr) {
	return XFcConfigGetFilename(tls, libc.UintptrFromInt32(0), url)
}

func XFcConfigRealFilename(tls *libc.TLS, config uintptr, url uintptr) (r uintptr) {
	bp := tls.Alloc(1200)
	defer tls.Free(1200)
	var dirname, n, path uintptr
	var len1, v1 Tssize_t
	var _ /* buf at bp+0 */ [1024]TFcChar8
	var _ /* sb at bp+1024 */ Tstat
	_, _, _, _, _ = dirname, len1, n, path, v1
	n = XFcConfigGetFilename(tls, config, url)
	if n != 0 {
		v1 = XFcReadLink(tls, n, bp, libc.Uint64FromInt64(1024)-libc.Uint64FromInt32(1))
		len1 = v1
		if v1 != int64(-int32(1)) {
			(*(*[1024]TFcChar8)(unsafe.Pointer(bp)))[len1] = uint8(0)
			/* We try to pick up a config from FONTCONFIG_FILE
			 * when url is null. don't try to address the real filename
			 * if it is a named pipe.
			 */
			if !(url != 0) && XFcStat(tls, n, bp+1024) == 0 && libc.Int32FromUint16((*(*Tstat)(unsafe.Pointer(bp + 1024))).Fst_mode)&int32(m_S_IFMT1) == int32(m_S_IFIFO1) {
				return n
			} else {
				if !(XFcStrIsAbsoluteFilename(tls, bp) != 0) {
					dirname = XFcStrDirname(tls, n)
					XFcStrFree(tls, n)
					if !(dirname != 0) {
						return libc.UintptrFromInt32(0)
					}
					path = XFcStrBuildFilename(tls, dirname, libc.VaList(bp+1176, bp, libc.UintptrFromInt32(0)))
					XFcStrFree(tls, dirname)
					if !(path != 0) {
						return libc.UintptrFromInt32(0)
					}
					n = XFcStrCanonFilename(tls, path)
					XFcStrFree(tls, path)
				} else {
					XFcStrFree(tls, n)
					n = libc.Xstrdup(tls, bp)
				}
			}
		}
	}
	return n
}

/*
 * Manage the application-specific fonts
 */

func XFcConfigAppFontAddFile(tls *libc.TLS, config uintptr, file uintptr) (r TFcBool) {
	var ret TFcBool
	var set, subdir, subdirs, sublist, v1, v2 uintptr
	_, _, _, _, _, _, _ = ret, set, subdir, subdirs, sublist, v1, v2
	ret = int32(m_FcTrue)
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return m_FcFalse
	}
	subdirs = XFcStrSetCreateEx(tls, uint32(m_FCSS_GROW_BY_64))
	if !(subdirs != 0) {
		ret = m_FcFalse
		goto bail
	}
	set = XFcConfigGetFonts(tls, config, int32(_FcSetApplication))
	if !(set != 0) {
		set = XFcFontSetCreate(tls)
		if !(set != 0) {
			XFcStrSetDestroy(tls, subdirs)
			ret = m_FcFalse
			goto bail
		}
		XFcConfigSetFonts(tls, config, set, int32(_FcSetApplication))
	}
	if !(XFcFileScanConfig(tls, set, subdirs, file, config) != 0) {
		XFcStrSetDestroy(tls, subdirs)
		ret = m_FcFalse
		goto bail
	}
	v1 = XFcStrListCreate(tls, subdirs)
	sublist = v1
	if v1 != 0 {
		for {
			v2 = XFcStrListNext(tls, sublist)
			subdir = v2
			if !(v2 != 0) {
				break
			}
			XFcConfigAppFontAddDir(tls, config, subdir)
		}
		XFcStrListDone(tls, sublist)
	}
	XFcStrSetDestroy(tls, subdirs)
	goto bail
bail:
	;
	XFcConfigDestroy(tls, config)
	return ret
}

func XFcConfigAppFontAddDir(tls *libc.TLS, config uintptr, dir uintptr) (r TFcBool) {
	var dirs, set uintptr
	var ret TFcBool
	_, _, _ = dirs, ret, set
	ret = int32(m_FcTrue)
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return m_FcFalse
	}
	dirs = XFcStrSetCreateEx(tls, uint32(m_FCSS_GROW_BY_64))
	if !(dirs != 0) {
		ret = m_FcFalse
		goto bail
	}
	set = XFcConfigGetFonts(tls, config, int32(_FcSetApplication))
	if !(set != 0) {
		set = XFcFontSetCreate(tls)
		if !(set != 0) {
			XFcStrSetDestroy(tls, dirs)
			ret = m_FcFalse
			goto bail
		}
		XFcConfigSetFonts(tls, config, set, int32(_FcSetApplication))
	}
	XFcStrSetAddFilename(tls, dirs, dir)
	if !(_FcConfigAddDirList(tls, config, int32(_FcSetApplication), dirs) != 0) {
		XFcStrSetDestroy(tls, dirs)
		ret = m_FcFalse
		goto bail
	}
	XFcStrSetDestroy(tls, dirs)
	goto bail
bail:
	;
	XFcConfigDestroy(tls, config)
	return ret
}

func XFcConfigAppFontClear(tls *libc.TLS, config uintptr) {
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return
	}
	XFcConfigSetFonts(tls, config, uintptr(0), int32(_FcSetApplication))
	XFcConfigDestroy(tls, config)
}

/*
 * Manage filename-based font source selectors
 */

func XFcConfigGlobAdd(tls *libc.TLS, config uintptr, glob uintptr, accept TFcBool) (r TFcBool) {
	var set, v1 uintptr
	_, _ = set, v1
	if accept != 0 {
		v1 = (*TFcConfig)(unsafe.Pointer(config)).FacceptGlobs
	} else {
		v1 = (*TFcConfig)(unsafe.Pointer(config)).FrejectGlobs
	}
	set = v1
	return XFcStrSetAdd(tls, set, glob)
}

func _FcConfigGlobsMatch(tls *libc.TLS, globs uintptr, string1 uintptr) (r TFcBool) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < (*TFcStrSet)(unsafe.Pointer(globs)).Fnum) {
			break
		}
		if XFcStrGlobMatch(tls, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(globs)).Fstrs + uintptr(i)*8)), string1) != 0 {
			return int32(m_FcTrue)
		}
		goto _1
	_1:
		;
		i++
	}
	return m_FcFalse
}

func XFcConfigAcceptFilename(tls *libc.TLS, config uintptr, filename uintptr) (r TFcBool) {
	if _FcConfigGlobsMatch(tls, (*TFcConfig)(unsafe.Pointer(config)).FacceptGlobs, filename) != 0 {
		return int32(m_FcTrue)
	}
	if _FcConfigGlobsMatch(tls, (*TFcConfig)(unsafe.Pointer(config)).FrejectGlobs, filename) != 0 {
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

/*
 * Manage font-pattern based font source selectors
 */

func XFcConfigPatternsAdd(tls *libc.TLS, config uintptr, pattern uintptr, accept TFcBool) (r TFcBool) {
	var set, v1 uintptr
	_, _ = set, v1
	if accept != 0 {
		v1 = (*TFcConfig)(unsafe.Pointer(config)).FacceptPatterns
	} else {
		v1 = (*TFcConfig)(unsafe.Pointer(config)).FrejectPatterns
	}
	set = v1
	return XFcFontSetAdd(tls, set, pattern)
}

func _FcConfigPatternsMatch(tls *libc.TLS, patterns uintptr, font uintptr) (r TFcBool) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < (*TFcFontSet)(unsafe.Pointer(patterns)).Fnfont) {
			break
		}
		if XFcListPatternMatchAny(tls, *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(patterns)).Ffonts + uintptr(i)*8)), font) != 0 {
			return int32(m_FcTrue)
		}
		goto _1
	_1:
		;
		i++
	}
	return m_FcFalse
}

func XFcConfigAcceptFont(tls *libc.TLS, config uintptr, font uintptr) (r TFcBool) {
	if _FcConfigPatternsMatch(tls, (*TFcConfig)(unsafe.Pointer(config)).FacceptPatterns, font) != 0 {
		return int32(m_FcTrue)
	}
	if _FcConfigPatternsMatch(tls, (*TFcConfig)(unsafe.Pointer(config)).FrejectPatterns, font) != 0 {
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

func XFcConfigGetSysRoot(tls *libc.TLS, config uintptr) (r uintptr) {
	if !(config != 0) {
		config = XFcConfigGetCurrent(tls)
		if !(config != 0) {
			return libc.UintptrFromInt32(0)
		}
	}
	return (*TFcConfig)(unsafe.Pointer(config)).FsysRoot
}

func XFcConfigSetSysRoot(tls *libc.TLS, config uintptr, sysroot uintptr) {
	var init1 TFcBool
	var nretry, v1 int32
	var s uintptr
	_, _, _, _ = init1, nretry, s, v1
	s = libc.UintptrFromInt32(0)
	init1 = m_FcFalse
	nretry = int32(3)
	goto retry
retry:
	;
	if !(config != 0) {
		/* We can't use FcConfigGetCurrent() here to ensure
		 * the sysroot is set prior to initialize FcConfig,
		 * to avoid loading caches from non-sysroot dirs.
		 * So postpone the initialization later.
		 */
		config = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&__fcConfig))))
		if !(config != 0) {
			config = XFcConfigCreate(tls)
			if !(config != 0) {
				return
			}
			init1 = int32(m_FcTrue)
		}
	}
	if sysroot != 0 {
		s = XFcStrRealPath(tls, sysroot)
		if !(s != 0) {
			return
		}
	}
	if (*TFcConfig)(unsafe.Pointer(config)).FsysRoot != 0 {
		XFcStrFree(tls, (*TFcConfig)(unsafe.Pointer(config)).FsysRoot)
	}
	(*TFcConfig)(unsafe.Pointer(config)).FsysRoot = s
	if init1 != 0 {
		config = XFcInitLoadOwnConfigAndFonts(tls, config)
		if !(config != 0) {
			/* Something failed. this is usually unlikely. so retrying */
			init1 = m_FcFalse
			nretry--
			v1 = nretry
			if v1 == 0 {
				libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+1664, 0)
				return
			}
			goto retry
		}
		XFcConfigSetCurrent(tls, config)
		/* FcConfigSetCurrent() increases the refcount.
		 * decrease it here to avoid the memory leak.
		 */
		XFcConfigDestroy(tls, config)
	}
}

func XFcRuleSetCreate(tls *libc.TLS, name uintptr) (r uintptr) {
	var k TFcMatchKind
	var p, ret uintptr
	_, _, _ = k, p, ret
	ret = libc.Xmalloc(tls, uint64(64))
	if !(name != 0) {
		p = __ccgo_ts + 110
	} else {
		p = name
	}
	if ret != 0 {
		(*TFcRuleSet)(unsafe.Pointer(ret)).Fname = libc.Xstrdup(tls, p)
		(*TFcRuleSet)(unsafe.Pointer(ret)).Fdescription = libc.UintptrFromInt32(0)
		(*TFcRuleSet)(unsafe.Pointer(ret)).Fdomain = libc.UintptrFromInt32(0)
		k = int32(_FcMatchKindBegin)
		for {
			if !(k < int32(_FcMatchKindEnd)) {
				break
			}
			*(*uintptr)(unsafe.Pointer(ret + 40 + uintptr(k)*8)) = XFcPtrListCreate(tls, __ccgo_fp(_FcDestroyAsRule))
			goto _1
		_1:
			;
			k++
		}
		(*TFcRef)(unsafe.Pointer(ret)).Fcount = int32(1)
	}
	return ret
}

func XFcRuleSetDestroy(tls *libc.TLS, rs uintptr) {
	var k TFcMatchKind
	var v1 int32
	var p3 uintptr
	_, _, _ = k, v1, p3
	if !(rs != 0) {
		return
	}
	p3 = rs
	*(*Tfc_atomic_int_t)(unsafe.Pointer(p3)) += -int32(1)
	v1 = *(*Tfc_atomic_int_t)(unsafe.Pointer(p3)) - -int32(1)
	goto _2
_2:
	if v1 != int32(1) {
		return
	}
	if (*TFcRuleSet)(unsafe.Pointer(rs)).Fname != 0 {
		XFcStrFree(tls, (*TFcRuleSet)(unsafe.Pointer(rs)).Fname)
	}
	if (*TFcRuleSet)(unsafe.Pointer(rs)).Fdescription != 0 {
		XFcStrFree(tls, (*TFcRuleSet)(unsafe.Pointer(rs)).Fdescription)
	}
	if (*TFcRuleSet)(unsafe.Pointer(rs)).Fdomain != 0 {
		XFcStrFree(tls, (*TFcRuleSet)(unsafe.Pointer(rs)).Fdomain)
	}
	k = int32(_FcMatchKindBegin)
	for {
		if !(k < int32(_FcMatchKindEnd)) {
			break
		}
		XFcPtrListDestroy(tls, *(*uintptr)(unsafe.Pointer(rs + 40 + uintptr(k)*8)))
		goto _4
	_4:
		;
		k++
	}
	libc.Xfree(tls, rs)
}

func XFcRuleSetReference(tls *libc.TLS, rs uintptr) {
	var v1 TFcBool
	var p4 uintptr
	_, _ = v1, p4
	v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(rs)).Fcount == -libc.Int32FromInt32(1))
	goto _2
_2:
	if !(v1 != 0) {
		p4 = rs
		*(*Tfc_atomic_int_t)(unsafe.Pointer(p4)) += +libc.Int32FromInt32(1)
		_ = *(*Tfc_atomic_int_t)(unsafe.Pointer(p4)) - +libc.Int32FromInt32(1)
		goto _3
	_3:
	}
}

func XFcRuleSetEnable(tls *libc.TLS, rs uintptr, flag TFcBool) {
	if rs != 0 {
		(*TFcRuleSet)(unsafe.Pointer(rs)).Fenabled = flag
		/* XXX: we may want to provide a feature
		 * to enable/disable rulesets through API
		 * in the future?
		 */
	}
}

func XFcRuleSetAddDescription(tls *libc.TLS, rs uintptr, domain uintptr, description uintptr) {
	var v1, v2 uintptr
	_, _ = v1, v2
	if (*TFcRuleSet)(unsafe.Pointer(rs)).Fdomain != 0 {
		XFcStrFree(tls, (*TFcRuleSet)(unsafe.Pointer(rs)).Fdomain)
	}
	if (*TFcRuleSet)(unsafe.Pointer(rs)).Fdescription != 0 {
		XFcStrFree(tls, (*TFcRuleSet)(unsafe.Pointer(rs)).Fdescription)
	}
	if domain != 0 {
		v1 = libc.Xstrdup(tls, domain)
	} else {
		v1 = libc.UintptrFromInt32(0)
	}
	(*TFcRuleSet)(unsafe.Pointer(rs)).Fdomain = v1
	if description != 0 {
		v2 = libc.Xstrdup(tls, description)
	} else {
		v2 = libc.UintptrFromInt32(0)
	}
	(*TFcRuleSet)(unsafe.Pointer(rs)).Fdescription = v2
}

func XFcRuleSetAdd(tls *libc.TLS, rs uintptr, rule uintptr, kind TFcMatchKind) (r1 int32) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var n, ret, v2 int32
	var r uintptr
	var _ /* iter at bp+0 */ TFcPtrListIter
	_, _, _, _ = n, r, ret, v2
	n = 0
	if !(rs != 0) || kind < int32(_FcMatchKindBegin) || kind >= int32(_FcMatchKindEnd) {
		return -int32(1)
	}
	XFcPtrListIterInitAtLast(tls, *(*uintptr)(unsafe.Pointer(rs + 40 + uintptr(kind)*8)), bp)
	if !(XFcPtrListIterAdd(tls, *(*uintptr)(unsafe.Pointer(rs + 40 + uintptr(kind)*8)), bp, rule) != 0) {
		return -int32(1)
	}
	r = rule
	for {
		if !(r != 0) {
			break
		}
		switch (*TFcRule)(unsafe.Pointer(r)).Ftype1 {
		case int32(_FcRuleTest):
			if *(*uintptr)(unsafe.Pointer(r + 16)) != 0 {
				if (*TFcTest)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fkind == -libc.Int32FromInt32(1) {
					(*TFcTest)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fkind = kind
				}
				if n < (*TFcTest)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject {
					n = (*TFcTest)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject
				}
			}
		case int32(_FcRuleEdit):
			if n < (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject {
				n = (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(r + 16)))).Fobject
			}
		default:
			break
		}
		goto _1
	_1:
		;
		r = (*TFcRule)(unsafe.Pointer(r)).Fnext
	}
	if XFcDebugVal&int32(m_FC_DBG_EDIT) != 0 {
		libc.Xprintf(tls, __ccgo_ts+1787, libc.VaList(bp+32, kind, (*TFcRuleSet)(unsafe.Pointer(rs)).Fname))
		XFcRulePrint(tls, rule)
	}
	ret = n & ^libc.Int32FromInt32(m_FC_EXT_OBJ_INDEX) - (int32(_FC_ONE_AFTER_MAX_BASE_OBJECT) - libc.Int32FromInt32(1))
	if ret < 0 {
		v2 = 0
	} else {
		v2 = ret
	}
	return v2
}

func XFcConfigFileInfoIterInit(tls *libc.TLS, config uintptr, iter uintptr) {
	var c, i uintptr
	_, _ = c, i
	i = iter
	if !(config != 0) {
		c = XFcConfigGetCurrent(tls)
	} else {
		c = config
	}
	XFcPtrListIterInit(tls, (*TFcConfig)(unsafe.Pointer(c)).FrulesetList, i)
}

func XFcConfigFileInfoIterNext(tls *libc.TLS, config uintptr, iter uintptr) (r TFcBool) {
	var c, i uintptr
	_, _ = c, i
	i = iter
	if !(config != 0) {
		c = XFcConfigGetCurrent(tls)
	} else {
		c = config
	}
	if XFcPtrListIterIsValid(tls, (*TFcConfig)(unsafe.Pointer(c)).FrulesetList, i) != 0 {
		XFcPtrListIterNext(tls, (*TFcConfig)(unsafe.Pointer(c)).FrulesetList, i)
	} else {
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

func XFcConfigFileInfoIterGet(tls *libc.TLS, config uintptr, iter uintptr, name uintptr, description uintptr, enabled uintptr) (r1 TFcBool) {
	var c, i, r, v1, v2 uintptr
	_, _, _, _, _ = c, i, r, v1, v2
	i = iter
	if !(config != 0) {
		c = XFcConfigGetCurrent(tls)
	} else {
		c = config
	}
	if !(XFcPtrListIterIsValid(tls, (*TFcConfig)(unsafe.Pointer(c)).FrulesetList, i) != 0) {
		return m_FcFalse
	}
	r = XFcPtrListIterGetValue(tls, (*TFcConfig)(unsafe.Pointer(c)).FrulesetList, i)
	if name != 0 {
		if (*TFcRuleSet)(unsafe.Pointer(r)).Fname != 0 && *(*TFcChar8)(unsafe.Pointer((*TFcRuleSet)(unsafe.Pointer(r)).Fname)) != 0 {
			v1 = (*TFcRuleSet)(unsafe.Pointer(r)).Fname
		} else {
			v1 = __ccgo_ts + 1653
		}
		*(*uintptr)(unsafe.Pointer(name)) = libc.Xstrdup(tls, v1)
	}
	if description != 0 {
		if !((*TFcRuleSet)(unsafe.Pointer(r)).Fdescription != 0) {
			v2 = __ccgo_ts + 1816
		} else {
			v2 = (*TFcRuleSet)(unsafe.Pointer(r)).Fdescription
		}
		*(*uintptr)(unsafe.Pointer(description)) = libc.Xstrdup(tls, v2)
	}
	if enabled != 0 {
		*(*TFcBool)(unsafe.Pointer(enabled)) = (*TFcRuleSet)(unsafe.Pointer(r)).Fenabled
	}
	return int32(m_FcTrue)
}

const m_FC_CHAR_LEAF_HASH_SIZE = 257
const m_FC_CHAR_SET_HASH_SIZE = 67
const m_FC_DIR_SEPARATOR2 = '/'
const m_FC_DIR_SEPARATOR_S2 = "/"
const m_FC_SEARCH_PATH_SEPARATOR2 = ':'
const m_S_IFIFO2 = 0010000
const m_S_IFMT2 = 0170000

type TFcCharSetFreezer = struct {
	Fleaf_hash_table    [257]uintptr
	Fleaf_blocks        uintptr
	Fleaf_block_count   int32
	Fset_hash_table     [67]uintptr
	Forig_hash_table    [67]uintptr
	Fcurrent_block      uintptr
	Fleaf_remain        int32
	Fleaves_seen        int32
	Fcharsets_seen      int32
	Fleaves_allocated   int32
	Fcharsets_allocated int32
}

type T_FcCharSetFreezer = TFcCharSetFreezer

/*
 * Copyright (c) 2000, 2002 - 2008, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/* #define CHECK */

func XFcCharSetCreate(tls *libc.TLS) (r uintptr) {
	var fcs uintptr
	_ = fcs
	fcs = libc.Xmalloc(tls, uint64(24))
	if !(fcs != 0) {
		return uintptr(0)
	}
	(*TFcRef)(unsafe.Pointer(fcs)).Fcount = int32(1)
	(*TFcCharSet)(unsafe.Pointer(fcs)).Fnum = 0
	(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset = 0
	(*TFcCharSet)(unsafe.Pointer(fcs)).Fnumbers_offset = 0
	return fcs
}

func XFcCharSetPromote(tls *libc.TLS, vbuf uintptr) (r uintptr) {
	var fcs uintptr
	_ = fcs
	fcs = vbuf
	(*TFcRef)(unsafe.Pointer(fcs)).Fcount = -libc.Int32FromInt32(1)
	(*TFcCharSet)(unsafe.Pointer(fcs)).Fnum = 0
	(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset = 0
	(*TFcCharSet)(unsafe.Pointer(fcs)).Fnumbers_offset = 0
	return fcs
}

func XFcCharSetNew(tls *libc.TLS) (r uintptr) {
	return XFcCharSetCreate(tls)
}

func XFcCharSetDestroy(tls *libc.TLS, fcs uintptr) {
	var i, v3 int32
	var v1 TFcBool
	var p5 uintptr
	_, _, _, _ = i, v1, v3, p5
	if fcs != 0 {
		v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(fcs)).Fcount == -libc.Int32FromInt32(1))
		goto _2
	_2:
		if v1 != 0 {
			XFcCacheObjectDereference(tls, fcs)
			return
		}
		p5 = fcs
		*(*Tfc_atomic_int_t)(unsafe.Pointer(p5)) += -int32(1)
		v3 = *(*Tfc_atomic_int_t)(unsafe.Pointer(p5)) - -int32(1)
		goto _4
	_4:
		if v3 != int32(1) {
			return
		}
		i = 0
		for {
			if !(i < (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum) {
				break
			}
			libc.Xfree(tls, uintptr(int64(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset))+*(*Tintptr_t)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset) + uintptr(i)*8))))
			goto _6
		_6:
			;
			i++
		}
		if (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum != 0 {
			libc.Xfree(tls, uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset))
			libc.Xfree(tls, uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fnumbers_offset))
		}
		libc.Xfree(tls, fcs)
	}
}

/*
 * Search for the leaf containing with the specified num.
 * Return its index if it exists, otherwise return negative of
 * the (position + 1) where it should be inserted
 */

func _FcCharSetFindLeafForward(tls *libc.TLS, fcs uintptr, start int32, num TFcChar16) (r int32) {
	var high, low, mid int32
	var numbers uintptr
	var page TFcChar16
	_, _, _, _, _ = high, low, mid, numbers, page
	numbers = uintptr(int64(fcs) + (*TFcCharSet)(unsafe.Pointer(fcs)).Fnumbers_offset)
	low = start
	high = (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum - int32(1)
	if !(numbers != 0) {
		return -int32(1)
	}
	for low <= high {
		mid = (low + high) >> int32(1)
		page = *(*TFcChar16)(unsafe.Pointer(numbers + uintptr(mid)*2))
		if libc.Int32FromUint16(page) == libc.Int32FromUint16(num) {
			return mid
		}
		if libc.Int32FromUint16(page) < libc.Int32FromUint16(num) {
			low = mid + int32(1)
		} else {
			high = mid - int32(1)
		}
	}
	if high < 0 || high < (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum && libc.Int32FromUint16(*(*TFcChar16)(unsafe.Pointer(numbers + uintptr(high)*2))) < libc.Int32FromUint16(num) {
		high++
	}
	return -(high + int32(1))
}

/*
 * Locate the leaf containing the specified char, return
 * its index if it exists, otherwise return negative of
 * the (position + 1) where it should be inserted
 */

func _FcCharSetFindLeafPos(tls *libc.TLS, fcs uintptr, ucs4 TFcChar32) (r int32) {
	return _FcCharSetFindLeafForward(tls, fcs, 0, uint16(ucs4>>int32(8)))
}

func _FcCharSetFindLeaf(tls *libc.TLS, fcs uintptr, ucs4 TFcChar32) (r uintptr) {
	var pos int32
	_ = pos
	pos = _FcCharSetFindLeafPos(tls, fcs, ucs4)
	if pos >= 0 {
		return uintptr(int64(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset)) + *(*Tintptr_t)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset) + uintptr(pos)*8)))
	}
	return uintptr(0)
}

func _FcCharSetPutLeaf(tls *libc.TLS, fcs uintptr, ucs4 TFcChar32, leaf uintptr, pos int32) (r TFcBool) {
	var alloced, alloced1 uint32
	var distance Tptrdiff_t
	var i int32
	var leaves, new_leaves, numbers uintptr
	_, _, _, _, _, _, _ = alloced, alloced1, distance, i, leaves, new_leaves, numbers
	leaves = uintptr(int64(fcs) + (*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset)
	numbers = uintptr(int64(fcs) + (*TFcCharSet)(unsafe.Pointer(fcs)).Fnumbers_offset)
	ucs4 >>= uint32(8)
	if ucs4 >= uint32(0x10000) {
		return m_FcFalse
	}
	if !((*TFcCharSet)(unsafe.Pointer(fcs)).Fnum&((*TFcCharSet)(unsafe.Pointer(fcs)).Fnum-libc.Int32FromInt32(1)) != 0) {
		if !((*TFcCharSet)(unsafe.Pointer(fcs)).Fnum != 0) {
			alloced = uint32(8)
			leaves = libc.Xmalloc(tls, uint64(alloced)*uint64(8))
			numbers = libc.Xmalloc(tls, uint64(alloced)*uint64(2))
			if !(leaves != 0) || !(numbers != 0) {
				if leaves != 0 {
					libc.Xfree(tls, leaves)
				}
				if numbers != 0 {
					libc.Xfree(tls, numbers)
				}
				return m_FcFalse
			}
		} else {
			alloced1 = libc.Uint32FromInt32((*TFcCharSet)(unsafe.Pointer(fcs)).Fnum)
			alloced1 *= uint32(2)
			numbers = libc.Xrealloc(tls, numbers, uint64(alloced1)*uint64(2))
			if !(numbers != 0) {
				return m_FcFalse
			}
			new_leaves = libc.Xrealloc(tls, leaves, uint64(alloced1)*uint64(8))
			if !(new_leaves != 0) {
				/*
				 * Revert the reallocation of numbers. We update numbers_offset
				 * first in case realloc() fails.
				 */
				(*TFcCharSet)(unsafe.Pointer(fcs)).Fnumbers_offset = int64(numbers) - int64(fcs)
				numbers = libc.Xrealloc(tls, numbers, uint64(alloced1/libc.Uint32FromInt32(2))*uint64(2))
				/* unlikely to fail though */
				if !(numbers != 0) {
					return m_FcFalse
				}
				(*TFcCharSet)(unsafe.Pointer(fcs)).Fnumbers_offset = int64(numbers) - int64(fcs)
				return m_FcFalse
			}
			distance = int64(new_leaves) - int64(leaves)
			i = 0
			for {
				if !(i < (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum) {
					break
				}
				*(*Tintptr_t)(unsafe.Pointer(new_leaves + uintptr(i)*8)) -= distance
				goto _1
			_1:
				;
				i++
			}
			leaves = new_leaves
		}
		(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset = int64(leaves) - int64(fcs)
		(*TFcCharSet)(unsafe.Pointer(fcs)).Fnumbers_offset = int64(numbers) - int64(fcs)
	}
	libc.X__builtin___memmove_chk(tls, leaves+uintptr(pos)*8+uintptr(1)*8, leaves+uintptr(pos)*8, libc.Uint64FromInt32((*TFcCharSet)(unsafe.Pointer(fcs)).Fnum-pos)*uint64(8), ^t__predefined_size_t(0))
	libc.X__builtin___memmove_chk(tls, numbers+uintptr(pos)*2+uintptr(1)*2, numbers+uintptr(pos)*2, libc.Uint64FromInt32((*TFcCharSet)(unsafe.Pointer(fcs)).Fnum-pos)*uint64(2), ^t__predefined_size_t(0))
	*(*TFcChar16)(unsafe.Pointer(numbers + uintptr(pos)*2)) = uint16(ucs4)
	*(*Tintptr_t)(unsafe.Pointer(leaves + uintptr(pos)*8)) = int64(leaf) - int64(leaves)
	(*TFcCharSet)(unsafe.Pointer(fcs)).Fnum++
	return int32(m_FcTrue)
}

/*
 * Locate the leaf containing the specified char, creating it
 * if desired
 */

func XFcCharSetFindLeafCreate(tls *libc.TLS, fcs uintptr, ucs4 TFcChar32) (r uintptr) {
	var leaf uintptr
	var pos int32
	_, _ = leaf, pos
	pos = _FcCharSetFindLeafPos(tls, fcs, ucs4)
	if pos >= 0 {
		return uintptr(int64(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset)) + *(*Tintptr_t)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset) + uintptr(pos)*8)))
	}
	leaf = libc.Xcalloc(tls, uint64(1), uint64(32))
	if !(leaf != 0) {
		return uintptr(0)
	}
	pos = -pos - int32(1)
	if !(_FcCharSetPutLeaf(tls, fcs, ucs4, leaf, pos) != 0) {
		libc.Xfree(tls, leaf)
		return uintptr(0)
	}
	return leaf
}

func _FcCharSetInsertLeaf(tls *libc.TLS, fcs uintptr, ucs4 TFcChar32, leaf uintptr) (r TFcBool) {
	var pos int32
	_ = pos
	pos = _FcCharSetFindLeafPos(tls, fcs, ucs4)
	if pos >= 0 {
		libc.Xfree(tls, uintptr(int64(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset))+*(*Tintptr_t)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset) + uintptr(pos)*8))))
		*(*Tintptr_t)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset) + uintptr(pos)*8)) = int64(leaf) - int64(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset))
		return int32(m_FcTrue)
	}
	pos = -pos - int32(1)
	return _FcCharSetPutLeaf(tls, fcs, ucs4, leaf, pos)
}

func XFcCharSetAddChar(tls *libc.TLS, fcs uintptr, ucs4 TFcChar32) (r TFcBool) {
	var b, leaf uintptr
	var v1 TFcBool
	var v3 bool
	_, _, _, _ = b, leaf, v1, v3
	if v3 = fcs == libc.UintptrFromInt32(0); !v3 {
		v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(fcs)).Fcount == -libc.Int32FromInt32(1))
		goto _2
	_2:
	}
	if v3 || v1 != 0 {
		return m_FcFalse
	}
	leaf = XFcCharSetFindLeafCreate(tls, fcs, ucs4)
	if !(leaf != 0) {
		return m_FcFalse
	}
	b = leaf + uintptr(ucs4&uint32(0xff)>>int32(5))*4
	*(*TFcChar32)(unsafe.Pointer(b)) |= uint32(1) << (ucs4 & uint32(0x1f))
	return int32(m_FcTrue)
}

func XFcCharSetDelChar(tls *libc.TLS, fcs uintptr, ucs4 TFcChar32) (r TFcBool) {
	var b, leaf uintptr
	var v1 TFcBool
	var v3 bool
	_, _, _, _ = b, leaf, v1, v3
	if v3 = fcs == libc.UintptrFromInt32(0); !v3 {
		v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(fcs)).Fcount == -libc.Int32FromInt32(1))
		goto _2
	_2:
	}
	if v3 || v1 != 0 {
		return m_FcFalse
	}
	leaf = _FcCharSetFindLeaf(tls, fcs, ucs4)
	if !(leaf != 0) {
		return int32(m_FcTrue)
	}
	b = leaf + uintptr(ucs4&uint32(0xff)>>int32(5))*4
	*(*TFcChar32)(unsafe.Pointer(b)) &= ^(libc.Uint32FromUint32(1) << (ucs4 & libc.Uint32FromInt32(0x1f)))
	/* We don't bother removing the leaf if it's empty */
	return int32(m_FcTrue)
}

/*
 * An iterator for the leaves of a charset
 */

type TFcCharSetIter = struct {
	Fleaf uintptr
	Fucs4 TFcChar32
	Fpos  int32
}

/*
 * An iterator for the leaves of a charset
 */

type T_fcCharSetIter = TFcCharSetIter

/*
 * Set iter->leaf to the leaf containing iter->ucs4 or higher
 */

func _FcCharSetIterSet(tls *libc.TLS, fcs uintptr, iter uintptr) {
	var pos int32
	_ = pos
	pos = _FcCharSetFindLeafPos(tls, fcs, (*TFcCharSetIter)(unsafe.Pointer(iter)).Fucs4)
	if pos < 0 {
		pos = -pos - int32(1)
		if pos == (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum {
			(*TFcCharSetIter)(unsafe.Pointer(iter)).Fucs4 = libc.Uint32FromInt32(^libc.Int32FromInt32(0))
			(*TFcCharSetIter)(unsafe.Pointer(iter)).Fleaf = uintptr(0)
			return
		}
		(*TFcCharSetIter)(unsafe.Pointer(iter)).Fucs4 = uint32(*(*TFcChar16)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fnumbers_offset) + uintptr(pos)*2))) << int32(8)
	}
	(*TFcCharSetIter)(unsafe.Pointer(iter)).Fleaf = uintptr(int64(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset)) + *(*Tintptr_t)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset) + uintptr(pos)*8)))
	(*TFcCharSetIter)(unsafe.Pointer(iter)).Fpos = pos
}

func _FcCharSetIterNext(tls *libc.TLS, fcs uintptr, iter uintptr) {
	var pos int32
	_ = pos
	pos = (*TFcCharSetIter)(unsafe.Pointer(iter)).Fpos + int32(1)
	if pos >= (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum {
		(*TFcCharSetIter)(unsafe.Pointer(iter)).Fucs4 = libc.Uint32FromInt32(^libc.Int32FromInt32(0))
		(*TFcCharSetIter)(unsafe.Pointer(iter)).Fleaf = uintptr(0)
	} else {
		(*TFcCharSetIter)(unsafe.Pointer(iter)).Fucs4 = uint32(*(*TFcChar16)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fnumbers_offset) + uintptr(pos)*2))) << int32(8)
		(*TFcCharSetIter)(unsafe.Pointer(iter)).Fleaf = uintptr(int64(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset)) + *(*Tintptr_t)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset) + uintptr(pos)*8)))
		(*TFcCharSetIter)(unsafe.Pointer(iter)).Fpos = pos
	}
}

func _FcCharSetIterStart(tls *libc.TLS, fcs uintptr, iter uintptr) {
	(*TFcCharSetIter)(unsafe.Pointer(iter)).Fucs4 = uint32(0)
	(*TFcCharSetIter)(unsafe.Pointer(iter)).Fpos = 0
	_FcCharSetIterSet(tls, fcs, iter)
}

func XFcCharSetCopy(tls *libc.TLS, src uintptr) (r uintptr) {
	var v1 TFcBool
	var p4 uintptr
	_, _ = v1, p4
	if src != 0 {
		v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(src)).Fcount == -libc.Int32FromInt32(1))
		goto _2
	_2:
		if !(v1 != 0) {
			p4 = src
			*(*Tfc_atomic_int_t)(unsafe.Pointer(p4)) += +libc.Int32FromInt32(1)
			_ = *(*Tfc_atomic_int_t)(unsafe.Pointer(p4)) - +libc.Int32FromInt32(1)
			goto _3
		_3:
		} else {
			XFcCacheObjectReference(tls, src)
		}
	}
	return src
}

func XFcCharSetEqual(tls *libc.TLS, a uintptr, b uintptr) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var i int32
	var _ /* ai at bp+0 */ TFcCharSetIter
	var _ /* bi at bp+16 */ TFcCharSetIter
	_ = i
	if a == b {
		return int32(m_FcTrue)
	}
	if !(a != 0) || !(b != 0) {
		return m_FcFalse
	}
	_FcCharSetIterStart(tls, a, bp)
	_FcCharSetIterStart(tls, b, bp+16)
	for {
		if !((*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf != 0 && (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fleaf != 0) {
			break
		}
		if (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4 != (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fucs4 {
			return m_FcFalse
		}
		i = 0
		for {
			if !(i < libc.Int32FromInt32(256)/libc.Int32FromInt32(32)) {
				break
			}
			if *(*TFcChar32)(unsafe.Pointer((*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf + uintptr(i)*4)) != *(*TFcChar32)(unsafe.Pointer((*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fleaf + uintptr(i)*4)) {
				return m_FcFalse
			}
			goto _2
		_2:
			;
			i++
		}
		goto _1
	_1:
		;
		_FcCharSetIterNext(tls, a, bp)
		_FcCharSetIterNext(tls, b, bp+16)
	}
	return libc.BoolInt32((*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf == (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fleaf)
}

func _FcCharSetAddLeaf(tls *libc.TLS, fcs uintptr, ucs4 TFcChar32, leaf uintptr) (r TFcBool) {
	var new1 uintptr
	_ = new1
	new1 = XFcCharSetFindLeafCreate(tls, fcs, ucs4)
	if !(new1 != 0) {
		return m_FcFalse
	}
	*(*TFcCharLeaf)(unsafe.Pointer(new1)) = *(*TFcCharLeaf)(unsafe.Pointer(leaf))
	return int32(m_FcTrue)
}

func _FcCharSetOperate(tls *libc.TLS, a uintptr, b uintptr, __ccgo_fp_overlap uintptr, aonly TFcBool, bonly TFcBool) (r uintptr) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var fcs uintptr
	var _ /* ai at bp+0 */ TFcCharSetIter
	var _ /* bi at bp+16 */ TFcCharSetIter
	var _ /* leaf at bp+32 */ TFcCharLeaf
	_ = fcs
	if !(a != 0) || !(b != 0) {
		goto bail0
	}
	fcs = XFcCharSetCreate(tls)
	if !(fcs != 0) {
		goto bail0
	}
	_FcCharSetIterStart(tls, a, bp)
	_FcCharSetIterStart(tls, b, bp+16)
	for ((*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf != 0 || bonly != 0 && (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fleaf != 0) && ((*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fleaf != 0 || aonly != 0 && (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf != 0) {
		if (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4 < (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fucs4 {
			if aonly != 0 {
				if !(_FcCharSetAddLeaf(tls, fcs, (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4, (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf) != 0) {
					goto bail1
				}
				_FcCharSetIterNext(tls, a, bp)
			} else {
				(*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4 = (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fucs4
				_FcCharSetIterSet(tls, a, bp)
			}
		} else {
			if (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fucs4 < (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4 {
				if bonly != 0 {
					if !(_FcCharSetAddLeaf(tls, fcs, (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fucs4, (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fleaf) != 0) {
						goto bail1
					}
					_FcCharSetIterNext(tls, b, bp+16)
				} else {
					(*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fucs4 = (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4
					_FcCharSetIterSet(tls, b, bp+16)
				}
			} else {
				if (*(*func(*libc.TLS, uintptr, uintptr, uintptr) TFcBool)(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_overlap})))(tls, bp+32, (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf, (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fleaf) != 0 {
					if !(_FcCharSetAddLeaf(tls, fcs, (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4, bp+32) != 0) {
						goto bail1
					}
				}
				_FcCharSetIterNext(tls, a, bp)
				_FcCharSetIterNext(tls, b, bp+16)
			}
		}
	}
	return fcs
	goto bail1
bail1:
	;
	XFcCharSetDestroy(tls, fcs)
	goto bail0
bail0:
	;
	return uintptr(0)
	return r
}

func _FcCharSetIntersectLeaf(tls *libc.TLS, result uintptr, al uintptr, bl uintptr) (r TFcBool) {
	var i int32
	var nonempty TFcBool
	var v2 TFcChar32
	_, _, _ = i, nonempty, v2
	nonempty = m_FcFalse
	i = 0
	for {
		if !(i < libc.Int32FromInt32(256)/libc.Int32FromInt32(32)) {
			break
		}
		v2 = *(*TFcChar32)(unsafe.Pointer(al + uintptr(i)*4)) & *(*TFcChar32)(unsafe.Pointer(bl + uintptr(i)*4))
		*(*TFcChar32)(unsafe.Pointer(result + uintptr(i)*4)) = v2
		if v2 != 0 {
			nonempty = int32(m_FcTrue)
		}
		goto _1
	_1:
		;
		i++
	}
	return nonempty
}

func XFcCharSetIntersect(tls *libc.TLS, a uintptr, b uintptr) (r uintptr) {
	return _FcCharSetOperate(tls, a, b, __ccgo_fp(_FcCharSetIntersectLeaf), m_FcFalse, m_FcFalse)
}

func _FcCharSetUnionLeaf(tls *libc.TLS, result uintptr, al uintptr, bl uintptr) (r TFcBool) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < libc.Int32FromInt32(256)/libc.Int32FromInt32(32)) {
			break
		}
		*(*TFcChar32)(unsafe.Pointer(result + uintptr(i)*4)) = *(*TFcChar32)(unsafe.Pointer(al + uintptr(i)*4)) | *(*TFcChar32)(unsafe.Pointer(bl + uintptr(i)*4))
		goto _1
	_1:
		;
		i++
	}
	return int32(m_FcTrue)
}

func XFcCharSetUnion(tls *libc.TLS, a uintptr, b uintptr) (r uintptr) {
	return _FcCharSetOperate(tls, a, b, __ccgo_fp(_FcCharSetUnionLeaf), int32(m_FcTrue), int32(m_FcTrue))
}

func XFcCharSetMerge(tls *libc.TLS, a uintptr, b uintptr, changed uintptr) (r TFcBool) {
	var ai, bi, v3 int32
	var al, bl uintptr
	var an, bn TFcChar16
	var v1 TFcBool
	_, _, _, _, _, _, _, _ = ai, al, an, bi, bl, bn, v1, v3
	ai = 0
	bi = 0
	if !(a != 0) || !(b != 0) {
		return m_FcFalse
	}
	v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(a)).Fcount == -libc.Int32FromInt32(1))
	goto _2
_2:
	if v1 != 0 {
		if changed != 0 {
			*(*TFcBool)(unsafe.Pointer(changed)) = m_FcFalse
		}
		return m_FcFalse
	}
	if changed != 0 {
		*(*TFcBool)(unsafe.Pointer(changed)) = libc.BoolInt32(!(XFcCharSetIsSubset(tls, b, a) != 0))
		if !(*(*TFcBool)(unsafe.Pointer(changed)) != 0) {
			return int32(m_FcTrue)
		}
	}
	for bi < (*TFcCharSet)(unsafe.Pointer(b)).Fnum {
		if ai < (*TFcCharSet)(unsafe.Pointer(a)).Fnum {
			v3 = libc.Int32FromUint16(*(*TFcChar16)(unsafe.Pointer(uintptr(int64(a)+(*TFcCharSet)(unsafe.Pointer(a)).Fnumbers_offset) + uintptr(ai)*2)))
		} else {
			v3 = ^libc.Int32FromInt32(0)
		}
		an = libc.Uint16FromInt32(v3)
		bn = *(*TFcChar16)(unsafe.Pointer(uintptr(int64(b)+(*TFcCharSet)(unsafe.Pointer(b)).Fnumbers_offset) + uintptr(bi)*2))
		if libc.Int32FromUint16(an) < libc.Int32FromUint16(bn) {
			ai = _FcCharSetFindLeafForward(tls, a, ai+int32(1), bn)
			if ai < 0 {
				ai = -ai - int32(1)
			}
		} else {
			bl = uintptr(int64(uintptr(int64(b)+(*TFcCharSet)(unsafe.Pointer(b)).Fleaves_offset)) + *(*Tintptr_t)(unsafe.Pointer(uintptr(int64(b)+(*TFcCharSet)(unsafe.Pointer(b)).Fleaves_offset) + uintptr(bi)*8)))
			if libc.Int32FromUint16(bn) < libc.Int32FromUint16(an) {
				if !(_FcCharSetAddLeaf(tls, a, libc.Uint32FromInt32(libc.Int32FromUint16(bn)<<int32(8)), bl) != 0) {
					return m_FcFalse
				}
			} else {
				al = uintptr(int64(uintptr(int64(a)+(*TFcCharSet)(unsafe.Pointer(a)).Fleaves_offset)) + *(*Tintptr_t)(unsafe.Pointer(uintptr(int64(a)+(*TFcCharSet)(unsafe.Pointer(a)).Fleaves_offset) + uintptr(ai)*8)))
				_FcCharSetUnionLeaf(tls, al, al, bl)
			}
			ai++
			bi++
		}
	}
	return int32(m_FcTrue)
}

func _FcCharSetSubtractLeaf(tls *libc.TLS, result uintptr, al uintptr, bl uintptr) (r TFcBool) {
	var i int32
	var nonempty TFcBool
	var v2 TFcChar32
	_, _, _ = i, nonempty, v2
	nonempty = m_FcFalse
	i = 0
	for {
		if !(i < libc.Int32FromInt32(256)/libc.Int32FromInt32(32)) {
			break
		}
		v2 = *(*TFcChar32)(unsafe.Pointer(al + uintptr(i)*4)) & ^*(*TFcChar32)(unsafe.Pointer(bl + uintptr(i)*4))
		*(*TFcChar32)(unsafe.Pointer(result + uintptr(i)*4)) = v2
		if v2 != 0 {
			nonempty = int32(m_FcTrue)
		}
		goto _1
	_1:
		;
		i++
	}
	return nonempty
}

func XFcCharSetSubtract(tls *libc.TLS, a uintptr, b uintptr) (r uintptr) {
	return _FcCharSetOperate(tls, a, b, __ccgo_fp(_FcCharSetSubtractLeaf), int32(m_FcTrue), m_FcFalse)
}

func XFcCharSetHasChar(tls *libc.TLS, fcs uintptr, ucs4 TFcChar32) (r TFcBool) {
	var leaf uintptr
	_ = leaf
	if !(fcs != 0) {
		return m_FcFalse
	}
	leaf = _FcCharSetFindLeaf(tls, fcs, ucs4)
	if !(leaf != 0) {
		return m_FcFalse
	}
	return libc.BoolInt32(*(*TFcChar32)(unsafe.Pointer(leaf + uintptr(ucs4&uint32(0xff)>>int32(5))*4))&(uint32(1)<<(ucs4&uint32(0x1f))) != uint32(0))
}

func _FcCharSetPopCount(tls *libc.TLS, c1 TFcChar32) (r TFcChar32) {
	return libc.Uint32FromInt32(libc.X__builtin_popcount(tls, c1))
}

func XFcCharSetIntersectCount(tls *libc.TLS, a uintptr, b uintptr) (r TFcChar32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var am, bm, v2, v3 uintptr
	var count TFcChar32
	var i, v1 int32
	var _ /* ai at bp+0 */ TFcCharSetIter
	var _ /* bi at bp+16 */ TFcCharSetIter
	_, _, _, _, _, _, _ = am, bm, count, i, v1, v2, v3
	count = uint32(0)
	if a != 0 && b != 0 {
		_FcCharSetIterStart(tls, a, bp)
		_FcCharSetIterStart(tls, b, bp+16)
		for (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf != 0 && (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fleaf != 0 {
			if (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4 == (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fucs4 {
				am = (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf
				bm = (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fleaf
				i = libc.Int32FromInt32(256) / libc.Int32FromInt32(32)
				for {
					v1 = i
					i--
					if !(v1 != 0) {
						break
					}
					v2 = am
					am += 4
					v3 = bm
					bm += 4
					count += _FcCharSetPopCount(tls, *(*TFcChar32)(unsafe.Pointer(v2))&*(*TFcChar32)(unsafe.Pointer(v3)))
				}
				_FcCharSetIterNext(tls, a, bp)
			} else {
				if (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4 < (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fucs4 {
					(*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4 = (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fucs4
					_FcCharSetIterSet(tls, a, bp)
				}
			}
			if (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fucs4 < (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4 {
				(*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fucs4 = (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4
				_FcCharSetIterSet(tls, b, bp+16)
			}
		}
	}
	return count
}

func XFcCharSetCount(tls *libc.TLS, a uintptr) (r TFcChar32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var am, v3 uintptr
	var count TFcChar32
	var i, v2 int32
	var _ /* ai at bp+0 */ TFcCharSetIter
	_, _, _, _, _ = am, count, i, v2, v3
	count = uint32(0)
	if a != 0 {
		_FcCharSetIterStart(tls, a, bp)
		for {
			if !((*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf != 0) {
				break
			}
			i = libc.Int32FromInt32(256) / libc.Int32FromInt32(32)
			am = (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf
			for {
				v2 = i
				i--
				if !(v2 != 0) {
					break
				}
				v3 = am
				am += 4
				count += _FcCharSetPopCount(tls, *(*TFcChar32)(unsafe.Pointer(v3)))
			}
			goto _1
		_1:
			;
			_FcCharSetIterNext(tls, a, bp)
		}
	}
	return count
}

func XFcCharSetSubtractCount(tls *libc.TLS, a uintptr, b uintptr) (r TFcChar32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var am, bm, v2, v3, v5 uintptr
	var count TFcChar32
	var i, v1, v4 int32
	var _ /* ai at bp+0 */ TFcCharSetIter
	var _ /* bi at bp+16 */ TFcCharSetIter
	_, _, _, _, _, _, _, _, _ = am, bm, count, i, v1, v2, v3, v4, v5
	count = uint32(0)
	if a != 0 && b != 0 {
		_FcCharSetIterStart(tls, a, bp)
		_FcCharSetIterStart(tls, b, bp+16)
		for (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf != 0 {
			if (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4 <= (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fucs4 {
				am = (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf
				i = libc.Int32FromInt32(256) / libc.Int32FromInt32(32)
				if (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4 == (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fucs4 {
					bm = (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fleaf
					for {
						v1 = i
						i--
						if !(v1 != 0) {
							break
						}
						v2 = am
						am += 4
						v3 = bm
						bm += 4
						count += _FcCharSetPopCount(tls, *(*TFcChar32)(unsafe.Pointer(v2)) & ^*(*TFcChar32)(unsafe.Pointer(v3)))
					}
				} else {
					for {
						v4 = i
						i--
						if !(v4 != 0) {
							break
						}
						v5 = am
						am += 4
						count += _FcCharSetPopCount(tls, *(*TFcChar32)(unsafe.Pointer(v5)))
					}
				}
				_FcCharSetIterNext(tls, a, bp)
			} else {
				if (*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fleaf != 0 {
					(*(*TFcCharSetIter)(unsafe.Pointer(bp + 16))).Fucs4 = (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4
					_FcCharSetIterSet(tls, b, bp+16)
				}
			}
		}
	}
	return count
}

// C documentation
//
//	/*
//	 * return FcTrue iff a is a subset of b
//	 */
func XFcCharSetIsSubset(tls *libc.TLS, a uintptr, b uintptr) (r TFcBool) {
	var ai, bi, i, v1 int32
	var am, bm, v2, v3 uintptr
	var an, bn TFcChar16
	_, _, _, _, _, _, _, _, _, _ = ai, am, an, bi, bm, bn, i, v1, v2, v3
	if a == b {
		return int32(m_FcTrue)
	}
	if !(a != 0) || !(b != 0) {
		return m_FcFalse
	}
	bi = 0
	ai = 0
	for ai < (*TFcCharSet)(unsafe.Pointer(a)).Fnum && bi < (*TFcCharSet)(unsafe.Pointer(b)).Fnum {
		an = *(*TFcChar16)(unsafe.Pointer(uintptr(int64(a)+(*TFcCharSet)(unsafe.Pointer(a)).Fnumbers_offset) + uintptr(ai)*2))
		bn = *(*TFcChar16)(unsafe.Pointer(uintptr(int64(b)+(*TFcCharSet)(unsafe.Pointer(b)).Fnumbers_offset) + uintptr(bi)*2))
		/*
		 * Check matching pages
		 */
		if libc.Int32FromUint16(an) == libc.Int32FromUint16(bn) {
			am = uintptr(int64(uintptr(int64(a)+(*TFcCharSet)(unsafe.Pointer(a)).Fleaves_offset)) + *(*Tintptr_t)(unsafe.Pointer(uintptr(int64(a)+(*TFcCharSet)(unsafe.Pointer(a)).Fleaves_offset) + uintptr(ai)*8)))
			bm = uintptr(int64(uintptr(int64(b)+(*TFcCharSet)(unsafe.Pointer(b)).Fleaves_offset)) + *(*Tintptr_t)(unsafe.Pointer(uintptr(int64(b)+(*TFcCharSet)(unsafe.Pointer(b)).Fleaves_offset) + uintptr(bi)*8)))
			if am != bm {
				i = libc.Int32FromInt32(256) / libc.Int32FromInt32(32)
				/*
				 * Does am have any bits not in bm?
				 */
				for {
					v1 = i
					i--
					if !(v1 != 0) {
						break
					}
					v2 = am
					am += 4
					v3 = bm
					bm += 4
					if *(*TFcChar32)(unsafe.Pointer(v2)) & ^*(*TFcChar32)(unsafe.Pointer(v3)) != 0 {
						return m_FcFalse
					}
				}
			}
			ai++
			bi++
		} else {
			if libc.Int32FromUint16(an) < libc.Int32FromUint16(bn) {
				return m_FcFalse
			} else {
				bi = _FcCharSetFindLeafForward(tls, b, bi+int32(1), an)
				if bi < 0 {
					bi = -bi - int32(1)
				}
			}
		}
	}
	/*
	 * did we look at every page?
	 */
	return libc.BoolInt32(ai >= (*TFcCharSet)(unsafe.Pointer(a)).Fnum)
}

/*
 * These two functions efficiently walk the entire charmap for
 * other software (like pango) that want their own copy
 */

func XFcCharSetNextPage(tls *libc.TLS, a uintptr, map1 uintptr, next uintptr) (r TFcChar32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var page TFcChar32
	var _ /* ai at bp+0 */ TFcCharSetIter
	_ = page
	if !(a != 0) {
		return libc.Uint32FromInt32(-libc.Int32FromInt32(1))
	}
	(*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4 = *(*TFcChar32)(unsafe.Pointer(next))
	_FcCharSetIterSet(tls, a, bp)
	if !((*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf != 0) {
		return libc.Uint32FromInt32(-libc.Int32FromInt32(1))
	}
	/*
	 * Save current information
	 */
	page = (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4
	libc.X__builtin___memcpy_chk(tls, map1, (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf, uint64(32), ^t__predefined_size_t(0))
	/*
	 * Step to next page
	 */
	_FcCharSetIterNext(tls, a, bp)
	*(*TFcChar32)(unsafe.Pointer(next)) = (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4
	return page
}

func XFcCharSetFirstPage(tls *libc.TLS, a uintptr, map1 uintptr, next uintptr) (r TFcChar32) {
	*(*TFcChar32)(unsafe.Pointer(next)) = uint32(0)
	return XFcCharSetNextPage(tls, a, map1, next)
}

/*
 * old coverage API, rather hard to use correctly
 */

func XFcCharSetCoverage(tls *libc.TLS, a uintptr, page TFcChar32, result uintptr) (r TFcChar32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* ai at bp+0 */ TFcCharSetIter
	(*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4 = page
	_FcCharSetIterSet(tls, a, bp)
	if !((*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf != 0) {
		libc.X__builtin___memset_chk(tls, result, int32('\000'), libc.Uint64FromInt32(libc.Int32FromInt32(256)/libc.Int32FromInt32(8)), ^t__predefined_size_t(0))
		page = uint32(0)
	} else {
		libc.X__builtin___memcpy_chk(tls, result, (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf, uint64(32), ^t__predefined_size_t(0))
		_FcCharSetIterNext(tls, a, bp)
		page = (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4
	}
	return page
}

func _FcNameParseRange(tls *libc.TLS, string1 uintptr, pfirst uintptr, plast uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var first, last, v10 int64
	var t uintptr
	var v1, v11, v15, v17, v18, v5, v7, v8 int32
	var v13, v3 t__darwin_ct_rune_t
	var v14, v4 uint64
	var _ /* s at bp+0 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = first, last, t, v1, v10, v11, v13, v14, v15, v17, v18, v3, v4, v5, v7, v8
	*(*uintptr)(unsafe.Pointer(bp)) = *(*uintptr)(unsafe.Pointer(string1))
	for {
		v3 = libc.Int32FromUint8(libc.Uint8FromInt8(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))))
		v4 = uint64(0x00004000)
		v8 = libc.BoolInt32(v3 & ^libc.Int32FromInt32(0x7F) == 0)
		goto _9
	_9:
		if v8 != 0 {
			v7 = libc.BoolInt32(!!(uint64(*(*t__uint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&libc.X_DefaultRuneLocale)) + 60 + uintptr(v3)*4)))&v4 != 0))
		} else {
			v7 = libc.BoolInt32(!!(libc.X__maskrune(tls, v3, v4) != 0))
		}
		v5 = v7
		goto _6
	_6:
		v1 = v5
		goto _2
	_2:
		if !(v1 != 0) {
			break
		}
		*(*uintptr)(unsafe.Pointer(bp))++
	}
	t = *(*uintptr)(unsafe.Pointer(bp))
	*(*int32)(unsafe.Pointer(libc.X__error(tls))) = 0
	v10 = libc.Xstrtol(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, int32(16))
	last = v10
	first = v10
	if *(*int32)(unsafe.Pointer(libc.X__error(tls))) != 0 {
		return m_FcFalse
	}
	for {
		v13 = libc.Int32FromUint8(libc.Uint8FromInt8(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))))
		v14 = uint64(0x00004000)
		v18 = libc.BoolInt32(v13 & ^libc.Int32FromInt32(0x7F) == 0)
		goto _19
	_19:
		if v18 != 0 {
			v17 = libc.BoolInt32(!!(uint64(*(*t__uint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&libc.X_DefaultRuneLocale)) + 60 + uintptr(v13)*4)))&v14 != 0))
		} else {
			v17 = libc.BoolInt32(!!(libc.X__maskrune(tls, v13, v14) != 0))
		}
		v15 = v17
		goto _16
	_16:
		v11 = v15
		goto _12
	_12:
		if !(v11 != 0) {
			break
		}
		*(*uintptr)(unsafe.Pointer(bp))++
	}
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32('-') {
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*int32)(unsafe.Pointer(libc.X__error(tls))) = 0
		last = libc.Xstrtol(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, int32(16))
		if *(*int32)(unsafe.Pointer(libc.X__error(tls))) != 0 {
			return m_FcFalse
		}
	}
	if *(*uintptr)(unsafe.Pointer(bp)) == t || first < 0 || last < 0 || last < first || last > int64(0x10ffff) {
		return m_FcFalse
	}
	*(*uintptr)(unsafe.Pointer(string1)) = *(*uintptr)(unsafe.Pointer(bp))
	*(*TFcChar32)(unsafe.Pointer(pfirst)) = libc.Uint32FromInt64(first)
	*(*TFcChar32)(unsafe.Pointer(plast)) = libc.Uint32FromInt64(last)
	return int32(m_FcTrue)
}

func XFcNameParseCharSet(tls *libc.TLS, _string uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp)) = _string
	var c uintptr
	var u TFcChar32
	var _ /* first at bp+8 */ TFcChar32
	var _ /* last at bp+12 */ TFcChar32
	_, _ = c, u
	c = XFcCharSetCreate(tls)
	if !(c != 0) {
		goto bail0
	}
	for *(*TFcChar8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0 {
		if !(_FcNameParseRange(tls, bp, bp+8, bp+12) != 0) {
			goto bail1
		}
		u = *(*TFcChar32)(unsafe.Pointer(bp + 8))
		for {
			if !(u < *(*TFcChar32)(unsafe.Pointer(bp + 12))+uint32(1)) {
				break
			}
			XFcCharSetAddChar(tls, c, u)
			goto _1
		_1:
			;
			u++
		}
	}
	return c
	goto bail1
bail1:
	;
	XFcCharSetDestroy(tls, c)
	goto bail0
bail0:
	;
	return libc.UintptrFromInt32(0)
	return r
}

func _FcNameUnparseUnicode(tls *libc.TLS, buf uintptr, u TFcChar32) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var _ /* buf_static at bp+0 */ [64]TFcChar8
	libc.X__builtin___snprintf_chk(tls, bp, uint64(64), 0, ^t__predefined_size_t(0), __ccgo_ts+1831, libc.VaList(bp+72, u))
	XFcStrBufString(tls, buf, bp)
}

func XFcNameUnparseCharSet(tls *libc.TLS, buf uintptr, c uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var bits, first, last, u, v1 TFcChar32
	var i int32
	var _ /* ci at bp+0 */ TFcCharSetIter
	_, _, _, _, _, _ = bits, first, i, last, u, v1
	v1 = libc.Uint32FromInt32(0x7FFFFFFF)
	last = v1
	first = v1
	_FcCharSetIterStart(tls, c, bp)
	for {
		if !((*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf != 0) {
			break
		}
		i = 0
		for {
			if !(i < libc.Int32FromInt32(256)/libc.Int32FromInt32(32)) {
				break
			}
			bits = *(*TFcChar32)(unsafe.Pointer((*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fleaf + uintptr(i)*4))
			u = (*(*TFcCharSetIter)(unsafe.Pointer(bp))).Fucs4 + libc.Uint32FromInt32(i*int32(32))
			for bits != 0 {
				if bits&uint32(1) != 0 {
					if u != last+uint32(1) {
						if last != first {
							XFcStrBufChar(tls, buf, uint8('-'))
							_FcNameUnparseUnicode(tls, buf, last)
						}
						if last != uint32(0x7FFFFFFF) {
							XFcStrBufChar(tls, buf, uint8(' '))
						}
						/* Start new range. */
						first = u
						_FcNameUnparseUnicode(tls, buf, u)
					}
					last = u
				}
				bits >>= uint32(1)
				u++
			}
			goto _3
		_3:
			;
			i++
		}
		goto _2
	_2:
		;
		_FcCharSetIterNext(tls, c, bp)
	}
	if last != first {
		XFcStrBufChar(tls, buf, uint8('-'))
		_FcNameUnparseUnicode(tls, buf, last)
	}
	return int32(m_FcTrue)
}

type TFcCharLeafEnt = struct {
	Fnext uintptr
	Fhash TFcChar32
	Fleaf TFcCharLeaf
}

type T_FcCharLeafEnt = TFcCharLeafEnt

type TFcCharSetEnt = struct {
	Fnext uintptr
	Fhash TFcChar32
	Fset  TFcCharSet
}

type T_FcCharSetEnt = TFcCharSetEnt

type TFcCharSetOrigEnt = struct {
	Fnext   uintptr
	Forig   uintptr
	Ffrozen uintptr
}

type T_FcCharSetOrigEnt = TFcCharSetOrigEnt

func _FcCharLeafEntCreate(tls *libc.TLS, freezer uintptr) (r uintptr) {
	var newBlocks, v1, v2, v3 uintptr
	_, _, _, _ = newBlocks, v1, v2, v3
	if !((*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaf_remain != 0) {
		(*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaf_block_count++
		newBlocks = libc.Xrealloc(tls, (*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaf_blocks, libc.Uint64FromInt32((*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaf_block_count)*uint64(8))
		if !(newBlocks != 0) {
			return uintptr(0)
		}
		(*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaf_blocks = newBlocks
		v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(4096)/libc.Uint64FromInt64(48)*libc.Uint64FromInt64(48))
		*(*uintptr)(unsafe.Pointer((*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaf_blocks + uintptr((*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaf_block_count-int32(1))*8)) = v1
		(*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fcurrent_block = v1
		if !((*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fcurrent_block != 0) {
			return uintptr(0)
		}
		(*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaf_remain = libc.Int32FromUint64(libc.Uint64FromInt32(4096) / libc.Uint64FromInt64(48))
	}
	(*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaf_remain--
	(*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaves_allocated++
	v3 = freezer + 3144
	v2 = *(*uintptr)(unsafe.Pointer(v3))
	*(*uintptr)(unsafe.Pointer(v3)) += 48
	return v2
}

func _FcCharLeafHash(tls *libc.TLS, leaf uintptr) (r TFcChar32) {
	var hash TFcChar32
	var i int32
	_, _ = hash, i
	hash = uint32(0)
	i = 0
	for {
		if !(i < libc.Int32FromInt32(256)/libc.Int32FromInt32(32)) {
			break
		}
		hash = hash<<libc.Int32FromInt32(1) | hash>>libc.Int32FromInt32(31) ^ *(*TFcChar32)(unsafe.Pointer(leaf + uintptr(i)*4))
		goto _1
	_1:
		;
		i++
	}
	return hash
}

func _FcCharSetFreezeLeaf(tls *libc.TLS, freezer uintptr, leaf uintptr) (r uintptr) {
	var bucket, ent uintptr
	var hash TFcChar32
	_, _, _ = bucket, ent, hash
	hash = _FcCharLeafHash(tls, leaf)
	bucket = freezer + uintptr(hash%uint32(m_FC_CHAR_LEAF_HASH_SIZE))*8
	ent = *(*uintptr)(unsafe.Pointer(bucket))
	for {
		if !(ent != 0) {
			break
		}
		if (*TFcCharLeafEnt)(unsafe.Pointer(ent)).Fhash == hash && !(libc.Xmemcmp(tls, ent+12, leaf, uint64(32)) != 0) {
			return ent + 12
		}
		goto _1
	_1:
		;
		ent = (*TFcCharLeafEnt)(unsafe.Pointer(ent)).Fnext
	}
	ent = _FcCharLeafEntCreate(tls, freezer)
	if !(ent != 0) {
		return uintptr(0)
	}
	(*TFcCharLeafEnt)(unsafe.Pointer(ent)).Fleaf = *(*TFcCharLeaf)(unsafe.Pointer(leaf))
	(*TFcCharLeafEnt)(unsafe.Pointer(ent)).Fhash = hash
	(*TFcCharLeafEnt)(unsafe.Pointer(ent)).Fnext = *(*uintptr)(unsafe.Pointer(bucket))
	*(*uintptr)(unsafe.Pointer(bucket)) = ent
	return ent + 12
}

func _FcCharSetHash(tls *libc.TLS, fcs uintptr) (r TFcChar32) {
	var hash TFcChar32
	var i int32
	_, _ = hash, i
	hash = uint32(0)
	/* hash in leaves */
	i = 0
	for {
		if !(i < (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum) {
			break
		}
		hash = hash<<libc.Int32FromInt32(1) | hash>>libc.Int32FromInt32(31) ^ _FcCharLeafHash(tls, uintptr(int64(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset))+*(*Tintptr_t)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset) + uintptr(i)*8))))
		goto _1
	_1:
		;
		i++
	}
	/* hash in numbers */
	i = 0
	for {
		if !(i < (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum) {
			break
		}
		hash = hash<<libc.Int32FromInt32(1) | hash>>libc.Int32FromInt32(31) ^ uint32(*(*TFcChar16)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fnumbers_offset) + uintptr(i)*2)))
		goto _2
	_2:
		;
		i++
	}
	return hash
}

func _FcCharSetFreezeOrig(tls *libc.TLS, freezer uintptr, orig uintptr, frozen uintptr) (r TFcBool) {
	var bucket, ent uintptr
	_, _ = bucket, ent
	bucket = freezer + 2608 + uintptr(uint64(orig)%uint64(m_FC_CHAR_SET_HASH_SIZE))*8
	ent = libc.Xmalloc(tls, uint64(24))
	if !(ent != 0) {
		return m_FcFalse
	}
	(*TFcCharSetOrigEnt)(unsafe.Pointer(ent)).Forig = orig
	(*TFcCharSetOrigEnt)(unsafe.Pointer(ent)).Ffrozen = frozen
	(*TFcCharSetOrigEnt)(unsafe.Pointer(ent)).Fnext = *(*uintptr)(unsafe.Pointer(bucket))
	*(*uintptr)(unsafe.Pointer(bucket)) = ent
	return int32(m_FcTrue)
}

func _FcCharSetFreezeBase(tls *libc.TLS, freezer uintptr, fcs uintptr) (r uintptr) {
	var bucket, ent, ent_leaves uintptr
	var hash TFcChar32
	var i, i1, size int32
	var ok TFcBool
	_, _, _, _, _, _, _, _ = bucket, ent, ent_leaves, hash, i, i1, ok, size
	hash = _FcCharSetHash(tls, fcs)
	bucket = freezer + 2072 + uintptr(hash%uint32(m_FC_CHAR_SET_HASH_SIZE))*8
	ent = *(*uintptr)(unsafe.Pointer(bucket))
	for {
		if !(ent != 0) {
			break
		}
		if (*TFcCharSetEnt)(unsafe.Pointer(ent)).Fhash == hash && (*TFcCharSetEnt)(unsafe.Pointer(ent)).Fset.Fnum == (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum && !(libc.Xmemcmp(tls, uintptr(Tintptr_t(ent+16)+(*TFcCharSet)(unsafe.Pointer(ent+16)).Fnumbers_offset), uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fnumbers_offset), libc.Uint64FromInt32((*TFcCharSet)(unsafe.Pointer(fcs)).Fnum)*uint64(2)) != 0) {
			ok = int32(m_FcTrue)
			i1 = 0
			for {
				if !(i1 < (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum) {
					break
				}
				if uintptr(int64(uintptr(Tintptr_t(ent+16)+(*TFcCharSet)(unsafe.Pointer(ent+16)).Fleaves_offset))+*(*Tintptr_t)(unsafe.Pointer(uintptr(Tintptr_t(ent+16)+(*TFcCharSet)(unsafe.Pointer(ent+16)).Fleaves_offset) + uintptr(i1)*8))) != uintptr(int64(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset))+*(*Tintptr_t)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset) + uintptr(i1)*8))) {
					ok = m_FcFalse
				}
				goto _2
			_2:
				;
				i1++
			}
			if ok != 0 {
				return ent + 16
			}
		}
		goto _1
	_1:
		;
		ent = (*TFcCharSetEnt)(unsafe.Pointer(ent)).Fnext
	}
	size = libc.Int32FromUint64(libc.Uint64FromInt64(40) + libc.Uint64FromInt32((*TFcCharSet)(unsafe.Pointer(fcs)).Fnum)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32((*TFcCharSet)(unsafe.Pointer(fcs)).Fnum)*libc.Uint64FromInt64(2))
	ent = libc.Xmalloc(tls, libc.Uint64FromInt32(size))
	if !(ent != 0) {
		return uintptr(0)
	}
	(*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fcharsets_allocated++
	(*TFcRef)(unsafe.Pointer(ent + 16)).Fcount = -libc.Int32FromInt32(1)
	(*TFcCharSetEnt)(unsafe.Pointer(ent)).Fset.Fnum = (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum
	if (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum != 0 {
		(*TFcCharSetEnt)(unsafe.Pointer(ent)).Fset.Fleaves_offset = int64(24)
		(*TFcCharSetEnt)(unsafe.Pointer(ent)).Fset.Fnumbers_offset = libc.Int64FromUint64(libc.Uint64FromInt64((*TFcCharSetEnt)(unsafe.Pointer(ent)).Fset.Fleaves_offset) + libc.Uint64FromInt32((*TFcCharSet)(unsafe.Pointer(fcs)).Fnum)*libc.Uint64FromInt64(8))
		ent_leaves = uintptr(Tintptr_t(ent+16) + (*TFcCharSet)(unsafe.Pointer(ent+16)).Fleaves_offset)
		i = 0
		for {
			if !(i < (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum) {
				break
			}
			*(*Tintptr_t)(unsafe.Pointer(ent_leaves + uintptr(i)*8)) = int64(uintptr(int64(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset))+*(*Tintptr_t)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset) + uintptr(i)*8)))) - int64(ent_leaves)
			goto _3
		_3:
			;
			i++
		}
		libc.X__builtin___memcpy_chk(tls, uintptr(Tintptr_t(ent+16)+(*TFcCharSet)(unsafe.Pointer(ent+16)).Fnumbers_offset), uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fnumbers_offset), libc.Uint64FromInt32((*TFcCharSet)(unsafe.Pointer(fcs)).Fnum)*uint64(2), ^t__predefined_size_t(0))
	} else {
		(*TFcCharSetEnt)(unsafe.Pointer(ent)).Fset.Fleaves_offset = 0
		(*TFcCharSetEnt)(unsafe.Pointer(ent)).Fset.Fnumbers_offset = 0
	}
	(*TFcCharSetEnt)(unsafe.Pointer(ent)).Fhash = hash
	(*TFcCharSetEnt)(unsafe.Pointer(ent)).Fnext = *(*uintptr)(unsafe.Pointer(bucket))
	*(*uintptr)(unsafe.Pointer(bucket)) = ent
	return ent + 16
}

func _FcCharSetFindFrozen(tls *libc.TLS, freezer uintptr, orig uintptr) (r uintptr) {
	var bucket, ent uintptr
	_, _ = bucket, ent
	bucket = freezer + 2608 + uintptr(uint64(orig)%uint64(m_FC_CHAR_SET_HASH_SIZE))*8
	ent = *(*uintptr)(unsafe.Pointer(bucket))
	for {
		if !(ent != 0) {
			break
		}
		if (*TFcCharSetOrigEnt)(unsafe.Pointer(ent)).Forig == orig {
			return (*TFcCharSetOrigEnt)(unsafe.Pointer(ent)).Ffrozen
		}
		goto _1
	_1:
		;
		ent = (*TFcCharSetOrigEnt)(unsafe.Pointer(ent)).Fnext
	}
	return libc.UintptrFromInt32(0)
}

func XFcCharSetFreeze(tls *libc.TLS, freezer uintptr, fcs uintptr) (r uintptr) {
	var b, l, n uintptr
	var i int32
	_, _, _, _ = b, i, l, n
	n = uintptr(0)
	b = XFcCharSetCreate(tls)
	if !(b != 0) {
		goto bail0
	}
	i = 0
	for {
		if !(i < (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum) {
			break
		}
		l = _FcCharSetFreezeLeaf(tls, freezer, uintptr(int64(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset))+*(*Tintptr_t)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fleaves_offset) + uintptr(i)*8))))
		if !(l != 0) {
			goto bail1
		}
		if !(_FcCharSetInsertLeaf(tls, b, libc.Uint32FromInt32(libc.Int32FromUint16(*(*TFcChar16)(unsafe.Pointer(uintptr(int64(fcs)+(*TFcCharSet)(unsafe.Pointer(fcs)).Fnumbers_offset) + uintptr(i)*2)))<<int32(8)), l) != 0) {
			goto bail1
		}
		goto _1
	_1:
		;
		i++
	}
	n = _FcCharSetFreezeBase(tls, freezer, b)
	if !(_FcCharSetFreezeOrig(tls, freezer, fcs, n) != 0) {
		n = libc.UintptrFromInt32(0)
		goto bail1
	}
	(*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fcharsets_seen++
	*(*int32)(unsafe.Pointer(freezer + 3156)) += (*TFcCharSet)(unsafe.Pointer(fcs)).Fnum
	goto bail1
bail1:
	;
	if (*TFcCharSet)(unsafe.Pointer(b)).Fnum != 0 {
		libc.Xfree(tls, uintptr(int64(b)+(*TFcCharSet)(unsafe.Pointer(b)).Fleaves_offset))
	}
	if (*TFcCharSet)(unsafe.Pointer(b)).Fnum != 0 {
		libc.Xfree(tls, uintptr(int64(b)+(*TFcCharSet)(unsafe.Pointer(b)).Fnumbers_offset))
	}
	libc.Xfree(tls, b)
	goto bail0
bail0:
	;
	return n
	return r
}

func XFcCharSetFreezerCreate(tls *libc.TLS) (r uintptr) {
	var freezer uintptr
	_ = freezer
	freezer = libc.Xcalloc(tls, uint64(1), uint64(3176))
	return freezer
}

func XFcCharSetFreezerDestroy(tls *libc.TLS, freezer uintptr) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var ent, ent1, next, next1 uintptr
	var i int32
	_, _, _, _, _ = ent, ent1, i, next, next1
	if XFcDebugVal&int32(m_FC_DBG_CACHE) != 0 {
		libc.Xprintf(tls, __ccgo_ts+1834, libc.VaList(bp+8, (*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fcharsets_seen, (*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fcharsets_allocated, (*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaves_seen, (*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaves_allocated))
	}
	i = 0
	for {
		if !(i < int32(m_FC_CHAR_SET_HASH_SIZE)) {
			break
		}
		ent = *(*uintptr)(unsafe.Pointer(freezer + 2072 + uintptr(i)*8))
		for {
			if !(ent != 0) {
				break
			}
			next = (*TFcCharSetEnt)(unsafe.Pointer(ent)).Fnext
			libc.Xfree(tls, ent)
			goto _2
		_2:
			;
			ent = next
		}
		goto _1
	_1:
		;
		i++
	}
	i = 0
	for {
		if !(i < int32(m_FC_CHAR_SET_HASH_SIZE)) {
			break
		}
		ent1 = *(*uintptr)(unsafe.Pointer(freezer + 2608 + uintptr(i)*8))
		for {
			if !(ent1 != 0) {
				break
			}
			next1 = (*TFcCharSetOrigEnt)(unsafe.Pointer(ent1)).Fnext
			libc.Xfree(tls, ent1)
			goto _4
		_4:
			;
			ent1 = next1
		}
		goto _3
	_3:
		;
		i++
	}
	i = 0
	for {
		if !(i < (*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaf_block_count) {
			break
		}
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer((*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaf_blocks + uintptr(i)*8)))
		goto _5
	_5:
		;
		i++
	}
	libc.Xfree(tls, (*TFcCharSetFreezer)(unsafe.Pointer(freezer)).Fleaf_blocks)
	libc.Xfree(tls, freezer)
}

func XFcCharSetSerializeAlloc(tls *libc.TLS, serialize uintptr, cs uintptr) (r TFcBool) {
	var i int32
	var leaves, numbers uintptr
	var v1 TFcBool
	_, _, _, _ = i, leaves, numbers, v1
	v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(cs)).Fcount == -libc.Int32FromInt32(1))
	goto _2
_2:
	if !(v1 != 0) {
		if !((*TFcSerialize)(unsafe.Pointer(serialize)).Fcs_freezer != 0) {
			(*TFcSerialize)(unsafe.Pointer(serialize)).Fcs_freezer = XFcCharSetFreezerCreate(tls)
			if !((*TFcSerialize)(unsafe.Pointer(serialize)).Fcs_freezer != 0) {
				return m_FcFalse
			}
		}
		if _FcCharSetFindFrozen(tls, (*TFcSerialize)(unsafe.Pointer(serialize)).Fcs_freezer, cs) != 0 {
			return int32(m_FcTrue)
		}
		cs = XFcCharSetFreeze(tls, (*TFcSerialize)(unsafe.Pointer(serialize)).Fcs_freezer, cs)
	}
	leaves = uintptr(int64(cs) + (*TFcCharSet)(unsafe.Pointer(cs)).Fleaves_offset)
	numbers = uintptr(int64(cs) + (*TFcCharSet)(unsafe.Pointer(cs)).Fnumbers_offset)
	if !(XFcSerializeAlloc(tls, serialize, cs, int32(24)) != 0) {
		return m_FcFalse
	}
	if !(XFcSerializeAlloc(tls, serialize, leaves, libc.Int32FromUint64(libc.Uint64FromInt32((*TFcCharSet)(unsafe.Pointer(cs)).Fnum)*uint64(8))) != 0) {
		return m_FcFalse
	}
	if !(XFcSerializeAlloc(tls, serialize, numbers, libc.Int32FromUint64(libc.Uint64FromInt32((*TFcCharSet)(unsafe.Pointer(cs)).Fnum)*uint64(2))) != 0) {
		return m_FcFalse
	}
	i = 0
	for {
		if !(i < (*TFcCharSet)(unsafe.Pointer(cs)).Fnum) {
			break
		}
		if !(XFcSerializeAlloc(tls, serialize, uintptr(int64(uintptr(int64(cs)+(*TFcCharSet)(unsafe.Pointer(cs)).Fleaves_offset))+*(*Tintptr_t)(unsafe.Pointer(uintptr(int64(cs)+(*TFcCharSet)(unsafe.Pointer(cs)).Fleaves_offset) + uintptr(i)*8))), int32(32)) != 0) {
			return m_FcFalse
		}
		goto _3
	_3:
		;
		i++
	}
	return int32(m_FcTrue)
}

func XFcCharSetSerialize(tls *libc.TLS, serialize uintptr, cs uintptr) (r uintptr) {
	var cs_serialized, leaf, leaf_serialized, leaves, leaves_serialized, numbers, numbers_serialized uintptr
	var i int32
	var v1 TFcBool
	_, _, _, _, _, _, _, _, _ = cs_serialized, i, leaf, leaf_serialized, leaves, leaves_serialized, numbers, numbers_serialized, v1
	v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(cs)).Fcount == -libc.Int32FromInt32(1))
	goto _2
_2:
	;
	if !(v1 != 0) && (*TFcSerialize)(unsafe.Pointer(serialize)).Fcs_freezer != 0 {
		cs = _FcCharSetFindFrozen(tls, (*TFcSerialize)(unsafe.Pointer(serialize)).Fcs_freezer, cs)
		if !(cs != 0) {
			return libc.UintptrFromInt32(0)
		}
	}
	cs_serialized = XFcSerializePtr(tls, serialize, cs)
	if !(cs_serialized != 0) {
		return libc.UintptrFromInt32(0)
	}
	(*TFcRef)(unsafe.Pointer(cs_serialized)).Fcount = -libc.Int32FromInt32(1)
	(*TFcCharSet)(unsafe.Pointer(cs_serialized)).Fnum = (*TFcCharSet)(unsafe.Pointer(cs)).Fnum
	if (*TFcCharSet)(unsafe.Pointer(cs)).Fnum != 0 {
		leaves = uintptr(int64(cs) + (*TFcCharSet)(unsafe.Pointer(cs)).Fleaves_offset)
		leaves_serialized = XFcSerializePtr(tls, serialize, leaves)
		if !(leaves_serialized != 0) {
			return libc.UintptrFromInt32(0)
		}
		(*TFcCharSet)(unsafe.Pointer(cs_serialized)).Fleaves_offset = int64(leaves_serialized) - int64(cs_serialized)
		numbers = uintptr(int64(cs) + (*TFcCharSet)(unsafe.Pointer(cs)).Fnumbers_offset)
		numbers_serialized = XFcSerializePtr(tls, serialize, numbers)
		if !(numbers != 0) {
			return libc.UintptrFromInt32(0)
		}
		(*TFcCharSet)(unsafe.Pointer(cs_serialized)).Fnumbers_offset = int64(numbers_serialized) - int64(cs_serialized)
		i = 0
		for {
			if !(i < (*TFcCharSet)(unsafe.Pointer(cs)).Fnum) {
				break
			}
			leaf = uintptr(int64(uintptr(int64(cs)+(*TFcCharSet)(unsafe.Pointer(cs)).Fleaves_offset)) + *(*Tintptr_t)(unsafe.Pointer(uintptr(int64(cs)+(*TFcCharSet)(unsafe.Pointer(cs)).Fleaves_offset) + uintptr(i)*8)))
			leaf_serialized = XFcSerializePtr(tls, serialize, leaf)
			if !(leaf_serialized != 0) {
				return libc.UintptrFromInt32(0)
			}
			*(*TFcCharLeaf)(unsafe.Pointer(leaf_serialized)) = *(*TFcCharLeaf)(unsafe.Pointer(leaf))
			*(*Tintptr_t)(unsafe.Pointer(leaves_serialized + uintptr(i)*8)) = int64(leaf_serialized) - int64(leaves_serialized)
			*(*TFcChar16)(unsafe.Pointer(numbers_serialized + uintptr(i)*2)) = *(*TFcChar16)(unsafe.Pointer(numbers + uintptr(i)*2))
			goto _3
		_3:
			;
			i++
		}
	} else {
		(*TFcCharSet)(unsafe.Pointer(cs_serialized)).Fleaves_offset = 0
		(*TFcCharSet)(unsafe.Pointer(cs_serialized)).Fnumbers_offset = 0
	}
	return cs_serialized
}

const m_FC_O_BINARY = 0
const m_FC_O_CLOEXEC = "O_CLOEXEC"
const m_FC_O_LARGEFILE = 0
const m_FC_O_NOINHERIT = 0
const m_FC_O_TEMPORARY = 0
const m_O_CLOEXEC1 = 16777216
const m_O_RDONLY1 = 0x0000
const m_O_RDWR1 = 0x0002

/*
 * Copyright (c) 2000, 2002-2006, 2008-2010, 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1998-1999 Apple Computer, Inc. All Rights Reserved
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)unistd.h	8.12 (Berkeley) 4/27/95
 *
 *  Copyright (c)  1998 Apple Compter, Inc.
 *  All Rights Reserved
 */

/* History:
      7/14/99 EKN at Apple fixed getdirentriesattr from getdirentryattr
      3/26/98 CHW at Apple added real interface to searchfs call
	3/5/98  CHW at Apple added hfs semantic system calls headers
*/

/*===---- stdarg.h - Variable argument handling ----------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*
 * This header is designed to be included multiple times. If any of the __need_
 * macros are defined, then only that subset of interfaces are provided. This
 * can be useful for POSIX headers that need to not expose all of stdarg.h, but
 * need to use some of its interfaces. Otherwise this header provides all of
 * the expected interfaces.
 *
 * When clang modules are enabled, this header is a textual header to support
 * the multiple include behavior. As such, it doesn't directly declare anything
 * so that it doesn't add duplicate declarations to all of its includers'
 * modules.
 */
/* GCC always defines __va_copy, but does not define va_copy unless in c99 mode
 * or -ansi is not specified, since it was not part of C90.
 */
/*===---- __stdarg_header_macro.h ------------------------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*===---- __stdarg___gnuc_va_list.h - Definition of __gnuc_va_list ---------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*===---- __stdarg_va_list.h - Definition of va_list -----------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*===---- __stdarg_va_arg.h - Definitions of va_start, va_arg, va_end-------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*===---- __stdarg___va_copy.h - Definition of __va_copy -------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*===---- __stdarg_va_copy.h - Definition of va_copy------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*
 * Copyright (c) 2000, 2002 - 2008, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2000, 2007, 2010, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

/*
 * Copyright (c) 2000, 2023 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.3 (Berkeley) 1/21/94
 */

/*
 * Copyright (c) 2023 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.3 (Berkeley) 1/21/94
 */

func XFcOpen(tls *libc.TLS, pathname uintptr, flags int32, va uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ap Tva_list
	var fd int32
	var mode Tmode_t
	_, _, _ = ap, fd, mode
	fd = -int32(1)
	if flags&int32(m_O_CREAT) != 0 {
		ap = va
		mode = libc.Uint16FromInt32(libc.VaInt32(&ap))
		_ = ap
		fd = libc.Xopen(tls, pathname, flags|int32(m_O_CLOEXEC1)|m_FC_O_LARGEFILE, libc.VaList(bp+8, libc.Int32FromUint16(mode)))
	} else {
		fd = libc.Xopen(tls, pathname, flags|int32(m_O_CLOEXEC1)|m_FC_O_LARGEFILE, 0)
	}
	return fd
}

func XFcMakeTempfile(tls *libc.TLS, template uintptr) (r int32) {
	var fd int32
	_ = fd
	fd = -int32(1)
	fd = libc.Xmkostemp(tls, template, int32(m_O_CLOEXEC1))
	return fd
}

func XFcRandom(tls *libc.TLS) (r Tint32_t) {
	var result Tint32_t
	var state uintptr
	_, _ = result, state
	if _initialized != int32(m_FcTrue) {
		state = libc.Xinitstate(tls, libc.Uint32FromInt64(libc.Xtime(tls, libc.UintptrFromInt32(0))), uintptr(unsafe.Pointer(&_statebuf)), uint64(256))
		_initialized = int32(m_FcTrue)
	} else {
		state = libc.Xsetstate(tls, uintptr(unsafe.Pointer(&_statebuf)))
	}
	result = int32(libc.Xrandom(tls))
	libc.Xsetstate(tls, state)
	return result
}

var _statebuf [256]int8

var _initialized TFcBool

func XFcMakeDirectory(tls *libc.TLS, dir uintptr) (r TFcBool) {
	var parent uintptr
	var ret TFcBool
	_, _ = parent, ret
	if libc.Xstrlen(tls, dir) == uint64(0) {
		return m_FcFalse
	}
	parent = XFcStrDirname(tls, dir)
	if !(parent != 0) {
		return m_FcFalse
	}
	if libc.Xaccess(tls, parent, m_F_OK) == 0 {
		ret = libc.BoolInt32(libc.Xmkdir(tls, dir, uint16(0755)) == 0 && libc.Xchmod(tls, dir, uint16(0755)) == 0)
	} else {
		if libc.Xaccess(tls, parent, m_F_OK) == -int32(1) {
			ret = libc.BoolInt32(XFcMakeDirectory(tls, parent) != 0 && libc.Xmkdir(tls, dir, uint16(0755)) == 0 && libc.Xchmod(tls, dir, uint16(0755)) == 0)
		} else {
			ret = m_FcFalse
		}
	}
	XFcStrFree(tls, parent)
	return ret
}

func XFcReadLink(tls *libc.TLS, pathname uintptr, buf uintptr, bufsiz Tsize_t) (r Tssize_t) {
	return libc.Xreadlink(tls, pathname, buf, bufsiz)
}

/*
 * Copyright (c) 2000, 2005, 2007, 2009, 2010, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdio.h	8.5 (Berkeley) 4/29/95
 */

/*
 * Copyright (c) 2000, 2005, 2007, 2009, 2010, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdio.h	8.5 (Berkeley) 4/29/95
 */

/*
 * Common header for stdio.h and xlocale/_stdio.h
 */

/*
 * Copyright (c) 2000, 2002 - 2008, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

func __FcValuePrintFile(tls *libc.TLS, f uintptr, _v TFcValue) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	*(*TFcValue)(unsafe.Pointer(bp)) = _v
	var v1, v2 uintptr
	_, _ = v1, v2
	switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
	case int32(_FcTypeUnknown):
		libc.Xfprintf(tls, f, __ccgo_ts+1870, 0)
	case int32(_FcTypeVoid):
		libc.Xfprintf(tls, f, __ccgo_ts+1880, 0)
	case int32(_FcTypeInteger):
		libc.Xfprintf(tls, f, __ccgo_ts+1887, libc.VaList(bp+24, *(*int32)(unsafe.Pointer(bp + 8))))
	case int32(_FcTypeDouble):
		libc.Xfprintf(tls, f, __ccgo_ts+1893, libc.VaList(bp+24, *(*float64)(unsafe.Pointer(bp + 8))))
	case int32(_FcTypeString):
		libc.Xfprintf(tls, f, __ccgo_ts+1899, libc.VaList(bp+24, *(*uintptr)(unsafe.Pointer(bp + 8))))
	case int32(_FcTypeBool):
		if *(*TFcBool)(unsafe.Pointer(bp + 8)) == int32(m_FcTrue) {
			v1 = __ccgo_ts + 1904
		} else {
			if *(*TFcBool)(unsafe.Pointer(bp + 8)) == m_FcFalse {
				v2 = __ccgo_ts + 1909
			} else {
				v2 = __ccgo_ts + 1915
			}
			v1 = v2
		}
		libc.Xfprintf(tls, f, v1, 0)
	case int32(_FcTypeMatrix):
		libc.Xfprintf(tls, f, __ccgo_ts+1924, libc.VaList(bp+24, (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fxx, (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fxy, (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fyx, (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fyy))
	case int32(_FcTypeCharSet): /* XXX */
		if f == libc.X__stdoutp {
			XFcCharSetPrint(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
		}
	case int32(_FcTypeLangSet):
		XFcLangSetPrint(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	case int32(_FcTypeFTFace):
		libc.Xfprintf(tls, f, __ccgo_ts+1939, 0)
	case int32(_FcTypeRange):
		libc.Xfprintf(tls, f, __ccgo_ts+1944, libc.VaList(bp+24, (*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fbegin, (*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fend))
		break
	}
}

func XFcValuePrintFile(tls *libc.TLS, f uintptr, v TFcValue) {
	libc.Xfprintf(tls, f, __ccgo_ts+1952, 0)
	__FcValuePrintFile(tls, f, v)
}

func XFcValuePrint(tls *libc.TLS, v TFcValue) {
	libc.Xprintf(tls, __ccgo_ts+1952, 0)
	__FcValuePrintFile(tls, libc.X__stdoutp, v)
}

func XFcValuePrintWithPosition(tls *libc.TLS, v TFcValue, show_pos_mark TFcBool) {
	if show_pos_mark != 0 {
		libc.Xprintf(tls, __ccgo_ts+1954, 0)
	} else {
		libc.Xprintf(tls, __ccgo_ts+1952, 0)
	}
	__FcValuePrintFile(tls, libc.X__stdoutp, v)
}

func _FcValueBindingPrint(tls *libc.TLS, l TFcValueListPtr) {
	switch (*T_FcValueList)(unsafe.Pointer(l)).Fbinding {
	case int32(_FcValueBindingWeak):
		libc.Xprintf(tls, __ccgo_ts+1965, 0)
	case int32(_FcValueBindingStrong):
		libc.Xprintf(tls, __ccgo_ts+1969, 0)
	case int32(_FcValueBindingSame):
		libc.Xprintf(tls, __ccgo_ts+1973, 0)
	default:
		/* shouldn't be reached */
		libc.Xprintf(tls, __ccgo_ts+1977, 0)
		break
	}
}

func XFcValueListPrintWithPosition(tls *libc.TLS, l TFcValueListPtr, pos TFcValueListPtr) {
	var v2 uintptr
	_ = v2
	for {
		if !(l != libc.UintptrFromInt32(0)) {
			break
		}
		XFcValuePrintWithPosition(tls, XFcValueCanonicalize(tls, l+8), libc.BoolInt32(pos != libc.UintptrFromInt32(0) && l == pos))
		_FcValueBindingPrint(tls, l)
		goto _1
	_1:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
			v2 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
		}
		l = v2
	}
	if !(pos != 0) {
		libc.Xprintf(tls, __ccgo_ts+1981, 0)
	}
}

func XFcValueListPrint(tls *libc.TLS, l TFcValueListPtr) {
	var v2 uintptr
	_ = v2
	for {
		if !(l != libc.UintptrFromInt32(0)) {
			break
		}
		XFcValuePrint(tls, XFcValueCanonicalize(tls, l+8))
		_FcValueBindingPrint(tls, l)
		goto _1
	_1:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
			v2 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
		}
		l = v2
	}
}

func XFcLangSetPrint(tls *libc.TLS, ls uintptr) {
	bp := tls.Alloc(1200)
	defer tls.Free(1200)
	var _ /* buf at bp+0 */ TFcStrBuf
	var _ /* init_buf at bp+152 */ [1024]TFcChar8
	XFcStrBufInit(tls, bp, bp+152, int32(1024))
	if XFcNameUnparseLangSet(tls, bp, ls) != 0 && XFcStrBufChar(tls, bp, uint8('\000')) != 0 {
		libc.Xprintf(tls, __ccgo_ts+1991, libc.VaList(bp+1184, (*(*TFcStrBuf)(unsafe.Pointer(bp))).Fbuf))
	} else {
		libc.Xprintf(tls, __ccgo_ts+1994, 0)
	}
	XFcStrBufDestroy(tls, bp)
}

func XFcCharSetPrint(tls *libc.TLS, c uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, j int32
	var leaf, leaves, numbers uintptr
	var leaf_offset Tintptr_t
	_, _, _, _, _, _ = i, j, leaf, leaf_offset, leaves, numbers
	leaves = uintptr(int64(c) + (*TFcCharSet)(unsafe.Pointer(c)).Fleaves_offset)
	numbers = uintptr(int64(c) + (*TFcCharSet)(unsafe.Pointer(c)).Fnumbers_offset)
	libc.Xprintf(tls, __ccgo_ts+1266, 0)
	i = 0
	for {
		if !(i < (*TFcCharSet)(unsafe.Pointer(c)).Fnum) {
			break
		}
		leaf_offset = *(*Tintptr_t)(unsafe.Pointer(leaves + uintptr(i)*8))
		leaf = uintptr(int64(leaves) + leaf_offset)
		libc.Xprintf(tls, __ccgo_ts+2016, 0)
		libc.Xprintf(tls, __ccgo_ts+2018, libc.VaList(bp+8, libc.Int32FromUint16(*(*TFcChar16)(unsafe.Pointer(numbers + uintptr(i)*2)))))
		j = 0
		for {
			if !(j < libc.Int32FromInt32(256)/libc.Int32FromInt32(32)) {
				break
			}
			libc.Xprintf(tls, __ccgo_ts+2024, libc.VaList(bp+8, *(*TFcChar32)(unsafe.Pointer(leaf + uintptr(j)*4))))
			goto _2
		_2:
			;
			j++
		}
		libc.Xprintf(tls, __ccgo_ts+1266, 0)
		goto _1
	_1:
		;
		i++
	}
}

func XFcPatternPrint(tls *libc.TLS, p uintptr) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var _ /* iter at bp+0 */ TFcPatternIter
	if !(p != 0) {
		libc.Xprintf(tls, __ccgo_ts+2030, 0)
		return
	}
	libc.Xprintf(tls, __ccgo_ts+2044, libc.VaList(bp+24, XFcPatternObjectCount(tls, p), (*TFcPattern)(unsafe.Pointer(p)).Fsize))
	XFcPatternIterStart(tls, p, bp)
	for cond := true; cond; cond = XFcPatternIterNext(tls, p, bp) != 0 {
		libc.Xprintf(tls, __ccgo_ts+2075, libc.VaList(bp+24, XFcPatternIterGetObject(tls, p, bp)))
		XFcValueListPrint(tls, XFcPatternIterGetValues(tls, p, bp))
		libc.Xprintf(tls, __ccgo_ts+1266, 0)
	}
	libc.Xprintf(tls, __ccgo_ts+1266, 0)
}

func XFcPatternPrint2(tls *libc.TLS, pp1 uintptr, pp2 uintptr, os uintptr) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var e1, e2, p1, p2, v10, v5, v6, v7, v8 uintptr
	var i, j, k, pos int32
	_, _, _, _, _, _, _, _, _, _, _, _, _ = e1, e2, i, j, k, p1, p2, pos, v10, v5, v6, v7, v8
	if os != 0 {
		p1 = XFcPatternFilter(tls, pp1, os)
		p2 = XFcPatternFilter(tls, pp2, os)
	} else {
		p1 = pp1
		p2 = pp2
	}
	libc.Xprintf(tls, __ccgo_ts+2080, libc.VaList(bp+8, (*TFcPattern)(unsafe.Pointer(p1)).Fnum, (*TFcPattern)(unsafe.Pointer(p1)).Fsize, (*TFcPattern)(unsafe.Pointer(p2)).Fnum, (*TFcPattern)(unsafe.Pointer(p2)).Fsize))
	i = 0
	j = libc.Int32FromInt32(0)
	for {
		if !(i < (*TFcPattern)(unsafe.Pointer(p1)).Fnum) {
			break
		}
		e1 = uintptr(int64(p1)+(*TFcPattern)(unsafe.Pointer(p1)).Felts_offset) + uintptr(i)*16
		e2 = uintptr(int64(p2)+(*TFcPattern)(unsafe.Pointer(p2)).Felts_offset) + uintptr(j)*16
		if !(!(e2 != 0) || (*TFcPatternElt)(unsafe.Pointer(e1)).Fobject != (*TFcPatternElt)(unsafe.Pointer(e2)).Fobject) {
			goto _2
		}
		pos = XFcPatternPosition(tls, p2, XFcObjectName(tls, (*TFcPatternElt)(unsafe.Pointer(e1)).Fobject))
		if pos >= 0 {
			k = j
			for {
				if !(k < pos) {
					break
				}
				e2 = uintptr(int64(p2)+(*TFcPattern)(unsafe.Pointer(p2)).Felts_offset) + uintptr(k)*16
				libc.Xprintf(tls, __ccgo_ts+2130, libc.VaList(bp+8, XFcObjectName(tls, (*TFcPatternElt)(unsafe.Pointer(e2)).Fobject)))
				if int64((*TFcPatternElt)(unsafe.Pointer(e2)).Fvalues)&int64(1) != 0 {
					v5 = uintptr(int64(e2) + int64((*TFcPatternElt)(unsafe.Pointer(e2)).Fvalues)&int64(^libc.Int32FromInt32(1)))
				} else {
					v5 = (*TFcPatternElt)(unsafe.Pointer(e2)).Fvalues
				}
				XFcValueListPrint(tls, v5)
				libc.Xprintf(tls, __ccgo_ts+1266, 0)
				goto _4
			_4:
				;
				k++
			}
			j = pos
			goto cont
		} else {
			libc.Xprintf(tls, __ccgo_ts+2075, libc.VaList(bp+8, XFcObjectName(tls, (*TFcPatternElt)(unsafe.Pointer(e1)).Fobject)))
			if int64((*TFcPatternElt)(unsafe.Pointer(e1)).Fvalues)&int64(1) != 0 {
				v6 = uintptr(int64(e1) + int64((*TFcPatternElt)(unsafe.Pointer(e1)).Fvalues)&int64(^libc.Int32FromInt32(1)))
			} else {
				v6 = (*TFcPatternElt)(unsafe.Pointer(e1)).Fvalues
			}
			XFcValueListPrint(tls, v6)
			libc.Xprintf(tls, __ccgo_ts+2146, 0)
		}
		goto _3
	_2:
		;
		goto cont
	cont:
		;
		libc.Xprintf(tls, __ccgo_ts+2075, libc.VaList(bp+8, XFcObjectName(tls, (*TFcPatternElt)(unsafe.Pointer(e1)).Fobject)))
		if int64((*TFcPatternElt)(unsafe.Pointer(e1)).Fvalues)&int64(1) != 0 {
			v7 = uintptr(int64(e1) + int64((*TFcPatternElt)(unsafe.Pointer(e1)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v7 = (*TFcPatternElt)(unsafe.Pointer(e1)).Fvalues
		}
		XFcValueListPrint(tls, v7)
		libc.Xprintf(tls, __ccgo_ts+2158, 0)
		e2 = uintptr(int64(p2)+(*TFcPattern)(unsafe.Pointer(p2)).Felts_offset) + uintptr(j)*16
		if int64((*TFcPatternElt)(unsafe.Pointer(e2)).Fvalues)&int64(1) != 0 {
			v8 = uintptr(int64(e2) + int64((*TFcPatternElt)(unsafe.Pointer(e2)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v8 = (*TFcPatternElt)(unsafe.Pointer(e2)).Fvalues
		}
		XFcValueListPrint(tls, v8)
		libc.Xprintf(tls, __ccgo_ts+1266, 0)
		j++
	_3:
		;
		goto _1
	_1:
		;
		i++
	}
	if j < (*TFcPattern)(unsafe.Pointer(p2)).Fnum {
		k = j
		for {
			if !(k < (*TFcPattern)(unsafe.Pointer(p2)).Fnum) {
				break
			}
			e2 = uintptr(int64(p2)+(*TFcPattern)(unsafe.Pointer(p2)).Felts_offset) + uintptr(k)*16
			if XFcObjectName(tls, (*TFcPatternElt)(unsafe.Pointer(e2)).Fobject) != 0 {
				libc.Xprintf(tls, __ccgo_ts+2130, libc.VaList(bp+8, XFcObjectName(tls, (*TFcPatternElt)(unsafe.Pointer(e2)).Fobject)))
				if int64((*TFcPatternElt)(unsafe.Pointer(e2)).Fvalues)&int64(1) != 0 {
					v10 = uintptr(int64(e2) + int64((*TFcPatternElt)(unsafe.Pointer(e2)).Fvalues)&int64(^libc.Int32FromInt32(1)))
				} else {
					v10 = (*TFcPatternElt)(unsafe.Pointer(e2)).Fvalues
				}
				XFcValueListPrint(tls, v10)
				libc.Xprintf(tls, __ccgo_ts+1266, 0)
			}
			goto _9
		_9:
			;
			k++
		}
	}
	if p1 != pp1 {
		XFcPatternDestroy(tls, p1)
	}
	if p2 != pp2 {
		XFcPatternDestroy(tls, p2)
	}
}

func XFcOpPrint(tls *libc.TLS, op_ TFcOp) {
	var f, f1, f2 int32
	var op TFcOp
	_, _, _, _ = f, f1, f2, op
	op = op_ & libc.Int32FromInt32(0xffff)
	switch op {
	case int32(_FcOpInteger):
		libc.Xprintf(tls, __ccgo_ts+2163, 0)
	case int32(_FcOpDouble):
		libc.Xprintf(tls, __ccgo_ts+2171, 0)
	case int32(_FcOpString):
		libc.Xprintf(tls, __ccgo_ts+2178, 0)
	case int32(_FcOpMatrix):
		libc.Xprintf(tls, __ccgo_ts+2185, 0)
	case int32(_FcOpRange):
		libc.Xprintf(tls, __ccgo_ts+2192, 0)
	case int32(_FcOpBool):
		libc.Xprintf(tls, __ccgo_ts+2198, 0)
	case int32(_FcOpCharSet):
		libc.Xprintf(tls, __ccgo_ts+2203, 0)
	case int32(_FcOpLangSet):
		libc.Xprintf(tls, __ccgo_ts+2211, 0)
	case int32(_FcOpField):
		libc.Xprintf(tls, __ccgo_ts+2219, 0)
	case int32(_FcOpConst):
		libc.Xprintf(tls, __ccgo_ts+2225, 0)
	case int32(_FcOpAssign):
		libc.Xprintf(tls, __ccgo_ts+2231, 0)
	case int32(_FcOpAssignReplace):
		libc.Xprintf(tls, __ccgo_ts+2238, 0)
	case int32(_FcOpPrepend):
		libc.Xprintf(tls, __ccgo_ts+1309, 0)
	case int32(_FcOpPrependFirst):
		libc.Xprintf(tls, __ccgo_ts+2252, 0)
	case int32(_FcOpAppend):
		libc.Xprintf(tls, __ccgo_ts+1302, 0)
	case int32(_FcOpAppendLast):
		libc.Xprintf(tls, __ccgo_ts+2265, 0)
	case int32(_FcOpDelete):
		libc.Xprintf(tls, __ccgo_ts+2276, 0)
	case int32(_FcOpDeleteAll):
		libc.Xprintf(tls, __ccgo_ts+2283, 0)
	case int32(_FcOpQuest):
		libc.Xprintf(tls, __ccgo_ts+2293, 0)
	case int32(_FcOpOr):
		libc.Xprintf(tls, __ccgo_ts+2299, 0)
	case int32(_FcOpAnd):
		libc.Xprintf(tls, __ccgo_ts+2302, 0)
	case int32(_FcOpEqual):
		libc.Xprintf(tls, __ccgo_ts+2306, 0)
		f = libc.Int32FromUint32(libc.Uint32FromInt32(op_) & libc.Uint32FromUint32(0xffff0000) >> libc.Int32FromInt32(16))
		if f&int32(_FcOpFlagIgnoreBlanks) != 0 {
			libc.Xprintf(tls, __ccgo_ts+2312, 0)
		}
	case int32(_FcOpNotEqual):
		libc.Xprintf(tls, __ccgo_ts+2328, 0)
		f1 = libc.Int32FromUint32(libc.Uint32FromInt32(op_) & libc.Uint32FromUint32(0xffff0000) >> libc.Int32FromInt32(16))
		if f1&int32(_FcOpFlagIgnoreBlanks) != 0 {
			libc.Xprintf(tls, __ccgo_ts+2312, 0)
		}
	case int32(_FcOpLess):
		libc.Xprintf(tls, __ccgo_ts+2337, 0)
	case int32(_FcOpLessEqual):
		libc.Xprintf(tls, __ccgo_ts+2342, 0)
	case int32(_FcOpMore):
		libc.Xprintf(tls, __ccgo_ts+2352, 0)
	case int32(_FcOpMoreEqual):
		libc.Xprintf(tls, __ccgo_ts+2357, 0)
	case int32(_FcOpContains):
		libc.Xprintf(tls, __ccgo_ts+2367, 0)
	case int32(_FcOpNotContains):
		libc.Xprintf(tls, __ccgo_ts+2376, 0)
	case int32(_FcOpPlus):
		libc.Xprintf(tls, __ccgo_ts+2388, 0)
	case int32(_FcOpMinus):
		libc.Xprintf(tls, __ccgo_ts+2393, 0)
	case int32(_FcOpTimes):
		libc.Xprintf(tls, __ccgo_ts+2399, 0)
	case int32(_FcOpDivide):
		libc.Xprintf(tls, __ccgo_ts+2405, 0)
	case int32(_FcOpNot):
		libc.Xprintf(tls, __ccgo_ts+2412, 0)
	case int32(_FcOpNil):
		libc.Xprintf(tls, __ccgo_ts+2416, 0)
	case int32(_FcOpComma):
		libc.Xprintf(tls, __ccgo_ts+2420, 0)
	case int32(_FcOpFloor):
		libc.Xprintf(tls, __ccgo_ts+2426, 0)
	case int32(_FcOpCeil):
		libc.Xprintf(tls, __ccgo_ts+2432, 0)
	case int32(_FcOpRound):
		libc.Xprintf(tls, __ccgo_ts+2437, 0)
	case int32(_FcOpTrunc):
		libc.Xprintf(tls, __ccgo_ts+2443, 0)
	case int32(_FcOpListing):
		libc.Xprintf(tls, __ccgo_ts+2449, 0)
		f2 = libc.Int32FromUint32(libc.Uint32FromInt32(op_) & libc.Uint32FromUint32(0xffff0000) >> libc.Int32FromInt32(16))
		if f2&int32(_FcOpFlagIgnoreBlanks) != 0 {
			libc.Xprintf(tls, __ccgo_ts+2312, 0)
		}
	case int32(_FcOpInvalid):
		libc.Xprintf(tls, __ccgo_ts+2457, 0)
		break
	}
}

func XFcExprPrint(tls *libc.TLS, expr uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var f, f1, f2 int32
	var v1 uintptr
	_, _, _, _ = f, f1, f2, v1
	if !(expr != 0) {
		libc.Xprintf(tls, __ccgo_ts+2465, 0)
	} else {
		switch (*TFcExpr)(unsafe.Pointer(expr)).Fop & libc.Int32FromInt32(0xffff) {
		case int32(_FcOpInteger):
			libc.Xprintf(tls, __ccgo_ts+2470, libc.VaList(bp+8, (*TFcExpr)(unsafe.Pointer(expr)).Fu.Fival))
		case int32(_FcOpDouble):
			libc.Xprintf(tls, __ccgo_ts+2473, libc.VaList(bp+8, *(*float64)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu))))
		case int32(_FcOpString):
			libc.Xprintf(tls, __ccgo_ts+1899, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu))))
		case int32(_FcOpMatrix):
			libc.Xprintf(tls, __ccgo_ts+2476, 0)
			XFcExprPrint(tls, (*TFcExprMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu)))).Fxx)
			libc.Xprintf(tls, __ccgo_ts+1952, 0)
			XFcExprPrint(tls, (*TFcExprMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu)))).Fxy)
			libc.Xprintf(tls, __ccgo_ts+2478, 0)
			XFcExprPrint(tls, (*TFcExprMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu)))).Fyx)
			libc.Xprintf(tls, __ccgo_ts+1952, 0)
			XFcExprPrint(tls, (*TFcExprMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu)))).Fyy)
			libc.Xprintf(tls, __ccgo_ts+2481, 0)
		case int32(_FcOpRange):
			libc.Xprintf(tls, __ccgo_ts+2483, libc.VaList(bp+8, (*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu)))).Fbegin, (*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu)))).Fend))
		case int32(_FcOpBool):
			if *(*TFcBool)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu)) != 0 {
				v1 = __ccgo_ts + 2492
			} else {
				v1 = __ccgo_ts + 2497
			}
			libc.Xprintf(tls, __ccgo_ts+1991, libc.VaList(bp+8, v1))
		case int32(_FcOpCharSet):
			libc.Xprintf(tls, __ccgo_ts+2503, 0)
		case int32(_FcOpLangSet):
			libc.Xprintf(tls, __ccgo_ts+2512, 0)
			XFcLangSetPrint(tls, *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu)))
			libc.Xprintf(tls, __ccgo_ts+1266, 0)
		case int32(_FcOpNil):
			libc.Xprintf(tls, __ccgo_ts+2521, 0)
		case int32(_FcOpField):
			libc.Xprintf(tls, __ccgo_ts+2526, libc.VaList(bp+8, XFcObjectName(tls, (*(*TFcExprName)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu))).Fobject)))
			switch (*(*TFcExprName)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu))).Fkind {
			case int32(_FcMatchPattern):
				libc.Xprintf(tls, __ccgo_ts+2530, 0)
			case int32(_FcMatchFont):
				libc.Xprintf(tls, __ccgo_ts+2541, 0)
				break
			}
		case int32(_FcOpConst):
			libc.Xprintf(tls, __ccgo_ts+1991, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu))))
		case int32(_FcOpQuest):
			XFcExprPrint(tls, (*(*struct {
				Fleft  uintptr
				Fright uintptr
			})(unsafe.Pointer(expr + 8))).Fleft)
			libc.Xprintf(tls, __ccgo_ts+2549, 0)
			XFcExprPrint(tls, (*(*struct {
				Fleft  uintptr
				Fright uintptr
			})(unsafe.Pointer((*(*struct {
				Fleft  uintptr
				Fright uintptr
			})(unsafe.Pointer(expr + 8))).Fright + 8))).Fleft)
			libc.Xprintf(tls, __ccgo_ts+2557, 0)
			XFcExprPrint(tls, (*(*struct {
				Fleft  uintptr
				Fright uintptr
			})(unsafe.Pointer((*(*struct {
				Fleft  uintptr
				Fright uintptr
			})(unsafe.Pointer(expr + 8))).Fright + 8))).Fright)
		case int32(_FcOpAssign):
			fallthrough
		case int32(_FcOpAssignReplace):
			fallthrough
		case int32(_FcOpPrependFirst):
			fallthrough
		case int32(_FcOpPrepend):
			fallthrough
		case int32(_FcOpAppend):
			fallthrough
		case int32(_FcOpAppendLast):
			fallthrough
		case int32(_FcOpOr):
			fallthrough
		case int32(_FcOpAnd):
			fallthrough
		case int32(_FcOpEqual):
			fallthrough
		case int32(_FcOpNotEqual):
			fallthrough
		case int32(_FcOpLess):
			fallthrough
		case int32(_FcOpLessEqual):
			fallthrough
		case int32(_FcOpMore):
			fallthrough
		case int32(_FcOpMoreEqual):
			fallthrough
		case int32(_FcOpContains):
			fallthrough
		case int32(_FcOpListing):
			fallthrough
		case int32(_FcOpNotContains):
			fallthrough
		case int32(_FcOpPlus):
			fallthrough
		case int32(_FcOpMinus):
			fallthrough
		case int32(_FcOpTimes):
			fallthrough
		case int32(_FcOpDivide):
			fallthrough
		case int32(_FcOpComma):
			XFcExprPrint(tls, (*(*struct {
				Fleft  uintptr
				Fright uintptr
			})(unsafe.Pointer(expr + 8))).Fleft)
			libc.Xprintf(tls, __ccgo_ts+1952, 0)
			switch (*TFcExpr)(unsafe.Pointer(expr)).Fop & libc.Int32FromInt32(0xffff) {
			case int32(_FcOpAssign):
				libc.Xprintf(tls, __ccgo_ts+2231, 0)
			case int32(_FcOpAssignReplace):
				libc.Xprintf(tls, __ccgo_ts+2238, 0)
			case int32(_FcOpPrependFirst):
				libc.Xprintf(tls, __ccgo_ts+2252, 0)
			case int32(_FcOpPrepend):
				libc.Xprintf(tls, __ccgo_ts+1309, 0)
			case int32(_FcOpAppend):
				libc.Xprintf(tls, __ccgo_ts+1302, 0)
			case int32(_FcOpAppendLast):
				libc.Xprintf(tls, __ccgo_ts+2265, 0)
			case int32(_FcOpOr):
				libc.Xprintf(tls, __ccgo_ts+2299, 0)
			case int32(_FcOpAnd):
				libc.Xprintf(tls, __ccgo_ts+2302, 0)
			case int32(_FcOpEqual):
				libc.Xprintf(tls, __ccgo_ts+2306, 0)
				f = libc.Int32FromUint32(libc.Uint32FromInt32((*TFcExpr)(unsafe.Pointer(expr)).Fop) & libc.Uint32FromUint32(0xffff0000) >> libc.Int32FromInt32(16))
				if f&int32(_FcOpFlagIgnoreBlanks) != 0 {
					libc.Xprintf(tls, __ccgo_ts+2312, 0)
				}
			case int32(_FcOpNotEqual):
				libc.Xprintf(tls, __ccgo_ts+2328, 0)
				f1 = libc.Int32FromUint32(libc.Uint32FromInt32((*TFcExpr)(unsafe.Pointer(expr)).Fop) & libc.Uint32FromUint32(0xffff0000) >> libc.Int32FromInt32(16))
				if f1&int32(_FcOpFlagIgnoreBlanks) != 0 {
					libc.Xprintf(tls, __ccgo_ts+2312, 0)
				}
			case int32(_FcOpLess):
				libc.Xprintf(tls, __ccgo_ts+2337, 0)
			case int32(_FcOpLessEqual):
				libc.Xprintf(tls, __ccgo_ts+2342, 0)
			case int32(_FcOpMore):
				libc.Xprintf(tls, __ccgo_ts+2352, 0)
			case int32(_FcOpMoreEqual):
				libc.Xprintf(tls, __ccgo_ts+2357, 0)
			case int32(_FcOpContains):
				libc.Xprintf(tls, __ccgo_ts+2367, 0)
			case int32(_FcOpListing):
				libc.Xprintf(tls, __ccgo_ts+2449, 0)
				f2 = libc.Int32FromUint32(libc.Uint32FromInt32((*TFcExpr)(unsafe.Pointer(expr)).Fop) & libc.Uint32FromUint32(0xffff0000) >> libc.Int32FromInt32(16))
				if f2&int32(_FcOpFlagIgnoreBlanks) != 0 {
					libc.Xprintf(tls, __ccgo_ts+2312, 0)
				}
			case int32(_FcOpNotContains):
				libc.Xprintf(tls, __ccgo_ts+2376, 0)
			case int32(_FcOpPlus):
				libc.Xprintf(tls, __ccgo_ts+2388, 0)
			case int32(_FcOpMinus):
				libc.Xprintf(tls, __ccgo_ts+2393, 0)
			case int32(_FcOpTimes):
				libc.Xprintf(tls, __ccgo_ts+2399, 0)
			case int32(_FcOpDivide):
				libc.Xprintf(tls, __ccgo_ts+2405, 0)
			case int32(_FcOpComma):
				libc.Xprintf(tls, __ccgo_ts+2420, 0)
			default:
				break
			}
			libc.Xprintf(tls, __ccgo_ts+1952, 0)
			XFcExprPrint(tls, (*(*struct {
				Fleft  uintptr
				Fright uintptr
			})(unsafe.Pointer(expr + 8))).Fright)
		case int32(_FcOpNot):
			libc.Xprintf(tls, __ccgo_ts+2565, 0)
			XFcExprPrint(tls, (*(*struct {
				Fleft  uintptr
				Fright uintptr
			})(unsafe.Pointer(expr + 8))).Fleft)
		case int32(_FcOpFloor):
			libc.Xprintf(tls, __ccgo_ts+2570, 0)
			XFcExprPrint(tls, (*(*struct {
				Fleft  uintptr
				Fright uintptr
			})(unsafe.Pointer(expr + 8))).Fleft)
		case int32(_FcOpCeil):
			libc.Xprintf(tls, __ccgo_ts+2577, 0)
			XFcExprPrint(tls, (*(*struct {
				Fleft  uintptr
				Fright uintptr
			})(unsafe.Pointer(expr + 8))).Fleft)
		case int32(_FcOpRound):
			libc.Xprintf(tls, __ccgo_ts+2583, 0)
			XFcExprPrint(tls, (*(*struct {
				Fleft  uintptr
				Fright uintptr
			})(unsafe.Pointer(expr + 8))).Fleft)
		case int32(_FcOpTrunc):
			libc.Xprintf(tls, __ccgo_ts+2590, 0)
			XFcExprPrint(tls, (*(*struct {
				Fleft  uintptr
				Fright uintptr
			})(unsafe.Pointer(expr + 8))).Fleft)
		case int32(_FcOpInvalid):
			libc.Xprintf(tls, __ccgo_ts+2457, 0)
			break
		}
	}
}

func XFcTestPrint(tls *libc.TLS, test uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	switch (*TFcTest)(unsafe.Pointer(test)).Fkind {
	case int32(_FcMatchPattern):
		libc.Xprintf(tls, __ccgo_ts+2597, 0)
	case int32(_FcMatchFont):
		libc.Xprintf(tls, __ccgo_ts+2606, 0)
	case int32(_FcMatchScan):
		libc.Xprintf(tls, __ccgo_ts+2612, 0)
	case int32(_FcMatchKindEnd):
		/* shouldn't be reached */
		return
	}
	switch (*TFcTest)(unsafe.Pointer(test)).Fqual {
	case int32(_FcQualAny):
		libc.Xprintf(tls, __ccgo_ts+2618, 0)
	case int32(_FcQualAll):
		libc.Xprintf(tls, __ccgo_ts+2623, 0)
	case int32(_FcQualFirst):
		libc.Xprintf(tls, __ccgo_ts+2628, 0)
	case int32(_FcQualNotFirst):
		libc.Xprintf(tls, __ccgo_ts+2635, 0)
		break
	}
	libc.Xprintf(tls, __ccgo_ts+2526, libc.VaList(bp+8, XFcObjectName(tls, (*TFcTest)(unsafe.Pointer(test)).Fobject)))
	XFcOpPrint(tls, (*TFcTest)(unsafe.Pointer(test)).Fop)
	libc.Xprintf(tls, __ccgo_ts+1952, 0)
	XFcExprPrint(tls, (*TFcTest)(unsafe.Pointer(test)).Fexpr)
	libc.Xprintf(tls, __ccgo_ts+1266, 0)
}

func XFcEditPrint(tls *libc.TLS, edit uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	libc.Xprintf(tls, __ccgo_ts+2646, libc.VaList(bp+8, XFcObjectName(tls, (*TFcEdit)(unsafe.Pointer(edit)).Fobject)))
	XFcOpPrint(tls, (*TFcEdit)(unsafe.Pointer(edit)).Fop)
	libc.Xprintf(tls, __ccgo_ts+1952, 0)
	XFcExprPrint(tls, (*TFcEdit)(unsafe.Pointer(edit)).Fexpr)
}

func XFcRulePrint(tls *libc.TLS, rule uintptr) {
	var last_type TFcRuleType
	var r uintptr
	_, _ = last_type, r
	last_type = int32(_FcRuleUnknown)
	r = rule
	for {
		if !(r != 0) {
			break
		}
		if last_type != (*TFcRule)(unsafe.Pointer(r)).Ftype1 {
			switch (*TFcRule)(unsafe.Pointer(r)).Ftype1 {
			case int32(_FcRuleTest):
				libc.Xprintf(tls, __ccgo_ts+2655, 0)
			case int32(_FcRuleEdit):
				libc.Xprintf(tls, __ccgo_ts+2663, 0)
			default:
				break
			}
			last_type = (*TFcRule)(unsafe.Pointer(r)).Ftype1
		}
		libc.Xprintf(tls, __ccgo_ts+2016, 0)
		switch (*TFcRule)(unsafe.Pointer(r)).Ftype1 {
		case int32(_FcRuleTest):
			XFcTestPrint(tls, *(*uintptr)(unsafe.Pointer(r + 16)))
		case int32(_FcRuleEdit):
			XFcEditPrint(tls, *(*uintptr)(unsafe.Pointer(r + 16)))
			libc.Xprintf(tls, __ccgo_ts+2671, 0)
		default:
			break
		}
		goto _1
	_1:
		;
		r = (*TFcRule)(unsafe.Pointer(r)).Fnext
	}
	libc.Xprintf(tls, __ccgo_ts+1266, 0)
}

func XFcFontSetPrint(tls *libc.TLS, s uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var i int32
	_ = i
	libc.Xprintf(tls, __ccgo_ts+2674, libc.VaList(bp+8, (*TFcFontSet)(unsafe.Pointer(s)).Fnfont, (*TFcFontSet)(unsafe.Pointer(s)).Fsfont))
	i = 0
	for {
		if !(i < (*TFcFontSet)(unsafe.Pointer(s)).Fnfont) {
			break
		}
		libc.Xprintf(tls, __ccgo_ts+2692, libc.VaList(bp+8, i))
		XFcPatternPrint(tls, *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(s)).Ffonts + uintptr(i)*8)))
		goto _1
	_1:
		;
		i++
	}
}

func XFcInitDebug(tls *libc.TLS) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e uintptr
	_ = e
	if !(XFcDebugVal != 0) {
		e = libc.Xgetenv(tls, __ccgo_ts+2701)
		if e != 0 {
			libc.Xprintf(tls, __ccgo_ts+2710, libc.VaList(bp+8, e))
			XFcDebugVal = libc.Xatoi(tls, e)
			if XFcDebugVal < 0 {
				XFcDebugVal = 0
			}
		}
	}
}

/*===---- limits.h - Standard header for integer sizes --------------------===* *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
\*===----------------------------------------------------------------------===*/

/*
 * Copyright (c) 2000, 2007, 2010, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

/* MT-safe */

var _FcBoolDefaults = [8]struct {
	Ffield TFcObject
	Fvalue TFcBool
}{
	0: {
		Ffield: int32(_FC_HINTING_OBJECT),
		Fvalue: int32(m_FcTrue),
	},
	1: {
		Ffield: int32(_FC_VERTICAL_LAYOUT_OBJECT),
	},
	2: {
		Ffield: int32(_FC_AUTOHINT_OBJECT),
	},
	3: {
		Ffield: int32(_FC_GLOBAL_ADVANCE_OBJECT),
		Fvalue: int32(m_FcTrue),
	},
	4: {
		Ffield: int32(_FC_EMBEDDED_BITMAP_OBJECT),
		Fvalue: int32(m_FcTrue),
	},
	5: {
		Ffield: int32(_FC_DECORATIVE_OBJECT),
	},
	6: {
		Ffield: int32(_FC_SYMBOL_OBJECT),
	},
	7: {
		Ffield: int32(_FC_VARIABLE_OBJECT),
	},
}

func XFcGetDefaultLangs(tls *libc.TLS) (r uintptr) {
	var langs, result uintptr
	var v1 int32
	_, _, _ = langs, result, v1
	goto retry
retry:
	;
	result = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&Xdefault_langs))))
	if !(result != 0) {
		result = XFcStrSetCreate(tls)
		langs = libc.Xgetenv(tls, __ccgo_ts+2723)
		if !(langs != 0) || !(*(*int8)(unsafe.Pointer(langs)) != 0) {
			langs = libc.Xgetenv(tls, __ccgo_ts+2731)
		}
		if !(langs != 0) || !(*(*int8)(unsafe.Pointer(langs)) != 0) {
			langs = libc.Xgetenv(tls, __ccgo_ts+2738)
		}
		if !(langs != 0) || !(*(*int8)(unsafe.Pointer(langs)) != 0) {
			langs = libc.Xgetenv(tls, __ccgo_ts+2747)
		}
		if langs != 0 && *(*int8)(unsafe.Pointer(langs)) != 0 {
			if !(XFcStrSetAddLangs(tls, result, langs) != 0) {
				XFcStrSetAdd(tls, result, __ccgo_ts+2752)
			}
		} else {
			XFcStrSetAdd(tls, result, __ccgo_ts+2752)
		}
		(*TFcRef)(unsafe.Pointer(result)).Fcount = -libc.Int32FromInt32(1)
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&Xdefault_langs)))) == libc.UintptrFromInt32(0) {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&Xdefault_langs)))) = result
			v1 = libc.Int32FromInt32(m_FcTrue)
		} else {
			v1 = m_FcFalse
		}
		if !(v1 != 0) {
			(*TFcRef)(unsafe.Pointer(result)).Fcount = int32(1)
			XFcStrSetDestroy(tls, result)
			goto retry
		}
	}
	return result
}

var _default_lang uintptr /* MT-safe */

func XFcGetDefaultLang(tls *libc.TLS) (r uintptr) {
	var lang, langs uintptr
	var v1 int32
	_, _, _ = lang, langs, v1
	goto retry
retry:
	;
	lang = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_lang))))
	if !(lang != 0) {
		langs = XFcGetDefaultLangs(tls)
		lang = libc.Xstrdup(tls, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(langs)).Fstrs)))
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_lang)))) == libc.UintptrFromInt32(0) {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_lang)))) = lang
			v1 = libc.Int32FromInt32(m_FcTrue)
		} else {
			v1 = m_FcFalse
		}
		if !(v1 != 0) {
			libc.Xfree(tls, lang)
			goto retry
		}
	}
	return lang
}

var _default_prgname uintptr

func XFcGetPrgname(tls *libc.TLS) (r uintptr) {
	var prgname, q uintptr
	var v1 int32
	_, _, _ = prgname, q, v1
	goto retry
retry:
	;
	prgname = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_prgname))))
	if !(prgname != 0) {
		q = libc.Xgetprogname(tls)
		if q != 0 {
			prgname = libc.Xstrdup(tls, q)
		} else {
			prgname = libc.Xstrdup(tls, __ccgo_ts+110)
		}
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_prgname)))) == libc.UintptrFromInt32(0) {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_prgname)))) = prgname
			v1 = libc.Int32FromInt32(m_FcTrue)
		} else {
			v1 = m_FcFalse
		}
		if !(v1 != 0) {
			libc.Xfree(tls, prgname)
			goto retry
		}
	}
	if prgname != 0 && !(*(*TFcChar8)(unsafe.Pointer(prgname)) != 0) {
		return libc.UintptrFromInt32(0)
	}
	return prgname
}

func XFcDefaultFini(tls *libc.TLS) {
	var lang, langs, prgname uintptr
	var v1, v3, v5 int32
	var v2, v4, v6 bool
	_, _, _, _, _, _, _, _, _ = lang, langs, prgname, v1, v2, v3, v4, v5, v6
	lang = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_lang))))
	if v2 = lang != 0; v2 {
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_lang)))) == lang {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_lang)))) = libc.UintptrFromInt32(0)
			v1 = libc.Int32FromInt32(m_FcTrue)
		} else {
			v1 = m_FcFalse
		}
	}
	if v2 && v1 != 0 {
		libc.Xfree(tls, lang)
	}
	langs = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&Xdefault_langs))))
	if v4 = langs != 0; v4 {
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&Xdefault_langs)))) == langs {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&Xdefault_langs)))) = libc.UintptrFromInt32(0)
			v3 = libc.Int32FromInt32(m_FcTrue)
		} else {
			v3 = m_FcFalse
		}
	}
	if v4 && v3 != 0 {
		(*TFcRef)(unsafe.Pointer(langs)).Fcount = int32(1)
		XFcStrSetDestroy(tls, langs)
	}
	prgname = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_prgname))))
	if v6 = prgname != 0; v6 {
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_prgname)))) == prgname {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_prgname)))) = libc.UintptrFromInt32(0)
			v5 = libc.Int32FromInt32(m_FcTrue)
		} else {
			v5 = m_FcFalse
		}
	}
	if v6 && v5 != 0 {
		libc.Xfree(tls, prgname)
	}
}

func XFcDefaultSubstitute(tls *libc.TLS, pattern uintptr) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var i int32
	var pixelsize float64
	var prgname uintptr
	var _ /* b at bp+96 */ float64
	var _ /* dpi at bp+64 */ float64
	var _ /* e at bp+104 */ float64
	var _ /* iter at bp+0 */ TFcPatternIter
	var _ /* namelang at bp+32 */ TFcValue
	var _ /* r at bp+88 */ uintptr
	var _ /* scale at bp+80 */ float64
	var _ /* size at bp+72 */ float64
	var _ /* v at bp+16 */ TFcValue
	var _ /* v2 at bp+48 */ TFcValue
	_, _, _ = i, pixelsize, prgname
	if !(XFcPatternFindObjectIter(tls, pattern, bp, int32(_FC_WEIGHT_OBJECT)) != 0) {
		XFcPatternObjectAddInteger(tls, pattern, int32(_FC_WEIGHT_OBJECT), int32(m_FC_WEIGHT_REGULAR))
	}
	if !(XFcPatternFindObjectIter(tls, pattern, bp, int32(_FC_SLANT_OBJECT)) != 0) {
		XFcPatternObjectAddInteger(tls, pattern, int32(_FC_SLANT_OBJECT), m_FC_SLANT_ROMAN)
	}
	if !(XFcPatternFindObjectIter(tls, pattern, bp, int32(_FC_WIDTH_OBJECT)) != 0) {
		XFcPatternObjectAddInteger(tls, pattern, int32(_FC_WIDTH_OBJECT), int32(m_FC_WIDTH_NORMAL))
	}
	i = 0
	for {
		if !(i < libc.Int32FromUint64(libc.Uint64FromInt64(64)/libc.Uint64FromInt64(8))) {
			break
		}
		if !(XFcPatternFindObjectIter(tls, pattern, bp, _FcBoolDefaults[i].Ffield) != 0) {
			XFcPatternObjectAddBool(tls, pattern, _FcBoolDefaults[i].Ffield, _FcBoolDefaults[i].Fvalue)
		}
		goto _1
	_1:
		;
		i++
	}
	if XFcPatternObjectGetDouble(tls, pattern, int32(_FC_SIZE_OBJECT), 0, bp+72) != int32(_FcResultMatch) {
		if XFcPatternObjectGetRange(tls, pattern, int32(_FC_SIZE_OBJECT), 0, bp+88) == int32(_FcResultMatch) && XFcRangeGetDouble(tls, *(*uintptr)(unsafe.Pointer(bp + 88)), bp+96, bp+104) != 0 {
			*(*float64)(unsafe.Pointer(bp + 72)) = float64((*(*float64)(unsafe.Pointer(bp + 96)) + *(*float64)(unsafe.Pointer(bp + 104))) * float64(0.5))
		} else {
			*(*float64)(unsafe.Pointer(bp + 72)) = libc.Float64FromFloat64(12)
		}
	}
	if XFcPatternObjectGetDouble(tls, pattern, int32(_FC_SCALE_OBJECT), 0, bp+80) != int32(_FcResultMatch) {
		*(*float64)(unsafe.Pointer(bp + 80)) = float64(1)
	}
	if XFcPatternObjectGetDouble(tls, pattern, int32(_FC_DPI_OBJECT), 0, bp+64) != int32(_FcResultMatch) {
		*(*float64)(unsafe.Pointer(bp + 64)) = float64(75)
	}
	if !(XFcPatternFindObjectIter(tls, pattern, bp, int32(_FC_PIXEL_SIZE_OBJECT)) != 0) {
		XFcPatternObjectDel(tls, pattern, int32(_FC_SCALE_OBJECT))
		XFcPatternObjectAddDouble(tls, pattern, int32(_FC_SCALE_OBJECT), *(*float64)(unsafe.Pointer(bp + 80)))
		pixelsize = float64(*(*float64)(unsafe.Pointer(bp + 72)) * *(*float64)(unsafe.Pointer(bp + 80)))
		XFcPatternObjectDel(tls, pattern, int32(_FC_DPI_OBJECT))
		XFcPatternObjectAddDouble(tls, pattern, int32(_FC_DPI_OBJECT), *(*float64)(unsafe.Pointer(bp + 64)))
		pixelsize *= *(*float64)(unsafe.Pointer(bp + 64)) / float64(72)
		XFcPatternObjectAddDouble(tls, pattern, int32(_FC_PIXEL_SIZE_OBJECT), pixelsize)
	} else {
		XFcPatternIterGetValue(tls, pattern, bp, 0, bp+16, libc.UintptrFromInt32(0))
		*(*float64)(unsafe.Pointer(bp + 72)) = *(*float64)(unsafe.Pointer(bp + 16 + 8))
		*(*float64)(unsafe.Pointer(bp + 72)) = float64(*(*float64)(unsafe.Pointer(bp + 72)) / *(*float64)(unsafe.Pointer(bp + 64)) * float64(72)) / *(*float64)(unsafe.Pointer(bp + 80))
	}
	XFcPatternObjectDel(tls, pattern, int32(_FC_SIZE_OBJECT))
	XFcPatternObjectAddDouble(tls, pattern, int32(_FC_SIZE_OBJECT), *(*float64)(unsafe.Pointer(bp + 72)))
	if !(XFcPatternFindObjectIter(tls, pattern, bp, int32(_FC_FONTVERSION_OBJECT)) != 0) {
		XFcPatternObjectAddInteger(tls, pattern, int32(_FC_FONTVERSION_OBJECT), int32(0x7fffffff))
	}
	if !(XFcPatternFindObjectIter(tls, pattern, bp, int32(_FC_HINT_STYLE_OBJECT)) != 0) {
		XFcPatternObjectAddInteger(tls, pattern, int32(_FC_HINT_STYLE_OBJECT), int32(m_FC_HINT_FULL))
	}
	if !(XFcPatternFindObjectIter(tls, pattern, bp, int32(_FC_NAMELANG_OBJECT)) != 0) {
		XFcPatternObjectAddString(tls, pattern, int32(_FC_NAMELANG_OBJECT), XFcGetDefaultLang(tls))
	}
	/* shouldn't be failed. */
	XFcPatternObjectGet(tls, pattern, int32(_FC_NAMELANG_OBJECT), 0, bp+32)
	/* Add a fallback to ensure the english name when the requested language
	 * isn't available. this would helps for the fonts that have non-English
	 * name at the beginning.
	 */
	/* Set "en-us" instead of "en" to avoid giving higher score to "en".
	 * This is a hack for the case that the orth is not like ll-cc, because,
	 * if no namelang isn't explicitly set, it will has something like ll-cc
	 * according to current locale. which may causes FcLangDifferentTerritory
	 * at FcLangCompare(). thus, the English name is selected so that
	 * exact matched "en" has higher score than ll-cc.
	 */
	(*(*TFcValue)(unsafe.Pointer(bp + 48))).Ftype1 = int32(_FcTypeString)
	*(*uintptr)(unsafe.Pointer(bp + 48 + 8)) = __ccgo_ts + 2755
	if !(XFcPatternFindObjectIter(tls, pattern, bp, int32(_FC_FAMILYLANG_OBJECT)) != 0) {
		XFcPatternObjectAdd(tls, pattern, int32(_FC_FAMILYLANG_OBJECT), *(*TFcValue)(unsafe.Pointer(bp + 32)), int32(m_FcTrue))
		XFcPatternObjectAddWithBinding(tls, pattern, int32(_FC_FAMILYLANG_OBJECT), *(*TFcValue)(unsafe.Pointer(bp + 48)), int32(_FcValueBindingWeak), int32(m_FcTrue))
	}
	if !(XFcPatternFindObjectIter(tls, pattern, bp, int32(_FC_STYLELANG_OBJECT)) != 0) {
		XFcPatternObjectAdd(tls, pattern, int32(_FC_STYLELANG_OBJECT), *(*TFcValue)(unsafe.Pointer(bp + 32)), int32(m_FcTrue))
		XFcPatternObjectAddWithBinding(tls, pattern, int32(_FC_STYLELANG_OBJECT), *(*TFcValue)(unsafe.Pointer(bp + 48)), int32(_FcValueBindingWeak), int32(m_FcTrue))
	}
	if !(XFcPatternFindObjectIter(tls, pattern, bp, int32(_FC_FULLNAMELANG_OBJECT)) != 0) {
		XFcPatternObjectAdd(tls, pattern, int32(_FC_FULLNAMELANG_OBJECT), *(*TFcValue)(unsafe.Pointer(bp + 32)), int32(m_FcTrue))
		XFcPatternObjectAddWithBinding(tls, pattern, int32(_FC_FULLNAMELANG_OBJECT), *(*TFcValue)(unsafe.Pointer(bp + 48)), int32(_FcValueBindingWeak), int32(m_FcTrue))
	}
	if XFcPatternObjectGet(tls, pattern, int32(_FC_PRGNAME_OBJECT), 0, bp+16) == int32(_FcResultNoMatch) {
		prgname = XFcGetPrgname(tls)
		if prgname != 0 {
			XFcPatternObjectAddString(tls, pattern, int32(_FC_PRGNAME_OBJECT), prgname)
		}
	}
	if !(XFcPatternFindObjectIter(tls, pattern, bp, int32(_FC_ORDER_OBJECT)) != 0) {
		XFcPatternObjectAddInteger(tls, pattern, int32(_FC_ORDER_OBJECT), 0)
	}
}

const m_S_IFDIR1 = 16384
const m_S_IFLNK1 = 40960
const m_S_IFMT3 = 61440
const m_S_IFREG1 = 32768

func XFcFileIsDir(tls *libc.TLS, file uintptr) (r TFcBool) {
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var _ /* statb at bp+0 */ Tstat
	if XFcStat(tls, file, bp) != 0 {
		return m_FcFalse
	}
	return libc.BoolInt32(libc.Int32FromUint16((*(*Tstat)(unsafe.Pointer(bp))).Fst_mode)&libc.Int32FromInt32(m_S_IFMT3) == libc.Int32FromInt32(m_S_IFDIR1))
}

func XFcFileIsLink(tls *libc.TLS, file uintptr) (r TFcBool) {
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var _ /* statb at bp+0 */ Tstat
	if libc.Xlstat(tls, file, bp) != 0 {
		return m_FcFalse
	}
	return libc.BoolInt32(libc.Int32FromUint16((*(*Tstat)(unsafe.Pointer(bp))).Fst_mode)&libc.Int32FromInt32(m_S_IFMT3) == libc.Int32FromInt32(m_S_IFLNK1))
}

func XFcFileIsFile(tls *libc.TLS, file uintptr) (r TFcBool) {
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var _ /* statb at bp+0 */ Tstat
	if XFcStat(tls, file, bp) != 0 {
		return m_FcFalse
	}
	return libc.BoolInt32(libc.Int32FromUint16((*(*Tstat)(unsafe.Pointer(bp))).Fst_mode)&libc.Int32FromInt32(m_S_IFMT3) == libc.Int32FromInt32(m_S_IFREG1))
}

func _FcFileScanFontConfig(tls *libc.TLS, set uintptr, file uintptr, config uintptr) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var font, s, sysroot uintptr
	var i, old_nfont int32
	var len1 Tsize_t
	var ret TFcBool
	var _ /* f at bp+0 */ uintptr
	_, _, _, _, _, _, _ = font, i, len1, old_nfont, ret, s, sysroot
	ret = int32(m_FcTrue)
	old_nfont = (*TFcFontSet)(unsafe.Pointer(set)).Fnfont
	sysroot = XFcConfigGetSysRoot(tls, config)
	if XFcDebugVal&int32(m_FC_DBG_SCAN) != 0 {
		libc.Xprintf(tls, __ccgo_ts+2761, libc.VaList(bp+16, file))
		libc.Xfflush(tls, libc.X__stdoutp)
	}
	if !(XFcFreeTypeQueryAll(tls, file, libc.Uint32FromInt32(-libc.Int32FromInt32(1)), libc.UintptrFromInt32(0), libc.UintptrFromInt32(0), set) != 0) {
		return m_FcFalse
	}
	if XFcDebugVal&int32(m_FC_DBG_SCAN) != 0 {
		libc.Xprintf(tls, __ccgo_ts+2782, 0)
	}
	i = old_nfont
	for {
		if !(i < (*TFcFontSet)(unsafe.Pointer(set)).Fnfont) {
			break
		}
		font = *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(set)).Ffonts + uintptr(i)*8))
		/*
		 * Get rid of sysroot here so that targeting scan rule may contains FC_FILE pattern
		 * and they should usually expect without sysroot.
		 */
		if sysroot != 0 {
			len1 = libc.Xstrlen(tls, sysroot)
			*(*uintptr)(unsafe.Pointer(bp)) = libc.UintptrFromInt32(0)
			if XFcPatternObjectGetString(tls, font, int32(_FC_FILE_OBJECT), 0, bp) == int32(_FcResultMatch) && libc.Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(bp)), sysroot, len1) == 0 {
				s = libc.Xstrdup(tls, *(*uintptr)(unsafe.Pointer(bp)))
				XFcPatternObjectDel(tls, font, int32(_FC_FILE_OBJECT))
				if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s + uintptr(len1)))) != int32('/') {
					len1--
				} else {
					if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s + uintptr(len1+uint64(1))))) == int32('/') {
						len1++
					}
				}
				XFcPatternObjectAddString(tls, font, int32(_FC_FILE_OBJECT), s+uintptr(len1))
				XFcStrFree(tls, s)
			}
		}
		/*
		 * Edit pattern with user-defined rules
		 */
		if config != 0 && !(XFcConfigSubstitute(tls, config, font, int32(_FcMatchScan)) != 0) {
			ret = m_FcFalse
		}
		if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
			libc.Xprintf(tls, __ccgo_ts+2788, 0)
			XFcPatternPrint(tls, font)
		}
		goto _1
	_1:
		;
		i++
	}
	return ret
}

func XFcFileScanConfig(tls *libc.TLS, set uintptr, dirs uintptr, file uintptr, config uintptr) (r TFcBool) {
	var d, sysroot uintptr
	var len1 Tsize_t
	_, _, _ = d, len1, sysroot
	if XFcFileIsDir(tls, file) != 0 {
		sysroot = XFcConfigGetSysRoot(tls, config)
		d = file
		if sysroot != 0 {
			len1 = libc.Xstrlen(tls, sysroot)
			if libc.Xstrncmp(tls, file, sysroot, len1) == 0 {
				if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(file + uintptr(len1)))) != int32('/') {
					len1--
				} else {
					if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(file + uintptr(len1+uint64(1))))) == int32('/') {
						len1++
					}
				}
				d = file + uintptr(len1)
			}
		}
		return XFcStrSetAdd(tls, dirs, d)
	} else {
		if set != 0 {
			return _FcFileScanFontConfig(tls, set, file, config)
		} else {
			return int32(m_FcTrue)
		}
	}
	return r
}

func XFcFileScan(tls *libc.TLS, set uintptr, dirs uintptr, cache uintptr, blanks uintptr, file uintptr, force TFcBool) (r TFcBool) {
	var config uintptr
	var ret TFcBool
	_, _ = config, ret
	config = XFcConfigReference(tls, libc.UintptrFromInt32(0))
	if !(config != 0) {
		return m_FcFalse
	}
	ret = XFcFileScanConfig(tls, set, dirs, file, config)
	XFcConfigDestroy(tls, config)
	return ret
}

// C documentation
//
//	/*
//	 * Strcmp helper that takes pointers to pointers, copied from qsort(3) manpage
//	 */
func _cmpstringp(tls *libc.TLS, p1 uintptr, p2 uintptr) (r int32) {
	return libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(p1)), *(*uintptr)(unsafe.Pointer(p2)))
}

func XFcDirScanConfig(tls *libc.TLS, set uintptr, dirs uintptr, dir uintptr, force TFcBool, config uintptr) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var base, d, e, file_prefix, files, s_dir, sysroot, v1 uintptr
	var i int32
	var ret TFcBool
	_, _, _, _, _, _, _, _, _, _ = base, d, e, file_prefix, files, i, ret, s_dir, sysroot, v1
	s_dir = libc.UintptrFromInt32(0)
	sysroot = XFcConfigGetSysRoot(tls, config)
	ret = int32(m_FcTrue)
	if !(force != 0) {
		return m_FcFalse
	}
	if !(set != 0) && !(dirs != 0) {
		return int32(m_FcTrue)
	}
	/* freed below */
	file_prefix = libc.Xmalloc(tls, libc.Xstrlen(tls, dir)+uint64(1)+uint64(m_FC_MAX_FILE_LEN)+uint64(1))
	if !(file_prefix != 0) {
		ret = m_FcFalse
		goto bail
	}
	libc.X__builtin___strcpy_chk(tls, file_prefix, dir, ^t__predefined_size_t(0))
	libc.X__builtin___strcat_chk(tls, file_prefix, __ccgo_ts+1485, ^t__predefined_size_t(0))
	base = file_prefix + uintptr(libc.Xstrlen(tls, file_prefix))
	if sysroot != 0 {
		s_dir = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+8, dir, libc.UintptrFromInt32(0)))
	} else {
		s_dir = libc.Xstrdup(tls, dir)
	}
	if !(s_dir != 0) {
		ret = m_FcFalse
		goto bail
	}
	if XFcDebugVal&int32(m_FC_DBG_SCAN) != 0 {
		libc.Xprintf(tls, __ccgo_ts+2809, libc.VaList(bp+8, s_dir))
	}
	d = libc.Xopendir(tls, s_dir)
	if !(d != 0) {
		/* Don't complain about missing directories */
		if *(*int32)(unsafe.Pointer(libc.X__error(tls))) != int32(m_ENOENT) {
			ret = m_FcFalse
		}
		goto bail
	}
	files = XFcStrSetCreateEx(tls, libc.Uint32FromInt32(libc.Int32FromInt32(m_FCSS_ALLOW_DUPLICATES)|libc.Int32FromInt32(m_FCSS_GROW_BY_64)))
	if !(files != 0) {
		ret = m_FcFalse
		goto bail1
	}
	for {
		v1 = libc.Xreaddir(tls, d)
		e = v1
		if !(v1 != 0) {
			break
		}
		if int32(*(*int8)(unsafe.Pointer(e + 21))) != int32('.') && libc.Xstrlen(tls, e+21) < uint64(m_FC_MAX_FILE_LEN) {
			libc.X__builtin___strcpy_chk(tls, base, e+21, ^t__predefined_size_t(0))
			if !(XFcStrSetAdd(tls, files, file_prefix) != 0) {
				ret = m_FcFalse
				goto bail2
			}
		}
	}
	/*
	 * Sort files to make things prettier
	 */
	libc.Xqsort(tls, (*TFcStrSet)(unsafe.Pointer(files)).Fstrs, libc.Uint64FromInt32((*TFcStrSet)(unsafe.Pointer(files)).Fnum), uint64(8), __ccgo_fp(_cmpstringp))
	/*
	 * Scan file files to build font patterns
	 */
	i = 0
	for {
		if !(i < (*TFcStrSet)(unsafe.Pointer(files)).Fnum) {
			break
		}
		XFcFileScanConfig(tls, set, dirs, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(files)).Fstrs + uintptr(i)*8)), config)
		goto _2
	_2:
		;
		i++
	}
	goto bail2
bail2:
	;
	XFcStrSetDestroy(tls, files)
	goto bail1
bail1:
	;
	libc.Xclosedir(tls, d)
	goto bail
bail:
	;
	if s_dir != 0 {
		libc.Xfree(tls, s_dir)
	}
	if file_prefix != 0 {
		libc.Xfree(tls, file_prefix)
	}
	return ret
}

func XFcDirScan(tls *libc.TLS, set uintptr, dirs uintptr, cache uintptr, blanks uintptr, dir uintptr, force TFcBool) (r TFcBool) {
	var config uintptr
	var ret TFcBool
	_, _ = config, ret
	if cache != 0 || !(force != 0) {
		return m_FcFalse
	}
	config = XFcConfigReference(tls, libc.UintptrFromInt32(0))
	if !(config != 0) {
		return m_FcFalse
	}
	ret = XFcDirScanConfig(tls, set, dirs, dir, force, config)
	XFcConfigDestroy(tls, config)
	return ret
}

// C documentation
//
//	/*
//	 * Scan the specified directory and construct a cache of its contents
//	 */
func XFcDirCacheScan(tls *libc.TLS, dir uintptr, config uintptr) (r uintptr) {
	bp := tls.Alloc(176)
	defer tls.Free(176)
	var cache, d, dirs, set, sysroot uintptr
	var fd int32
	var _ /* dir_stat at bp+0 */ Tstat
	_, _, _, _, _, _ = cache, d, dirs, fd, set, sysroot
	cache = libc.UintptrFromInt32(0)
	sysroot = XFcConfigGetSysRoot(tls, config)
	fd = -int32(1)
	if sysroot != 0 {
		d = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+152, dir, libc.UintptrFromInt32(0)))
	} else {
		d = libc.Xstrdup(tls, dir)
	}
	if XFcDebugVal&int32(m_FC_DBG_FONTSET) != 0 {
		libc.Xprintf(tls, __ccgo_ts+2827, libc.VaList(bp+152, d))
	}
	if XFcStatChecksum(tls, d, bp) < 0 {
		goto bail
	}
	set = XFcFontSetCreate(tls)
	if !(set != 0) {
		goto bail
	}
	dirs = XFcStrSetCreateEx(tls, uint32(m_FCSS_GROW_BY_64))
	if !(dirs != 0) {
		goto bail1
	}
	fd = XFcDirCacheLock(tls, dir, config)
	/*
	 * Scan the dir
	 */
	/* Do not pass sysroot here. FcDirScanConfig() do take care of it */
	if !(XFcDirScanConfig(tls, set, dirs, dir, int32(m_FcTrue), config) != 0) {
		goto bail2
	}
	/*
	 * Build the cache object
	 */
	cache = XFcDirCacheBuild(tls, set, dir, bp, dirs)
	if !(cache != 0) {
		goto bail2
	}
	/*
	 * Write out the cache file, ignoring any troubles
	 */
	XFcDirCacheWrite(tls, cache, config)
	goto bail2
bail2:
	;
	XFcDirCacheUnlock(tls, fd)
	XFcStrSetDestroy(tls, dirs)
	goto bail1
bail1:
	;
	XFcFontSetDestroy(tls, set)
	goto bail
bail:
	;
	XFcStrFree(tls, d)
	return cache
}

func XFcDirCacheRescan(tls *libc.TLS, dir uintptr, config uintptr) (r uintptr) {
	bp := tls.Alloc(176)
	defer tls.Free(176)
	var cache, d, dirs, new1, sysroot uintptr
	var fd int32
	var _ /* dir_stat at bp+0 */ Tstat
	_, _, _, _, _, _ = cache, d, dirs, fd, new1, sysroot
	new1 = libc.UintptrFromInt32(0)
	d = libc.UintptrFromInt32(0)
	fd = -int32(1)
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return libc.UintptrFromInt32(0)
	}
	sysroot = XFcConfigGetSysRoot(tls, config)
	cache = XFcDirCacheLoad(tls, dir, config, libc.UintptrFromInt32(0))
	if !(cache != 0) {
		goto bail
	}
	if sysroot != 0 {
		d = XFcStrBuildFilename(tls, sysroot, libc.VaList(bp+152, dir, libc.UintptrFromInt32(0)))
	} else {
		d = libc.Xstrdup(tls, dir)
	}
	if XFcStatChecksum(tls, d, bp) < 0 {
		goto bail
	}
	dirs = XFcStrSetCreateEx(tls, uint32(m_FCSS_GROW_BY_64))
	if !(dirs != 0) {
		goto bail
	}
	fd = XFcDirCacheLock(tls, dir, config)
	/*
	 * Scan the dir
	 */
	/* Do not pass sysroot here. FcDirScanConfig() do take care of it */
	if !(XFcDirScanConfig(tls, libc.UintptrFromInt32(0), dirs, dir, int32(m_FcTrue), config) != 0) {
		goto bail1
	}
	/*
	 * Rebuild the cache object
	 */
	new1 = XFcDirCacheRebuild(tls, cache, bp, dirs)
	if !(new1 != 0) {
		goto bail1
	}
	XFcDirCacheUnload(tls, cache)
	/*
	 * Write out the cache file, ignoring any troubles
	 */
	XFcDirCacheWrite(tls, new1, config)
	goto bail1
bail1:
	;
	XFcDirCacheUnlock(tls, fd)
	XFcStrSetDestroy(tls, dirs)
	goto bail
bail:
	;
	if d != 0 {
		XFcStrFree(tls, d)
	}
	XFcConfigDestroy(tls, config)
	return new1
}

// C documentation
//
//	/*
//	 * Read (or construct) the cache for a directory
//	 */
func XFcDirCacheRead(tls *libc.TLS, dir uintptr, force TFcBool, config uintptr) (r uintptr) {
	var cache uintptr
	_ = cache
	cache = libc.UintptrFromInt32(0)
	config = XFcConfigReference(tls, config)
	/* Try to use existing cache file */
	if !(force != 0) {
		cache = XFcDirCacheLoad(tls, dir, config, libc.UintptrFromInt32(0))
	}
	/* Not using existing cache file, construct new cache */
	if !(cache != 0) {
		cache = XFcDirCacheScan(tls, dir, config)
	}
	XFcConfigDestroy(tls, config)
	return cache
}

func XFcDirSave(tls *libc.TLS, set uintptr, dirs uintptr, dir uintptr) (r TFcBool) {
	return m_FcFalse /* XXX deprecated */
}

const m_FCCAT_FORMAT = "\"%{file|basename|cescape}\" %{index} \"%{-file{%{=unparse|cescape}}}\""
const m_FCLIST_FORMAT = "%{?file{%{file}: }}%{-file{%{=unparse}}}"
const m_FCMATCH_FORMAT = "%{file:-<unknown filename>|basename}: \"%{family[0]:-<unknown family>}\" \"%{style[0]:-<unknown style>}\""
const m_PKGKIT_FORMAT = "%{[]family{font(%{family|downcase|delete( )})\n}}%{[]lang{font(:lang=%{lang|downcase|translate(_,-)})\n}}"
const m_S_IFDIR2 = 0040000
const m_S_IFLNK2 = 0120000
const m_S_IFMT4 = 0170000
const m_S_IFREG2 = 0100000

/*
 * Copyright (c) 2000, 2002 - 2008, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2000, 2007, 2010, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

/*===---- stdarg.h - Variable argument handling ----------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*
 * This header is designed to be included multiple times. If any of the __need_
 * macros are defined, then only that subset of interfaces are provided. This
 * can be useful for POSIX headers that need to not expose all of stdarg.h, but
 * need to use some of its interfaces. Otherwise this header provides all of
 * the expected interfaces.
 *
 * When clang modules are enabled, this header is a textual header to support
 * the multiple include behavior. As such, it doesn't directly declare anything
 * so that it doesn't add duplicate declarations to all of its includers'
 * modules.
 */
/* GCC always defines __va_copy, but does not define va_copy unless in c99 mode
 * or -ansi is not specified, since it was not part of C90.
 */
/*===---- __stdarg_header_macro.h ------------------------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*===---- __stdarg___gnuc_va_list.h - Definition of __gnuc_va_list ---------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*===---- __stdarg_va_list.h - Definition of va_list -----------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*===---- __stdarg_va_arg.h - Definitions of va_start, va_arg, va_end-------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*===---- __stdarg___va_copy.h - Definition of __va_copy -------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*===---- __stdarg_va_copy.h - Definition of va_copy------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/* The language is documented in doc/fcformat.fncs
 * These are the features implemented:
 *
 * simple	%{elt}
 * width	%width{elt}
 * index	%{elt[idx]}
 * name=	%{elt=}
 * :name=	%{:elt}
 * default	%{elt:-word}
 * count	%{#elt}
 * subexpr	%{{expr}}
 * filter-out	%{-elt1,elt2,elt3{expr}}
 * filter-in	%{+elt1,elt2,elt3{expr}}
 * conditional	%{?elt1,elt2,!elt3{}{}}
 * enumerate	%{[]elt1,elt2{expr}}
 * langset	langset enumeration using the same syntax
 * builtin	%{=blt}
 * convert	%{elt|conv1|conv2|conv3}
 *
 * converters:
 * basename	FcStrBasename
 * dirname	FcStrDirname
 * downcase	FcStrDowncase
 * shescape
 * cescape
 * xmlescape
 * delete	delete chars
 * escape	escape chars
 * translate	translate chars
 *
 * builtins:
 * unparse	FcNameUnparse
 * fcmatch	fc-match default
 * fclist	fc-list default
 * fccat	fc-cat default
 * pkgkit	PackageKit package tag format
 *
 *
 * Some ideas for future syntax extensions:
 *
 * - verbose builtin that is like FcPatternPrint
 * - allow indexing subexprs using '%{[idx]elt1,elt2{subexpr}}'
 * - allow indexing in +, -, ? filtering?
 * - conditional/filtering/deletion on binding (using '(w)'/'(s)'/'(=)' notation)
 */

func _message(tls *libc.TLS, fmt uintptr, va uintptr) {
	var args Tva_list
	_ = args
	args = va
	libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+2846, 0)
	libc.Xvfprintf(tls, libc.X__stderrp, fmt, args)
	libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+2881, 0)
	_ = args
}

type TFcFormatContext = struct {
	Fformat_orig    uintptr
	Fformat         uintptr
	Fformat_len     int32
	Fword           uintptr
	Fword_allocated TFcBool
}

type T_FcFormatContext = TFcFormatContext

func _FcFormatContextInit(tls *libc.TLS, c uintptr, format uintptr, scratch uintptr, scratch_len int32) (r TFcBool) {
	var v1 uintptr
	_ = v1
	v1 = format
	(*TFcFormatContext)(unsafe.Pointer(c)).Fformat = v1
	(*TFcFormatContext)(unsafe.Pointer(c)).Fformat_orig = v1
	(*TFcFormatContext)(unsafe.Pointer(c)).Fformat_len = libc.Int32FromUint64(libc.Xstrlen(tls, format))
	if (*TFcFormatContext)(unsafe.Pointer(c)).Fformat_len < scratch_len {
		(*TFcFormatContext)(unsafe.Pointer(c)).Fword = scratch
		(*TFcFormatContext)(unsafe.Pointer(c)).Fword_allocated = m_FcFalse
	} else {
		(*TFcFormatContext)(unsafe.Pointer(c)).Fword = libc.Xmalloc(tls, libc.Uint64FromInt32((*TFcFormatContext)(unsafe.Pointer(c)).Fformat_len+int32(1)))
		(*TFcFormatContext)(unsafe.Pointer(c)).Fword_allocated = int32(m_FcTrue)
	}
	return libc.BoolInt32((*TFcFormatContext)(unsafe.Pointer(c)).Fword != libc.UintptrFromInt32(0))
}

func _FcFormatContextDone(tls *libc.TLS, c uintptr) {
	if c != 0 && (*TFcFormatContext)(unsafe.Pointer(c)).Fword_allocated != 0 {
		libc.Xfree(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword)
	}
}

func _consume_char(tls *libc.TLS, c uintptr, term TFcChar8) (r TFcBool) {
	if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) != libc.Int32FromUint8(term) {
		return m_FcFalse
	}
	(*TFcFormatContext)(unsafe.Pointer(c)).Fformat++
	return int32(m_FcTrue)
}

func _expect_char(tls *libc.TLS, c uintptr, term TFcChar8) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var res TFcBool
	_ = res
	res = _consume_char(tls, c, term)
	if !(res != 0) {
		if (*TFcFormatContext)(unsafe.Pointer(c)).Fformat == (*TFcFormatContext)(unsafe.Pointer(c)).Fformat_orig+uintptr((*TFcFormatContext)(unsafe.Pointer(c)).Fformat_len) {
			_message(tls, __ccgo_ts+2884, libc.VaList(bp+8, libc.Int32FromUint8(term)))
		} else {
			_message(tls, __ccgo_ts+2918, libc.VaList(bp+8, libc.Int32FromUint8(term), int64((*TFcFormatContext)(unsafe.Pointer(c)).Fformat)-int64((*TFcFormatContext)(unsafe.Pointer(c)).Fformat_orig)+int64(1)))
		}
	}
	return res
}

func _FcCharIsPunct(tls *libc.TLS, c TFcChar8) (r TFcBool) {
	if libc.Int32FromUint8(c) < int32('0') {
		return int32(m_FcTrue)
	}
	if libc.Int32FromUint8(c) <= int32('9') {
		return m_FcFalse
	}
	if libc.Int32FromUint8(c) < int32('A') {
		return int32(m_FcTrue)
	}
	if libc.Int32FromUint8(c) <= int32('Z') {
		return m_FcFalse
	}
	if libc.Int32FromUint8(c) < int32('a') {
		return int32(m_FcTrue)
	}
	if libc.Int32FromUint8(c) <= int32('z') {
		return m_FcFalse
	}
	if libc.Int32FromUint8(c) <= int32('~') {
		return int32(m_FcTrue)
	}
	return m_FcFalse
}

func _escaped_char(tls *libc.TLS, ch int8) (r int8) {
	switch int32(ch) {
	case int32('a'):
		return int8('\a')
	case int32('b'):
		return int8('\b')
	case int32('f'):
		return int8('\f')
	case int32('n'):
		return int8('\n')
	case int32('r'):
		return int8('\r')
	case int32('t'):
		return int8('\t')
	case int32('v'):
		return int8('\v')
	default:
		return ch
	}
	return r
}

func _read_word(tls *libc.TLS, c uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var p, v1, v2, v3, v4, v5, v6 uintptr
	_, _, _, _, _, _, _ = p, v1, v2, v3, v4, v5, v6
	p = (*TFcFormatContext)(unsafe.Pointer(c)).Fword
	for *(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat)) != 0 {
		if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) == int32('\\') {
			(*TFcFormatContext)(unsafe.Pointer(c)).Fformat++
			if *(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat)) != 0 {
				v1 = p
				p++
				v3 = c + 8
				v2 = *(*uintptr)(unsafe.Pointer(v3))
				*(*uintptr)(unsafe.Pointer(v3))++
				*(*TFcChar8)(unsafe.Pointer(v1)) = libc.Uint8FromInt8(_escaped_char(tls, libc.Int8FromUint8(*(*TFcChar8)(unsafe.Pointer(v2)))))
			}
			continue
		} else {
			if _FcCharIsPunct(tls, *(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) != 0 {
				break
			}
		}
		v4 = p
		p++
		v6 = c + 8
		v5 = *(*uintptr)(unsafe.Pointer(v6))
		*(*uintptr)(unsafe.Pointer(v6))++
		*(*TFcChar8)(unsafe.Pointer(v4)) = *(*TFcChar8)(unsafe.Pointer(v5))
	}
	*(*TFcChar8)(unsafe.Pointer(p)) = uint8('\000')
	if p == (*TFcFormatContext)(unsafe.Pointer(c)).Fword {
		_message(tls, __ccgo_ts+2938, libc.VaList(bp+8, int64((*TFcFormatContext)(unsafe.Pointer(c)).Fformat)-int64((*TFcFormatContext)(unsafe.Pointer(c)).Fformat_orig)+int64(1)))
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

func _read_chars(tls *libc.TLS, c uintptr, term TFcChar8) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var p, v1, v2, v3, v4, v5, v6 uintptr
	_, _, _, _, _, _, _ = p, v1, v2, v3, v4, v5, v6
	p = (*TFcFormatContext)(unsafe.Pointer(c)).Fword
	for *(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat)) != 0 && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) != int32('}') && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) != libc.Int32FromUint8(term) {
		if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) == int32('\\') {
			(*TFcFormatContext)(unsafe.Pointer(c)).Fformat++
			if *(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat)) != 0 {
				v1 = p
				p++
				v3 = c + 8
				v2 = *(*uintptr)(unsafe.Pointer(v3))
				*(*uintptr)(unsafe.Pointer(v3))++
				*(*TFcChar8)(unsafe.Pointer(v1)) = libc.Uint8FromInt8(_escaped_char(tls, libc.Int8FromUint8(*(*TFcChar8)(unsafe.Pointer(v2)))))
			}
			continue
		}
		v4 = p
		p++
		v6 = c + 8
		v5 = *(*uintptr)(unsafe.Pointer(v6))
		*(*uintptr)(unsafe.Pointer(v6))++
		*(*TFcChar8)(unsafe.Pointer(v4)) = *(*TFcChar8)(unsafe.Pointer(v5))
	}
	*(*TFcChar8)(unsafe.Pointer(p)) = uint8('\000')
	if p == (*TFcFormatContext)(unsafe.Pointer(c)).Fword {
		_message(tls, __ccgo_ts+2964, libc.VaList(bp+8, int64((*TFcFormatContext)(unsafe.Pointer(c)).Fformat)-int64((*TFcFormatContext)(unsafe.Pointer(c)).Fformat_orig)+int64(1)))
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

func _interpret_builtin(tls *libc.TLS, c uintptr, pat uintptr, buf uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var new_str uintptr
	var ret TFcBool
	_, _ = new_str, ret
	if !(_expect_char(tls, c, uint8('=')) != 0) || !(_read_word(tls, c) != 0) {
		return m_FcFalse
	}
	/* try simple builtins first */
	if 0 != 0 {
	} else {
		if 0 == libc.Xstrcmp(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, __ccgo_ts+2994) {
			new_str = XFcNameUnparse(tls, pat)
			ret = int32(m_FcTrue)
		} else {
			ret = m_FcFalse
		}
	}
	if ret != 0 {
		if new_str != 0 {
			XFcStrBufString(tls, buf, new_str)
			XFcStrFree(tls, new_str)
			return int32(m_FcTrue)
		} else {
			return m_FcFalse
		}
	}
	/* now try our custom formats */
	if 0 != 0 {
	} else {
		if 0 == libc.Xstrcmp(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, __ccgo_ts+3002) {
			ret = _FcPatternFormatToBuf(tls, pat, __ccgo_ts+3008, buf)
		} else {
			if 0 == libc.Xstrcmp(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, __ccgo_ts+3076) {
				ret = _FcPatternFormatToBuf(tls, pat, __ccgo_ts+3084, buf)
			} else {
				if 0 == libc.Xstrcmp(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, __ccgo_ts+3186) {
					ret = _FcPatternFormatToBuf(tls, pat, __ccgo_ts+3193, buf)
				} else {
					if 0 == libc.Xstrcmp(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, __ccgo_ts+3234) {
						ret = _FcPatternFormatToBuf(tls, pat, __ccgo_ts+3241, buf)
					} else {
						ret = m_FcFalse
					}
				}
			}
		}
	}
	if !(ret != 0) {
		_message(tls, __ccgo_ts+3345, libc.VaList(bp+8, (*TFcFormatContext)(unsafe.Pointer(c)).Fword))
	}
	return ret
}

func _interpret_subexpr(tls *libc.TLS, c uintptr, pat uintptr, buf uintptr) (r TFcBool) {
	return libc.BoolInt32(_expect_char(tls, c, uint8('{')) != 0 && _interpret_expr(tls, c, pat, buf, uint8('}')) != 0 && _expect_char(tls, c, uint8('}')) != 0)
}

func _maybe_interpret_subexpr(tls *libc.TLS, c uintptr, pat uintptr, buf uintptr) (r TFcBool) {
	var v1 int32
	_ = v1
	if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) == int32('{') {
		v1 = _interpret_subexpr(tls, c, pat, buf)
	} else {
		v1 = int32(m_FcTrue)
	}
	return v1
}

func _skip_percent(tls *libc.TLS, c uintptr) (r TFcBool) {
	if !(_expect_char(tls, c, uint8('%')) != 0) {
		return m_FcFalse
	}
	/* skip an optional width specifier */
	if libc.Xstrtol(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fformat, c+8, int32(10)) != 0 {
		/* don't care */
	}
	if !(_expect_char(tls, c, uint8('{')) != 0) {
		return m_FcFalse
	}
	for *(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat)) != 0 && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) != int32('}') {
		switch libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) {
		case int32('\\'):
			(*TFcFormatContext)(unsafe.Pointer(c)).Fformat++ /* skip over '\\' */
			if *(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat)) != 0 {
				(*TFcFormatContext)(unsafe.Pointer(c)).Fformat++
			}
			continue
		case int32('{'):
			if !(_skip_subexpr(tls, c) != 0) {
				return m_FcFalse
			}
			continue
		}
		(*TFcFormatContext)(unsafe.Pointer(c)).Fformat++
	}
	return _expect_char(tls, c, uint8('}'))
}

func _skip_expr(tls *libc.TLS, c uintptr) (r TFcBool) {
	for *(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat)) != 0 && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) != int32('}') {
		switch libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) {
		case int32('\\'):
			(*TFcFormatContext)(unsafe.Pointer(c)).Fformat++ /* skip over '\\' */
			if *(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat)) != 0 {
				(*TFcFormatContext)(unsafe.Pointer(c)).Fformat++
			}
			continue
		case int32('%'):
			if !(_skip_percent(tls, c) != 0) {
				return m_FcFalse
			}
			continue
		}
		(*TFcFormatContext)(unsafe.Pointer(c)).Fformat++
	}
	return int32(m_FcTrue)
}

func _skip_subexpr(tls *libc.TLS, c uintptr) (r TFcBool) {
	return libc.BoolInt32(_expect_char(tls, c, uint8('{')) != 0 && _skip_expr(tls, c) != 0 && _expect_char(tls, c, uint8('}')) != 0)
}

func _maybe_skip_subexpr(tls *libc.TLS, c uintptr) (r TFcBool) {
	var v1 int32
	_ = v1
	if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) == int32('{') {
		v1 = _skip_subexpr(tls, c)
	} else {
		v1 = int32(m_FcTrue)
	}
	return v1
}

func _interpret_filter_in(tls *libc.TLS, c uintptr, pat uintptr, buf uintptr) (r TFcBool) {
	var os, subpat uintptr
	_, _ = os, subpat
	if !(_expect_char(tls, c, uint8('+')) != 0) {
		return m_FcFalse
	}
	os = XFcObjectSetCreate(tls)
	if !(os != 0) {
		return m_FcFalse
	}
	for cond := true; cond; cond = _consume_char(tls, c, uint8(',')) != 0 {
		/* XXX binding */
		if !(_read_word(tls, c) != 0) || !(XFcObjectSetAdd(tls, os, (*TFcFormatContext)(unsafe.Pointer(c)).Fword) != 0) {
			XFcObjectSetDestroy(tls, os)
			return m_FcFalse
		}
	}
	subpat = XFcPatternFilter(tls, pat, os)
	XFcObjectSetDestroy(tls, os)
	if !(subpat != 0) || !(_interpret_subexpr(tls, c, subpat, buf) != 0) {
		return m_FcFalse
	}
	XFcPatternDestroy(tls, subpat)
	return int32(m_FcTrue)
}

func _interpret_filter_out(tls *libc.TLS, c uintptr, pat uintptr, buf uintptr) (r TFcBool) {
	var subpat uintptr
	_ = subpat
	if !(_expect_char(tls, c, uint8('-')) != 0) {
		return m_FcFalse
	}
	subpat = XFcPatternDuplicate(tls, pat)
	if !(subpat != 0) {
		return m_FcFalse
	}
	for cond := true; cond; cond = _consume_char(tls, c, uint8(',')) != 0 {
		if !(_read_word(tls, c) != 0) {
			XFcPatternDestroy(tls, subpat)
			return m_FcFalse
		}
		XFcPatternDel(tls, subpat, (*TFcFormatContext)(unsafe.Pointer(c)).Fword)
	}
	if !(_interpret_subexpr(tls, c, subpat, buf) != 0) {
		return m_FcFalse
	}
	XFcPatternDestroy(tls, subpat)
	return int32(m_FcTrue)
}

func _interpret_cond(tls *libc.TLS, c uintptr, pat uintptr, buf uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var negate, pass TFcBool
	var _ /* v at bp+0 */ TFcValue
	_, _ = negate, pass
	if !(_expect_char(tls, c, uint8('?')) != 0) {
		return m_FcFalse
	}
	pass = int32(m_FcTrue)
	for cond := true; cond; cond = _consume_char(tls, c, uint8(',')) != 0 {
		negate = _consume_char(tls, c, uint8('!'))
		if !(_read_word(tls, c) != 0) {
			return m_FcFalse
		}
		pass = libc.BoolInt32(pass != 0 && negate^libc.BoolInt32(int32(_FcResultMatch) == XFcPatternGet(tls, pat, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, 0, bp)) != 0)
	}
	if pass != 0 {
		if !(_interpret_subexpr(tls, c, pat, buf) != 0) || !(_maybe_skip_subexpr(tls, c) != 0) {
			return m_FcFalse
		}
	} else {
		if !(_skip_subexpr(tls, c) != 0) || !(_maybe_interpret_subexpr(tls, c, pat, buf) != 0) {
			return m_FcFalse
		}
	}
	return int32(m_FcTrue)
}

func _interpret_count(tls *libc.TLS, c uintptr, pat uintptr, buf uintptr) (r TFcBool) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var count int32
	var _ /* buf_static at bp+16 */ [64]TFcChar8
	var _ /* iter at bp+0 */ TFcPatternIter
	_ = count
	if !(_expect_char(tls, c, uint8('#')) != 0) {
		return m_FcFalse
	}
	if !(_read_word(tls, c) != 0) {
		return m_FcFalse
	}
	count = 0
	if XFcPatternFindIter(tls, pat, bp, (*TFcFormatContext)(unsafe.Pointer(c)).Fword) != 0 {
		count = XFcPatternIterValueCount(tls, pat, bp)
	}
	libc.X__builtin___snprintf_chk(tls, bp+16, uint64(64), 0, ^t__predefined_size_t(0), __ccgo_ts+2470, libc.VaList(bp+88, count))
	XFcStrBufString(tls, buf, bp+16)
	return int32(m_FcTrue)
}

func _interpret_enumerate(tls *libc.TLS, c uintptr, pat uintptr, buf uintptr) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var done, ret TFcBool
	var format_save, lang, lang_strs, os, ss, subpat, v1, v2, v4 uintptr
	var i, idx int32
	var v3 bool
	var _ /* langset at bp+0 */ uintptr
	var _ /* v at bp+8 */ TFcValue
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = done, format_save, i, idx, lang, lang_strs, os, ret, ss, subpat, v1, v2, v3, v4
	if !(_expect_char(tls, c, uint8('[')) != 0) || !(_expect_char(tls, c, uint8(']')) != 0) {
		return m_FcFalse
	}
	os = XFcObjectSetCreate(tls)
	if !(os != 0) {
		return m_FcFalse
	}
	ret = int32(m_FcTrue)
	for cond := true; cond; cond = _consume_char(tls, c, uint8(',')) != 0 {
		if !(_read_word(tls, c) != 0) || !(XFcObjectSetAdd(tls, os, (*TFcFormatContext)(unsafe.Pointer(c)).Fword) != 0) {
			XFcObjectSetDestroy(tls, os)
			return m_FcFalse
		}
	}
	/* If we have one element and it's of type FcLangSet, we want
	 * to enumerate the languages in it. */
	lang_strs = libc.UintptrFromInt32(0)
	if (*TFcObjectSet)(unsafe.Pointer(os)).Fnobject == int32(1) {
		if int32(_FcResultMatch) == XFcPatternGetLangSet(tls, pat, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects)), 0, bp) {
			v1 = XFcLangSetGetLangs(tls, *(*uintptr)(unsafe.Pointer(bp)))
			ss = v1
			if v3 = !(v1 != 0); !v3 {
				v2 = XFcStrListCreate(tls, ss)
				lang_strs = v2
			}
			if v3 || !(v2 != 0) {
				goto bail0
			}
		}
	}
	subpat = XFcPatternDuplicate(tls, pat)
	if !(subpat != 0) {
		goto bail0
	}
	format_save = (*TFcFormatContext)(unsafe.Pointer(c)).Fformat
	idx = 0
	for cond := true; cond; cond = !(done != 0) {
		done = int32(m_FcTrue)
		if lang_strs != 0 {
			XFcPatternDel(tls, subpat, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects)))
			v4 = XFcStrListNext(tls, lang_strs)
			lang = v4
			if v4 != 0 {
				/* XXX binding? */
				XFcPatternAddString(tls, subpat, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects)), lang)
				done = m_FcFalse
			}
		} else {
			i = 0
			for {
				if !(i < (*TFcObjectSet)(unsafe.Pointer(os)).Fnobject) {
					break
				}
				/* XXX this can be optimized by accessing valuelist linked lists
				 * directly and remembering where we were.  Most (all) value lists
				 * in normal uses are pretty short though (language tags are
				 * stored as a LangSet, not separate values.). */
				XFcPatternDel(tls, subpat, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(i)*8)))
				if int32(_FcResultMatch) == XFcPatternGet(tls, pat, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(i)*8)), idx, bp+8) {
					/* XXX binding */
					XFcPatternAdd(tls, subpat, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(i)*8)), *(*TFcValue)(unsafe.Pointer(bp + 8)), m_FcFalse)
					done = m_FcFalse
				}
				goto _5
			_5:
				;
				i++
			}
		}
		if !(done != 0) {
			(*TFcFormatContext)(unsafe.Pointer(c)).Fformat = format_save
			ret = _interpret_subexpr(tls, c, subpat, buf)
			if !(ret != 0) {
				goto bail
			}
		}
		idx++
	}
	if (*TFcFormatContext)(unsafe.Pointer(c)).Fformat == format_save {
		_skip_subexpr(tls, c)
	}
	goto bail
bail:
	;
	XFcPatternDestroy(tls, subpat)
	goto bail0
bail0:
	;
	if lang_strs != 0 {
		XFcStrListDone(tls, lang_strs)
	}
	XFcObjectSetDestroy(tls, os)
	return ret
}

func _interpret_simple(tls *libc.TLS, c uintptr, pat uintptr, buf uintptr) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var add_colon, add_elt_name TFcBool
	var else_string, orig, v3 uintptr
	var idx int32
	var l TFcValueListPtr
	var _ /* iter at bp+0 */ TFcPatternIter
	_, _, _, _, _, _, _ = add_colon, add_elt_name, else_string, idx, l, orig, v3
	add_colon = m_FcFalse
	add_elt_name = m_FcFalse
	if _consume_char(tls, c, uint8(':')) != 0 {
		add_colon = int32(m_FcTrue)
	}
	if !(_read_word(tls, c) != 0) {
		return m_FcFalse
	}
	idx = -int32(1)
	if _consume_char(tls, c, uint8('[')) != 0 {
		idx = int32(libc.Xstrtol(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fformat, c+8, int32(10)))
		if idx < 0 {
			_message(tls, __ccgo_ts+3366, libc.VaList(bp+24, int64((*TFcFormatContext)(unsafe.Pointer(c)).Fformat-uintptr(1))-int64((*TFcFormatContext)(unsafe.Pointer(c)).Fformat_orig)+int64(1)))
			return m_FcFalse
		}
		if !(_expect_char(tls, c, uint8(']')) != 0) {
			return m_FcFalse
		}
	}
	if _consume_char(tls, c, uint8('=')) != 0 {
		add_elt_name = int32(m_FcTrue)
	}
	/* modifiers */
	else_string = libc.UintptrFromInt32(0)
	if _consume_char(tls, c, uint8(':')) != 0 {
		/* divert the c->word for now */
		orig = (*TFcFormatContext)(unsafe.Pointer(c)).Fword
		(*TFcFormatContext)(unsafe.Pointer(c)).Fword = (*TFcFormatContext)(unsafe.Pointer(c)).Fword + uintptr(libc.Xstrlen(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword)) + uintptr(1)
		/* for now we just support 'default value' */
		if !(_expect_char(tls, c, uint8('-')) != 0) || !(_read_chars(tls, c, uint8('|')) != 0) {
			(*TFcFormatContext)(unsafe.Pointer(c)).Fword = orig
			return m_FcFalse
		}
		else_string = (*TFcFormatContext)(unsafe.Pointer(c)).Fword
		(*TFcFormatContext)(unsafe.Pointer(c)).Fword = orig
	}
	if XFcPatternFindIter(tls, pat, bp, (*TFcFormatContext)(unsafe.Pointer(c)).Fword) != 0 || else_string != 0 {
		l = libc.UintptrFromInt32(0)
		if add_colon != 0 {
			XFcStrBufChar(tls, buf, uint8(':'))
		}
		if add_elt_name != 0 {
			XFcStrBufString(tls, buf, (*TFcFormatContext)(unsafe.Pointer(c)).Fword)
			XFcStrBufChar(tls, buf, uint8('='))
		}
		l = XFcPatternIterGetValues(tls, pat, bp)
		if !(idx != -int32(1)) {
			goto _1
		}
		for l != 0 && idx > 0 {
			if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
				v3 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
			} else {
				v3 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
			}
			l = v3
			idx--
		}
		if l != 0 && idx == 0 {
			if !(XFcNameUnparseValue(tls, buf, l+8, libc.UintptrFromInt32(0)) != 0) {
				return m_FcFalse
			}
		} else {
			goto notfound
		}
		goto _2
	_1:
		;
		if !(l != 0) {
			goto _4
		}
		XFcNameUnparseValueList(tls, buf, l, libc.UintptrFromInt32(0))
		goto _5
	_4:
		;
		goto notfound
	notfound:
		;
		if else_string != 0 {
			XFcStrBufString(tls, buf, else_string)
		}
	_5:
		;
	_2:
	}
	return int32(m_FcTrue)
}

func _cescape(tls *libc.TLS, c uintptr, str uintptr, buf uintptr) (r TFcBool) {
	var v1 uintptr
	_ = v1
	/* XXX escape \n etc? */
	for *(*TFcChar8)(unsafe.Pointer(str)) != 0 {
		switch libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(str))) {
		case int32('\\'):
			fallthrough
		case int32('"'):
			XFcStrBufChar(tls, buf, uint8('\\'))
			break
		}
		v1 = str
		str++
		XFcStrBufChar(tls, buf, *(*TFcChar8)(unsafe.Pointer(v1)))
	}
	return int32(m_FcTrue)
}

func _shescape(tls *libc.TLS, c uintptr, str uintptr, buf uintptr) (r TFcBool) {
	XFcStrBufChar(tls, buf, uint8('\''))
	for *(*TFcChar8)(unsafe.Pointer(str)) != 0 {
		if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(str))) == int32('\'') {
			XFcStrBufString(tls, buf, __ccgo_ts+3401)
		} else {
			XFcStrBufChar(tls, buf, *(*TFcChar8)(unsafe.Pointer(str)))
		}
		str++
	}
	XFcStrBufChar(tls, buf, uint8('\''))
	return int32(m_FcTrue)
}

func _xmlescape(tls *libc.TLS, c uintptr, str uintptr, buf uintptr) (r TFcBool) {
	/* XXX escape \n etc? */
	for *(*TFcChar8)(unsafe.Pointer(str)) != 0 {
		switch libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(str))) {
		case int32('&'):
			XFcStrBufString(tls, buf, __ccgo_ts+3406)
		case int32('<'):
			XFcStrBufString(tls, buf, __ccgo_ts+3412)
		case int32('>'):
			XFcStrBufString(tls, buf, __ccgo_ts+3417)
		default:
			XFcStrBufChar(tls, buf, *(*TFcChar8)(unsafe.Pointer(str)))
			break
		}
		str++
	}
	return int32(m_FcTrue)
}

func _delete_chars(tls *libc.TLS, c uintptr, str uintptr, buf uintptr) (r TFcBool) {
	var p uintptr
	_ = p
	/* XXX not UTF-8 aware */
	if !(_expect_char(tls, c, uint8('(')) != 0) || !(_read_chars(tls, c, uint8(')')) != 0) || !(_expect_char(tls, c, uint8(')')) != 0) {
		return m_FcFalse
	}
	for *(*TFcChar8)(unsafe.Pointer(str)) != 0 {
		p = libc.Xstrpbrk(tls, str, (*TFcFormatContext)(unsafe.Pointer(c)).Fword)
		if p != 0 {
			XFcStrBufData(tls, buf, str, int32(int64(p)-int64(str)))
			str = p + uintptr(1)
		} else {
			XFcStrBufString(tls, buf, str)
			break
		}
	}
	return int32(m_FcTrue)
}

func _escape_chars(tls *libc.TLS, c uintptr, str uintptr, buf uintptr) (r TFcBool) {
	var p uintptr
	_ = p
	/* XXX not UTF-8 aware */
	if !(_expect_char(tls, c, uint8('(')) != 0) || !(_read_chars(tls, c, uint8(')')) != 0) || !(_expect_char(tls, c, uint8(')')) != 0) {
		return m_FcFalse
	}
	for *(*TFcChar8)(unsafe.Pointer(str)) != 0 {
		p = libc.Xstrpbrk(tls, str, (*TFcFormatContext)(unsafe.Pointer(c)).Fword)
		if p != 0 {
			XFcStrBufData(tls, buf, str, int32(int64(p)-int64(str)))
			XFcStrBufChar(tls, buf, *(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fword)))
			XFcStrBufChar(tls, buf, *(*TFcChar8)(unsafe.Pointer(p)))
			str = p + uintptr(1)
		} else {
			XFcStrBufString(tls, buf, str)
			break
		}
	}
	return int32(m_FcTrue)
}

func _translate_chars(tls *libc.TLS, c uintptr, str uintptr, buf uintptr) (r TFcBool) {
	var from, p, to uintptr
	var from_len, i, to_len, v1 int32
	var repeat int8
	_, _, _, _, _, _, _, _ = from, from_len, i, p, repeat, to, to_len, v1
	/* XXX not UTF-8 aware */
	if !(_expect_char(tls, c, uint8('(')) != 0) || !(_read_chars(tls, c, uint8(',')) != 0) || !(_expect_char(tls, c, uint8(',')) != 0) {
		return m_FcFalse
	}
	from = (*TFcFormatContext)(unsafe.Pointer(c)).Fword
	from_len = libc.Int32FromUint64(libc.Xstrlen(tls, from))
	to = from + uintptr(from_len) + uintptr(1)
	/* hack: we temporarily divert c->word */
	(*TFcFormatContext)(unsafe.Pointer(c)).Fword = to
	if !(_read_chars(tls, c, uint8(')')) != 0) {
		(*TFcFormatContext)(unsafe.Pointer(c)).Fword = from
		return m_FcFalse
	}
	(*TFcFormatContext)(unsafe.Pointer(c)).Fword = from
	to_len = libc.Int32FromUint64(libc.Xstrlen(tls, to))
	repeat = *(*int8)(unsafe.Pointer(to + uintptr(to_len-int32(1))))
	if !(_expect_char(tls, c, uint8(')')) != 0) {
		return m_FcFalse
	}
	for *(*TFcChar8)(unsafe.Pointer(str)) != 0 {
		p = libc.Xstrpbrk(tls, str, from)
		if p != 0 {
			XFcStrBufData(tls, buf, str, int32(int64(p)-int64(str)))
			i = int32(int64(libc.Xstrchr(tls, from, libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(p))))) - int64(from))
			if i < to_len {
				v1 = int32(*(*int8)(unsafe.Pointer(to + uintptr(i))))
			} else {
				v1 = int32(repeat)
			}
			XFcStrBufChar(tls, buf, libc.Uint8FromInt32(v1))
			str = p + uintptr(1)
		} else {
			XFcStrBufString(tls, buf, str)
			break
		}
	}
	return int32(m_FcTrue)
}

func _interpret_convert(tls *libc.TLS, c uintptr, buf uintptr, start int32) (r TFcBool) {
	bp := tls.Alloc(8368)
	defer tls.Free(8368)
	var new_str, str uintptr
	var ret TFcBool
	var _ /* buf_static at bp+152 */ [8192]TFcChar8
	var _ /* new_buf at bp+0 */ TFcStrBuf
	_, _, _ = new_str, ret, str
	if !(_expect_char(tls, c, uint8('|')) != 0) || !(_read_word(tls, c) != 0) {
		return m_FcFalse
	}
	/* prepare the buffer */
	XFcStrBufChar(tls, buf, uint8('\000'))
	if (*TFcStrBuf)(unsafe.Pointer(buf)).Ffailed != 0 {
		return m_FcFalse
	}
	str = (*TFcStrBuf)(unsafe.Pointer(buf)).Fbuf + uintptr(start)
	(*TFcStrBuf)(unsafe.Pointer(buf)).Flen1 = start
	/* try simple converters first */
	if 0 != 0 {
	} else {
		if 0 == libc.Xstrcmp(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, __ccgo_ts+3422) {
			new_str = XFcStrDowncase(tls, str)
			ret = int32(m_FcTrue)
		} else {
			if 0 == libc.Xstrcmp(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, __ccgo_ts+3431) {
				new_str = XFcStrBasename(tls, str)
				ret = int32(m_FcTrue)
			} else {
				if 0 == libc.Xstrcmp(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, __ccgo_ts+3440) {
					new_str = XFcStrDirname(tls, str)
					ret = int32(m_FcTrue)
				} else {
					ret = m_FcFalse
				}
			}
		}
	}
	if ret != 0 {
		if new_str != 0 {
			XFcStrBufString(tls, buf, new_str)
			XFcStrFree(tls, new_str)
			return int32(m_FcTrue)
		} else {
			return m_FcFalse
		}
	}
	XFcStrBufInit(tls, bp, bp+152, int32(8192))
	/* now try our custom converters */
	if 0 != 0 {
	} else {
		if 0 == libc.Xstrcmp(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, __ccgo_ts+3448) {
			ret = _cescape(tls, c, str, bp)
		} else {
			if 0 == libc.Xstrcmp(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, __ccgo_ts+3456) {
				ret = _shescape(tls, c, str, bp)
			} else {
				if 0 == libc.Xstrcmp(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, __ccgo_ts+3465) {
					ret = _xmlescape(tls, c, str, bp)
				} else {
					if 0 == libc.Xstrcmp(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, __ccgo_ts+3475) {
						ret = _delete_chars(tls, c, str, bp)
					} else {
						if 0 == libc.Xstrcmp(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, __ccgo_ts+3482) {
							ret = _escape_chars(tls, c, str, bp)
						} else {
							if 0 == libc.Xstrcmp(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fword, __ccgo_ts+3489) {
								ret = _translate_chars(tls, c, str, bp)
							} else {
								ret = m_FcFalse
							}
						}
					}
				}
			}
		}
	}
	if ret != 0 {
		XFcStrBufChar(tls, bp, uint8('\000'))
		XFcStrBufString(tls, buf, (*(*TFcStrBuf)(unsafe.Pointer(bp))).Fbuf)
	} else {
		_message(tls, __ccgo_ts+3499, libc.VaList(bp+8352, (*TFcFormatContext)(unsafe.Pointer(c)).Fword))
	}
	XFcStrBufDestroy(tls, bp)
	return ret
}

func _maybe_interpret_converts(tls *libc.TLS, c uintptr, buf uintptr, start int32) (r TFcBool) {
	for libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) == int32('|') {
		if !(_interpret_convert(tls, c, buf, start) != 0) {
			return m_FcFalse
		}
	}
	return int32(m_FcTrue)
}

func _align_to_width(tls *libc.TLS, buf uintptr, start int32, width int32) (r TFcBool) {
	var len1, old_len, v1, v2 int32
	_, _, _, _ = len1, old_len, v1, v2
	if (*TFcStrBuf)(unsafe.Pointer(buf)).Ffailed != 0 {
		return m_FcFalse
	}
	len1 = (*TFcStrBuf)(unsafe.Pointer(buf)).Flen1 - start
	if len1 < -width {
		/* left align */
		for {
			v1 = len1
			len1++
			if !(v1 < -width) {
				break
			}
			XFcStrBufChar(tls, buf, uint8(' '))
		}
	} else {
		if len1 < width {
			old_len = len1
			/* right align */
			for {
				v2 = len1
				len1++
				if !(v2 < width) {
					break
				}
				XFcStrBufChar(tls, buf, uint8(' '))
			}
			if (*TFcStrBuf)(unsafe.Pointer(buf)).Ffailed != 0 {
				return m_FcFalse
			}
			len1 = old_len
			libc.X__builtin___memmove_chk(tls, (*TFcStrBuf)(unsafe.Pointer(buf)).Fbuf+uintptr((*TFcStrBuf)(unsafe.Pointer(buf)).Flen1)-uintptr(len1), (*TFcStrBuf)(unsafe.Pointer(buf)).Fbuf+uintptr((*TFcStrBuf)(unsafe.Pointer(buf)).Flen1)-uintptr(width), libc.Uint64FromInt32(len1), ^t__predefined_size_t(0))
			libc.X__builtin___memset_chk(tls, (*TFcStrBuf)(unsafe.Pointer(buf)).Fbuf+uintptr((*TFcStrBuf)(unsafe.Pointer(buf)).Flen1)-uintptr(width), int32(' '), libc.Uint64FromInt32(width-len1), ^t__predefined_size_t(0))
		}
	}
	return libc.BoolInt32(!((*TFcStrBuf)(unsafe.Pointer(buf)).Ffailed != 0))
}

func _interpret_percent(tls *libc.TLS, c uintptr, pat uintptr, buf uintptr) (r TFcBool) {
	var ret TFcBool
	var start, width int32
	_, _, _ = ret, start, width
	if !(_expect_char(tls, c, uint8('%')) != 0) {
		return m_FcFalse
	}
	if _consume_char(tls, c, uint8('%')) != 0 { /* "%%" */
		XFcStrBufChar(tls, buf, uint8('%'))
		return int32(m_FcTrue)
	}
	/* parse an optional width specifier */
	width = int32(libc.Xstrtol(tls, (*TFcFormatContext)(unsafe.Pointer(c)).Fformat, c+8, int32(10)))
	if !(_expect_char(tls, c, uint8('{')) != 0) {
		return m_FcFalse
	}
	start = (*TFcStrBuf)(unsafe.Pointer(buf)).Flen1
	switch libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) {
	case int32('='):
		ret = _interpret_builtin(tls, c, pat, buf)
	case int32('{'):
		ret = _interpret_subexpr(tls, c, pat, buf)
	case int32('+'):
		ret = _interpret_filter_in(tls, c, pat, buf)
	case int32('-'):
		ret = _interpret_filter_out(tls, c, pat, buf)
	case int32('?'):
		ret = _interpret_cond(tls, c, pat, buf)
	case int32('#'):
		ret = _interpret_count(tls, c, pat, buf)
	case int32('['):
		ret = _interpret_enumerate(tls, c, pat, buf)
	default:
		ret = _interpret_simple(tls, c, pat, buf)
		break
	}
	return libc.BoolInt32(ret != 0 && _maybe_interpret_converts(tls, c, buf, start) != 0 && _align_to_width(tls, buf, start, width) != 0 && _expect_char(tls, c, uint8('}')) != 0)
}

func _interpret_expr(tls *libc.TLS, c uintptr, pat uintptr, buf uintptr, term TFcChar8) (r TFcBool) {
	var v1, v2, v3, v4 uintptr
	_, _, _, _ = v1, v2, v3, v4
	for *(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat)) != 0 && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) != libc.Int32FromUint8(term) {
		switch libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat))) {
		case int32('\\'):
			(*TFcFormatContext)(unsafe.Pointer(c)).Fformat++ /* skip over '\\' */
			if *(*TFcChar8)(unsafe.Pointer((*TFcFormatContext)(unsafe.Pointer(c)).Fformat)) != 0 {
				v2 = c + 8
				v1 = *(*uintptr)(unsafe.Pointer(v2))
				*(*uintptr)(unsafe.Pointer(v2))++
				XFcStrBufChar(tls, buf, libc.Uint8FromInt8(_escaped_char(tls, libc.Int8FromUint8(*(*TFcChar8)(unsafe.Pointer(v1))))))
			}
			continue
		case int32('%'):
			if !(_interpret_percent(tls, c, pat, buf) != 0) {
				return m_FcFalse
			}
			continue
		}
		v4 = c + 8
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		XFcStrBufChar(tls, buf, *(*TFcChar8)(unsafe.Pointer(v3)))
	}
	return int32(m_FcTrue)
}

func _FcPatternFormatToBuf(tls *libc.TLS, pat uintptr, format uintptr, buf uintptr) (r TFcBool) {
	bp := tls.Alloc(1072)
	defer tls.Free(1072)
	var ret TFcBool
	var _ /* c at bp+0 */ TFcFormatContext
	var _ /* word_static at bp+40 */ [1024]TFcChar8
	_ = ret
	if !(_FcFormatContextInit(tls, bp, format, bp+40, int32(1024)) != 0) {
		return m_FcFalse
	}
	ret = _interpret_expr(tls, bp, pat, buf, uint8('\000'))
	_FcFormatContextDone(tls, bp)
	return ret
}

func XFcPatternFormat(tls *libc.TLS, pat uintptr, format uintptr) (r uintptr) {
	bp := tls.Alloc(7328)
	defer tls.Free(7328)
	var alloced, v1 uintptr
	var ret TFcBool
	var _ /* buf at bp+0 */ TFcStrBuf
	var _ /* buf_static at bp+152 */ [7168]TFcChar8
	_, _, _ = alloced, ret, v1
	alloced = libc.UintptrFromInt32(0)
	if !(pat != 0) {
		v1 = XFcPatternCreate(tls)
		pat = v1
		alloced = v1
	}
	XFcStrBufInit(tls, bp, bp+152, int32(7168))
	ret = _FcPatternFormatToBuf(tls, pat, format, bp)
	if alloced != 0 {
		XFcPatternDestroy(tls, alloced)
	}
	if ret != 0 {
		return XFcStrBufDone(tls, bp)
	} else {
		XFcStrBufDestroy(tls, bp)
		return libc.UintptrFromInt32(0)
	}
	return r
}

const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_2_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_3_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_4_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_11_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_1_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_2_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_4_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_12_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_13 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_8 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_8_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_9 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_3 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_4 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_1 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_2 = "DEPRECATED_ATTRIBUTE"
const m_AVAILABLE_MAC_OS_X_VERSION_10_9_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_4 = "DEPRECATED_ATTRIBUTE"
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 = 500
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 = 1000
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3 = 1667
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4 = 2333
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1 = 400
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2 = 275
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3 = 275
const m_CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4 = 0
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_0_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_10_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_11_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_12_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_13_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_14_4_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_1_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_2_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_3_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_4_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_8_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DEPRECATED_IN_MAC_OS_X_VERSION_10_9_AND_LATER = "DEPRECATED_ATTRIBUTE"
const m_DYNAMIC_TARGETS_ENABLED = 0
const m_FC_ENCODING_MAC_ROMAN = "MACINTOSH"
const m_FREETYPE_MAJOR = 2
const m_FREETYPE_MINOR = 10
const m_FREETYPE_PATCH = 4
const m_FT_ADVANCE_FLAG_FAST_ONLY = 0x20000000
const m_FT_AUTOHINTER_H = "FT_DRIVER_H"
const m_FT_CACHE_CHARMAP_H = "FT_CACHE_H"
const m_FT_CACHE_IMAGE_H = "FT_CACHE_H"
const m_FT_CACHE_INTERNAL_CACHE_H = "FT_CACHE_H"
const m_FT_CACHE_INTERNAL_GLYPH_H = "FT_CACHE_H"
const m_FT_CACHE_INTERNAL_IMAGE_H = "FT_CACHE_H"
const m_FT_CACHE_INTERNAL_MANAGER_H = "FT_CACHE_H"
const m_FT_CACHE_INTERNAL_MRU_H = "FT_CACHE_H"
const m_FT_CACHE_INTERNAL_SBITS_H = "FT_CACHE_H"
const m_FT_CACHE_MANAGER_H = "FT_CACHE_H"
const m_FT_CACHE_SMALL_BITMAPS_H = "FT_CACHE_H"
const m_FT_CFF_DRIVER_H = "FT_DRIVER_H"
const m_FT_CHAR_BIT = "CHAR_BIT"
const m_FT_CURVE_TAG_CONIC = 0x00
const m_FT_CURVE_TAG_CUBIC = 0x02
const m_FT_CURVE_TAG_HAS_SCANMODE = 0x04
const m_FT_CURVE_TAG_ON = 0x01
const m_FT_CURVE_TAG_TOUCH_X = 0x08
const m_FT_CURVE_TAG_TOUCH_Y = 0x10
const m_FT_Curve_Tag_Conic = "FT_CURVE_TAG_CONIC"
const m_FT_Curve_Tag_Cubic = "FT_CURVE_TAG_CUBIC"
const m_FT_Curve_Tag_On = "FT_CURVE_TAG_ON"
const m_FT_Curve_Tag_Touch_X = "FT_CURVE_TAG_TOUCH_X"
const m_FT_Curve_Tag_Touch_Y = "FT_CURVE_TAG_TOUCH_Y"
const m_FT_FILE = "FILE"
const m_FT_FSTYPE_BITMAP_EMBEDDING_ONLY = 0x0200
const m_FT_FSTYPE_EDITABLE_EMBEDDING = 0x0008
const m_FT_FSTYPE_INSTALLABLE_EMBEDDING = 0x0000
const m_FT_FSTYPE_NO_SUBSETTING = 0x0100
const m_FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING = 0x0004
const m_FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING = 0x0002
const m_FT_INT64 = "long"
const m_FT_INT_MAX = "INT_MAX"
const m_FT_INT_MIN = "INT_MIN"
const m_FT_LOAD_DEFAULT = 0x0
const m_FT_LONG_MAX = "LONG_MAX"
const m_FT_LONG_MIN = "LONG_MIN"
const m_FT_MAX_MODULES = 32
const m_FT_OPEN_DRIVER = 0x8
const m_FT_OPEN_MEMORY = 0x1
const m_FT_OPEN_PARAMS = 0x10
const m_FT_OPEN_PATHNAME = 0x4
const m_FT_OPEN_STREAM = 0x2
const m_FT_OUTLINE_CONTOURS_MAX = "SHRT_MAX"
const m_FT_OUTLINE_EVEN_ODD_FILL = 0x2
const m_FT_OUTLINE_HIGH_PRECISION = 0x100
const m_FT_OUTLINE_IGNORE_DROPOUTS = 0x8
const m_FT_OUTLINE_INCLUDE_STUBS = 0x20
const m_FT_OUTLINE_NONE = 0x0
const m_FT_OUTLINE_OVERLAP = 0x40
const m_FT_OUTLINE_OWNER = 0x1
const m_FT_OUTLINE_POINTS_MAX = "SHRT_MAX"
const m_FT_OUTLINE_REVERSE_FILL = 0x4
const m_FT_OUTLINE_SINGLE_PASS = 0x200
const m_FT_OUTLINE_SMART_DROPOUTS = 0x10
const m_FT_Outline_ConicTo_Func = "FT_Outline_ConicToFunc"
const m_FT_Outline_CubicTo_Func = "FT_Outline_CubicToFunc"
const m_FT_Outline_LineTo_Func = "FT_Outline_LineToFunc"
const m_FT_Outline_MoveTo_Func = "FT_Outline_MoveToFunc"
const m_FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY = "FT_PARAM_TAG_IGNORE_TYPOGRAPHIC_FAMILY"
const m_FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY = "FT_PARAM_TAG_IGNORE_TYPOGRAPHIC_SUBFAMILY"
const m_FT_PCF_DRIVER_H = "FT_DRIVER_H"
const m_FT_RASTER_FLAG_AA = 0x1
const m_FT_RASTER_FLAG_CLIP = 0x4
const m_FT_RASTER_FLAG_DEFAULT = 0x0
const m_FT_RASTER_FLAG_DIRECT = 0x2
const m_FT_RENDER_POOL_SIZE = 16384
const m_FT_Raster_Done_Func = "FT_Raster_DoneFunc"
const m_FT_Raster_New_Func = "FT_Raster_NewFunc"
const m_FT_Raster_Render_Func = "FT_Raster_RenderFunc"
const m_FT_Raster_Reset_Func = "FT_Raster_ResetFunc"
const m_FT_Raster_Set_Mode_Func = "FT_Raster_SetModeFunc"
const m_FT_Raster_Span_Func = "FT_SpanFunc"
const m_FT_SUBGLYPH_FLAG_2X2 = 0x80
const m_FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS = 1
const m_FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES = 2
const m_FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID = 4
const m_FT_SUBGLYPH_FLAG_SCALE = 8
const m_FT_SUBGLYPH_FLAG_USE_MY_METRICS = 0x200
const m_FT_SUBGLYPH_FLAG_XY_SCALE = 0x40
const m_FT_TRUETYPE_DRIVER_H = "FT_DRIVER_H"
const m_FT_UINT_MAX = "UINT_MAX"
const m_FT_ULONG_MAX = "ULONG_MAX"
const m_FT_USHORT_MAX = "USHRT_MAX"
const m_FT_VAR_AXIS_FLAG_HIDDEN = 1
const m_FT_XFREE86_H = "FT_FONT_FORMATS_H"
const m_MAC_OS_X_VERSION_MAX_ALLOWED = "MAC_OS_X_VERSION_MIN_REQUIRED"
const m_MAC_OS_X_VERSION_MIN_REQUIRED = "__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__"
const m_OTLAYOUT_HEAD = "otlayout:"
const m_OTLAYOUT_HEAD_LEN = 9
const m_OTLAYOUT_ID_LEN = 4
const m_T1_MAX_CHARSTRINGS_OPERANDS = 256
const m_T1_MAX_DICT_DEPTH = 5
const m_T1_MAX_MM_AXIS = 4
const m_T1_MAX_MM_DESIGNS = 16
const m_T1_MAX_MM_MAP_POINTS = 20
const m_T1_MAX_SUBRS_CALLS = 16
const m_TARGET_CPU_68K = 0
const m_TARGET_CPU_ALPHA = 0
const m_TARGET_CPU_ARM = 0
const m_TARGET_CPU_ARM64 = 0
const m_TARGET_CPU_MIPS = 0
const m_TARGET_CPU_PPC = 0
const m_TARGET_CPU_PPC64 = 0
const m_TARGET_CPU_SPARC = 0
const m_TARGET_CPU_X86 = 0
const m_TARGET_CPU_X86_64 = 1
const m_TARGET_OS_RTKIT = 0
const m_TARGET_RT_64_BIT = 1
const m_TARGET_RT_BIG_ENDIAN = 0
const m_TARGET_RT_LITTLE_ENDIAN = 1
const m_TARGET_RT_MAC_CFM = 0
const m_TARGET_RT_MAC_MACHO = 1
const m_TT_ADOBE_ID_CUSTOM = 2
const m_TT_ADOBE_ID_EXPERT = 1
const m_TT_ADOBE_ID_LATIN_1 = 3
const m_TT_ADOBE_ID_STANDARD = 0
const m_TT_APPLE_ID_DEFAULT = 0
const m_TT_APPLE_ID_FULL_UNICODE = 6
const m_TT_APPLE_ID_ISO_10646 = 2
const m_TT_APPLE_ID_UNICODE_1_1 = 1
const m_TT_APPLE_ID_UNICODE_2_0 = 3
const m_TT_APPLE_ID_UNICODE_32 = 4
const m_TT_APPLE_ID_VARIANT_SELECTOR = 5
const m_TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES = 1000000
const m_TT_CONFIG_OPTION_SUBPIXEL_HINTING = 2
const m_TT_ENCODING_DONT_CARE = 65535
const m_TT_ISO_ID_10646 = 1
const m_TT_ISO_ID_7BIT_ASCII = 0
const m_TT_ISO_ID_8859_1 = 2
const m_TT_LANGUAGE_DONT_CARE = 65535
const m_TT_MAC_ID_ARABIC = 4
const m_TT_MAC_ID_ARMENIAN = 24
const m_TT_MAC_ID_BENGALI = 13
const m_TT_MAC_ID_BURMESE = 19
const m_TT_MAC_ID_DEVANAGARI = 9
const m_TT_MAC_ID_GEEZ = 28
const m_TT_MAC_ID_GEORGIAN = 23
const m_TT_MAC_ID_GREEK = 6
const m_TT_MAC_ID_GUJARATI = 11
const m_TT_MAC_ID_GURMUKHI = 10
const m_TT_MAC_ID_HEBREW = 5
const m_TT_MAC_ID_JAPANESE = 1
const m_TT_MAC_ID_KANNADA = 16
const m_TT_MAC_ID_KHMER = 20
const m_TT_MAC_ID_KOREAN = 3
const m_TT_MAC_ID_LAOTIAN = 22
const m_TT_MAC_ID_MALAYALAM = 17
const m_TT_MAC_ID_MALDIVIAN = 25
const m_TT_MAC_ID_MONGOLIAN = 27
const m_TT_MAC_ID_ORIYA = 12
const m_TT_MAC_ID_ROMAN = 0
const m_TT_MAC_ID_RSYMBOL = 8
const m_TT_MAC_ID_RUSSIAN = 7
const m_TT_MAC_ID_SIMPLIFIED_CHINESE = 25
const m_TT_MAC_ID_SINDHI = 31
const m_TT_MAC_ID_SINHALESE = 18
const m_TT_MAC_ID_SLAVIC = 29
const m_TT_MAC_ID_TAMIL = 14
const m_TT_MAC_ID_TELUGU = 15
const m_TT_MAC_ID_THAI = 21
const m_TT_MAC_ID_TIBETAN = 26
const m_TT_MAC_ID_TRADITIONAL_CHINESE = 2
const m_TT_MAC_ID_UNINTERP = 32
const m_TT_MAC_ID_VIETNAMESE = 30
const m_TT_MAC_LANGID_AFRIKAANS = 141
const m_TT_MAC_LANGID_ALBANIAN = 36
const m_TT_MAC_LANGID_AMHARIC = 85
const m_TT_MAC_LANGID_ARABIC = 12
const m_TT_MAC_LANGID_ARMENIAN = 51
const m_TT_MAC_LANGID_ASSAMESE = 68
const m_TT_MAC_LANGID_AYMARA = 134
const m_TT_MAC_LANGID_AZERBAIJANI = 49
const m_TT_MAC_LANGID_AZERBAIJANI_ARABIC_SCRIPT = 50
const m_TT_MAC_LANGID_AZERBAIJANI_CYRILLIC_SCRIPT = 49
const m_TT_MAC_LANGID_AZERBAIJANI_ROMAN_SCRIPT = 150
const m_TT_MAC_LANGID_BASQUE = 129
const m_TT_MAC_LANGID_BENGALI = 67
const m_TT_MAC_LANGID_BRETON = 142
const m_TT_MAC_LANGID_BULGARIAN = 44
const m_TT_MAC_LANGID_BURMESE = 77
const m_TT_MAC_LANGID_BYELORUSSIAN = 46
const m_TT_MAC_LANGID_CATALAN = 130
const m_TT_MAC_LANGID_CHEWA = 92
const m_TT_MAC_LANGID_CHINESE_SIMPLIFIED = 33
const m_TT_MAC_LANGID_CHINESE_TRADITIONAL = 19
const m_TT_MAC_LANGID_CROATIAN = 18
const m_TT_MAC_LANGID_CZECH = 38
const m_TT_MAC_LANGID_DANISH = 7
const m_TT_MAC_LANGID_DUTCH = 4
const m_TT_MAC_LANGID_DZONGKHA = 137
const m_TT_MAC_LANGID_ENGLISH = 0
const m_TT_MAC_LANGID_ESPERANTO = 94
const m_TT_MAC_LANGID_ESTONIAN = 27
const m_TT_MAC_LANGID_FAEROESE = 30
const m_TT_MAC_LANGID_FARSI = 31
const m_TT_MAC_LANGID_FINNISH = 13
const m_TT_MAC_LANGID_FLEMISH = 34
const m_TT_MAC_LANGID_FRENCH = 1
const m_TT_MAC_LANGID_GALICIAN = 140
const m_TT_MAC_LANGID_GALLA = 87
const m_TT_MAC_LANGID_GEORGIAN = 52
const m_TT_MAC_LANGID_GERMAN = 2
const m_TT_MAC_LANGID_GREEK = 14
const m_TT_MAC_LANGID_GREEK_POLYTONIC = 148
const m_TT_MAC_LANGID_GREELANDIC = 149
const m_TT_MAC_LANGID_GUARANI = 133
const m_TT_MAC_LANGID_GUJARATI = 69
const m_TT_MAC_LANGID_HEBREW = 10
const m_TT_MAC_LANGID_HINDI = 21
const m_TT_MAC_LANGID_HUNGARIAN = 26
const m_TT_MAC_LANGID_ICELANDIC = 15
const m_TT_MAC_LANGID_INDONESIAN = 81
const m_TT_MAC_LANGID_INUKTITUT = 143
const m_TT_MAC_LANGID_IRISH = 35
const m_TT_MAC_LANGID_IRISH_GAELIC = 146
const m_TT_MAC_LANGID_ITALIAN = 3
const m_TT_MAC_LANGID_JAPANESE = 11
const m_TT_MAC_LANGID_JAVANESE = 138
const m_TT_MAC_LANGID_KANNADA = 73
const m_TT_MAC_LANGID_KASHMIRI = 61
const m_TT_MAC_LANGID_KAZAKH = 48
const m_TT_MAC_LANGID_KHMER = 78
const m_TT_MAC_LANGID_KIRGHIZ = 54
const m_TT_MAC_LANGID_KOREAN = 23
const m_TT_MAC_LANGID_KURDISH = 60
const m_TT_MAC_LANGID_LAO = 79
const m_TT_MAC_LANGID_LATIN = 131
const m_TT_MAC_LANGID_LETTISH = 28
const m_TT_MAC_LANGID_LITHUANIAN = 24
const m_TT_MAC_LANGID_MACEDONIAN = 43
const m_TT_MAC_LANGID_MALAGASY = 93
const m_TT_MAC_LANGID_MALAYALAM = 72
const m_TT_MAC_LANGID_MALAY_ARABIC_SCRIPT = 84
const m_TT_MAC_LANGID_MALAY_ROMAN_SCRIPT = 83
const m_TT_MAC_LANGID_MALTESE = 16
const m_TT_MAC_LANGID_MANX_GAELIC = 145
const m_TT_MAC_LANGID_MARATHI = 66
const m_TT_MAC_LANGID_MOLDAVIAN = 53
const m_TT_MAC_LANGID_MONGOLIAN = 57
const m_TT_MAC_LANGID_MONGOLIAN_CYRILLIC_SCRIPT = 58
const m_TT_MAC_LANGID_MONGOLIAN_MONGOLIAN_SCRIPT = 57
const m_TT_MAC_LANGID_NEPALI = 64
const m_TT_MAC_LANGID_NORWEGIAN = 9
const m_TT_MAC_LANGID_ORIYA = 71
const m_TT_MAC_LANGID_PASHTO = 59
const m_TT_MAC_LANGID_POLISH = 25
const m_TT_MAC_LANGID_PORTUGUESE = 8
const m_TT_MAC_LANGID_PUNJABI = 70
const m_TT_MAC_LANGID_QUECHUA = 132
const m_TT_MAC_LANGID_ROMANIAN = 37
const m_TT_MAC_LANGID_RUANDA = 90
const m_TT_MAC_LANGID_RUNDI = 91
const m_TT_MAC_LANGID_RUSSIAN = 32
const m_TT_MAC_LANGID_SAAMISK = 29
const m_TT_MAC_LANGID_SANSKRIT = 65
const m_TT_MAC_LANGID_SCOTTISH_GAELIC = 144
const m_TT_MAC_LANGID_SERBIAN = 42
const m_TT_MAC_LANGID_SINDHI = 62
const m_TT_MAC_LANGID_SINHALESE = 76
const m_TT_MAC_LANGID_SLOVAK = 39
const m_TT_MAC_LANGID_SLOVENIAN = 40
const m_TT_MAC_LANGID_SOMALI = 88
const m_TT_MAC_LANGID_SPANISH = 6
const m_TT_MAC_LANGID_SUNDANESE = 139
const m_TT_MAC_LANGID_SWAHILI = 89
const m_TT_MAC_LANGID_SWEDISH = 5
const m_TT_MAC_LANGID_TAGALOG = 82
const m_TT_MAC_LANGID_TAJIKI = 55
const m_TT_MAC_LANGID_TAMIL = 74
const m_TT_MAC_LANGID_TATAR = 135
const m_TT_MAC_LANGID_TELUGU = 75
const m_TT_MAC_LANGID_THAI = 22
const m_TT_MAC_LANGID_TIBETAN = 63
const m_TT_MAC_LANGID_TIGRINYA = 86
const m_TT_MAC_LANGID_TONGAN = 147
const m_TT_MAC_LANGID_TURKISH = 17
const m_TT_MAC_LANGID_TURKMEN = 56
const m_TT_MAC_LANGID_UIGHUR = 136
const m_TT_MAC_LANGID_UKRAINIAN = 45
const m_TT_MAC_LANGID_URDU = 20
const m_TT_MAC_LANGID_UZBEK = 47
const m_TT_MAC_LANGID_VIETNAMESE = 80
const m_TT_MAC_LANGID_WELSH = 128
const m_TT_MAC_LANGID_YIDDISH = 41
const m_TT_MS_ID_BIG_5 = 4
const m_TT_MS_ID_GB2312 = "TT_MS_ID_PRC"
const m_TT_MS_ID_JOHAB = 6
const m_TT_MS_ID_PRC = 3
const m_TT_MS_ID_SJIS = 2
const m_TT_MS_ID_SYMBOL_CS = 0
const m_TT_MS_ID_UCS_4 = 10
const m_TT_MS_ID_UNICODE_CS = 1
const m_TT_MS_ID_WANSUNG = 5
const m_TT_MS_LANGID_AFRIKAANS_SOUTH_AFRICA = 1078
const m_TT_MS_LANGID_ALBANIAN_ALBANIA = 1052
const m_TT_MS_LANGID_ALSATIAN_FRANCE = 0x0484
const m_TT_MS_LANGID_AMHARIC_ETHIOPIA = 1118
const m_TT_MS_LANGID_ARABIC_ALGERIA = 5121
const m_TT_MS_LANGID_ARABIC_BAHRAIN = 15361
const m_TT_MS_LANGID_ARABIC_EGYPT = 3073
const m_TT_MS_LANGID_ARABIC_GENERAL = 1
const m_TT_MS_LANGID_ARABIC_IRAQ = 2049
const m_TT_MS_LANGID_ARABIC_JORDAN = 11265
const m_TT_MS_LANGID_ARABIC_KUWAIT = 13313
const m_TT_MS_LANGID_ARABIC_LEBANON = 12289
const m_TT_MS_LANGID_ARABIC_LIBYA = 4097
const m_TT_MS_LANGID_ARABIC_MOROCCO = 6145
const m_TT_MS_LANGID_ARABIC_OMAN = 8193
const m_TT_MS_LANGID_ARABIC_QATAR = 16385
const m_TT_MS_LANGID_ARABIC_SAUDI_ARABIA = 1025
const m_TT_MS_LANGID_ARABIC_SYRIA = 10241
const m_TT_MS_LANGID_ARABIC_TUNISIA = 7169
const m_TT_MS_LANGID_ARABIC_UAE = 14337
const m_TT_MS_LANGID_ARABIC_YEMEN = 9217
const m_TT_MS_LANGID_ARMENIAN_ARMENIA = 1067
const m_TT_MS_LANGID_ASSAMESE_INDIA = 1101
const m_TT_MS_LANGID_AZERI_AZERBAIJAN_CYRILLIC = 2092
const m_TT_MS_LANGID_AZERI_AZERBAIJAN_LATIN = 1068
const m_TT_MS_LANGID_BASHKIR_RUSSIA = 0x046D
const m_TT_MS_LANGID_BASQUE_BASQUE = 1069
const m_TT_MS_LANGID_BASQUE_SPAIN = "TT_MS_LANGID_BASQUE_BASQUE"
const m_TT_MS_LANGID_BELARUSIAN_BELARUS = 1059
const m_TT_MS_LANGID_BENGALI_BANGLADESH = 2117
const m_TT_MS_LANGID_BENGALI_INDIA = 1093
const m_TT_MS_LANGID_BOSNIAN_BOSNIA_HERZEGOVINA = 5146
const m_TT_MS_LANGID_BOSNIAN_BOSNIA_HERZ_CYRILLIC = 0x201A
const m_TT_MS_LANGID_BRETON_FRANCE = 0x047E
const m_TT_MS_LANGID_BULGARIAN_BULGARIA = 1026
const m_TT_MS_LANGID_BURMESE_MYANMAR = 1109
const m_TT_MS_LANGID_CATALAN_CATALAN = 1027
const m_TT_MS_LANGID_CATALAN_SPAIN = "TT_MS_LANGID_CATALAN_CATALAN"
const m_TT_MS_LANGID_CHEROKEE_UNITED_STATES = 1116
const m_TT_MS_LANGID_CHINESE_GENERAL = 4
const m_TT_MS_LANGID_CHINESE_HONG_KONG = 3076
const m_TT_MS_LANGID_CHINESE_MACAO = 5124
const m_TT_MS_LANGID_CHINESE_MACAU = "TT_MS_LANGID_CHINESE_MACAO"
const m_TT_MS_LANGID_CHINESE_PRC = 2052
const m_TT_MS_LANGID_CHINESE_SINGAPORE = 4100
const m_TT_MS_LANGID_CHINESE_TAIWAN = 1028
const m_TT_MS_LANGID_CLASSIC_LITHUANIAN_LITHUANIA = 2087
const m_TT_MS_LANGID_CORSICAN_FRANCE = 0x0483
const m_TT_MS_LANGID_CROATIAN_BOSNIA_HERZEGOVINA = 0x101A
const m_TT_MS_LANGID_CROATIAN_CROATIA = 1050
const m_TT_MS_LANGID_CZECH_CZECH_REPUBLIC = 1029
const m_TT_MS_LANGID_DANISH_DENMARK = 1030
const m_TT_MS_LANGID_DARI_AFGHANISTAN = 0x048C
const m_TT_MS_LANGID_DHIVEHI_MALDIVES = 1125
const m_TT_MS_LANGID_DIVEHI_MALDIVES = "TT_MS_LANGID_DHIVEHI_MALDIVES"
const m_TT_MS_LANGID_DUTCH_BELGIUM = 2067
const m_TT_MS_LANGID_DUTCH_NETHERLANDS = 1043
const m_TT_MS_LANGID_DZONGHKA_BHUTAN = 2129
const m_TT_MS_LANGID_EDO_NIGERIA = 0x0466
const m_TT_MS_LANGID_ENGLISH_AUSTRALIA = 3081
const m_TT_MS_LANGID_ENGLISH_BELIZE = 10249
const m_TT_MS_LANGID_ENGLISH_CANADA = 4105
const m_TT_MS_LANGID_ENGLISH_CARIBBEAN = 9225
const m_TT_MS_LANGID_ENGLISH_GENERAL = 9
const m_TT_MS_LANGID_ENGLISH_HONG_KONG = 15369
const m_TT_MS_LANGID_ENGLISH_INDIA = 16393
const m_TT_MS_LANGID_ENGLISH_INDONESIA = 0x3809
const m_TT_MS_LANGID_ENGLISH_IRELAND = 6153
const m_TT_MS_LANGID_ENGLISH_JAMAICA = 8201
const m_TT_MS_LANGID_ENGLISH_MALAYSIA = 17417
const m_TT_MS_LANGID_ENGLISH_NEW_ZEALAND = 5129
const m_TT_MS_LANGID_ENGLISH_PHILIPPINES = 13321
const m_TT_MS_LANGID_ENGLISH_SINGAPORE = 18441
const m_TT_MS_LANGID_ENGLISH_SOUTH_AFRICA = 7177
const m_TT_MS_LANGID_ENGLISH_TRINIDAD = 11273
const m_TT_MS_LANGID_ENGLISH_UNITED_KINGDOM = 2057
const m_TT_MS_LANGID_ENGLISH_UNITED_STATES = 1033
const m_TT_MS_LANGID_ENGLISH_ZIMBABWE = 12297
const m_TT_MS_LANGID_ESTONIAN_ESTONIA = 1061
const m_TT_MS_LANGID_FAEROESE_FAEROE_ISLANDS = 1080
const m_TT_MS_LANGID_FARSI_IRAN = 1065
const m_TT_MS_LANGID_FILIPINO_PHILIPPINES = 1124
const m_TT_MS_LANGID_FINNISH_FINLAND = 1035
const m_TT_MS_LANGID_FRENCH_BELGIUM = 2060
const m_TT_MS_LANGID_FRENCH_CAMEROON = 11276
const m_TT_MS_LANGID_FRENCH_CANADA = 3084
const m_TT_MS_LANGID_FRENCH_CONGO = 9228
const m_TT_MS_LANGID_FRENCH_COTE_D_IVOIRE = 12300
const m_TT_MS_LANGID_FRENCH_FRANCE = 1036
const m_TT_MS_LANGID_FRENCH_HAITI = 15372
const m_TT_MS_LANGID_FRENCH_LUXEMBOURG = 5132
const m_TT_MS_LANGID_FRENCH_MALI = 13324
const m_TT_MS_LANGID_FRENCH_MONACO = 6156
const m_TT_MS_LANGID_FRENCH_MOROCCO = 14348
const m_TT_MS_LANGID_FRENCH_NORTH_AFRICA = 58380
const m_TT_MS_LANGID_FRENCH_REUNION = 8204
const m_TT_MS_LANGID_FRENCH_SENEGAL = 10252
const m_TT_MS_LANGID_FRENCH_SWITZERLAND = 4108
const m_TT_MS_LANGID_FRENCH_WEST_INDIES = 7180
const m_TT_MS_LANGID_FRENCH_ZAIRE = "TT_MS_LANGID_FRENCH_CONGO"
const m_TT_MS_LANGID_FRISIAN_NETHERLANDS = 1122
const m_TT_MS_LANGID_FULFULDE_NIGERIA = 0x0467
const m_TT_MS_LANGID_GALICIAN_GALICIAN = 1110
const m_TT_MS_LANGID_GALICIAN_SPAIN = "TT_MS_LANGID_GALICIAN_GALICIAN"
const m_TT_MS_LANGID_GEORGIAN_GEORGIA = 1079
const m_TT_MS_LANGID_GERMAN_AUSTRIA = 3079
const m_TT_MS_LANGID_GERMAN_GERMANY = 1031
const m_TT_MS_LANGID_GERMAN_LIECHTENSTEI = "TT_MS_LANGID_GERMAN_LIECHTENSTEIN"
const m_TT_MS_LANGID_GERMAN_LIECHTENSTEIN = 5127
const m_TT_MS_LANGID_GERMAN_LUXEMBOURG = 4103
const m_TT_MS_LANGID_GERMAN_SWITZERLAND = 2055
const m_TT_MS_LANGID_GREEK_GREECE = 1032
const m_TT_MS_LANGID_GREENLANDIC_GREENLAND = 0x046F
const m_TT_MS_LANGID_GUARANI_PARAGUAY = 1140
const m_TT_MS_LANGID_GUJARATI_INDIA = 1095
const m_TT_MS_LANGID_HAUSA_NIGERIA = 1128
const m_TT_MS_LANGID_HAWAIIAN_UNITED_STATES = 1141
const m_TT_MS_LANGID_HEBREW_ISRAEL = 1037
const m_TT_MS_LANGID_HINDI_INDIA = 1081
const m_TT_MS_LANGID_HUNGARIAN_HUNGARY = 1038
const m_TT_MS_LANGID_IBIBIO_NIGERIA = 0x0469
const m_TT_MS_LANGID_ICELANDIC_ICELAND = 1039
const m_TT_MS_LANGID_IGBO_NIGERIA = 1136
const m_TT_MS_LANGID_INDONESIAN_INDONESIA = 1057
const m_TT_MS_LANGID_INUKTITUT_CANADA = 1117
const m_TT_MS_LANGID_INUKTITUT_CANADA_LATIN = 0x085D
const m_TT_MS_LANGID_IRISH_GAELIC_IRELAND = 1084
const m_TT_MS_LANGID_IRISH_IRELAND = 0x083C
const m_TT_MS_LANGID_ISIXHOSA_SOUTH_AFRICA = 1076
const m_TT_MS_LANGID_ISIZULU_SOUTH_AFRICA = 1077
const m_TT_MS_LANGID_ITALIAN_ITALY = 1040
const m_TT_MS_LANGID_ITALIAN_SWITZERLAND = 2064
const m_TT_MS_LANGID_JAPANESE_JAPAN = 1041
const m_TT_MS_LANGID_KANNADA_INDIA = 1099
const m_TT_MS_LANGID_KANURI_NIGERIA = 1137
const m_TT_MS_LANGID_KASHMIRI_INDIA = "TT_MS_LANGID_KASHMIRI_SASIA"
const m_TT_MS_LANGID_KASHMIRI_PAKISTAN = 1120
const m_TT_MS_LANGID_KASHMIRI_SASIA = 2144
const m_TT_MS_LANGID_KAZAKH_KAZAKHSTAN = 1087
const m_TT_MS_LANGID_KAZAK_KAZAKSTAN = "TT_MS_LANGID_KAZAKH_KAZAKHSTAN"
const m_TT_MS_LANGID_KHMER_CAMBODIA = 1107
const m_TT_MS_LANGID_KICHE_GUATEMALA = 0x0486
const m_TT_MS_LANGID_KINYARWANDA_RWANDA = 0x0487
const m_TT_MS_LANGID_KIRGHIZ_KIRGHIZSTAN = "TT_MS_LANGID_KYRGYZ_KYRGYZSTAN"
const m_TT_MS_LANGID_KIRGHIZ_KIRGHIZ_REPUBLIC = "TT_MS_LANGID_KYRGYZ_KYRGYZSTAN"
const m_TT_MS_LANGID_KISWAHILI_KENYA = 1089
const m_TT_MS_LANGID_KONKANI_INDIA = 1111
const m_TT_MS_LANGID_KOREAN_EXTENDED_WANSUNG_KOREA = "TT_MS_LANGID_KOREAN_KOREA"
const m_TT_MS_LANGID_KOREAN_JOHAB_KOREA = 2066
const m_TT_MS_LANGID_KOREAN_KOREA = 1042
const m_TT_MS_LANGID_KYRGYZ_KYRGYZSTAN = 1088
const m_TT_MS_LANGID_LAO_LAOS = 1108
const m_TT_MS_LANGID_LATIN = 1142
const m_TT_MS_LANGID_LATVIAN_LATVIA = 1062
const m_TT_MS_LANGID_LITHUANIAN_LITHUANIA = 1063
const m_TT_MS_LANGID_LOWER_SORBIAN_GERMANY = 0x082E
const m_TT_MS_LANGID_LUXEMBOURGISH_LUXEMBOURG = 0x046E
const m_TT_MS_LANGID_MACEDONIAN_MACEDONIA = 1071
const m_TT_MS_LANGID_MALAYALAM_INDIA = 1100
const m_TT_MS_LANGID_MALAY_BRUNEI_DARUSSALAM = 2110
const m_TT_MS_LANGID_MALAY_MALAYSIA = 1086
const m_TT_MS_LANGID_MALTESE_MALTA = 1082
const m_TT_MS_LANGID_MANIPURI_INDIA = 1112
const m_TT_MS_LANGID_MAORI_NEW_ZEALAND = 1153
const m_TT_MS_LANGID_MAPUDUNGUN_CHILE = 0x047A
const m_TT_MS_LANGID_MARATHI_INDIA = 1102
const m_TT_MS_LANGID_MOHAWK_MOHAWK = 0x047C
const m_TT_MS_LANGID_MOLDAVIAN_MOLDAVIA = 2072
const m_TT_MS_LANGID_MONGOLIAN_MONGOLIA = 1104
const m_TT_MS_LANGID_MONGOLIAN_MONGOLIA_MONGOLIAN = "TT_MS_LANGID_MONGOLIAN_PRC"
const m_TT_MS_LANGID_MONGOLIAN_PRC = 2128
const m_TT_MS_LANGID_NEPALI_INDIA = 2145
const m_TT_MS_LANGID_NEPALI_NEPAL = 1121
const m_TT_MS_LANGID_NORWEGIAN_NORWAY_BOKMAL = 1044
const m_TT_MS_LANGID_NORWEGIAN_NORWAY_NYNORSK = 2068
const m_TT_MS_LANGID_OCCITAN_FRANCE = 0x0482
const m_TT_MS_LANGID_ODIA_INDIA = 1096
const m_TT_MS_LANGID_ORIYA_INDIA = "TT_MS_LANGID_ODIA_INDIA"
const m_TT_MS_LANGID_OROMO_ETHIOPIA = 1138
const m_TT_MS_LANGID_PAPIAMENTU_NETHERLANDS_ANTILLES = 1145
const m_TT_MS_LANGID_PASHTO_AFGHANISTAN = 1123
const m_TT_MS_LANGID_POLISH_POLAND = 1045
const m_TT_MS_LANGID_PORTUGUESE_BRAZIL = 1046
const m_TT_MS_LANGID_PORTUGUESE_PORTUGAL = 2070
const m_TT_MS_LANGID_PUNJABI_ARABIC_PAKISTAN = 2118
const m_TT_MS_LANGID_PUNJABI_INDIA = 1094
const m_TT_MS_LANGID_QUECHUA_BOLIVIA = 0x046B
const m_TT_MS_LANGID_QUECHUA_ECUADOR = 0x086B
const m_TT_MS_LANGID_QUECHUA_PERU = 0x0C6B
const m_TT_MS_LANGID_RHAETO_ROMANIC_SWITZERLAND = "TT_MS_LANGID_ROMANSH_SWITZERLAND"
const m_TT_MS_LANGID_ROMANIAN_ROMANIA = 1048
const m_TT_MS_LANGID_ROMANSH_SWITZERLAND = 1047
const m_TT_MS_LANGID_RUSSIAN_MOLDAVIA = 2073
const m_TT_MS_LANGID_RUSSIAN_RUSSIA = 1049
const m_TT_MS_LANGID_SAAMI_LAPONIA = 1083
const m_TT_MS_LANGID_SAMI_INARI_FINLAND = 0x243B
const m_TT_MS_LANGID_SAMI_LULE_NORWAY = 0x103B
const m_TT_MS_LANGID_SAMI_LULE_SWEDEN = 0x143B
const m_TT_MS_LANGID_SAMI_NORTHERN_FINLAND = 0x0C3B
const m_TT_MS_LANGID_SAMI_NORTHERN_NORWAY = 0x043B
const m_TT_MS_LANGID_SAMI_NORTHERN_SWEDEN = 0x083B
const m_TT_MS_LANGID_SAMI_SKOLT_FINLAND = 0x203B
const m_TT_MS_LANGID_SAMI_SOUTHERN_NORWAY = 0x183B
const m_TT_MS_LANGID_SAMI_SOUTHERN_SWEDEN = 0x1C3B
const m_TT_MS_LANGID_SANSKRIT_INDIA = 1103
const m_TT_MS_LANGID_SCOTTISH_GAELIC_UNITED_KINGDOM = 2108
const m_TT_MS_LANGID_SEPEDI_SOUTH_AFRICA = "TT_MS_LANGID_SESOTHO_SA_LEBOA_SOUTH_AFRICA"
const m_TT_MS_LANGID_SERBIAN_BOSNIA_HERZ_CYRILLIC = 0x1C1A
const m_TT_MS_LANGID_SERBIAN_BOSNIA_HERZ_LATIN = 0x181A
const m_TT_MS_LANGID_SERBIAN_SERBIA_CYRILLIC = 3098
const m_TT_MS_LANGID_SERBIAN_SERBIA_LATIN = 2074
const m_TT_MS_LANGID_SESOTHO_SA_LEBOA_SOUTH_AFRICA = 0x046C
const m_TT_MS_LANGID_SETSWANA_SOUTH_AFRICA = 1074
const m_TT_MS_LANGID_SINDHI_INDIA = 1113
const m_TT_MS_LANGID_SINDHI_PAKISTAN = 0x0859
const m_TT_MS_LANGID_SINHALA_SRI_LANKA = 1115
const m_TT_MS_LANGID_SINHALESE_SRI_LANKA = "TT_MS_LANGID_SINHALA_SRI_LANKA"
const m_TT_MS_LANGID_SLOVAK_SLOVAKIA = 1051
const m_TT_MS_LANGID_SLOVENE_SLOVENIA = "TT_MS_LANGID_SLOVENIAN_SLOVENIA"
const m_TT_MS_LANGID_SLOVENIAN_SLOVENIA = 1060
const m_TT_MS_LANGID_SOMALI_SOMALIA = 1143
const m_TT_MS_LANGID_SORBIAN_GERMANY = "TT_MS_LANGID_UPPER_SORBIAN_GERMANY"
const m_TT_MS_LANGID_SOTHO_SOUTHERN_SOUTH_AFRICA = "TT_MS_LANGID_SESOTHO_SA_LEBOA_SOUTH_AFRICA"
const m_TT_MS_LANGID_SPANISH_ARGENTINA = 11274
const m_TT_MS_LANGID_SPANISH_BOLIVIA = 16394
const m_TT_MS_LANGID_SPANISH_CHILE = 13322
const m_TT_MS_LANGID_SPANISH_COLOMBIA = 9226
const m_TT_MS_LANGID_SPANISH_COSTA_RICA = 5130
const m_TT_MS_LANGID_SPANISH_DOMINICAN_REPUBLIC = 7178
const m_TT_MS_LANGID_SPANISH_ECUADOR = 12298
const m_TT_MS_LANGID_SPANISH_EL_SALVADOR = 17418
const m_TT_MS_LANGID_SPANISH_GUATEMALA = 4106
const m_TT_MS_LANGID_SPANISH_HONDURAS = 18442
const m_TT_MS_LANGID_SPANISH_LATIN_AMERICA = 58378
const m_TT_MS_LANGID_SPANISH_MEXICO = 2058
const m_TT_MS_LANGID_SPANISH_NICARAGUA = 19466
const m_TT_MS_LANGID_SPANISH_PANAMA = 6154
const m_TT_MS_LANGID_SPANISH_PARAGUAY = 15370
const m_TT_MS_LANGID_SPANISH_PERU = 10250
const m_TT_MS_LANGID_SPANISH_PUERTO_RICO = 20490
const m_TT_MS_LANGID_SPANISH_SPAIN_INTERNATIONAL_SORT = "TT_MS_LANGID_SPANISH_SPAIN_MODERN_SORT"
const m_TT_MS_LANGID_SPANISH_SPAIN_MODERN_SORT = 3082
const m_TT_MS_LANGID_SPANISH_SPAIN_TRADITIONAL_SORT = 1034
const m_TT_MS_LANGID_SPANISH_UNITED_STATES = 21514
const m_TT_MS_LANGID_SPANISH_URUGUAY = 14346
const m_TT_MS_LANGID_SPANISH_VENEZUELA = 8202
const m_TT_MS_LANGID_SUTU_SOUTH_AFRICA = 1072
const m_TT_MS_LANGID_SWAHILI_KENYA = "TT_MS_LANGID_KISWAHILI_KENYA"
const m_TT_MS_LANGID_SWEDISH_FINLAND = 2077
const m_TT_MS_LANGID_SWEDISH_SWEDEN = 1053
const m_TT_MS_LANGID_SYRIAC_SYRIA = 1114
const m_TT_MS_LANGID_TAJIK_TAJIKISTAN = 1064
const m_TT_MS_LANGID_TAMAZIGHT_ALGERIA = 0x085F
const m_TT_MS_LANGID_TAMAZIGHT_MOROCCO = 0x045F
const m_TT_MS_LANGID_TAMAZIGHT_MOROCCO_LATIN = "TT_MS_LANGID_TAMAZIGHT_ALGERIA"
const m_TT_MS_LANGID_TAMIL_INDIA = 1097
const m_TT_MS_LANGID_TATAR_RUSSIA = 1092
const m_TT_MS_LANGID_TATAR_TATARSTAN = "TT_MS_LANGID_TATAR_RUSSIA"
const m_TT_MS_LANGID_TELUGU_INDIA = 1098
const m_TT_MS_LANGID_THAI_THAILAND = 1054
const m_TT_MS_LANGID_TIBETAN_BHUTAN = "TT_MS_LANGID_DZONGHKA_BHUTAN"
const m_TT_MS_LANGID_TIBETAN_CHINA = "TT_MS_LANGID_TIBETAN_PRC"
const m_TT_MS_LANGID_TIBETAN_PRC = 1105
const m_TT_MS_LANGID_TIGRIGNA_ERYTHREA = 2163
const m_TT_MS_LANGID_TIGRIGNA_ERYTREA = "TT_MS_LANGID_TIGRIGNA_ERYTHREA"
const m_TT_MS_LANGID_TIGRIGNA_ETHIOPIA = 1139
const m_TT_MS_LANGID_TSONGA_SOUTH_AFRICA = 1073
const m_TT_MS_LANGID_TSWANA_SOUTH_AFRICA = "TT_MS_LANGID_SETSWANA_SOUTH_AFRICA"
const m_TT_MS_LANGID_TURKISH_TURKEY = 1055
const m_TT_MS_LANGID_TURKMEN_TURKMENISTAN = 1090
const m_TT_MS_LANGID_UIGHUR_CHINA = "TT_MS_LANGID_UIGHUR_PRC"
const m_TT_MS_LANGID_UIGHUR_PRC = 0x0480
const m_TT_MS_LANGID_UKRAINIAN_UKRAINE = 1058
const m_TT_MS_LANGID_UPPER_SORBIAN_GERMANY = 1070
const m_TT_MS_LANGID_URDU_INDIA = 2080
const m_TT_MS_LANGID_URDU_PAKISTAN = 1056
const m_TT_MS_LANGID_UZBEK_UZBEKISTAN_CYRILLIC = 2115
const m_TT_MS_LANGID_UZBEK_UZBEKISTAN_LATIN = 1091
const m_TT_MS_LANGID_VENDA_SOUTH_AFRICA = 1075
const m_TT_MS_LANGID_VIETNAMESE_VIET_NAM = 1066
const m_TT_MS_LANGID_WELSH_UNITED_KINGDOM = 1106
const m_TT_MS_LANGID_WELSH_WALES = "TT_MS_LANGID_WELSH_UNITED_KINGDOM"
const m_TT_MS_LANGID_WOLOF_SENEGAL = 0x0488
const m_TT_MS_LANGID_XHOSA_SOUTH_AFRICA = "TT_MS_LANGID_ISIXHOSA_SOUTH_AFRICA"
const m_TT_MS_LANGID_YAKUT_RUSSIA = 0x0485
const m_TT_MS_LANGID_YIDDISH_GERMANY = 1085
const m_TT_MS_LANGID_YI_CHINA = "TT_MS_LANGID_YI_PRC"
const m_TT_MS_LANGID_YI_PRC = 0x0478
const m_TT_MS_LANGID_YORUBA_NIGERIA = 1130
const m_TT_MS_LANGID_ZULU_SOUTH_AFRICA = "TT_MS_LANGID_ISIZULU_SOUTH_AFRICA"
const m_TT_NAME_ID_CID_FINDFONT_NAME = 20
const m_TT_NAME_ID_COPYRIGHT = 0
const m_TT_NAME_ID_DARK_BACKGROUND = 24
const m_TT_NAME_ID_DESCRIPTION = 10
const m_TT_NAME_ID_DESIGNER = 9
const m_TT_NAME_ID_DESIGNER_URL = 12
const m_TT_NAME_ID_FONT_FAMILY = 1
const m_TT_NAME_ID_FONT_SUBFAMILY = 2
const m_TT_NAME_ID_FULL_NAME = 4
const m_TT_NAME_ID_LICENSE = 13
const m_TT_NAME_ID_LICENSE_URL = 14
const m_TT_NAME_ID_LIGHT_BACKGROUND = 23
const m_TT_NAME_ID_MAC_FULL_NAME = 18
const m_TT_NAME_ID_MANUFACTURER = 8
const m_TT_NAME_ID_PREFERRED_FAMILY = "TT_NAME_ID_TYPOGRAPHIC_FAMILY"
const m_TT_NAME_ID_PREFERRED_SUBFAMILY = "TT_NAME_ID_TYPOGRAPHIC_SUBFAMILY"
const m_TT_NAME_ID_PS_NAME = 6
const m_TT_NAME_ID_SAMPLE_TEXT = 19
const m_TT_NAME_ID_TRADEMARK = 7
const m_TT_NAME_ID_TYPOGRAPHIC_FAMILY = 16
const m_TT_NAME_ID_TYPOGRAPHIC_SUBFAMILY = 17
const m_TT_NAME_ID_UNIQUE_ID = 3
const m_TT_NAME_ID_VARIATIONS_PREFIX = 25
const m_TT_NAME_ID_VENDOR_URL = 11
const m_TT_NAME_ID_VERSION_STRING = 5
const m_TT_NAME_ID_WWS_FAMILY = 21
const m_TT_NAME_ID_WWS_SUBFAMILY = 22
const m_TT_PLATFORM_ADOBE = 7
const m_TT_PLATFORM_APPLE_UNICODE = 0
const m_TT_PLATFORM_CUSTOM = 4
const m_TT_PLATFORM_ISO = 2
const m_TT_PLATFORM_MACINTOSH = 1
const m_TT_PLATFORM_MICROSOFT = 3
const m_TT_UCR_ARABIC_PRESENTATION_A = "TT_UCR_ARABIC_PRESENTATION_FORMS_A"
const m_TT_UCR_ARABIC_PRESENTATION_B = "TT_UCR_ARABIC_PRESENTATION_FORMS_B"
const m_TT_UCR_COMBINING_DIACRITICS = "TT_UCR_COMBINING_DIACRITICAL_MARKS"
const m_TT_UCR_COMBINING_DIACRITICS_SYMB = "TT_UCR_COMBINING_DIACRITICAL_MARKS_SYMB"
const m_TT_UCR_KANBUN = "TT_UCR_CJK_MISC"
const m_TT_UCR_NON_PLANE_0 = "TT_UCR_SURROGATES"
const m___IPHONE_COMPAT_VERSION = "__IPHONE_NA"
const m_ft_encoding_adobe_custom = "FT_ENCODING_ADOBE_CUSTOM"
const m_ft_encoding_adobe_expert = "FT_ENCODING_ADOBE_EXPERT"
const m_ft_encoding_adobe_standard = "FT_ENCODING_ADOBE_STANDARD"
const m_ft_encoding_apple_roman = "FT_ENCODING_APPLE_ROMAN"
const m_ft_encoding_big5 = "FT_ENCODING_BIG5"
const m_ft_encoding_gb2312 = "FT_ENCODING_PRC"
const m_ft_encoding_johab = "FT_ENCODING_JOHAB"
const m_ft_encoding_latin_1 = "FT_ENCODING_ADOBE_LATIN_1"
const m_ft_encoding_latin_2 = "FT_ENCODING_OLD_LATIN_2"
const m_ft_encoding_none = "FT_ENCODING_NONE"
const m_ft_encoding_sjis = "FT_ENCODING_SJIS"
const m_ft_encoding_symbol = "FT_ENCODING_MS_SYMBOL"
const m_ft_encoding_unicode = "FT_ENCODING_UNICODE"
const m_ft_encoding_wansung = "FT_ENCODING_WANSUNG"
const m_ft_fclose = "fclose"
const m_ft_fopen = "fopen"
const m_ft_fread = "fread"
const m_ft_fseek = "fseek"
const m_ft_ftell = "ftell"
const m_ft_getenv = "getenv"
const m_ft_glyph_format_bitmap = "FT_GLYPH_FORMAT_BITMAP"
const m_ft_glyph_format_composite = "FT_GLYPH_FORMAT_COMPOSITE"
const m_ft_glyph_format_none = "FT_GLYPH_FORMAT_NONE"
const m_ft_glyph_format_outline = "FT_GLYPH_FORMAT_OUTLINE"
const m_ft_glyph_format_plotter = "FT_GLYPH_FORMAT_PLOTTER"
const m_ft_jmp_buf = "jmp_buf"
const m_ft_kerning_default = "FT_KERNING_DEFAULT"
const m_ft_kerning_unfitted = "FT_KERNING_UNFITTED"
const m_ft_kerning_unscaled = "FT_KERNING_UNSCALED"
const m_ft_longjmp = "longjmp"
const m_ft_memchr = "memchr"
const m_ft_memcmp = "memcmp"
const m_ft_memcpy = "memcpy"
const m_ft_memmove = "memmove"
const m_ft_memset = "memset"
const m_ft_open_driver = "FT_OPEN_DRIVER"
const m_ft_open_memory = "FT_OPEN_MEMORY"
const m_ft_open_params = "FT_OPEN_PARAMS"
const m_ft_open_pathname = "FT_OPEN_PATHNAME"
const m_ft_open_stream = "FT_OPEN_STREAM"
const m_ft_outline_even_odd_fill = "FT_OUTLINE_EVEN_ODD_FILL"
const m_ft_outline_high_precision = "FT_OUTLINE_HIGH_PRECISION"
const m_ft_outline_ignore_dropouts = "FT_OUTLINE_IGNORE_DROPOUTS"
const m_ft_outline_none = "FT_OUTLINE_NONE"
const m_ft_outline_owner = "FT_OUTLINE_OWNER"
const m_ft_outline_reverse_fill = "FT_OUTLINE_REVERSE_FILL"
const m_ft_outline_single_pass = "FT_OUTLINE_SINGLE_PASS"
const m_ft_pixel_mode_grays = "FT_PIXEL_MODE_GRAY"
const m_ft_pixel_mode_mono = "FT_PIXEL_MODE_MONO"
const m_ft_pixel_mode_none = "FT_PIXEL_MODE_NONE"
const m_ft_pixel_mode_pal2 = "FT_PIXEL_MODE_GRAY2"
const m_ft_pixel_mode_pal4 = "FT_PIXEL_MODE_GRAY4"
const m_ft_ptrdiff_t = "ptrdiff_t"
const m_ft_qsort = "qsort"
const m_ft_raster_flag_aa = "FT_RASTER_FLAG_AA"
const m_ft_raster_flag_clip = "FT_RASTER_FLAG_CLIP"
const m_ft_raster_flag_default = "FT_RASTER_FLAG_DEFAULT"
const m_ft_raster_flag_direct = "FT_RASTER_FLAG_DIRECT"
const m_ft_render_mode_mono = "FT_RENDER_MODE_MONO"
const m_ft_render_mode_normal = "FT_RENDER_MODE_NORMAL"
const m_ft_scalloc = "calloc"
const m_ft_sfnt_head = 0
const m_ft_sfnt_hhea = "FT_SFNT_HHEA"
const m_ft_sfnt_maxp = "FT_SFNT_MAXP"
const m_ft_sfnt_os2 = "FT_SFNT_OS2"
const m_ft_sfnt_pclt = "FT_SFNT_PCLT"
const m_ft_sfnt_post = "FT_SFNT_POST"
const m_ft_sfnt_vhea = "FT_SFNT_VHEA"
const m_ft_sfree = "free"
const m_ft_smalloc = "malloc"
const m_ft_sprintf = "sprintf"
const m_ft_srealloc = "realloc"
const m_ft_strcat = "strcat"
const m_ft_strcmp = "strcmp"
const m_ft_strcpy = "strcpy"
const m_ft_strlen = "strlen"
const m_ft_strncmp = "strncmp"
const m_ft_strncpy = "strncpy"
const m_ft_strrchr = "strrchr"
const m_ft_strstr = "strstr"
const m_ft_strtol = "strtol"
const m_t1_blend_blue_scale = "T1_BLEND_BLUE_SCALE"
const m_t1_blend_blue_shift = "T1_BLEND_BLUE_SHIFT"
const m_t1_blend_blue_values = "T1_BLEND_BLUE_VALUES"
const m_t1_blend_family_blues = "T1_BLEND_FAMILY_BLUES"
const m_t1_blend_family_other_blues = "T1_BLEND_FAMILY_OTHER_BLUES"
const m_t1_blend_force_bold = "T1_BLEND_FORCE_BOLD"
const m_t1_blend_italic_angle = "T1_BLEND_ITALIC_ANGLE"
const m_t1_blend_max = "T1_BLEND_MAX"
const m_t1_blend_other_blues = "T1_BLEND_OTHER_BLUES"
const m_t1_blend_standard_height = "T1_BLEND_STANDARD_HEIGHT"
const m_t1_blend_standard_widths = "T1_BLEND_STANDARD_WIDTH"
const m_t1_blend_stem_snap_heights = "T1_BLEND_STEM_SNAP_HEIGHTS"
const m_t1_blend_stem_snap_widths = "T1_BLEND_STEM_SNAP_WIDTHS"
const m_t1_blend_underline_position = "T1_BLEND_UNDERLINE_POSITION"
const m_t1_blend_underline_thickness = "T1_BLEND_UNDERLINE_THICKNESS"

type Tjmp_buf = [37]int32

type Tsigjmp_buf = [38]int32

type TFT_Int16 = int16

type TFT_UInt16 = uint16

type TFT_Int32 = int32

type TFT_UInt32 = uint32

type TFT_Fast = int32

type TFT_UFast = uint32

type TFT_Int64 = int64

type TFT_UInt64 = uint64

type TFT_Memory = uintptr

type TFT_MemoryRec_ = struct {
	Fuser    uintptr
	Falloc   TFT_Alloc_Func
	Ffree    TFT_Free_Func
	Frealloc TFT_Realloc_Func
}

type TFT_Alloc_Func = uintptr

type TFT_Free_Func = uintptr

type TFT_Realloc_Func = uintptr

type TFT_Stream = uintptr

type TFT_StreamRec_ = struct {
	Fbase       uintptr
	Fsize       uint64
	Fpos        uint64
	Fdescriptor TFT_StreamDesc
	Fpathname   TFT_StreamDesc
	Fread       TFT_Stream_IoFunc
	Fclose1     TFT_Stream_CloseFunc
	Fmemory     TFT_Memory
	Fcursor     uintptr
	Flimit      uintptr
}

type TFT_StreamDesc = struct {
	Fpointer [0]uintptr
	Fvalue   int64
}

type TFT_StreamDesc_ = TFT_StreamDesc

type TFT_Stream_IoFunc = uintptr

type TFT_Stream_CloseFunc = uintptr

type TFT_StreamRec = struct {
	Fbase       uintptr
	Fsize       uint64
	Fpos        uint64
	Fdescriptor TFT_StreamDesc
	Fpathname   TFT_StreamDesc
	Fread       TFT_Stream_IoFunc
	Fclose1     TFT_Stream_CloseFunc
	Fmemory     TFT_Memory
	Fcursor     uintptr
	Flimit      uintptr
}

type TFT_Pos = int64

type TFT_Vector = struct {
	Fx TFT_Pos
	Fy TFT_Pos
}

type TFT_Vector_ = TFT_Vector

type TFT_BBox = struct {
	FxMin TFT_Pos
	FyMin TFT_Pos
	FxMax TFT_Pos
	FyMax TFT_Pos
}

type TFT_BBox_ = TFT_BBox

type TFT_Pixel_Mode = int32

type _FT_Pixel_Mode_ = int32

const _FT_PIXEL_MODE_NONE = 0
const _FT_PIXEL_MODE_MONO = 1
const _FT_PIXEL_MODE_GRAY = 2
const _FT_PIXEL_MODE_GRAY2 = 3
const _FT_PIXEL_MODE_GRAY4 = 4
const _FT_PIXEL_MODE_LCD = 5
const _FT_PIXEL_MODE_LCD_V = 6
const _FT_PIXEL_MODE_BGRA = 7
const _FT_PIXEL_MODE_MAX = 8

type TFT_Bitmap = struct {
	Frows         uint32
	Fwidth        uint32
	Fpitch        int32
	Fbuffer       uintptr
	Fnum_grays    uint16
	Fpixel_mode   uint8
	Fpalette_mode uint8
	Fpalette      uintptr
}

type TFT_Bitmap_ = TFT_Bitmap

type TFT_Outline = struct {
	Fn_contours int16
	Fn_points   int16
	Fpoints     uintptr
	Ftags       uintptr
	Fcontours   uintptr
	Fflags      int32
}

type TFT_Outline_ = TFT_Outline

type TFT_Outline_MoveToFunc = uintptr

type TFT_Outline_LineToFunc = uintptr

type TFT_Outline_ConicToFunc = uintptr

type TFT_Outline_CubicToFunc = uintptr

type TFT_Outline_Funcs = struct {
	Fmove_to  TFT_Outline_MoveToFunc
	Fline_to  TFT_Outline_LineToFunc
	Fconic_to TFT_Outline_ConicToFunc
	Fcubic_to TFT_Outline_CubicToFunc
	Fshift    int32
	Fdelta    TFT_Pos
}

type TFT_Outline_Funcs_ = TFT_Outline_Funcs

type TFT_Glyph_Format = int32

type _FT_Glyph_Format_ = int32

const _FT_GLYPH_FORMAT_NONE = 0
const _FT_GLYPH_FORMAT_COMPOSITE = 1668246896
const _FT_GLYPH_FORMAT_BITMAP = 1651078259
const _FT_GLYPH_FORMAT_OUTLINE = 1869968492
const _FT_GLYPH_FORMAT_PLOTTER = 1886154612

type TFT_Raster = uintptr

type TFT_Span = struct {
	Fx        int16
	Flen1     uint16
	Fcoverage uint8
}

type TFT_Span_ = TFT_Span

type TFT_SpanFunc = uintptr

type TFT_Raster_BitTest_Func = uintptr

type TFT_Raster_BitSet_Func = uintptr

type TFT_Raster_Params = struct {
	Ftarget      uintptr
	Fsource      uintptr
	Fflags       int32
	Fgray_spans  TFT_SpanFunc
	Fblack_spans TFT_SpanFunc
	Fbit_test    TFT_Raster_BitTest_Func
	Fbit_set     TFT_Raster_BitSet_Func
	Fuser        uintptr
	Fclip_box    TFT_BBox
}

type TFT_Raster_Params_ = TFT_Raster_Params

type TFT_Raster_NewFunc = uintptr

type TFT_Raster_DoneFunc = uintptr

type TFT_Raster_ResetFunc = uintptr

type TFT_Raster_SetModeFunc = uintptr

type TFT_Raster_RenderFunc = uintptr

type TFT_Raster_Funcs = struct {
	Fglyph_format    TFT_Glyph_Format
	Fraster_new      TFT_Raster_NewFunc
	Fraster_reset    TFT_Raster_ResetFunc
	Fraster_set_mode TFT_Raster_SetModeFunc
	Fraster_render   TFT_Raster_RenderFunc
	Fraster_done     TFT_Raster_DoneFunc
}

type TFT_Raster_Funcs_ = TFT_Raster_Funcs

type TFT_Bool = uint8

type TFT_FWord = int16

type TFT_UFWord = uint16

type TFT_Char = int8

type TFT_Byte = uint8

type TFT_Bytes = uintptr

type TFT_Tag = uint32

type TFT_String = int8

type TFT_Short = int16

type TFT_UShort = uint16

type TFT_Int = int32

type TFT_UInt = uint32

type TFT_Long = int64

type TFT_ULong = uint64

type TFT_F2Dot14 = int16

type TFT_F26Dot6 = int64

type TFT_Fixed = int64

type TFT_Error = int32

type TFT_Pointer = uintptr

type TFT_Offset = uint64

type TFT_PtrDist = int64

type TFT_UnitVector = struct {
	Fx TFT_F2Dot14
	Fy TFT_F2Dot14
}

type TFT_UnitVector_ = TFT_UnitVector

type TFT_Matrix = struct {
	Fxx TFT_Fixed
	Fxy TFT_Fixed
	Fyx TFT_Fixed
	Fyy TFT_Fixed
}

type TFT_Matrix_ = TFT_Matrix

type TFT_Data = struct {
	Fpointer uintptr
	Flength  TFT_Int
}

type TFT_Data_ = TFT_Data

type TFT_Generic_Finalizer = uintptr

type TFT_Generic = struct {
	Fdata      uintptr
	Ffinalizer TFT_Generic_Finalizer
}

type TFT_Generic_ = TFT_Generic

type TFT_ListNode = uintptr

type TFT_ListNodeRec_ = struct {
	Fprev TFT_ListNode
	Fnext TFT_ListNode
	Fdata uintptr
}

type TFT_List = uintptr

type TFT_ListRec_ = struct {
	Fhead TFT_ListNode
	Ftail TFT_ListNode
}

type TFT_ListNodeRec = struct {
	Fprev TFT_ListNode
	Fnext TFT_ListNode
	Fdata uintptr
}

type TFT_ListRec = struct {
	Fhead TFT_ListNode
	Ftail TFT_ListNode
}

const _FT_Mod_Err_Base = 0
const _FT_Mod_Err_Autofit = 0
const _FT_Mod_Err_BDF = 0
const _FT_Mod_Err_Bzip2 = 0
const _FT_Mod_Err_Cache = 0
const _FT_Mod_Err_CFF = 0
const _FT_Mod_Err_CID = 0
const _FT_Mod_Err_Gzip = 0
const _FT_Mod_Err_LZW = 0
const _FT_Mod_Err_OTvalid = 0
const _FT_Mod_Err_PCF = 0
const _FT_Mod_Err_PFR = 0
const _FT_Mod_Err_PSaux = 0
const _FT_Mod_Err_PShinter = 0
const _FT_Mod_Err_PSnames = 0
const _FT_Mod_Err_Raster = 0
const _FT_Mod_Err_SFNT = 0
const _FT_Mod_Err_Smooth = 0
const _FT_Mod_Err_TrueType = 0
const _FT_Mod_Err_Type1 = 0
const _FT_Mod_Err_Type42 = 0
const _FT_Mod_Err_Winfonts = 0
const _FT_Mod_Err_GXvalid = 0
const _FT_Mod_Err_Max = 1
const _FT_Err_Ok = 0
const _FT_Err_Cannot_Open_Resource = 1
const _FT_Err_Unknown_File_Format = 2
const _FT_Err_Invalid_File_Format = 3
const _FT_Err_Invalid_Version = 4
const _FT_Err_Lower_Module_Version = 5
const _FT_Err_Invalid_Argument = 6
const _FT_Err_Unimplemented_Feature = 7
const _FT_Err_Invalid_Table = 8
const _FT_Err_Invalid_Offset = 9
const _FT_Err_Array_Too_Large = 10
const _FT_Err_Missing_Module = 11
const _FT_Err_Missing_Property = 12
const _FT_Err_Invalid_Glyph_Index = 16
const _FT_Err_Invalid_Character_Code = 17
const _FT_Err_Invalid_Glyph_Format = 18
const _FT_Err_Cannot_Render_Glyph = 19
const _FT_Err_Invalid_Outline = 20
const _FT_Err_Invalid_Composite = 21
const _FT_Err_Too_Many_Hints = 22
const _FT_Err_Invalid_Pixel_Size = 23
const _FT_Err_Invalid_Handle = 32
const _FT_Err_Invalid_Library_Handle = 33
const _FT_Err_Invalid_Driver_Handle = 34
const _FT_Err_Invalid_Face_Handle = 35
const _FT_Err_Invalid_Size_Handle = 36
const _FT_Err_Invalid_Slot_Handle = 37
const _FT_Err_Invalid_CharMap_Handle = 38
const _FT_Err_Invalid_Cache_Handle = 39
const _FT_Err_Invalid_Stream_Handle = 40
const _FT_Err_Too_Many_Drivers = 48
const _FT_Err_Too_Many_Extensions = 49
const _FT_Err_Out_Of_Memory = 64
const _FT_Err_Unlisted_Object = 65
const _FT_Err_Cannot_Open_Stream = 81
const _FT_Err_Invalid_Stream_Seek = 82
const _FT_Err_Invalid_Stream_Skip = 83
const _FT_Err_Invalid_Stream_Read = 84
const _FT_Err_Invalid_Stream_Operation = 85
const _FT_Err_Invalid_Frame_Operation = 86
const _FT_Err_Nested_Frame_Access = 87
const _FT_Err_Invalid_Frame_Read = 88
const _FT_Err_Raster_Uninitialized = 96
const _FT_Err_Raster_Corrupted = 97
const _FT_Err_Raster_Overflow = 98
const _FT_Err_Raster_Negative_Height = 99
const _FT_Err_Too_Many_Caches = 112
const _FT_Err_Invalid_Opcode = 128
const _FT_Err_Too_Few_Arguments = 129
const _FT_Err_Stack_Overflow = 130
const _FT_Err_Code_Overflow = 131
const _FT_Err_Bad_Argument = 132
const _FT_Err_Divide_By_Zero = 133
const _FT_Err_Invalid_Reference = 134
const _FT_Err_Debug_OpCode = 135
const _FT_Err_ENDF_In_Exec_Stream = 136
const _FT_Err_Nested_DEFS = 137
const _FT_Err_Invalid_CodeRange = 138
const _FT_Err_Execution_Too_Long = 139
const _FT_Err_Too_Many_Function_Defs = 140
const _FT_Err_Too_Many_Instruction_Defs = 141
const _FT_Err_Table_Missing = 142
const _FT_Err_Horiz_Header_Missing = 143
const _FT_Err_Locations_Missing = 144
const _FT_Err_Name_Table_Missing = 145
const _FT_Err_CMap_Table_Missing = 146
const _FT_Err_Hmtx_Table_Missing = 147
const _FT_Err_Post_Table_Missing = 148
const _FT_Err_Invalid_Horiz_Metrics = 149
const _FT_Err_Invalid_CharMap_Format = 150
const _FT_Err_Invalid_PPem = 151
const _FT_Err_Invalid_Vert_Metrics = 152
const _FT_Err_Could_Not_Find_Context = 153
const _FT_Err_Invalid_Post_Table_Format = 154
const _FT_Err_Invalid_Post_Table = 155
const _FT_Err_DEF_In_Glyf_Bytecode = 156
const _FT_Err_Missing_Bitmap = 157
const _FT_Err_Syntax_Error = 160
const _FT_Err_Stack_Underflow = 161
const _FT_Err_Ignore = 162
const _FT_Err_No_Unicode_Glyph_Name = 163
const _FT_Err_Glyph_Too_Big = 164
const _FT_Err_Missing_Startfont_Field = 176
const _FT_Err_Missing_Font_Field = 177
const _FT_Err_Missing_Size_Field = 178
const _FT_Err_Missing_Fontboundingbox_Field = 179
const _FT_Err_Missing_Chars_Field = 180
const _FT_Err_Missing_Startchar_Field = 181
const _FT_Err_Missing_Encoding_Field = 182
const _FT_Err_Missing_Bbx_Field = 183
const _FT_Err_Bbx_Too_Big = 184
const _FT_Err_Corrupted_Font_Header = 185
const _FT_Err_Corrupted_Font_Glyphs = 186
const _FT_Err_Max = 187

type TFT_Glyph_Metrics = struct {
	Fwidth        TFT_Pos
	Fheight       TFT_Pos
	FhoriBearingX TFT_Pos
	FhoriBearingY TFT_Pos
	FhoriAdvance  TFT_Pos
	FvertBearingX TFT_Pos
	FvertBearingY TFT_Pos
	FvertAdvance  TFT_Pos
}

type TFT_Glyph_Metrics_ = TFT_Glyph_Metrics

type TFT_Bitmap_Size = struct {
	Fheight TFT_Short
	Fwidth  TFT_Short
	Fsize   TFT_Pos
	Fx_ppem TFT_Pos
	Fy_ppem TFT_Pos
}

type TFT_Bitmap_Size_ = TFT_Bitmap_Size

type TFT_Library = uintptr

type TFT_Module = uintptr

type TFT_Driver = uintptr

type TFT_Renderer = uintptr

type TFT_Face = uintptr

type TFT_FaceRec_ = struct {
	Fnum_faces           TFT_Long
	Fface_index          TFT_Long
	Fface_flags          TFT_Long
	Fstyle_flags         TFT_Long
	Fnum_glyphs          TFT_Long
	Ffamily_name         uintptr
	Fstyle_name          uintptr
	Fnum_fixed_sizes     TFT_Int
	Favailable_sizes     uintptr
	Fnum_charmaps        TFT_Int
	Fcharmaps            uintptr
	Fgeneric             TFT_Generic
	Fbbox                TFT_BBox
	Funits_per_EM        TFT_UShort
	Fascender            TFT_Short
	Fdescender           TFT_Short
	Fheight              TFT_Short
	Fmax_advance_width   TFT_Short
	Fmax_advance_height  TFT_Short
	Funderline_position  TFT_Short
	Funderline_thickness TFT_Short
	Fglyph               TFT_GlyphSlot
	Fsize                TFT_Size
	Fcharmap             TFT_CharMap
	Fdriver              TFT_Driver
	Fmemory              TFT_Memory
	Fstream              TFT_Stream
	Fsizes_list          TFT_ListRec
	Fautohint            TFT_Generic
	Fextensions          uintptr
	Finternal            TFT_Face_Internal
}

type TFT_Size = uintptr

type TFT_SizeRec_ = struct {
	Fface     TFT_Face
	Fgeneric  TFT_Generic
	Fmetrics  TFT_Size_Metrics
	Finternal TFT_Size_Internal
}

type TFT_GlyphSlot = uintptr

type TFT_GlyphSlotRec_ = struct {
	Flibrary           TFT_Library
	Fface              TFT_Face
	Fnext              TFT_GlyphSlot
	Fglyph_index       TFT_UInt
	Fgeneric           TFT_Generic
	Fmetrics           TFT_Glyph_Metrics
	FlinearHoriAdvance TFT_Fixed
	FlinearVertAdvance TFT_Fixed
	Fadvance           TFT_Vector
	Fformat            TFT_Glyph_Format
	Fbitmap            TFT_Bitmap
	Fbitmap_left       TFT_Int
	Fbitmap_top        TFT_Int
	Foutline           TFT_Outline
	Fnum_subglyphs     TFT_UInt
	Fsubglyphs         TFT_SubGlyph
	Fcontrol_data      uintptr
	Fcontrol_len       int64
	Flsb_delta         TFT_Pos
	Frsb_delta         TFT_Pos
	Fother             uintptr
	Finternal          TFT_Slot_Internal
}

type TFT_CharMap = uintptr

type TFT_CharMapRec_ = struct {
	Fface        TFT_Face
	Fencoding    TFT_Encoding
	Fplatform_id TFT_UShort
	Fencoding_id TFT_UShort
}

type _FT_Encoding_ = int32

const _FT_ENCODING_NONE = 0
const _FT_ENCODING_MS_SYMBOL = 1937337698
const _FT_ENCODING_UNICODE = 1970170211
const _FT_ENCODING_SJIS = 1936353651
const _FT_ENCODING_PRC = 1734484000
const _FT_ENCODING_BIG5 = 1651074869
const _FT_ENCODING_WANSUNG = 2002873971
const _FT_ENCODING_JOHAB = 1785686113
const _FT_ENCODING_GB2312 = 1734484000
const _FT_ENCODING_MS_SJIS = 1936353651
const _FT_ENCODING_MS_GB2312 = 1734484000
const _FT_ENCODING_MS_BIG5 = 1651074869
const _FT_ENCODING_MS_WANSUNG = 2002873971
const _FT_ENCODING_MS_JOHAB = 1785686113
const _FT_ENCODING_ADOBE_STANDARD = 1094995778
const _FT_ENCODING_ADOBE_EXPERT = 1094992453
const _FT_ENCODING_ADOBE_CUSTOM = 1094992451
const _FT_ENCODING_ADOBE_LATIN_1 = 1818326065
const _FT_ENCODING_OLD_LATIN_2 = 1818326066
const _FT_ENCODING_APPLE_ROMAN = 1634889070

type TFT_Encoding = int32

type TFT_CharMapRec = struct {
	Fface        TFT_Face
	Fencoding    TFT_Encoding
	Fplatform_id TFT_UShort
	Fencoding_id TFT_UShort
}

type TFT_Face_Internal = uintptr

type TFT_FaceRec = struct {
	Fnum_faces           TFT_Long
	Fface_index          TFT_Long
	Fface_flags          TFT_Long
	Fstyle_flags         TFT_Long
	Fnum_glyphs          TFT_Long
	Ffamily_name         uintptr
	Fstyle_name          uintptr
	Fnum_fixed_sizes     TFT_Int
	Favailable_sizes     uintptr
	Fnum_charmaps        TFT_Int
	Fcharmaps            uintptr
	Fgeneric             TFT_Generic
	Fbbox                TFT_BBox
	Funits_per_EM        TFT_UShort
	Fascender            TFT_Short
	Fdescender           TFT_Short
	Fheight              TFT_Short
	Fmax_advance_width   TFT_Short
	Fmax_advance_height  TFT_Short
	Funderline_position  TFT_Short
	Funderline_thickness TFT_Short
	Fglyph               TFT_GlyphSlot
	Fsize                TFT_Size
	Fcharmap             TFT_CharMap
	Fdriver              TFT_Driver
	Fmemory              TFT_Memory
	Fstream              TFT_Stream
	Fsizes_list          TFT_ListRec
	Fautohint            TFT_Generic
	Fextensions          uintptr
	Finternal            TFT_Face_Internal
}

type TFT_Size_Internal = uintptr

type TFT_Size_Metrics = struct {
	Fx_ppem      TFT_UShort
	Fy_ppem      TFT_UShort
	Fx_scale     TFT_Fixed
	Fy_scale     TFT_Fixed
	Fascender    TFT_Pos
	Fdescender   TFT_Pos
	Fheight      TFT_Pos
	Fmax_advance TFT_Pos
}

type TFT_Size_Metrics_ = TFT_Size_Metrics

type TFT_SizeRec = struct {
	Fface     TFT_Face
	Fgeneric  TFT_Generic
	Fmetrics  TFT_Size_Metrics
	Finternal TFT_Size_Internal
}

type TFT_SubGlyph = uintptr

type TFT_Slot_Internal = uintptr

type TFT_GlyphSlotRec = struct {
	Flibrary           TFT_Library
	Fface              TFT_Face
	Fnext              TFT_GlyphSlot
	Fglyph_index       TFT_UInt
	Fgeneric           TFT_Generic
	Fmetrics           TFT_Glyph_Metrics
	FlinearHoriAdvance TFT_Fixed
	FlinearVertAdvance TFT_Fixed
	Fadvance           TFT_Vector
	Fformat            TFT_Glyph_Format
	Fbitmap            TFT_Bitmap
	Fbitmap_left       TFT_Int
	Fbitmap_top        TFT_Int
	Foutline           TFT_Outline
	Fnum_subglyphs     TFT_UInt
	Fsubglyphs         TFT_SubGlyph
	Fcontrol_data      uintptr
	Fcontrol_len       int64
	Flsb_delta         TFT_Pos
	Frsb_delta         TFT_Pos
	Fother             uintptr
	Finternal          TFT_Slot_Internal
}

type TFT_Parameter = struct {
	Ftag  TFT_ULong
	Fdata TFT_Pointer
}

type TFT_Parameter_ = TFT_Parameter

type TFT_Open_Args = struct {
	Fflags       TFT_UInt
	Fmemory_base uintptr
	Fmemory_size TFT_Long
	Fpathname    uintptr
	Fstream      TFT_Stream
	Fdriver      TFT_Module
	Fnum_params  TFT_Int
	Fparams      uintptr
}

type TFT_Open_Args_ = TFT_Open_Args

type TFT_Size_Request_Type = int32

type _FT_Size_Request_Type_ = int32

const _FT_SIZE_REQUEST_TYPE_NOMINAL = 0
const _FT_SIZE_REQUEST_TYPE_REAL_DIM = 1
const _FT_SIZE_REQUEST_TYPE_BBOX = 2
const _FT_SIZE_REQUEST_TYPE_CELL = 3
const _FT_SIZE_REQUEST_TYPE_SCALES = 4
const _FT_SIZE_REQUEST_TYPE_MAX = 5

type TFT_Size_RequestRec = struct {
	Ftype1          TFT_Size_Request_Type
	Fwidth          TFT_Long
	Fheight         TFT_Long
	FhoriResolution TFT_UInt
	FvertResolution TFT_UInt
}

type TFT_Size_RequestRec_ = TFT_Size_RequestRec

type TFT_Size_Request = uintptr

type TFT_Render_Mode = int32

type _FT_Render_Mode_ = int32

const _FT_RENDER_MODE_NORMAL = 0
const _FT_RENDER_MODE_LIGHT = 1
const _FT_RENDER_MODE_MONO = 2
const _FT_RENDER_MODE_LCD = 3
const _FT_RENDER_MODE_LCD_V = 4
const _FT_RENDER_MODE_MAX = 5

type TFT_Kerning_Mode = int32

type _FT_Kerning_Mode_ = int32

const _FT_KERNING_DEFAULT = 0
const _FT_KERNING_UNFITTED = 1
const _FT_KERNING_UNSCALED = 2

type TFT_LayerIterator = struct {
	Fnum_layers TFT_UInt
	Flayer      TFT_UInt
	Fp          uintptr
}

type TFT_LayerIterator_ = TFT_LayerIterator

type TTT_Header = struct {
	FTable_Version       TFT_Fixed
	FFont_Revision       TFT_Fixed
	FCheckSum_Adjust     TFT_Long
	FMagic_Number        TFT_Long
	FFlags               TFT_UShort
	FUnits_Per_EM        TFT_UShort
	FCreated             [2]TFT_ULong
	FModified            [2]TFT_ULong
	FxMin                TFT_Short
	FyMin                TFT_Short
	FxMax                TFT_Short
	FyMax                TFT_Short
	FMac_Style           TFT_UShort
	FLowest_Rec_PPEM     TFT_UShort
	FFont_Direction      TFT_Short
	FIndex_To_Loc_Format TFT_Short
	FGlyph_Data_Format   TFT_Short
}

type TTT_Header_ = TTT_Header

type TTT_HoriHeader = struct {
	FVersion                TFT_Fixed
	FAscender               TFT_Short
	FDescender              TFT_Short
	FLine_Gap               TFT_Short
	Fadvance_Width_Max      TFT_UShort
	Fmin_Left_Side_Bearing  TFT_Short
	Fmin_Right_Side_Bearing TFT_Short
	FxMax_Extent            TFT_Short
	Fcaret_Slope_Rise       TFT_Short
	Fcaret_Slope_Run        TFT_Short
	Fcaret_Offset           TFT_Short
	FReserved               [4]TFT_Short
	Fmetric_Data_Format     TFT_Short
	Fnumber_Of_HMetrics     TFT_UShort
	Flong_metrics           uintptr
	Fshort_metrics          uintptr
}

type TTT_HoriHeader_ = TTT_HoriHeader

type TTT_VertHeader = struct {
	FVersion                 TFT_Fixed
	FAscender                TFT_Short
	FDescender               TFT_Short
	FLine_Gap                TFT_Short
	Fadvance_Height_Max      TFT_UShort
	Fmin_Top_Side_Bearing    TFT_Short
	Fmin_Bottom_Side_Bearing TFT_Short
	FyMax_Extent             TFT_Short
	Fcaret_Slope_Rise        TFT_Short
	Fcaret_Slope_Run         TFT_Short
	Fcaret_Offset            TFT_Short
	FReserved                [4]TFT_Short
	Fmetric_Data_Format      TFT_Short
	Fnumber_Of_VMetrics      TFT_UShort
	Flong_metrics            uintptr
	Fshort_metrics           uintptr
}

type TTT_VertHeader_ = TTT_VertHeader

type TTT_OS2 = struct {
	Fversion                 TFT_UShort
	FxAvgCharWidth           TFT_Short
	FusWeightClass           TFT_UShort
	FusWidthClass            TFT_UShort
	FfsType                  TFT_UShort
	FySubscriptXSize         TFT_Short
	FySubscriptYSize         TFT_Short
	FySubscriptXOffset       TFT_Short
	FySubscriptYOffset       TFT_Short
	FySuperscriptXSize       TFT_Short
	FySuperscriptYSize       TFT_Short
	FySuperscriptXOffset     TFT_Short
	FySuperscriptYOffset     TFT_Short
	FyStrikeoutSize          TFT_Short
	FyStrikeoutPosition      TFT_Short
	FsFamilyClass            TFT_Short
	Fpanose                  [10]TFT_Byte
	FulUnicodeRange1         TFT_ULong
	FulUnicodeRange2         TFT_ULong
	FulUnicodeRange3         TFT_ULong
	FulUnicodeRange4         TFT_ULong
	FachVendID               [4]TFT_Char
	FfsSelection             TFT_UShort
	FusFirstCharIndex        TFT_UShort
	FusLastCharIndex         TFT_UShort
	FsTypoAscender           TFT_Short
	FsTypoDescender          TFT_Short
	FsTypoLineGap            TFT_Short
	FusWinAscent             TFT_UShort
	FusWinDescent            TFT_UShort
	FulCodePageRange1        TFT_ULong
	FulCodePageRange2        TFT_ULong
	FsxHeight                TFT_Short
	FsCapHeight              TFT_Short
	FusDefaultChar           TFT_UShort
	FusBreakChar             TFT_UShort
	FusMaxContext            TFT_UShort
	FusLowerOpticalPointSize TFT_UShort
	FusUpperOpticalPointSize TFT_UShort
}

type TTT_OS2_ = TTT_OS2

type TTT_Postscript = struct {
	FFormatType         TFT_Fixed
	FitalicAngle        TFT_Fixed
	FunderlinePosition  TFT_Short
	FunderlineThickness TFT_Short
	FisFixedPitch       TFT_ULong
	FminMemType42       TFT_ULong
	FmaxMemType42       TFT_ULong
	FminMemType1        TFT_ULong
	FmaxMemType1        TFT_ULong
}

type TTT_Postscript_ = TTT_Postscript

type TTT_PCLT = struct {
	FVersion             TFT_Fixed
	FFontNumber          TFT_ULong
	FPitch               TFT_UShort
	FxHeight             TFT_UShort
	FStyle               TFT_UShort
	FTypeFamily          TFT_UShort
	FCapHeight           TFT_UShort
	FSymbolSet           TFT_UShort
	FTypeFace            [16]TFT_Char
	FCharacterComplement [8]TFT_Char
	FFileName            [6]TFT_Char
	FStrokeWeight        TFT_Char
	FWidthType           TFT_Char
	FSerifStyle          TFT_Byte
	FReserved            TFT_Byte
}

type TTT_PCLT_ = TTT_PCLT

type TTT_MaxProfile = struct {
	Fversion               TFT_Fixed
	FnumGlyphs             TFT_UShort
	FmaxPoints             TFT_UShort
	FmaxContours           TFT_UShort
	FmaxCompositePoints    TFT_UShort
	FmaxCompositeContours  TFT_UShort
	FmaxZones              TFT_UShort
	FmaxTwilightPoints     TFT_UShort
	FmaxStorage            TFT_UShort
	FmaxFunctionDefs       TFT_UShort
	FmaxInstructionDefs    TFT_UShort
	FmaxStackElements      TFT_UShort
	FmaxSizeOfInstructions TFT_UShort
	FmaxComponentElements  TFT_UShort
	FmaxComponentDepth     TFT_UShort
}

type TTT_MaxProfile_ = TTT_MaxProfile

type TFT_Sfnt_Tag = int32

type _FT_Sfnt_Tag_ = int32

const _FT_SFNT_HEAD = 0
const _FT_SFNT_MAXP = 1
const _FT_SFNT_OS2 = 2
const _FT_SFNT_HHEA = 3
const _FT_SFNT_VHEA = 4
const _FT_SFNT_POST = 5
const _FT_SFNT_PCLT = 6
const _FT_SFNT_MAX = 7

type TFT_SfntName = struct {
	Fplatform_id TFT_UShort
	Fencoding_id TFT_UShort
	Flanguage_id TFT_UShort
	Fname_id     TFT_UShort
	Fstring1     uintptr
	Fstring_len  TFT_UInt
}

type TFT_SfntName_ = TFT_SfntName

type TFT_SfntLangTag = struct {
	Fstring1    uintptr
	Fstring_len TFT_UInt
}

type TFT_SfntLangTag_ = TFT_SfntLangTag

type TPS_FontInfoRec = struct {
	Fversion             uintptr
	Fnotice              uintptr
	Ffull_name           uintptr
	Ffamily_name         uintptr
	Fweight              uintptr
	Fitalic_angle        TFT_Long
	Fis_fixed_pitch      TFT_Bool
	Funderline_position  TFT_Short
	Funderline_thickness TFT_UShort
}

type TPS_FontInfoRec_ = TPS_FontInfoRec

type TPS_FontInfo = uintptr

type TT1_FontInfo = struct {
	Fversion             uintptr
	Fnotice              uintptr
	Ffull_name           uintptr
	Ffamily_name         uintptr
	Fweight              uintptr
	Fitalic_angle        TFT_Long
	Fis_fixed_pitch      TFT_Bool
	Funderline_position  TFT_Short
	Funderline_thickness TFT_UShort
}

type TPS_PrivateRec = struct {
	Funique_id              TFT_Int
	FlenIV                  TFT_Int
	Fnum_blue_values        TFT_Byte
	Fnum_other_blues        TFT_Byte
	Fnum_family_blues       TFT_Byte
	Fnum_family_other_blues TFT_Byte
	Fblue_values            [14]TFT_Short
	Fother_blues            [10]TFT_Short
	Ffamily_blues           [14]TFT_Short
	Ffamily_other_blues     [10]TFT_Short
	Fblue_scale             TFT_Fixed
	Fblue_shift             TFT_Int
	Fblue_fuzz              TFT_Int
	Fstandard_width         [1]TFT_UShort
	Fstandard_height        [1]TFT_UShort
	Fnum_snap_widths        TFT_Byte
	Fnum_snap_heights       TFT_Byte
	Fforce_bold             TFT_Bool
	Fround_stem_up          TFT_Bool
	Fsnap_widths            [13]TFT_Short
	Fsnap_heights           [13]TFT_Short
	Fexpansion_factor       TFT_Fixed
	Flanguage_group         TFT_Long
	Fpassword               TFT_Long
	Fmin_feature            [2]TFT_Short
}

type TPS_PrivateRec_ = TPS_PrivateRec

type TPS_Private = uintptr

type TT1_Private = struct {
	Funique_id              TFT_Int
	FlenIV                  TFT_Int
	Fnum_blue_values        TFT_Byte
	Fnum_other_blues        TFT_Byte
	Fnum_family_blues       TFT_Byte
	Fnum_family_other_blues TFT_Byte
	Fblue_values            [14]TFT_Short
	Fother_blues            [10]TFT_Short
	Ffamily_blues           [14]TFT_Short
	Ffamily_other_blues     [10]TFT_Short
	Fblue_scale             TFT_Fixed
	Fblue_shift             TFT_Int
	Fblue_fuzz              TFT_Int
	Fstandard_width         [1]TFT_UShort
	Fstandard_height        [1]TFT_UShort
	Fnum_snap_widths        TFT_Byte
	Fnum_snap_heights       TFT_Byte
	Fforce_bold             TFT_Bool
	Fround_stem_up          TFT_Bool
	Fsnap_widths            [13]TFT_Short
	Fsnap_heights           [13]TFT_Short
	Fexpansion_factor       TFT_Fixed
	Flanguage_group         TFT_Long
	Fpassword               TFT_Long
	Fmin_feature            [2]TFT_Short
}

type TT1_Blend_Flags = int32

type _T1_Blend_Flags_ = int32

const _T1_BLEND_UNDERLINE_POSITION = 0
const _T1_BLEND_UNDERLINE_THICKNESS = 1
const _T1_BLEND_ITALIC_ANGLE = 2
const _T1_BLEND_BLUE_VALUES = 3
const _T1_BLEND_OTHER_BLUES = 4
const _T1_BLEND_STANDARD_WIDTH = 5
const _T1_BLEND_STANDARD_HEIGHT = 6
const _T1_BLEND_STEM_SNAP_WIDTHS = 7
const _T1_BLEND_STEM_SNAP_HEIGHTS = 8
const _T1_BLEND_BLUE_SCALE = 9
const _T1_BLEND_BLUE_SHIFT = 10
const _T1_BLEND_FAMILY_BLUES = 11
const _T1_BLEND_FAMILY_OTHER_BLUES = 12
const _T1_BLEND_FORCE_BOLD = 13
const _T1_BLEND_MAX = 14

type TPS_DesignMapRec = struct {
	Fnum_points    TFT_Byte
	Fdesign_points uintptr
	Fblend_points  uintptr
}

type TPS_DesignMap_ = TPS_DesignMapRec

type TPS_DesignMap = uintptr

type TT1_DesignMap = struct {
	Fnum_points    TFT_Byte
	Fdesign_points uintptr
	Fblend_points  uintptr
}

type TPS_BlendRec = struct {
	Fnum_designs               TFT_UInt
	Fnum_axis                  TFT_UInt
	Faxis_names                [4]uintptr
	Fdesign_pos                [16]uintptr
	Fdesign_map                [4]TPS_DesignMapRec
	Fweight_vector             uintptr
	Fdefault_weight_vector     uintptr
	Ffont_infos                [17]TPS_FontInfo
	Fprivates                  [17]TPS_Private
	Fblend_bitflags            TFT_ULong
	Fbboxes                    [17]uintptr
	Fdefault_design_vector     [16]TFT_UInt
	Fnum_default_design_vector TFT_UInt
}

type TPS_BlendRec_ = TPS_BlendRec

type TPS_Blend = uintptr

type TT1_Blend = struct {
	Fnum_designs               TFT_UInt
	Fnum_axis                  TFT_UInt
	Faxis_names                [4]uintptr
	Fdesign_pos                [16]uintptr
	Fdesign_map                [4]TPS_DesignMapRec
	Fweight_vector             uintptr
	Fdefault_weight_vector     uintptr
	Ffont_infos                [17]TPS_FontInfo
	Fprivates                  [17]TPS_Private
	Fblend_bitflags            TFT_ULong
	Fbboxes                    [17]uintptr
	Fdefault_design_vector     [16]TFT_UInt
	Fnum_default_design_vector TFT_UInt
}

type TCID_FaceDictRec = struct {
	Fprivate_dict        TPS_PrivateRec
	Flen_buildchar       TFT_UInt
	Fforcebold_threshold TFT_Fixed
	Fstroke_width        TFT_Pos
	Fexpansion_factor    TFT_Fixed
	Fpaint_type          TFT_Byte
	Ffont_type           TFT_Byte
	Ffont_matrix         TFT_Matrix
	Ffont_offset         TFT_Vector
	Fnum_subrs           TFT_UInt
	Fsubrmap_offset      TFT_ULong
	Fsd_bytes            TFT_Int
}

type TCID_FaceDictRec_ = TCID_FaceDictRec

type TCID_FaceDict = uintptr

type TCID_FontDict = struct {
	Fprivate_dict        TPS_PrivateRec
	Flen_buildchar       TFT_UInt
	Fforcebold_threshold TFT_Fixed
	Fstroke_width        TFT_Pos
	Fexpansion_factor    TFT_Fixed
	Fpaint_type          TFT_Byte
	Ffont_type           TFT_Byte
	Ffont_matrix         TFT_Matrix
	Ffont_offset         TFT_Vector
	Fnum_subrs           TFT_UInt
	Fsubrmap_offset      TFT_ULong
	Fsd_bytes            TFT_Int
}

type TCID_FaceInfoRec = struct {
	Fcid_font_name uintptr
	Fcid_version   TFT_Fixed
	Fcid_font_type TFT_Int
	Fregistry      uintptr
	Fordering      uintptr
	Fsupplement    TFT_Int
	Ffont_info     TPS_FontInfoRec
	Ffont_bbox     TFT_BBox
	Fuid_base      TFT_ULong
	Fnum_xuid      TFT_Int
	Fxuid          [16]TFT_ULong
	Fcidmap_offset TFT_ULong
	Ffd_bytes      TFT_Int
	Fgd_bytes      TFT_Int
	Fcid_count     TFT_ULong
	Fnum_dicts     TFT_Int
	Ffont_dicts    TCID_FaceDict
	Fdata_offset   TFT_ULong
}

type TCID_FaceInfoRec_ = TCID_FaceInfoRec

type TCID_FaceInfo = uintptr

type TCID_Info = struct {
	Fcid_font_name uintptr
	Fcid_version   TFT_Fixed
	Fcid_font_type TFT_Int
	Fregistry      uintptr
	Fordering      uintptr
	Fsupplement    TFT_Int
	Ffont_info     TPS_FontInfoRec
	Ffont_bbox     TFT_BBox
	Fuid_base      TFT_ULong
	Fnum_xuid      TFT_Int
	Fxuid          [16]TFT_ULong
	Fcidmap_offset TFT_ULong
	Ffd_bytes      TFT_Int
	Fgd_bytes      TFT_Int
	Fcid_count     TFT_ULong
	Fnum_dicts     TFT_Int
	Ffont_dicts    TCID_FaceDict
	Fdata_offset   TFT_ULong
}

type TT1_EncodingType = int32

type _T1_EncodingType_ = int32

const _T1_ENCODING_TYPE_NONE = 0
const _T1_ENCODING_TYPE_ARRAY = 1
const _T1_ENCODING_TYPE_STANDARD = 2
const _T1_ENCODING_TYPE_ISOLATIN1 = 3
const _T1_ENCODING_TYPE_EXPERT = 4

type TPS_Dict_Keys = int32

type _PS_Dict_Keys_ = int32

const _PS_DICT_FONT_TYPE = 0
const _PS_DICT_FONT_MATRIX = 1
const _PS_DICT_FONT_BBOX = 2
const _PS_DICT_PAINT_TYPE = 3
const _PS_DICT_FONT_NAME = 4
const _PS_DICT_UNIQUE_ID = 5
const _PS_DICT_NUM_CHAR_STRINGS = 6
const _PS_DICT_CHAR_STRING_KEY = 7
const _PS_DICT_CHAR_STRING = 8
const _PS_DICT_ENCODING_TYPE = 9
const _PS_DICT_ENCODING_ENTRY = 10
const _PS_DICT_NUM_SUBRS = 11
const _PS_DICT_SUBR = 12
const _PS_DICT_STD_HW = 13
const _PS_DICT_STD_VW = 14
const _PS_DICT_NUM_BLUE_VALUES = 15
const _PS_DICT_BLUE_VALUE = 16
const _PS_DICT_BLUE_FUZZ = 17
const _PS_DICT_NUM_OTHER_BLUES = 18
const _PS_DICT_OTHER_BLUE = 19
const _PS_DICT_NUM_FAMILY_BLUES = 20
const _PS_DICT_FAMILY_BLUE = 21
const _PS_DICT_NUM_FAMILY_OTHER_BLUES = 22
const _PS_DICT_FAMILY_OTHER_BLUE = 23
const _PS_DICT_BLUE_SCALE = 24
const _PS_DICT_BLUE_SHIFT = 25
const _PS_DICT_NUM_STEM_SNAP_H = 26
const _PS_DICT_STEM_SNAP_H = 27
const _PS_DICT_NUM_STEM_SNAP_V = 28
const _PS_DICT_STEM_SNAP_V = 29
const _PS_DICT_FORCE_BOLD = 30
const _PS_DICT_RND_STEM_UP = 31
const _PS_DICT_MIN_FEATURE = 32
const _PS_DICT_LEN_IV = 33
const _PS_DICT_PASSWORD = 34
const _PS_DICT_LANGUAGE_GROUP = 35
const _PS_DICT_VERSION = 36
const _PS_DICT_NOTICE = 37
const _PS_DICT_FULL_NAME = 38
const _PS_DICT_FAMILY_NAME = 39
const _PS_DICT_WEIGHT = 40
const _PS_DICT_IS_FIXED_PITCH = 41
const _PS_DICT_UNDERLINE_POSITION = 42
const _PS_DICT_UNDERLINE_THICKNESS = 43
const _PS_DICT_FS_TYPE = 44
const _PS_DICT_ITALIC_ANGLE = 45
const _PS_DICT_MAX = 45

type TFT_MM_Axis = struct {
	Fname    uintptr
	Fminimum TFT_Long
	Fmaximum TFT_Long
}

type TFT_MM_Axis_ = TFT_MM_Axis

type TFT_Multi_Master = struct {
	Fnum_axis    TFT_UInt
	Fnum_designs TFT_UInt
	Faxis        [4]TFT_MM_Axis
}

type TFT_Multi_Master_ = TFT_Multi_Master

type TFT_Var_Axis = struct {
	Fname    uintptr
	Fminimum TFT_Fixed
	Fdef     TFT_Fixed
	Fmaximum TFT_Fixed
	Ftag     TFT_ULong
	Fstrid   TFT_UInt
}

type TFT_Var_Axis_ = TFT_Var_Axis

type TFT_Var_Named_Style = struct {
	Fcoords uintptr
	Fstrid  TFT_UInt
	Fpsid   TFT_UInt
}

type TFT_Var_Named_Style_ = TFT_Var_Named_Style

type TFT_MM_Var = struct {
	Fnum_axis        TFT_UInt
	Fnum_designs     TFT_UInt
	Fnum_namedstyles TFT_UInt
	Faxis            uintptr
	Fnamedstyle      uintptr
}

type TFT_MM_Var_ = TFT_MM_Var

var _FcNoticeFoundries = [18][2]uintptr{
	0: {
		0: __ccgo_ts + 3522,
		1: __ccgo_ts + 3528,
	},
	1: {
		0: __ccgo_ts + 3534,
		1: __ccgo_ts + 3542,
	},
	2: {
		0: __ccgo_ts + 3546,
		1: __ccgo_ts + 3556,
	},
	3: {
		0: __ccgo_ts + 3566,
		1: __ccgo_ts + 3571,
	},
	4: {
		0: __ccgo_ts + 3578,
		1: __ccgo_ts + 3571,
	},
	5: {
		0: __ccgo_ts + 3584,
		1: __ccgo_ts + 3599,
	},
	6: {
		0: __ccgo_ts + 3607,
		1: __ccgo_ts + 3614,
	},
	7: {
		0: __ccgo_ts + 3619,
		1: __ccgo_ts + 3623,
	},
	8: {
		0: __ccgo_ts + 3627,
		1: __ccgo_ts + 3662,
	},
	9: {
		0: __ccgo_ts + 3666,
		1: __ccgo_ts + 3675,
	},
	10: {
		0: __ccgo_ts + 3684,
		1: __ccgo_ts + 3675,
	},
	11: {
		0: __ccgo_ts + 3698,
		1: __ccgo_ts + 3708,
	},
	12: {
		0: __ccgo_ts + 3718,
		1: __ccgo_ts + 3727,
	},
	13: {
		0: __ccgo_ts + 3736,
		1: __ccgo_ts + 3742,
	},
	14: {
		0: __ccgo_ts + 3748,
		1: __ccgo_ts + 3763,
	},
	15: {
		0: __ccgo_ts + 3768,
		1: __ccgo_ts + 3772,
	},
	16: {
		0: __ccgo_ts + 3776,
		1: __ccgo_ts + 3784,
	},
	17: {
		0: __ccgo_ts + 3792,
		1: __ccgo_ts + 3797,
	},
}

/*
 * Keep Han languages separated by eliminating languages
 * that the codePageRange bits says aren't supported
 */

var _FcCodePageRange = [4]struct {
	Fbit  int8
	Flang [6]TFcChar8
}{
	0: {
		Fbit:  int8(17),
		Flang: [6]TFcChar8{'j', 'a'},
	},
	1: {
		Fbit:  int8(18),
		Flang: [6]TFcChar8{'z', 'h', '-', 'c', 'n'},
	},
	2: {
		Fbit:  int8(19),
		Flang: [6]TFcChar8{'k', 'o'},
	},
	3: {
		Fbit:  int8(20),
		Flang: [6]TFcChar8{'z', 'h', '-', 't', 'w'},
	},
}

func XFcFreeTypeIsExclusiveLang(tls *libc.TLS, lang uintptr) (r TFcBool) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < libc.Int32FromUint64(libc.Uint64FromInt64(28)/libc.Uint64FromInt64(7))) {
			break
		}
		if XFcLangCompare(tls, lang, uintptr(unsafe.Pointer(&_FcCodePageRange))+uintptr(i)*7+1) == int32(_FcLangEqual) {
			return int32(m_FcTrue)
		}
		goto _1
	_1:
		;
		i++
	}
	return m_FcFalse
}

type TFcFtEncoding = struct {
	Fplatform_id TFT_UShort
	Fencoding_id TFT_UShort
	Ffromcode    [12]int8
}

var _fcFtEncoding = [14]TFcFtEncoding{
	0: {
		Fencoding_id: uint16(m_TT_ENCODING_DONT_CARE),
		Ffromcode:    [12]int8{'U', 'T', 'F', '-', '1', '6', 'B', 'E'},
	},
	1: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Ffromcode:    [12]int8{'M', 'A', 'C', 'I', 'N', 'T', 'O', 'S', 'H'},
	},
	2: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Fencoding_id: uint16(m_TT_MAC_ID_JAPANESE),
		Ffromcode:    [12]int8{'S', 'J', 'I', 'S'},
	},
	3: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Ffromcode:    [12]int8{'U', 'T', 'F', '-', '1', '6', 'B', 'E'},
	},
	4: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Fencoding_id: uint16(m_TT_MS_ID_UNICODE_CS),
		Ffromcode:    [12]int8{'U', 'T', 'F', '-', '1', '6', 'B', 'E'},
	},
	5: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Fencoding_id: uint16(m_TT_MS_ID_SJIS),
		Ffromcode:    [12]int8{'S', 'J', 'I', 'S', '-', 'W', 'I', 'N'},
	},
	6: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Fencoding_id: uint16(m_TT_MS_ID_PRC),
		Ffromcode:    [12]int8{'G', 'B', '2', '3', '1', '2'},
	},
	7: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Fencoding_id: uint16(m_TT_MS_ID_BIG_5),
		Ffromcode:    [12]int8{'B', 'I', 'G', '-', '5'},
	},
	8: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Fencoding_id: uint16(m_TT_MS_ID_WANSUNG),
		Ffromcode:    [12]int8{'W', 'a', 'n', 's', 'u', 'n', 'g'},
	},
	9: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Fencoding_id: uint16(m_TT_MS_ID_JOHAB),
		Ffromcode:    [12]int8{'J', 'o', 'h', 'a', 'b'},
	},
	10: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Fencoding_id: uint16(m_TT_MS_ID_UCS_4),
		Ffromcode:    [12]int8{'U', 'T', 'F', '-', '1', '6', 'B', 'E'},
	},
	11: {
		Fplatform_id: uint16(m_TT_PLATFORM_ISO),
		Ffromcode:    [12]int8{'A', 'S', 'C', 'I', 'I'},
	},
	12: {
		Fplatform_id: uint16(m_TT_PLATFORM_ISO),
		Fencoding_id: uint16(m_TT_ISO_ID_10646),
		Ffromcode:    [12]int8{'U', 'T', 'F', '-', '1', '6', 'B', 'E'},
	},
	13: {
		Fplatform_id: uint16(m_TT_PLATFORM_ISO),
		Fencoding_id: uint16(m_TT_ISO_ID_8859_1),
		Ffromcode:    [12]int8{'I', 'S', 'O', '-', '8', '8', '5', '9', '-', '1'},
	},
}

type TFcFtLanguage = struct {
	Fplatform_id TFT_UShort
	Flanguage_id TFT_UShort
	Flang        [8]int8
}

var _fcFtLanguage = [335]TFcFtLanguage{
	0: {
		Flanguage_id: uint16(m_TT_LANGUAGE_DONT_CARE),
		Flang:        [8]int8{},
	},
	1: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flang:        [8]int8{'e', 'n'},
	},
	2: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_FRENCH),
		Flang:        [8]int8{'f', 'r'},
	},
	3: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_GERMAN),
		Flang:        [8]int8{'d', 'e'},
	},
	4: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_ITALIAN),
		Flang:        [8]int8{'i', 't'},
	},
	5: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_DUTCH),
		Flang:        [8]int8{'n', 'l'},
	},
	6: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_SWEDISH),
		Flang:        [8]int8{'s', 'v'},
	},
	7: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_SPANISH),
		Flang:        [8]int8{'e', 's'},
	},
	8: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_DANISH),
		Flang:        [8]int8{'d', 'a'},
	},
	9: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_PORTUGUESE),
		Flang:        [8]int8{'p', 't'},
	},
	10: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_NORWEGIAN),
		Flang:        [8]int8{'n', 'o'},
	},
	11: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_HEBREW),
		Flang:        [8]int8{'h', 'e'},
	},
	12: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_JAPANESE),
		Flang:        [8]int8{'j', 'a'},
	},
	13: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_ARABIC),
		Flang:        [8]int8{'a', 'r'},
	},
	14: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_FINNISH),
		Flang:        [8]int8{'f', 'i'},
	},
	15: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_GREEK),
		Flang:        [8]int8{'e', 'l'},
	},
	16: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_ICELANDIC),
		Flang:        [8]int8{'i', 's'},
	},
	17: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_MALTESE),
		Flang:        [8]int8{'m', 't'},
	},
	18: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_TURKISH),
		Flang:        [8]int8{'t', 'r'},
	},
	19: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_CROATIAN),
		Flang:        [8]int8{'h', 'r'},
	},
	20: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_CHINESE_TRADITIONAL),
		Flang:        [8]int8{'z', 'h', '-', 't', 'w'},
	},
	21: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_URDU),
		Flang:        [8]int8{'u', 'r'},
	},
	22: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_HINDI),
		Flang:        [8]int8{'h', 'i'},
	},
	23: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_THAI),
		Flang:        [8]int8{'t', 'h'},
	},
	24: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_KOREAN),
		Flang:        [8]int8{'k', 'o'},
	},
	25: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_LITHUANIAN),
		Flang:        [8]int8{'l', 't'},
	},
	26: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_POLISH),
		Flang:        [8]int8{'p', 'l'},
	},
	27: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_HUNGARIAN),
		Flang:        [8]int8{'h', 'u'},
	},
	28: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_ESTONIAN),
		Flang:        [8]int8{'e', 't'},
	},
	29: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_LETTISH),
		Flang:        [8]int8{'l', 'v'},
	},
	30: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_FAEROESE),
		Flang:        [8]int8{'f', 'o'},
	},
	31: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_FARSI),
		Flang:        [8]int8{'f', 'a'},
	},
	32: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_RUSSIAN),
		Flang:        [8]int8{'r', 'u'},
	},
	33: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_CHINESE_SIMPLIFIED),
		Flang:        [8]int8{'z', 'h', '-', 'c', 'n'},
	},
	34: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_FLEMISH),
		Flang:        [8]int8{'n', 'l'},
	},
	35: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_IRISH),
		Flang:        [8]int8{'g', 'a'},
	},
	36: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_ALBANIAN),
		Flang:        [8]int8{'s', 'q'},
	},
	37: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_ROMANIAN),
		Flang:        [8]int8{'r', 'o'},
	},
	38: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_CZECH),
		Flang:        [8]int8{'c', 's'},
	},
	39: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_SLOVAK),
		Flang:        [8]int8{'s', 'k'},
	},
	40: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_SLOVENIAN),
		Flang:        [8]int8{'s', 'l'},
	},
	41: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_YIDDISH),
		Flang:        [8]int8{'y', 'i'},
	},
	42: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_SERBIAN),
		Flang:        [8]int8{'s', 'r'},
	},
	43: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_MACEDONIAN),
		Flang:        [8]int8{'m', 'k'},
	},
	44: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_BULGARIAN),
		Flang:        [8]int8{'b', 'g'},
	},
	45: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_UKRAINIAN),
		Flang:        [8]int8{'u', 'k'},
	},
	46: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_BYELORUSSIAN),
		Flang:        [8]int8{'b', 'e'},
	},
	47: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_UZBEK),
		Flang:        [8]int8{'u', 'z'},
	},
	48: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_KAZAKH),
		Flang:        [8]int8{'k', 'k'},
	},
	49: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_AZERBAIJANI),
		Flang:        [8]int8{'a', 'z'},
	},
	50: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_AZERBAIJANI_CYRILLIC_SCRIPT),
		Flang:        [8]int8{'a', 'z'},
	},
	51: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_AZERBAIJANI_ARABIC_SCRIPT),
		Flang:        [8]int8{'a', 'r'},
	},
	52: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_ARMENIAN),
		Flang:        [8]int8{'h', 'y'},
	},
	53: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_GEORGIAN),
		Flang:        [8]int8{'k', 'a'},
	},
	54: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_MOLDAVIAN),
		Flang:        [8]int8{'m', 'o'},
	},
	55: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_KIRGHIZ),
		Flang:        [8]int8{'k', 'y'},
	},
	56: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_TAJIKI),
		Flang:        [8]int8{'t', 'g'},
	},
	57: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_TURKMEN),
		Flang:        [8]int8{'t', 'k'},
	},
	58: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_MONGOLIAN),
		Flang:        [8]int8{'m', 'n'},
	},
	59: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_MONGOLIAN_MONGOLIAN_SCRIPT),
		Flang:        [8]int8{'m', 'n'},
	},
	60: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_MONGOLIAN_CYRILLIC_SCRIPT),
		Flang:        [8]int8{'m', 'n'},
	},
	61: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_PASHTO),
		Flang:        [8]int8{'p', 's'},
	},
	62: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_KURDISH),
		Flang:        [8]int8{'k', 'u'},
	},
	63: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_KASHMIRI),
		Flang:        [8]int8{'k', 's'},
	},
	64: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_SINDHI),
		Flang:        [8]int8{'s', 'd'},
	},
	65: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_TIBETAN),
		Flang:        [8]int8{'b', 'o'},
	},
	66: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_NEPALI),
		Flang:        [8]int8{'n', 'e'},
	},
	67: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_SANSKRIT),
		Flang:        [8]int8{'s', 'a'},
	},
	68: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_MARATHI),
		Flang:        [8]int8{'m', 'r'},
	},
	69: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_BENGALI),
		Flang:        [8]int8{'b', 'n'},
	},
	70: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_ASSAMESE),
		Flang:        [8]int8{'a', 's'},
	},
	71: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_GUJARATI),
		Flang:        [8]int8{'g', 'u'},
	},
	72: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_PUNJABI),
		Flang:        [8]int8{'p', 'a'},
	},
	73: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_ORIYA),
		Flang:        [8]int8{'o', 'r'},
	},
	74: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_MALAYALAM),
		Flang:        [8]int8{'m', 'l'},
	},
	75: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_KANNADA),
		Flang:        [8]int8{'k', 'n'},
	},
	76: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_TAMIL),
		Flang:        [8]int8{'t', 'a'},
	},
	77: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_TELUGU),
		Flang:        [8]int8{'t', 'e'},
	},
	78: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_SINHALESE),
		Flang:        [8]int8{'s', 'i'},
	},
	79: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_BURMESE),
		Flang:        [8]int8{'m', 'y'},
	},
	80: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_KHMER),
		Flang:        [8]int8{'k', 'm'},
	},
	81: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_LAO),
		Flang:        [8]int8{'l', 'o'},
	},
	82: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_VIETNAMESE),
		Flang:        [8]int8{'v', 'i'},
	},
	83: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_INDONESIAN),
		Flang:        [8]int8{'i', 'd'},
	},
	84: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_TAGALOG),
		Flang:        [8]int8{'t', 'l'},
	},
	85: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_MALAY_ROMAN_SCRIPT),
		Flang:        [8]int8{'m', 's'},
	},
	86: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_MALAY_ARABIC_SCRIPT),
		Flang:        [8]int8{'m', 's'},
	},
	87: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_AMHARIC),
		Flang:        [8]int8{'a', 'm'},
	},
	88: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_TIGRINYA),
		Flang:        [8]int8{'t', 'i'},
	},
	89: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_GALLA),
		Flang:        [8]int8{'o', 'm'},
	},
	90: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_SOMALI),
		Flang:        [8]int8{'s', 'o'},
	},
	91: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_SWAHILI),
		Flang:        [8]int8{'s', 'w'},
	},
	92: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_RUANDA),
		Flang:        [8]int8{'r', 'w'},
	},
	93: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_RUNDI),
		Flang:        [8]int8{'r', 'n'},
	},
	94: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_CHEWA),
		Flang:        [8]int8{'n', 'y'},
	},
	95: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_MALAGASY),
		Flang:        [8]int8{'m', 'g'},
	},
	96: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_ESPERANTO),
		Flang:        [8]int8{'e', 'o'},
	},
	97: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_WELSH),
		Flang:        [8]int8{'c', 'y'},
	},
	98: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_BASQUE),
		Flang:        [8]int8{'e', 'u'},
	},
	99: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_CATALAN),
		Flang:        [8]int8{'c', 'a'},
	},
	100: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_LATIN),
		Flang:        [8]int8{'l', 'a'},
	},
	101: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_QUECHUA),
		Flang:        [8]int8{'q', 'u'},
	},
	102: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_GUARANI),
		Flang:        [8]int8{'g', 'n'},
	},
	103: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_AYMARA),
		Flang:        [8]int8{'a', 'y'},
	},
	104: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_TATAR),
		Flang:        [8]int8{'t', 't'},
	},
	105: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_UIGHUR),
		Flang:        [8]int8{'u', 'g'},
	},
	106: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_DZONGKHA),
		Flang:        [8]int8{'d', 'z'},
	},
	107: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_JAVANESE),
		Flang:        [8]int8{'j', 'w'},
	},
	108: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_SUNDANESE),
		Flang:        [8]int8{'s', 'u'},
	},
	109: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_GALICIAN),
		Flang:        [8]int8{'g', 'l'},
	},
	110: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_AFRIKAANS),
		Flang:        [8]int8{'a', 'f'},
	},
	111: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_BRETON),
		Flang:        [8]int8{'b', 'r'},
	},
	112: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_INUKTITUT),
		Flang:        [8]int8{'i', 'u'},
	},
	113: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_SCOTTISH_GAELIC),
		Flang:        [8]int8{'g', 'd'},
	},
	114: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_MANX_GAELIC),
		Flang:        [8]int8{'g', 'v'},
	},
	115: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_IRISH_GAELIC),
		Flang:        [8]int8{'g', 'a'},
	},
	116: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_TONGAN),
		Flang:        [8]int8{'t', 'o'},
	},
	117: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_GREEK_POLYTONIC),
		Flang:        [8]int8{'e', 'l'},
	},
	118: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_GREELANDIC),
		Flang:        [8]int8{'i', 'k'},
	},
	119: {
		Fplatform_id: uint16(m_TT_PLATFORM_MACINTOSH),
		Flanguage_id: uint16(m_TT_MAC_LANGID_AZERBAIJANI_ROMAN_SCRIPT),
		Flang:        [8]int8{'a', 'z'},
	},
	120: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_SAUDI_ARABIA),
		Flang:        [8]int8{'a', 'r'},
	},
	121: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_IRAQ),
		Flang:        [8]int8{'a', 'r'},
	},
	122: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_EGYPT),
		Flang:        [8]int8{'a', 'r'},
	},
	123: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_LIBYA),
		Flang:        [8]int8{'a', 'r'},
	},
	124: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_ALGERIA),
		Flang:        [8]int8{'a', 'r'},
	},
	125: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_MOROCCO),
		Flang:        [8]int8{'a', 'r'},
	},
	126: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_TUNISIA),
		Flang:        [8]int8{'a', 'r'},
	},
	127: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_OMAN),
		Flang:        [8]int8{'a', 'r'},
	},
	128: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_YEMEN),
		Flang:        [8]int8{'a', 'r'},
	},
	129: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_SYRIA),
		Flang:        [8]int8{'a', 'r'},
	},
	130: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_JORDAN),
		Flang:        [8]int8{'a', 'r'},
	},
	131: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_LEBANON),
		Flang:        [8]int8{'a', 'r'},
	},
	132: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_KUWAIT),
		Flang:        [8]int8{'a', 'r'},
	},
	133: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_UAE),
		Flang:        [8]int8{'a', 'r'},
	},
	134: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_BAHRAIN),
		Flang:        [8]int8{'a', 'r'},
	},
	135: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_QATAR),
		Flang:        [8]int8{'a', 'r'},
	},
	136: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_BULGARIAN_BULGARIA),
		Flang:        [8]int8{'b', 'g'},
	},
	137: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_CATALAN_CATALAN),
		Flang:        [8]int8{'c', 'a'},
	},
	138: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_CHINESE_TAIWAN),
		Flang:        [8]int8{'z', 'h', '-', 't', 'w'},
	},
	139: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_CHINESE_PRC),
		Flang:        [8]int8{'z', 'h', '-', 'c', 'n'},
	},
	140: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_CHINESE_HONG_KONG),
		Flang:        [8]int8{'z', 'h', '-', 'h', 'k'},
	},
	141: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_CHINESE_SINGAPORE),
		Flang:        [8]int8{'z', 'h', '-', 's', 'g'},
	},
	142: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_CHINESE_MACAO),
		Flang:        [8]int8{'z', 'h', '-', 'm', 'o'},
	},
	143: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_CZECH_CZECH_REPUBLIC),
		Flang:        [8]int8{'c', 's'},
	},
	144: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_DANISH_DENMARK),
		Flang:        [8]int8{'d', 'a'},
	},
	145: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_GERMAN_GERMANY),
		Flang:        [8]int8{'d', 'e'},
	},
	146: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_GERMAN_SWITZERLAND),
		Flang:        [8]int8{'d', 'e'},
	},
	147: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_GERMAN_AUSTRIA),
		Flang:        [8]int8{'d', 'e'},
	},
	148: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_GERMAN_LUXEMBOURG),
		Flang:        [8]int8{'d', 'e'},
	},
	149: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_GERMAN_LIECHTENSTEIN),
		Flang:        [8]int8{'d', 'e'},
	},
	150: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_GREEK_GREECE),
		Flang:        [8]int8{'e', 'l'},
	},
	151: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_UNITED_STATES),
		Flang:        [8]int8{'e', 'n'},
	},
	152: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_UNITED_KINGDOM),
		Flang:        [8]int8{'e', 'n'},
	},
	153: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_AUSTRALIA),
		Flang:        [8]int8{'e', 'n'},
	},
	154: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_CANADA),
		Flang:        [8]int8{'e', 'n'},
	},
	155: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_NEW_ZEALAND),
		Flang:        [8]int8{'e', 'n'},
	},
	156: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_IRELAND),
		Flang:        [8]int8{'e', 'n'},
	},
	157: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_SOUTH_AFRICA),
		Flang:        [8]int8{'e', 'n'},
	},
	158: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_JAMAICA),
		Flang:        [8]int8{'e', 'n'},
	},
	159: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_CARIBBEAN),
		Flang:        [8]int8{'e', 'n'},
	},
	160: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_BELIZE),
		Flang:        [8]int8{'e', 'n'},
	},
	161: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_TRINIDAD),
		Flang:        [8]int8{'e', 'n'},
	},
	162: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_ZIMBABWE),
		Flang:        [8]int8{'e', 'n'},
	},
	163: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_PHILIPPINES),
		Flang:        [8]int8{'e', 'n'},
	},
	164: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_SPAIN_TRADITIONAL_SORT),
		Flang:        [8]int8{'e', 's'},
	},
	165: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_MEXICO),
		Flang:        [8]int8{'e', 's'},
	},
	166: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_SPAIN_MODERN_SORT),
		Flang:        [8]int8{'e', 's'},
	},
	167: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_GUATEMALA),
		Flang:        [8]int8{'e', 's'},
	},
	168: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_COSTA_RICA),
		Flang:        [8]int8{'e', 's'},
	},
	169: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_PANAMA),
		Flang:        [8]int8{'e', 's'},
	},
	170: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_DOMINICAN_REPUBLIC),
		Flang:        [8]int8{'e', 's'},
	},
	171: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_VENEZUELA),
		Flang:        [8]int8{'e', 's'},
	},
	172: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_COLOMBIA),
		Flang:        [8]int8{'e', 's'},
	},
	173: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_PERU),
		Flang:        [8]int8{'e', 's'},
	},
	174: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_ARGENTINA),
		Flang:        [8]int8{'e', 's'},
	},
	175: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_ECUADOR),
		Flang:        [8]int8{'e', 's'},
	},
	176: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_CHILE),
		Flang:        [8]int8{'e', 's'},
	},
	177: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_URUGUAY),
		Flang:        [8]int8{'e', 's'},
	},
	178: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_PARAGUAY),
		Flang:        [8]int8{'e', 's'},
	},
	179: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_BOLIVIA),
		Flang:        [8]int8{'e', 's'},
	},
	180: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_EL_SALVADOR),
		Flang:        [8]int8{'e', 's'},
	},
	181: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_HONDURAS),
		Flang:        [8]int8{'e', 's'},
	},
	182: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_NICARAGUA),
		Flang:        [8]int8{'e', 's'},
	},
	183: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_PUERTO_RICO),
		Flang:        [8]int8{'e', 's'},
	},
	184: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FINNISH_FINLAND),
		Flang:        [8]int8{'f', 'i'},
	},
	185: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_FRANCE),
		Flang:        [8]int8{'f', 'r'},
	},
	186: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_BELGIUM),
		Flang:        [8]int8{'f', 'r'},
	},
	187: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_CANADA),
		Flang:        [8]int8{'f', 'r'},
	},
	188: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_SWITZERLAND),
		Flang:        [8]int8{'f', 'r'},
	},
	189: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_LUXEMBOURG),
		Flang:        [8]int8{'f', 'r'},
	},
	190: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_MONACO),
		Flang:        [8]int8{'f', 'r'},
	},
	191: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_HEBREW_ISRAEL),
		Flang:        [8]int8{'h', 'e'},
	},
	192: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_HUNGARIAN_HUNGARY),
		Flang:        [8]int8{'h', 'u'},
	},
	193: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ICELANDIC_ICELAND),
		Flang:        [8]int8{'i', 's'},
	},
	194: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ITALIAN_ITALY),
		Flang:        [8]int8{'i', 't'},
	},
	195: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ITALIAN_SWITZERLAND),
		Flang:        [8]int8{'i', 't'},
	},
	196: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_JAPANESE_JAPAN),
		Flang:        [8]int8{'j', 'a'},
	},
	197: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_KOREAN_KOREA),
		Flang:        [8]int8{'k', 'o'},
	},
	198: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_KOREAN_JOHAB_KOREA),
		Flang:        [8]int8{'k', 'o'},
	},
	199: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_DUTCH_NETHERLANDS),
		Flang:        [8]int8{'n', 'l'},
	},
	200: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_DUTCH_BELGIUM),
		Flang:        [8]int8{'n', 'l'},
	},
	201: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_NORWEGIAN_NORWAY_BOKMAL),
		Flang:        [8]int8{'n', 'o'},
	},
	202: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_NORWEGIAN_NORWAY_NYNORSK),
		Flang:        [8]int8{'n', 'n'},
	},
	203: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_POLISH_POLAND),
		Flang:        [8]int8{'p', 'l'},
	},
	204: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_PORTUGUESE_BRAZIL),
		Flang:        [8]int8{'p', 't'},
	},
	205: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_PORTUGUESE_PORTUGAL),
		Flang:        [8]int8{'p', 't'},
	},
	206: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ROMANSH_SWITZERLAND),
		Flang:        [8]int8{'r', 'm'},
	},
	207: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ROMANIAN_ROMANIA),
		Flang:        [8]int8{'r', 'o'},
	},
	208: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_MOLDAVIAN_MOLDAVIA),
		Flang:        [8]int8{'m', 'o'},
	},
	209: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_RUSSIAN_RUSSIA),
		Flang:        [8]int8{'r', 'u'},
	},
	210: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_RUSSIAN_MOLDAVIA),
		Flang:        [8]int8{'r', 'u'},
	},
	211: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_CROATIAN_CROATIA),
		Flang:        [8]int8{'h', 'r'},
	},
	212: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SERBIAN_SERBIA_LATIN),
		Flang:        [8]int8{'s', 'r'},
	},
	213: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SERBIAN_SERBIA_CYRILLIC),
		Flang:        [8]int8{'s', 'r'},
	},
	214: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SLOVAK_SLOVAKIA),
		Flang:        [8]int8{'s', 'k'},
	},
	215: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ALBANIAN_ALBANIA),
		Flang:        [8]int8{'s', 'q'},
	},
	216: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SWEDISH_SWEDEN),
		Flang:        [8]int8{'s', 'v'},
	},
	217: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SWEDISH_FINLAND),
		Flang:        [8]int8{'s', 'v'},
	},
	218: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_THAI_THAILAND),
		Flang:        [8]int8{'t', 'h'},
	},
	219: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_TURKISH_TURKEY),
		Flang:        [8]int8{'t', 'r'},
	},
	220: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_URDU_PAKISTAN),
		Flang:        [8]int8{'u', 'r'},
	},
	221: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_INDONESIAN_INDONESIA),
		Flang:        [8]int8{'i', 'd'},
	},
	222: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_UKRAINIAN_UKRAINE),
		Flang:        [8]int8{'u', 'k'},
	},
	223: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_BELARUSIAN_BELARUS),
		Flang:        [8]int8{'b', 'e'},
	},
	224: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SLOVENIAN_SLOVENIA),
		Flang:        [8]int8{'s', 'l'},
	},
	225: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ESTONIAN_ESTONIA),
		Flang:        [8]int8{'e', 't'},
	},
	226: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_LATVIAN_LATVIA),
		Flang:        [8]int8{'l', 'v'},
	},
	227: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_LITHUANIAN_LITHUANIA),
		Flang:        [8]int8{'l', 't'},
	},
	228: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_CLASSIC_LITHUANIAN_LITHUANIA),
		Flang:        [8]int8{'l', 't'},
	},
	229: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_MAORI_NEW_ZEALAND),
		Flang:        [8]int8{'m', 'i'},
	},
	230: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FARSI_IRAN),
		Flang:        [8]int8{'f', 'a'},
	},
	231: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_VIETNAMESE_VIET_NAM),
		Flang:        [8]int8{'v', 'i'},
	},
	232: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARMENIAN_ARMENIA),
		Flang:        [8]int8{'h', 'y'},
	},
	233: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_AZERI_AZERBAIJAN_LATIN),
		Flang:        [8]int8{'a', 'z'},
	},
	234: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_AZERI_AZERBAIJAN_CYRILLIC),
		Flang:        [8]int8{'a', 'z'},
	},
	235: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_BASQUE_BASQUE),
		Flang:        [8]int8{'e', 'u'},
	},
	236: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_UPPER_SORBIAN_GERMANY),
		Flang:        [8]int8{'w', 'e', 'n'},
	},
	237: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_MACEDONIAN_MACEDONIA),
		Flang:        [8]int8{'m', 'k'},
	},
	238: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SUTU_SOUTH_AFRICA),
		Flang:        [8]int8{'s', 't'},
	},
	239: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_TSONGA_SOUTH_AFRICA),
		Flang:        [8]int8{'t', 's'},
	},
	240: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SETSWANA_SOUTH_AFRICA),
		Flang:        [8]int8{'t', 'n'},
	},
	241: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_VENDA_SOUTH_AFRICA),
		Flang:        [8]int8{'v', 'e', 'n'},
	},
	242: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ISIXHOSA_SOUTH_AFRICA),
		Flang:        [8]int8{'x', 'h'},
	},
	243: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ISIZULU_SOUTH_AFRICA),
		Flang:        [8]int8{'z', 'u'},
	},
	244: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_AFRIKAANS_SOUTH_AFRICA),
		Flang:        [8]int8{'a', 'f'},
	},
	245: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_GEORGIAN_GEORGIA),
		Flang:        [8]int8{'k', 'a'},
	},
	246: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FAEROESE_FAEROE_ISLANDS),
		Flang:        [8]int8{'f', 'o'},
	},
	247: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_HINDI_INDIA),
		Flang:        [8]int8{'h', 'i'},
	},
	248: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_MALTESE_MALTA),
		Flang:        [8]int8{'m', 't'},
	},
	249: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SAAMI_LAPONIA),
		Flang:        [8]int8{'s', 'e'},
	},
	250: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SCOTTISH_GAELIC_UNITED_KINGDOM),
		Flang:        [8]int8{'g', 'd'},
	},
	251: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_IRISH_GAELIC_IRELAND),
		Flang:        [8]int8{'g', 'a'},
	},
	252: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_MALAY_MALAYSIA),
		Flang:        [8]int8{'m', 's'},
	},
	253: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_MALAY_BRUNEI_DARUSSALAM),
		Flang:        [8]int8{'m', 's'},
	},
	254: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_KAZAKH_KAZAKHSTAN),
		Flang:        [8]int8{'k', 'k'},
	},
	255: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_KISWAHILI_KENYA),
		Flang:        [8]int8{'s', 'w'},
	},
	256: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_UZBEK_UZBEKISTAN_LATIN),
		Flang:        [8]int8{'u', 'z'},
	},
	257: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_UZBEK_UZBEKISTAN_CYRILLIC),
		Flang:        [8]int8{'u', 'z'},
	},
	258: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_TATAR_RUSSIA),
		Flang:        [8]int8{'t', 't'},
	},
	259: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_BENGALI_INDIA),
		Flang:        [8]int8{'b', 'n'},
	},
	260: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_PUNJABI_INDIA),
		Flang:        [8]int8{'p', 'a'},
	},
	261: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_GUJARATI_INDIA),
		Flang:        [8]int8{'g', 'u'},
	},
	262: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ODIA_INDIA),
		Flang:        [8]int8{'o', 'r'},
	},
	263: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_TAMIL_INDIA),
		Flang:        [8]int8{'t', 'a'},
	},
	264: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_TELUGU_INDIA),
		Flang:        [8]int8{'t', 'e'},
	},
	265: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_KANNADA_INDIA),
		Flang:        [8]int8{'k', 'n'},
	},
	266: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_MALAYALAM_INDIA),
		Flang:        [8]int8{'m', 'l'},
	},
	267: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ASSAMESE_INDIA),
		Flang:        [8]int8{'a', 's'},
	},
	268: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_MARATHI_INDIA),
		Flang:        [8]int8{'m', 'r'},
	},
	269: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SANSKRIT_INDIA),
		Flang:        [8]int8{'s', 'a'},
	},
	270: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_KONKANI_INDIA),
		Flang:        [8]int8{'k', 'o', 'k'},
	},
	271: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ARABIC_GENERAL),
		Flang:        [8]int8{'a', 'r'},
	},
	272: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_CHINESE_GENERAL),
		Flang:        [8]int8{'z', 'h'},
	},
	273: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_GENERAL),
		Flang:        [8]int8{'e', 'n'},
	},
	274: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_WEST_INDIES),
		Flang:        [8]int8{'f', 'r'},
	},
	275: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_REUNION),
		Flang:        [8]int8{'f', 'r'},
	},
	276: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_CONGO),
		Flang:        [8]int8{'f', 'r'},
	},
	277: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_SENEGAL),
		Flang:        [8]int8{'f', 'r'},
	},
	278: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_CAMEROON),
		Flang:        [8]int8{'f', 'r'},
	},
	279: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_COTE_D_IVOIRE),
		Flang:        [8]int8{'f', 'r'},
	},
	280: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_MALI),
		Flang:        [8]int8{'f', 'r'},
	},
	281: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_BOSNIAN_BOSNIA_HERZEGOVINA),
		Flang:        [8]int8{'b', 's'},
	},
	282: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_URDU_INDIA),
		Flang:        [8]int8{'u', 'r'},
	},
	283: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_TAJIK_TAJIKISTAN),
		Flang:        [8]int8{'t', 'g'},
	},
	284: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_YIDDISH_GERMANY),
		Flang:        [8]int8{'y', 'i'},
	},
	285: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_KYRGYZ_KYRGYZSTAN),
		Flang:        [8]int8{'k', 'y'},
	},
	286: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_TURKMEN_TURKMENISTAN),
		Flang:        [8]int8{'t', 'k'},
	},
	287: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_MONGOLIAN_MONGOLIA),
		Flang:        [8]int8{'m', 'n'},
	},
	288: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_DZONGHKA_BHUTAN),
		Flang:        [8]int8{'b', 'o'},
	},
	289: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_TIBETAN_PRC),
		Flang:        [8]int8{'b', 'o'},
	},
	290: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_DZONGHKA_BHUTAN),
		Flang:        [8]int8{'d', 'z'},
	},
	291: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_WELSH_UNITED_KINGDOM),
		Flang:        [8]int8{'c', 'y'},
	},
	292: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_KHMER_CAMBODIA),
		Flang:        [8]int8{'k', 'm'},
	},
	293: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_LAO_LAOS),
		Flang:        [8]int8{'l', 'o'},
	},
	294: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_BURMESE_MYANMAR),
		Flang:        [8]int8{'m', 'y'},
	},
	295: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_GALICIAN_GALICIAN),
		Flang:        [8]int8{'g', 'l'},
	},
	296: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_MANIPURI_INDIA),
		Flang:        [8]int8{'m', 'n', 'i'},
	},
	297: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SINDHI_INDIA),
		Flang:        [8]int8{'s', 'd'},
	},
	298: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_KASHMIRI_PAKISTAN),
		Flang:        [8]int8{'k', 's'},
	},
	299: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_KASHMIRI_SASIA),
		Flang:        [8]int8{'k', 's'},
	},
	300: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_NEPALI_NEPAL),
		Flang:        [8]int8{'n', 'e'},
	},
	301: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_NEPALI_INDIA),
		Flang:        [8]int8{'n', 'e'},
	},
	302: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRISIAN_NETHERLANDS),
		Flang:        [8]int8{'f', 'y'},
	},
	303: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_HONG_KONG),
		Flang:        [8]int8{'e', 'n'},
	},
	304: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_INDIA),
		Flang:        [8]int8{'e', 'n'},
	},
	305: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_MALAYSIA),
		Flang:        [8]int8{'e', 'n'},
	},
	306: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_SINGAPORE),
		Flang:        [8]int8{'e', 'n'},
	},
	307: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SYRIAC_SYRIA),
		Flang:        [8]int8{'s', 'y', 'r'},
	},
	308: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SINHALA_SRI_LANKA),
		Flang:        [8]int8{'s', 'i'},
	},
	309: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_CHEROKEE_UNITED_STATES),
		Flang:        [8]int8{'c', 'h', 'r'},
	},
	310: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_INUKTITUT_CANADA),
		Flang:        [8]int8{'i', 'u'},
	},
	311: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_AMHARIC_ETHIOPIA),
		Flang:        [8]int8{'a', 'm'},
	},
	312: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_PASHTO_AFGHANISTAN),
		Flang:        [8]int8{'p', 's'},
	},
	313: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FILIPINO_PHILIPPINES),
		Flang:        [8]int8{'p', 'h', 'i'},
	},
	314: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_DHIVEHI_MALDIVES),
		Flang:        [8]int8{'d', 'i', 'v'},
	},
	315: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_OROMO_ETHIOPIA),
		Flang:        [8]int8{'o', 'm'},
	},
	316: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_TIGRIGNA_ETHIOPIA),
		Flang:        [8]int8{'t', 'i'},
	},
	317: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_TIGRIGNA_ERYTHREA),
		Flang:        [8]int8{'t', 'i'},
	},
	318: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SPANISH_UNITED_STATES),
		Flang:        [8]int8{'e', 's'},
	},
	319: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(0xE40A),
		Flang:        [8]int8{'e', 's'},
	},
	320: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(0xE40C),
		Flang:        [8]int8{'f', 'r'},
	},
	321: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_MOROCCO),
		Flang:        [8]int8{'f', 'r'},
	},
	322: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_FRENCH_HAITI),
		Flang:        [8]int8{'f', 'r'},
	},
	323: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_BENGALI_BANGLADESH),
		Flang:        [8]int8{'b', 'n'},
	},
	324: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_PUNJABI_ARABIC_PAKISTAN),
		Flang:        [8]int8{'a', 'r'},
	},
	325: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_MONGOLIAN_PRC),
		Flang:        [8]int8{'m', 'n'},
	},
	326: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_HAUSA_NIGERIA),
		Flang:        [8]int8{'h', 'a'},
	},
	327: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_YORUBA_NIGERIA),
		Flang:        [8]int8{'y', 'o'},
	},
	328: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_IGBO_NIGERIA),
		Flang:        [8]int8{'i', 'b', 'o'},
	},
	329: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_KANURI_NIGERIA),
		Flang:        [8]int8{'k', 'a', 'u'},
	},
	330: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_GUARANI_PARAGUAY),
		Flang:        [8]int8{'g', 'n'},
	},
	331: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_HAWAIIAN_UNITED_STATES),
		Flang:        [8]int8{'h', 'a', 'w'},
	},
	332: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_LATIN),
		Flang:        [8]int8{'l', 'a'},
	},
	333: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_SOMALI_SOMALIA),
		Flang:        [8]int8{'s', 'o'},
	},
	334: {
		Fplatform_id: uint16(m_TT_PLATFORM_MICROSOFT),
		Flanguage_id: uint16(m_TT_MS_LANGID_PAPIAMENTU_NETHERLANDS_ANTILLES),
		Flang:        [8]int8{'p', 'a', 'p'},
	},
}

type TFcMacRomanFake = struct {
	Flanguage_id TFT_UShort
	Ffromcode    [12]int8
}

var _fcMacRomanFake = [2]TFcMacRomanFake{
	0: {
		Flanguage_id: uint16(m_TT_MS_LANGID_JAPANESE_JAPAN),
		Ffromcode:    [12]int8{'S', 'J', 'I', 'S', '-', 'W', 'I', 'N'},
	},
	1: {
		Flanguage_id: uint16(m_TT_MS_LANGID_ENGLISH_UNITED_STATES),
		Ffromcode:    [12]int8{'A', 'S', 'C', 'I', 'I'},
	},
}

// C documentation
//
//	/* From http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/ROMAN.TXT */
var _fcMacRomanNonASCIIToUnicode = [128]TFcChar16{
	0:   uint16(0x00C4),
	1:   uint16(0x00C5),
	2:   uint16(0x00C7),
	3:   uint16(0x00C9),
	4:   uint16(0x00D1),
	5:   uint16(0x00D6),
	6:   uint16(0x00DC),
	7:   uint16(0x00E1),
	8:   uint16(0x00E0),
	9:   uint16(0x00E2),
	10:  uint16(0x00E4),
	11:  uint16(0x00E3),
	12:  uint16(0x00E5),
	13:  uint16(0x00E7),
	14:  uint16(0x00E9),
	15:  uint16(0x00E8),
	16:  uint16(0x00EA),
	17:  uint16(0x00EB),
	18:  uint16(0x00ED),
	19:  uint16(0x00EC),
	20:  uint16(0x00EE),
	21:  uint16(0x00EF),
	22:  uint16(0x00F1),
	23:  uint16(0x00F3),
	24:  uint16(0x00F2),
	25:  uint16(0x00F4),
	26:  uint16(0x00F6),
	27:  uint16(0x00F5),
	28:  uint16(0x00FA),
	29:  uint16(0x00F9),
	30:  uint16(0x00FB),
	31:  uint16(0x00FC),
	32:  uint16(0x2020),
	33:  uint16(0x00B0),
	34:  uint16(0x00A2),
	35:  uint16(0x00A3),
	36:  uint16(0x00A7),
	37:  uint16(0x2022),
	38:  uint16(0x00B6),
	39:  uint16(0x00DF),
	40:  uint16(0x00AE),
	41:  uint16(0x00A9),
	42:  uint16(0x2122),
	43:  uint16(0x00B4),
	44:  uint16(0x00A8),
	45:  uint16(0x2260),
	46:  uint16(0x00C6),
	47:  uint16(0x00D8),
	48:  uint16(0x221E),
	49:  uint16(0x00B1),
	50:  uint16(0x2264),
	51:  uint16(0x2265),
	52:  uint16(0x00A5),
	53:  uint16(0x00B5),
	54:  uint16(0x2202),
	55:  uint16(0x2211),
	56:  uint16(0x220F),
	57:  uint16(0x03C0),
	58:  uint16(0x222B),
	59:  uint16(0x00AA),
	60:  uint16(0x00BA),
	61:  uint16(0x03A9),
	62:  uint16(0x00E6),
	63:  uint16(0x00F8),
	64:  uint16(0x00BF),
	65:  uint16(0x00A1),
	66:  uint16(0x00AC),
	67:  uint16(0x221A),
	68:  uint16(0x0192),
	69:  uint16(0x2248),
	70:  uint16(0x2206),
	71:  uint16(0x00AB),
	72:  uint16(0x00BB),
	73:  uint16(0x2026),
	74:  uint16(0x00A0),
	75:  uint16(0x00C0),
	76:  uint16(0x00C3),
	77:  uint16(0x00D5),
	78:  uint16(0x0152),
	79:  uint16(0x0153),
	80:  uint16(0x2013),
	81:  uint16(0x2014),
	82:  uint16(0x201C),
	83:  uint16(0x201D),
	84:  uint16(0x2018),
	85:  uint16(0x2019),
	86:  uint16(0x00F7),
	87:  uint16(0x25CA),
	88:  uint16(0x00FF),
	89:  uint16(0x0178),
	90:  uint16(0x2044),
	91:  uint16(0x20AC),
	92:  uint16(0x2039),
	93:  uint16(0x203A),
	94:  uint16(0xFB01),
	95:  uint16(0xFB02),
	96:  uint16(0x2021),
	97:  uint16(0x00B7),
	98:  uint16(0x201A),
	99:  uint16(0x201E),
	100: uint16(0x2030),
	101: uint16(0x00C2),
	102: uint16(0x00CA),
	103: uint16(0x00C1),
	104: uint16(0x00CB),
	105: uint16(0x00C8),
	106: uint16(0x00CD),
	107: uint16(0x00CE),
	108: uint16(0x00CF),
	109: uint16(0x00CC),
	110: uint16(0x00D3),
	111: uint16(0x00D4),
	112: uint16(0xF8FF),
	113: uint16(0x00D2),
	114: uint16(0x00DA),
	115: uint16(0x00DB),
	116: uint16(0x00D9),
	117: uint16(0x0131),
	118: uint16(0x02C6),
	119: uint16(0x02DC),
	120: uint16(0x00AF),
	121: uint16(0x02D8),
	122: uint16(0x02D9),
	123: uint16(0x02DA),
	124: uint16(0x00B8),
	125: uint16(0x02DD),
	126: uint16(0x02DB),
	127: uint16(0x02C7),
}

// C documentation
//
//	/*
//	 * A shift-JIS will have many high bits turned on
//	 */
func _FcLooksLikeSJIS(tls *libc.TLS, string1 uintptr, len1 int32) (r TFcBool) {
	var nhigh, nlow, v1 int32
	var v2 uintptr
	_, _, _, _ = nhigh, nlow, v1, v2
	nhigh = 0
	nlow = 0
	for {
		v1 = len1
		len1--
		if !(v1 > 0) {
			break
		}
		v2 = string1
		string1++
		if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v2)))&int32(0x80) != 0 {
			nhigh++
		} else {
			nlow++
		}
	}
	/*
	 * Heuristic -- if more than 1/3 of the bytes have the high-bit set,
	 * this is likely to be SJIS and not ROMAN
	 */
	if nhigh*int32(2) > nlow {
		return int32(m_FcTrue)
	}
	return m_FcFalse
}

func _FcSfntNameTranscode(tls *libc.TLS, sname uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var f, i, ilen, olen, olen1, olen2, src_len, src_len1, src_len2, v3 int32
	var fromcode, src, src1, src2, u8, u81, u82, utf8, v4, v5 uintptr
	var ucs41, ucs42 TFcChar32
	var _ /* len at bp+0 */ int32
	var _ /* ucs4 at bp+8 */ TFcChar32
	var _ /* wchar at bp+4 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = f, fromcode, i, ilen, olen, olen1, olen2, src, src1, src2, src_len, src_len1, src_len2, u8, u81, u82, ucs41, ucs42, utf8, v3, v4, v5
	i = 0
	for {
		if !(i < libc.Int32FromUint64(libc.Uint64FromInt64(224)/libc.Uint64FromInt64(16))) {
			break
		}
		if libc.Int32FromUint16(_fcFtEncoding[i].Fplatform_id) == libc.Int32FromUint16((*TFT_SfntName)(unsafe.Pointer(sname)).Fplatform_id) && (libc.Int32FromUint16(_fcFtEncoding[i].Fencoding_id) == int32(m_TT_ENCODING_DONT_CARE) || libc.Int32FromUint16(_fcFtEncoding[i].Fencoding_id) == libc.Int32FromUint16((*TFT_SfntName)(unsafe.Pointer(sname)).Fencoding_id)) {
			break
		}
		goto _1
	_1:
		;
		i++
	}
	if i == libc.Int32FromUint64(libc.Uint64FromInt64(224)/libc.Uint64FromInt64(16)) {
		return uintptr(0)
	}
	fromcode = uintptr(unsafe.Pointer(&_fcFtEncoding)) + uintptr(i)*16 + 4
	/*
	 * Many names encoded for TT_PLATFORM_MACINTOSH are broken
	 * in various ways. Kludge around them.
	 */
	if !(libc.Xstrcmp(tls, fromcode, __ccgo_ts+3802) != 0) {
		if libc.Int32FromUint16((*TFT_SfntName)(unsafe.Pointer(sname)).Flanguage_id) == m_TT_MAC_LANGID_ENGLISH && _FcLooksLikeSJIS(tls, (*TFT_SfntName)(unsafe.Pointer(sname)).Fstring1, libc.Int32FromUint32((*TFT_SfntName)(unsafe.Pointer(sname)).Fstring_len)) != 0 {
			fromcode = __ccgo_ts + 3812
		} else {
			if libc.Int32FromUint16((*TFT_SfntName)(unsafe.Pointer(sname)).Flanguage_id) >= int32(0x100) {
				fromcode = libc.UintptrFromInt32(0)
				f = 0
				for {
					if !(f < libc.Int32FromUint64(libc.Uint64FromInt64(28)/libc.Uint64FromInt64(14))) {
						break
					}
					if libc.Int32FromUint16(_fcMacRomanFake[f].Flanguage_id) == libc.Int32FromUint16((*TFT_SfntName)(unsafe.Pointer(sname)).Flanguage_id) {
						fromcode = uintptr(unsafe.Pointer(&_fcMacRomanFake)) + uintptr(f)*14 + 2
						break
					}
					goto _2
				_2:
					;
					f++
				}
				if !(fromcode != 0) {
					return uintptr(0)
				}
			}
		}
	}
	if !(libc.Xstrcmp(tls, fromcode, __ccgo_ts+3817) != 0) || !(libc.Xstrcmp(tls, fromcode, __ccgo_ts+3825) != 0) {
		src = (*TFT_SfntName)(unsafe.Pointer(sname)).Fstring1
		src_len = libc.Int32FromUint32((*TFT_SfntName)(unsafe.Pointer(sname)).Fstring_len)
		/*
		 * Convert Utf16 to Utf8
		 */
		if !(XFcUtf16Len(tls, src, int32(_FcEndianBig), src_len, bp, bp+4) != 0) {
			return uintptr(0)
		}
		/*
		 * Allocate plenty of space.  Freed below
		 */
		utf8 = libc.Xmalloc(tls, libc.Uint64FromInt32(*(*int32)(unsafe.Pointer(bp))*int32(m_FC_UTF8_MAX_LEN)+int32(1)))
		if !(utf8 != 0) {
			return uintptr(0)
		}
		u8 = utf8
		for {
			v3 = XFcUtf16ToUcs4(tls, src, int32(_FcEndianBig), bp+8, src_len)
			ilen = v3
			if !(v3 > 0) {
				break
			}
			src_len -= ilen
			src += uintptr(ilen)
			olen = XFcUcs4ToUtf8(tls, *(*TFcChar32)(unsafe.Pointer(bp + 8)), u8)
			u8 += uintptr(olen)
		}
		*(*TFcChar8)(unsafe.Pointer(u8)) = uint8('\000')
		goto done
	}
	if !(libc.Xstrcmp(tls, fromcode, __ccgo_ts+3834) != 0) || !(libc.Xstrcmp(tls, fromcode, __ccgo_ts+3840) != 0) {
		src1 = (*TFT_SfntName)(unsafe.Pointer(sname)).Fstring1
		src_len1 = libc.Int32FromUint32((*TFT_SfntName)(unsafe.Pointer(sname)).Fstring_len)
		/*
		 * Convert Latin1 to Utf8. Freed below
		 */
		utf8 = libc.Xmalloc(tls, libc.Uint64FromInt32(src_len1*int32(2)+int32(1)))
		if !(utf8 != 0) {
			return uintptr(0)
		}
		u81 = utf8
		for src_len1 > 0 {
			v4 = src1
			src1++
			ucs41 = uint32(*(*TFcChar8)(unsafe.Pointer(v4)))
			src_len1--
			olen1 = XFcUcs4ToUtf8(tls, ucs41, u81)
			u81 += uintptr(olen1)
		}
		*(*TFcChar8)(unsafe.Pointer(u81)) = uint8('\000')
		goto done
	}
	if !(libc.Xstrcmp(tls, fromcode, __ccgo_ts+3802) != 0) {
		src2 = (*TFT_SfntName)(unsafe.Pointer(sname)).Fstring1
		src_len2 = libc.Int32FromUint32((*TFT_SfntName)(unsafe.Pointer(sname)).Fstring_len)
		/*
		 * Convert Latin1 to Utf8. Freed below
		 */
		utf8 = libc.Xmalloc(tls, libc.Uint64FromInt32(src_len2*int32(3)+int32(1)))
		if !(utf8 != 0) {
			return uintptr(0)
		}
		u82 = utf8
		for src_len2 > 0 {
			v5 = src2
			src2++
			ucs42 = uint32(*(*TFcChar8)(unsafe.Pointer(v5)))
			if ucs42 >= uint32(128) {
				ucs42 = uint32(_fcMacRomanNonASCIIToUnicode[ucs42-uint32(128)])
			}
			src_len2--
			olen2 = XFcUcs4ToUtf8(tls, ucs42, u82)
			u82 += uintptr(olen2)
		}
		*(*TFcChar8)(unsafe.Pointer(u82)) = uint8('\000')
		goto done
	}
	return uintptr(0)
	goto done
done:
	;
	if XFcStrCmpIgnoreBlanksAndCase(tls, utf8, __ccgo_ts+110) == 0 {
		libc.Xfree(tls, utf8)
		return uintptr(0)
	}
	return utf8
}

func _FcSfntNameLanguage(tls *libc.TLS, sname uintptr) (r uintptr) {
	var i int32
	var language_id, platform_id TFT_UShort
	_, _, _ = i, language_id, platform_id
	platform_id = (*TFT_SfntName)(unsafe.Pointer(sname)).Fplatform_id
	language_id = (*TFT_SfntName)(unsafe.Pointer(sname)).Flanguage_id
	/*
	 * Many names encoded for TT_PLATFORM_MACINTOSH are broken
	 * in various ways. Kludge around them.
	 */
	if libc.Int32FromUint16(platform_id) == int32(m_TT_PLATFORM_MACINTOSH) && libc.Int32FromUint16((*TFT_SfntName)(unsafe.Pointer(sname)).Fencoding_id) == m_TT_MAC_ID_ROMAN && _FcLooksLikeSJIS(tls, (*TFT_SfntName)(unsafe.Pointer(sname)).Fstring1, libc.Int32FromUint32((*TFT_SfntName)(unsafe.Pointer(sname)).Fstring_len)) != 0 {
		language_id = uint16(m_TT_MAC_LANGID_JAPANESE)
	}
	i = 0
	for {
		if !(i < libc.Int32FromUint64(libc.Uint64FromInt64(4020)/libc.Uint64FromInt64(12))) {
			break
		}
		if libc.Int32FromUint16(_fcFtLanguage[i].Fplatform_id) == libc.Int32FromUint16(platform_id) && (libc.Int32FromUint16(_fcFtLanguage[i].Flanguage_id) == int32(m_TT_LANGUAGE_DONT_CARE) || libc.Int32FromUint16(_fcFtLanguage[i].Flanguage_id) == libc.Int32FromUint16(language_id)) {
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcFtLanguage)) + uintptr(i)*12 + 4))) == int32('\000') {
				return libc.UintptrFromInt32(0)
			} else {
				return uintptr(unsafe.Pointer(&_fcFtLanguage)) + uintptr(i)*12 + 4
			}
		}
		goto _1
	_1:
		;
		i++
	}
	return uintptr(0)
}

func _FcNoticeFoundry(tls *libc.TLS, notice uintptr) (r uintptr) {
	var f, n uintptr
	var i int32
	_, _, _ = f, i, n
	if notice != 0 {
		i = 0
		for {
			if !(i < libc.Int32FromUint64(libc.Uint64FromInt64(288)/libc.Uint64FromInt64(16))) {
				break
			}
			n = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_FcNoticeFoundries)) + uintptr(i)*16))
			f = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_FcNoticeFoundries)) + uintptr(i)*16 + 1*8))
			if libc.Xstrstr(tls, notice, n) != 0 {
				return f
			}
			goto _1
		_1:
			;
			i++
		}
	}
	return uintptr(0)
}

type TFcStringConst = struct {
	Fname  uintptr
	Fvalue int32
}

type T_FcStringConst = TFcStringConst

func _FcStringIsConst(tls *libc.TLS, string1 uintptr, c uintptr, nc int32) (r int32) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < nc) {
			break
		}
		if XFcStrCmpIgnoreBlanksAndCase(tls, string1, (*(*TFcStringConst)(unsafe.Pointer(c + uintptr(i)*16))).Fname) == 0 {
			return (*(*TFcStringConst)(unsafe.Pointer(c + uintptr(i)*16))).Fvalue
		}
		goto _1
	_1:
		;
		i++
	}
	return -int32(1)
}

func _FcStringContainsConst(tls *libc.TLS, string1 uintptr, c uintptr, nc int32) (r int32) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < nc) {
			break
		}
		if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer((*(*TFcStringConst)(unsafe.Pointer(c + uintptr(i)*16))).Fname))) == int32('<') {
			if XFcStrContainsWord(tls, string1, (*(*TFcStringConst)(unsafe.Pointer(c + uintptr(i)*16))).Fname+uintptr(1)) != 0 {
				return (*(*TFcStringConst)(unsafe.Pointer(c + uintptr(i)*16))).Fvalue
			}
		} else {
			if XFcStrContainsIgnoreBlanksAndCase(tls, string1, (*(*TFcStringConst)(unsafe.Pointer(c + uintptr(i)*16))).Fname) != 0 {
				return (*(*TFcStringConst)(unsafe.Pointer(c + uintptr(i)*16))).Fvalue
			}
		}
		goto _1
	_1:
		;
		i++
	}
	return -int32(1)
}

type TFC8 = uintptr

var _weightConsts = [23]TFcStringConst{
	0: {
		Fname: __ccgo_ts + 3851,
	},
	1: {
		Fname:  __ccgo_ts + 3856,
		Fvalue: int32(m_FC_WEIGHT_EXTRALIGHT),
	},
	2: {
		Fname:  __ccgo_ts + 3867,
		Fvalue: int32(m_FC_WEIGHT_EXTRALIGHT),
	},
	3: {
		Fname:  __ccgo_ts + 3878,
		Fvalue: int32(m_FC_WEIGHT_DEMILIGHT),
	},
	4: {
		Fname:  __ccgo_ts + 3888,
		Fvalue: int32(m_FC_WEIGHT_DEMILIGHT),
	},
	5: {
		Fname:  __ccgo_ts + 3898,
		Fvalue: int32(m_FC_WEIGHT_LIGHT),
	},
	6: {
		Fname:  __ccgo_ts + 3904,
		Fvalue: int32(m_FC_WEIGHT_BOOK),
	},
	7: {
		Fname:  __ccgo_ts + 3909,
		Fvalue: int32(m_FC_WEIGHT_REGULAR),
	},
	8: {
		Fname:  __ccgo_ts + 3917,
		Fvalue: int32(m_FC_WEIGHT_REGULAR),
	},
	9: {
		Fname:  __ccgo_ts + 3924,
		Fvalue: int32(m_FC_WEIGHT_MEDIUM),
	},
	10: {
		Fname:  __ccgo_ts + 3931,
		Fvalue: int32(m_FC_WEIGHT_DEMIBOLD),
	},
	11: {
		Fname:  __ccgo_ts + 3940,
		Fvalue: int32(m_FC_WEIGHT_DEMIBOLD),
	},
	12: {
		Fname:  __ccgo_ts + 3945,
		Fvalue: int32(m_FC_WEIGHT_DEMIBOLD),
	},
	13: {
		Fname:  __ccgo_ts + 3954,
		Fvalue: int32(m_FC_WEIGHT_EXTRABOLD),
	},
	14: {
		Fname:  __ccgo_ts + 3964,
		Fvalue: int32(m_FC_WEIGHT_EXTRABOLD),
	},
	15: {
		Fname:  __ccgo_ts + 3974,
		Fvalue: int32(m_FC_WEIGHT_EXTRABOLD),
	},
	16: {
		Fname:  __ccgo_ts + 3984,
		Fvalue: int32(m_FC_WEIGHT_BOLD),
	},
	17: {
		Fname:  __ccgo_ts + 3989,
		Fvalue: int32(m_FC_WEIGHT_EXTRABLACK),
	},
	18: {
		Fname:  __ccgo_ts + 4000,
		Fvalue: int32(m_FC_WEIGHT_EXTRABLACK),
	},
	19: {
		Fname:  __ccgo_ts + 4011,
		Fvalue: int32(m_FC_WEIGHT_EXTRABLACK),
	},
	20: {
		Fname:  __ccgo_ts + 4022,
		Fvalue: int32(m_FC_WEIGHT_EXTRABOLD),
	},
	21: {
		Fname:  __ccgo_ts + 4029,
		Fvalue: int32(m_FC_WEIGHT_BLACK),
	},
	22: {
		Fname:  __ccgo_ts + 4035,
		Fvalue: int32(m_FC_WEIGHT_BLACK),
	},
}

var _widthConsts = [10]TFcStringConst{
	0: {
		Fname:  __ccgo_ts + 4041,
		Fvalue: int32(m_FC_WIDTH_ULTRACONDENSED),
	},
	1: {
		Fname:  __ccgo_ts + 4056,
		Fvalue: int32(m_FC_WIDTH_EXTRACONDENSED),
	},
	2: {
		Fname:  __ccgo_ts + 4071,
		Fvalue: int32(m_FC_WIDTH_SEMICONDENSED),
	},
	3: {
		Fname:  __ccgo_ts + 4085,
		Fvalue: int32(m_FC_WIDTH_CONDENSED),
	},
	4: {
		Fname:  __ccgo_ts + 3917,
		Fvalue: int32(m_FC_WIDTH_NORMAL),
	},
	5: {
		Fname:  __ccgo_ts + 4095,
		Fvalue: int32(m_FC_WIDTH_SEMIEXPANDED),
	},
	6: {
		Fname:  __ccgo_ts + 4108,
		Fvalue: int32(m_FC_WIDTH_EXTRAEXPANDED),
	},
	7: {
		Fname:  __ccgo_ts + 4122,
		Fvalue: int32(m_FC_WIDTH_ULTRAEXPANDED),
	},
	8: {
		Fname:  __ccgo_ts + 4136,
		Fvalue: int32(m_FC_WIDTH_EXPANDED),
	},
	9: {
		Fname:  __ccgo_ts + 4145,
		Fvalue: int32(m_FC_WIDTH_EXPANDED),
	},
}

var _slantConsts = [3]TFcStringConst{
	0: {
		Fname:  __ccgo_ts + 4154,
		Fvalue: int32(m_FC_SLANT_ITALIC),
	},
	1: {
		Fname:  __ccgo_ts + 4161,
		Fvalue: int32(m_FC_SLANT_ITALIC),
	},
	2: {
		Fname:  __ccgo_ts + 4168,
		Fvalue: int32(m_FC_SLANT_OBLIQUE),
	},
}

var _decorativeConsts = [6]TFcStringConst{
	0: {
		Fname:  __ccgo_ts + 4176,
		Fvalue: int32(m_FcTrue),
	},
	1: {
		Fname:  __ccgo_ts + 4183,
		Fvalue: int32(m_FcTrue),
	},
	2: {
		Fname:  __ccgo_ts + 4188,
		Fvalue: int32(m_FcTrue),
	},
	3: {
		Fname:  __ccgo_ts + 4196,
		Fvalue: int32(m_FcTrue),
	},
	4: {
		Fname:  __ccgo_ts + 4204,
		Fvalue: int32(m_FcTrue),
	},
	5: {
		Fname:  __ccgo_ts + 4212,
		Fvalue: int32(m_FcTrue),
	},
}

func _FcGetPixelSize(tls *libc.TLS, face TFT_Face, i int32) (r float64) {
	return float64((*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(i)*32))).Fy_ppem) / float64(64)
}

func _FcStringInPatternElement(tls *libc.TLS, pat uintptr, obj TFcObject, string1 uintptr) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var l TFcValueListPtr
	var v2 uintptr
	var _ /* iter at bp+0 */ TFcPatternIter
	var _ /* v at bp+16 */ TFcValue
	_, _ = l, v2
	XFcPatternIterStart(tls, pat, bp)
	if !(XFcPatternFindObjectIter(tls, pat, bp, obj) != 0) {
		return m_FcFalse
	}
	l = XFcPatternIterGetValues(tls, pat, bp)
	for {
		if !(l != 0) {
			break
		}
		*(*TFcValue)(unsafe.Pointer(bp + 16)) = TFcValue{}
		*(*T_FcValue)(unsafe.Pointer(bp + 16)) = XFcValueCanonicalize(tls, l+8)
		if (*(*TFcValue)(unsafe.Pointer(bp + 16))).Ftype1 != int32(_FcTypeString) {
			break
		}
		if !(XFcStrCmpIgnoreBlanksAndCase(tls, *(*uintptr)(unsafe.Pointer(bp + 16 + 8)), string1) != 0) {
			return int32(m_FcTrue)
		}
		goto _1
	_1:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
			v2 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
		}
		l = v2
	}
	return m_FcFalse
}

var _platform_order = [4]TFT_UShort{
	0: uint16(m_TT_PLATFORM_MICROSOFT),
	2: uint16(m_TT_PLATFORM_MACINTOSH),
	3: uint16(m_TT_PLATFORM_ISO),
}

var _nameid_order = [10]TFT_UShort{
	0: uint16(m_TT_NAME_ID_WWS_FAMILY),
	1: uint16(m_TT_NAME_ID_TYPOGRAPHIC_FAMILY),
	2: uint16(m_TT_NAME_ID_FONT_FAMILY),
	3: uint16(m_TT_NAME_ID_MAC_FULL_NAME),
	4: uint16(m_TT_NAME_ID_FULL_NAME),
	5: uint16(m_TT_NAME_ID_WWS_SUBFAMILY),
	6: uint16(m_TT_NAME_ID_TYPOGRAPHIC_SUBFAMILY),
	7: uint16(m_TT_NAME_ID_FONT_SUBFAMILY),
	8: uint16(m_TT_NAME_ID_TRADEMARK),
	9: uint16(m_TT_NAME_ID_MANUFACTURER),
}

type TFcNameMapping = struct {
	Fplatform_id uint32
	Fname_id     uint32
	Fencoding_id uint32
	Flanguage_id uint32
	Fidx         uint32
}

func __is_english(tls *libc.TLS, platform int32, language int32) (r TFcBool) {
	var ret TFcBool
	_ = ret
	ret = m_FcFalse
	switch platform {
	case int32(m_TT_PLATFORM_MACINTOSH):
		ret = libc.BoolInt32(language == m_TT_MAC_LANGID_ENGLISH)
	case int32(m_TT_PLATFORM_MICROSOFT):
		ret = libc.BoolInt32(language == int32(m_TT_MS_LANGID_ENGLISH_UNITED_STATES))
		break
	}
	return ret
}

func _name_mapping_cmp(tls *libc.TLS, pa uintptr, pb uintptr) (r int32) {
	var a, b uintptr
	var v1, v2 int32
	_, _, _, _ = a, b, v1, v2
	a = pa
	b = pb
	if (*TFcNameMapping)(unsafe.Pointer(a)).Fplatform_id != (*TFcNameMapping)(unsafe.Pointer(b)).Fplatform_id {
		return libc.Int32FromUint32((*TFcNameMapping)(unsafe.Pointer(a)).Fplatform_id) - libc.Int32FromUint32((*TFcNameMapping)(unsafe.Pointer(b)).Fplatform_id)
	}
	if (*TFcNameMapping)(unsafe.Pointer(a)).Fname_id != (*TFcNameMapping)(unsafe.Pointer(b)).Fname_id {
		return libc.Int32FromUint32((*TFcNameMapping)(unsafe.Pointer(a)).Fname_id) - libc.Int32FromUint32((*TFcNameMapping)(unsafe.Pointer(b)).Fname_id)
	}
	if (*TFcNameMapping)(unsafe.Pointer(a)).Fencoding_id != (*TFcNameMapping)(unsafe.Pointer(b)).Fencoding_id {
		return libc.Int32FromUint32((*TFcNameMapping)(unsafe.Pointer(a)).Fencoding_id) - libc.Int32FromUint32((*TFcNameMapping)(unsafe.Pointer(b)).Fencoding_id)
	}
	if (*TFcNameMapping)(unsafe.Pointer(a)).Flanguage_id != (*TFcNameMapping)(unsafe.Pointer(b)).Flanguage_id {
		if __is_english(tls, libc.Int32FromUint32((*TFcNameMapping)(unsafe.Pointer(a)).Fplatform_id), libc.Int32FromUint32((*TFcNameMapping)(unsafe.Pointer(a)).Flanguage_id)) != 0 {
			v1 = -int32(1)
		} else {
			if __is_english(tls, libc.Int32FromUint32((*TFcNameMapping)(unsafe.Pointer(b)).Fplatform_id), libc.Int32FromUint32((*TFcNameMapping)(unsafe.Pointer(b)).Flanguage_id)) != 0 {
				v2 = int32(1)
			} else {
				v2 = libc.Int32FromUint32((*TFcNameMapping)(unsafe.Pointer(a)).Flanguage_id) - libc.Int32FromUint32((*TFcNameMapping)(unsafe.Pointer(b)).Flanguage_id)
			}
			v1 = v2
		}
		return v1
	}
	if (*TFcNameMapping)(unsafe.Pointer(a)).Fidx != (*TFcNameMapping)(unsafe.Pointer(b)).Fidx {
		return libc.Int32FromUint32((*TFcNameMapping)(unsafe.Pointer(a)).Fidx) - libc.Int32FromUint32((*TFcNameMapping)(unsafe.Pointer(b)).Fidx)
	}
	return 0
}

func _FcFreeTypeGetFirstName(tls *libc.TLS, face TFT_Face, platform uint32, nameid uint32, mapping uintptr, count uint32, sname uintptr) (r int32) {
	var max, mid, min int32
	_, _, _ = max, mid, min
	min = 0
	max = libc.Int32FromUint32(count) - int32(1)
	for min <= max {
		mid = (min + max) / int32(2)
		if libfreetype.XFT_Get_Sfnt_Name(tls, face, (*(*TFcNameMapping)(unsafe.Pointer(mapping + uintptr(mid)*20))).Fidx, sname) != 0 {
			return m_FcFalse
		}
		if platform < uint32((*TFT_SfntName)(unsafe.Pointer(sname)).Fplatform_id) || platform == uint32((*TFT_SfntName)(unsafe.Pointer(sname)).Fplatform_id) && (nameid < uint32((*TFT_SfntName)(unsafe.Pointer(sname)).Fname_id) || nameid == uint32((*TFT_SfntName)(unsafe.Pointer(sname)).Fname_id) && (mid != 0 && platform == (*(*TFcNameMapping)(unsafe.Pointer(mapping + uintptr(mid-int32(1))*20))).Fplatform_id && nameid == (*(*TFcNameMapping)(unsafe.Pointer(mapping + uintptr(mid-int32(1))*20))).Fname_id)) {
			max = mid - int32(1)
		} else {
			if platform > uint32((*TFT_SfntName)(unsafe.Pointer(sname)).Fplatform_id) || platform == uint32((*TFT_SfntName)(unsafe.Pointer(sname)).Fplatform_id) && nameid > uint32((*TFT_SfntName)(unsafe.Pointer(sname)).Fname_id) {
				min = mid + int32(1)
			} else {
				return mid
			}
		}
	}
	return -int32(1)
}

func _FcFreeTypeQueryFaceInternal(tls *libc.TLS, face TFT_Face, file uintptr, id uint32, cs_share uintptr, ls_share uintptr, nm_share uintptr) (r2 uintptr) {
	bp := tls.Alloc(576)
	defer tls.Free(576)
	var bit, has_color, has_outline, i3, i7, lookupid, n1, n2, name_count, nameid, nameidx, platform, slant, spacing, st, v12, v13, v17, v21, v23, v24, v27, v31, v33, v34 int32
	var bits TFT_ULong
	var complex_, cs, end, exclusiveLang, family, foundry, foundry_, head, instance, lang, ls, name_mapping, nlangp, np, os2, p1, pat, pp, r, r1, ss, start, style_regular, tmp, utf8, utf81, v15, v39 uintptr
	var decorative, symbol, variable, variable_size, variable_weight, variable_width TFcBool
	var def_value, default_value, lower_size, max_value, min_value, mult, upper_size, value, weight, weight_mult, width, width_mult, v3 float64
	var ftresult TFT_Error
	var i, i1, i2, i5, i6, n, p, v6, v7, v8, v9 uint32
	var i4, len1, len11, len2 Tsize_t
	var obj, obj1, objlang TFcObject
	var v19, v29 t__darwin_ct_rune_t
	var v20, v30 uint64
	var v36, v40 bool
	var _ /* family at bp+520 */ uintptr
	var _ /* family at bp+88 */ uintptr
	var _ /* familylang at bp+528 */ uintptr
	var _ /* lang at bp+104 */ uintptr
	var _ /* master at bp+0 */ uintptr
	var _ /* nfamily at bp+8 */ int32
	var _ /* nfamily_lang at bp+12 */ int32
	var _ /* nfullname at bp+24 */ int32
	var _ /* nfullname_lang at bp+28 */ int32
	var _ /* nstyle at bp+16 */ int32
	var _ /* nstyle_lang at bp+20 */ int32
	var _ /* psname at bp+264 */ [256]int8
	var _ /* sbuf at bp+112 */ TFcStrBuf
	var _ /* sname at bp+40 */ TFT_SfntName
	var _ /* sname at bp+64 */ TFT_SfntName
	var _ /* style at bp+32 */ uintptr
	var _ /* style at bp+96 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = bit, bits, complex_, cs, decorative, def_value, default_value, end, exclusiveLang, family, foundry, foundry_, ftresult, has_color, has_outline, head, i, i1, i2, i3, i4, i5, i6, i7, instance, lang, len1, len11, len2, lookupid, lower_size, ls, max_value, min_value, mult, n, n1, n2, name_count, name_mapping, nameid, nameidx, nlangp, np, obj, obj1, objlang, os2, p, p1, pat, platform, pp, r, r1, slant, spacing, ss, st, start, style_regular, symbol, tmp, upper_size, utf8, utf81, value, variable, variable_size, variable_weight, variable_width, weight, weight_mult, width, width_mult, v12, v13, v15, v17, v19, v20, v21, v23, v24, v27, v29, v3, v30, v31, v33, v34, v36, v39, v40, v6, v7, v8, v9
	slant = -int32(1)
	weight = float64(-libc.Int32FromInt32(1))
	width = float64(-libc.Int32FromInt32(1))
	decorative = m_FcFalse
	variable = m_FcFalse
	variable_weight = m_FcFalse
	variable_width = m_FcFalse
	variable_size = m_FcFalse
	name_mapping = libc.UintptrFromInt32(0)
	foundry_ = libc.UintptrFromInt32(0)
	foundry = uintptr(0)
	/* Support for glyph-variation named-instances. */
	*(*uintptr)(unsafe.Pointer(bp)) = libc.UintptrFromInt32(0)
	instance = libc.UintptrFromInt32(0)
	weight_mult = float64(1)
	width_mult = float64(1)
	exclusiveLang = uintptr(0)
	name_count = 0
	*(*int32)(unsafe.Pointer(bp + 8)) = 0
	*(*int32)(unsafe.Pointer(bp + 12)) = 0
	*(*int32)(unsafe.Pointer(bp + 16)) = 0
	*(*int32)(unsafe.Pointer(bp + 20)) = 0
	*(*int32)(unsafe.Pointer(bp + 24)) = 0
	*(*int32)(unsafe.Pointer(bp + 28)) = 0
	*(*uintptr)(unsafe.Pointer(bp + 32)) = uintptr(0)
	symbol = m_FcFalse
	XFcInitDebug(tls) /* We might be called with no initizalization whatsoever. */
	pat = XFcPatternCreate(tls)
	if !(pat != 0) {
		goto bail0
	}
	has_outline = libc.BoolInt32(!!((*TFT_FaceRec_)(unsafe.Pointer(face)).Fface_flags&(libc.Int64FromInt64(1)<<libc.Int32FromInt32(0)) != 0))
	has_color = 0
	if !(XFcPatternObjectAddBool(tls, pat, int32(_FC_OUTLINE_OBJECT), has_outline) != 0) {
		goto bail1
	}
	has_color = libc.BoolInt32(!!!!((*TFT_FaceRec_)(unsafe.Pointer(face)).Fface_flags&(libc.Int64FromInt64(1)<<libc.Int32FromInt32(14)) != 0))
	if !(XFcPatternObjectAddBool(tls, pat, int32(_FC_COLOR_OBJECT), has_color) != 0) {
		goto bail1
	}
	/* All color fonts are designed to be scaled, even if they only have
	 * bitmap strikes.  Client is responsible to scale the bitmaps.  This
	 * is in contrast to non-color strikes... */
	if !(XFcPatternObjectAddBool(tls, pat, int32(_FC_SCALABLE_OBJECT), libc.BoolInt32(has_outline != 0 || has_color != 0)) != 0) {
		goto bail1
	}
	ftresult = libfreetype.XFT_Get_MM_Var(tls, face, bp)
	if id>>int32(16) != 0 {
		if ftresult != 0 {
			goto bail1
		}
		if id>>int32(16) == uint32(0x8000) {
			i = uint32(0)
			for {
				if !(i < (*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fnum_axis) {
					break
				}
				min_value = float64((*(*TFT_Var_Axis)(unsafe.Pointer((*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Faxis + uintptr(i)*48))).Fminimum) / float64(libc.Uint32FromUint32(1)<<libc.Int32FromInt32(16))
				def_value = float64((*(*TFT_Var_Axis)(unsafe.Pointer((*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Faxis + uintptr(i)*48))).Fdef) / float64(libc.Uint32FromUint32(1)<<libc.Int32FromInt32(16))
				max_value = float64((*(*TFT_Var_Axis)(unsafe.Pointer((*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Faxis + uintptr(i)*48))).Fmaximum) / float64(libc.Uint32FromUint32(1)<<libc.Int32FromInt32(16))
				obj = int32(_FC_INVALID_OBJECT)
				if min_value > def_value || def_value > max_value || min_value == max_value {
					goto _1
				}
				switch (*(*TFT_Var_Axis)(unsafe.Pointer((*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Faxis + uintptr(i)*48))).Ftag {
				case uint64(uint32(libc.Uint64FromUint8('w')<<libc.Int32FromInt32(24) | libc.Uint64FromUint8('g')<<libc.Int32FromInt32(16) | libc.Uint64FromUint8('h')<<libc.Int32FromInt32(8) | libc.Uint64FromUint8('t'))):
					obj = int32(_FC_WEIGHT_OBJECT)
					min_value = XFcWeightFromOpenTypeDouble(tls, min_value)
					max_value = XFcWeightFromOpenTypeDouble(tls, max_value)
					variable_weight = int32(m_FcTrue)
					weight = libc.Float64FromInt32(0) /* To stop looking for weight. */
				case uint64(uint32(libc.Uint64FromUint8('w')<<libc.Int32FromInt32(24) | libc.Uint64FromUint8('d')<<libc.Int32FromInt32(16) | libc.Uint64FromUint8('t')<<libc.Int32FromInt32(8) | libc.Uint64FromUint8('h'))):
					obj = int32(_FC_WIDTH_OBJECT)
					/* Values in 'wdth' match Fontconfig FC_WIDTH_* scheme directly. */
					variable_width = int32(m_FcTrue)
					width = libc.Float64FromInt32(0) /* To stop looking for width. */
				case uint64(uint32(libc.Uint64FromUint8('o')<<libc.Int32FromInt32(24) | libc.Uint64FromUint8('p')<<libc.Int32FromInt32(16) | libc.Uint64FromUint8('s')<<libc.Int32FromInt32(8) | libc.Uint64FromUint8('z'))):
					obj = int32(_FC_SIZE_OBJECT)
					/* Values in 'opsz' match Fontconfig FC_SIZE, both are in points. */
					variable_size = int32(m_FcTrue)
					break
				}
				if obj != int32(_FC_INVALID_OBJECT) {
					r = XFcRangeCreateDouble(tls, min_value, max_value)
					if !(XFcPatternObjectAddRange(tls, pat, obj, r) != 0) {
						XFcRangeDestroy(tls, r)
						goto bail1
					}
					XFcRangeDestroy(tls, r)
					variable = int32(m_FcTrue)
				}
				goto _1
			_1:
				;
				i++
			}
			if !(variable != 0) {
				goto bail1
			}
			id &= uint32(0xFFFF)
		} else {
			if id>>int32(16)-uint32(1) < (*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fnum_namedstyles {
				instance = (*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fnamedstyle + uintptr(id>>int32(16)-uint32(1))*16
				i1 = uint32(0)
				for {
					if !(i1 < (*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fnum_axis) {
						break
					}
					value = float64(*(*TFT_Fixed)(unsafe.Pointer((*TFT_Var_Named_Style)(unsafe.Pointer(instance)).Fcoords + uintptr(i1)*8))) / float64(libc.Uint32FromUint32(1)<<libc.Int32FromInt32(16))
					default_value = float64((*(*TFT_Var_Axis)(unsafe.Pointer((*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Faxis + uintptr(i1)*48))).Fdef) / float64(libc.Uint32FromUint32(1)<<libc.Int32FromInt32(16))
					if default_value != 0 {
						v3 = value / default_value
					} else {
						v3 = libc.Float64FromInt32(1)
					}
					mult = v3
					//printf ("named-instance, axis %d tag %lx value %g\n", i, master->axis[i].tag, value);
					switch (*(*TFT_Var_Axis)(unsafe.Pointer((*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Faxis + uintptr(i1)*48))).Ftag {
					case uint64(uint32(libc.Uint64FromUint8('w')<<libc.Int32FromInt32(24) | libc.Uint64FromUint8('g')<<libc.Int32FromInt32(16) | libc.Uint64FromUint8('h')<<libc.Int32FromInt32(8) | libc.Uint64FromUint8('t'))):
						weight_mult = mult
					case uint64(uint32(libc.Uint64FromUint8('w')<<libc.Int32FromInt32(24) | libc.Uint64FromUint8('d')<<libc.Int32FromInt32(16) | libc.Uint64FromUint8('t')<<libc.Int32FromInt32(8) | libc.Uint64FromUint8('h'))):
						width_mult = mult
					case uint64(uint32(libc.Uint64FromUint8('o')<<libc.Int32FromInt32(24) | libc.Uint64FromUint8('p')<<libc.Int32FromInt32(16) | libc.Uint64FromUint8('s')<<libc.Int32FromInt32(8) | libc.Uint64FromUint8('z'))):
						if !(XFcPatternObjectAddDouble(tls, pat, int32(_FC_SIZE_OBJECT), value) != 0) {
							goto bail1
						}
						break
					}
					goto _2
				_2:
					;
					i1++
				}
			} else {
				goto bail1
			}
		}
	} else {
		if !(ftresult != 0) {
			i2 = uint32(0)
			for {
				if !(i2 < (*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fnum_axis) {
					break
				}
				switch (*(*TFT_Var_Axis)(unsafe.Pointer((*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Faxis + uintptr(i2)*48))).Ftag {
				case uint64(uint32(libc.Uint64FromUint8('o')<<libc.Int32FromInt32(24) | libc.Uint64FromUint8('p')<<libc.Int32FromInt32(16) | libc.Uint64FromUint8('s')<<libc.Int32FromInt32(8) | libc.Uint64FromUint8('z'))):
					if !(XFcPatternObjectAddDouble(tls, pat, int32(_FC_SIZE_OBJECT), float64((*(*TFT_Var_Axis)(unsafe.Pointer((*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Faxis + uintptr(i2)*48))).Fdef)/float64(libc.Uint32FromUint32(1)<<libc.Int32FromInt32(16))) != 0) {
						goto bail1
					}
					variable_size = int32(m_FcTrue)
					break
				}
				goto _4
			_4:
				;
				i2++
			}
		} else {
			/* ignore an error of FT_Get_MM_Var() */
		}
	}
	if !(XFcPatternObjectAddBool(tls, pat, int32(_FC_VARIABLE_OBJECT), variable) != 0) {
		goto bail1
	}
	/*
	 * Get the OS/2 table
	 */
	os2 = libfreetype.XFT_Get_Sfnt_Table(tls, face, int32(_FT_SFNT_OS2))
	/*
	 * Look first in the OS/2 table for the foundry, if
	 * not found here, the various notices will be searched for
	 * that information, either from the sfnt name tables or
	 * the Postscript FontInfo dictionary.  Finally, the
	 * BDF properties will queried.
	 */
	if os2 != 0 && libc.Int32FromUint16((*TTT_OS2)(unsafe.Pointer(os2)).Fversion) >= int32(0x0001) && libc.Int32FromUint16((*TTT_OS2)(unsafe.Pointer(os2)).Fversion) != int32(0xffff) {
		if int32(*(*TFT_Char)(unsafe.Pointer(os2 + 80))) != 0 {
			foundry_ = libc.Xmalloc(tls, libc.Uint64FromInt64(4)+libc.Uint64FromInt32(1))
			libc.X__builtin___memcpy_chk(tls, foundry_, os2+80, uint64(4), ^t__predefined_size_t(0))
			*(*TFcChar8)(unsafe.Pointer(foundry_ + uintptr(4))) = uint8(0)
			foundry = foundry_
		}
	}
	if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
		libc.Xprintf(tls, __ccgo_ts+1266, 0)
	}
	/*
	 * Grub through the name table looking for family
	 * and style names.  FreeType makes quite a hash
	 * of them
	 */
	name_count = libc.Int32FromUint32(libfreetype.XFT_Get_Sfnt_Name_Count(tls, face))
	if nm_share != 0 {
		name_mapping = *(*uintptr)(unsafe.Pointer(nm_share))
	}
	if !(name_mapping != 0) {
		i3 = 0
		name_mapping = libc.Xmalloc(tls, libc.Uint64FromInt32(name_count)*uint64(20))
		if !(name_mapping != 0) {
			name_count = 0
		}
		i3 = 0
		for {
			if !(i3 < name_count) {
				break
			}
			p1 = name_mapping + uintptr(i3)*20
			if libfreetype.XFT_Get_Sfnt_Name(tls, face, libc.Uint32FromInt32(i3), bp+40) == 0 {
				(*TFcNameMapping)(unsafe.Pointer(p1)).Fplatform_id = uint32((*(*TFT_SfntName)(unsafe.Pointer(bp + 40))).Fplatform_id)
				(*TFcNameMapping)(unsafe.Pointer(p1)).Fname_id = uint32((*(*TFT_SfntName)(unsafe.Pointer(bp + 40))).Fname_id)
				(*TFcNameMapping)(unsafe.Pointer(p1)).Fencoding_id = uint32((*(*TFT_SfntName)(unsafe.Pointer(bp + 40))).Fencoding_id)
				(*TFcNameMapping)(unsafe.Pointer(p1)).Flanguage_id = uint32((*(*TFT_SfntName)(unsafe.Pointer(bp + 40))).Flanguage_id)
				(*TFcNameMapping)(unsafe.Pointer(p1)).Fidx = libc.Uint32FromInt32(i3)
			} else {
				v9 = libc.Uint32FromInt32(-libc.Int32FromInt32(1))
				(*TFcNameMapping)(unsafe.Pointer(p1)).Fidx = v9
				v8 = v9
				(*TFcNameMapping)(unsafe.Pointer(p1)).Flanguage_id = v8
				v7 = v8
				(*TFcNameMapping)(unsafe.Pointer(p1)).Fencoding_id = v7
				v6 = v7
				(*TFcNameMapping)(unsafe.Pointer(p1)).Fname_id = v6
				(*TFcNameMapping)(unsafe.Pointer(p1)).Fplatform_id = v6
			}
			goto _5
		_5:
			;
			i3++
		}
		libc.Xqsort(tls, name_mapping, libc.Uint64FromInt32(name_count), uint64(20), __ccgo_fp(_name_mapping_cmp))
		if nm_share != 0 {
			*(*uintptr)(unsafe.Pointer(nm_share)) = name_mapping
		}
	}
	p = uint32(0)
	for {
		if !(uint64(p) < libc.Uint64FromInt64(8)/libc.Uint64FromInt64(2)) {
			break
		}
		platform = libc.Int32FromUint16(_platform_order[p])
		/*
		 * Order nameids so preferred names appear first
		 * in the resulting list
		 */
		n = uint32(0)
		for {
			if !(uint64(n) < libc.Uint64FromInt64(20)/libc.Uint64FromInt64(2)) {
				break
			}
			np = uintptr(0)
			nlangp = uintptr(0)
			obj1 = int32(_FC_INVALID_OBJECT)
			objlang = int32(_FC_INVALID_OBJECT)
			v12 = libc.Int32FromUint16(_nameid_order[n])
			lookupid = v12
			nameid = v12
			if instance != 0 {
				/* For named-instances, we skip regular style nameIDs,
				 * and treat the instance's nameid as FONT_SUBFAMILY.
				 * Postscript name is automatically handled by FreeType. */
				if nameid == int32(m_TT_NAME_ID_WWS_SUBFAMILY) || nameid == int32(m_TT_NAME_ID_TYPOGRAPHIC_SUBFAMILY) || nameid == int32(m_TT_NAME_ID_FULL_NAME) {
					goto _11
				}
				if nameid == int32(m_TT_NAME_ID_FONT_SUBFAMILY) {
					lookupid = libc.Int32FromUint32((*TFT_Var_Named_Style)(unsafe.Pointer(instance)).Fstrid)
				}
			}
			nameidx = _FcFreeTypeGetFirstName(tls, face, libc.Uint32FromInt32(platform), libc.Uint32FromInt32(lookupid), name_mapping, libc.Uint32FromInt32(name_count), bp+64)
			if nameidx == -int32(1) {
				goto _11
			}
			for {
				switch nameid {
				case int32(m_TT_NAME_ID_WWS_FAMILY):
					fallthrough
				case int32(m_TT_NAME_ID_TYPOGRAPHIC_FAMILY):
					fallthrough
				case int32(m_TT_NAME_ID_FONT_FAMILY):
					if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
						libc.Xprintf(tls, __ccgo_ts+4220, libc.VaList(bp+544, libc.Int32FromUint16((*(*TFT_SfntName)(unsafe.Pointer(bp + 64))).Fname_id), libc.Int32FromUint16((*(*TFT_SfntName)(unsafe.Pointer(bp + 64))).Fplatform_id), libc.Int32FromUint16((*(*TFT_SfntName)(unsafe.Pointer(bp + 64))).Fencoding_id), libc.Int32FromUint16((*(*TFT_SfntName)(unsafe.Pointer(bp + 64))).Flanguage_id)))
					}
					obj1 = int32(_FC_FAMILY_OBJECT)
					objlang = int32(_FC_FAMILYLANG_OBJECT)
					np = bp + 8
					nlangp = bp + 12
				case int32(m_TT_NAME_ID_MAC_FULL_NAME):
					fallthrough
				case int32(m_TT_NAME_ID_FULL_NAME):
					if variable != 0 {
						break
					}
					if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
						libc.Xprintf(tls, __ccgo_ts+4260, libc.VaList(bp+544, libc.Int32FromUint16((*(*TFT_SfntName)(unsafe.Pointer(bp + 64))).Fname_id), libc.Int32FromUint16((*(*TFT_SfntName)(unsafe.Pointer(bp + 64))).Fplatform_id), libc.Int32FromUint16((*(*TFT_SfntName)(unsafe.Pointer(bp + 64))).Fencoding_id), libc.Int32FromUint16((*(*TFT_SfntName)(unsafe.Pointer(bp + 64))).Flanguage_id)))
					}
					obj1 = int32(_FC_FULLNAME_OBJECT)
					objlang = int32(_FC_FULLNAMELANG_OBJECT)
					np = bp + 24
					nlangp = bp + 28
				case int32(m_TT_NAME_ID_WWS_SUBFAMILY):
					fallthrough
				case int32(m_TT_NAME_ID_TYPOGRAPHIC_SUBFAMILY):
					fallthrough
				case int32(m_TT_NAME_ID_FONT_SUBFAMILY):
					if variable != 0 {
						break
					}
					if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
						libc.Xprintf(tls, __ccgo_ts+4300, libc.VaList(bp+544, libc.Int32FromUint16((*(*TFT_SfntName)(unsafe.Pointer(bp + 64))).Fname_id), libc.Int32FromUint16((*(*TFT_SfntName)(unsafe.Pointer(bp + 64))).Fplatform_id), libc.Int32FromUint16((*(*TFT_SfntName)(unsafe.Pointer(bp + 64))).Fencoding_id), libc.Int32FromUint16((*(*TFT_SfntName)(unsafe.Pointer(bp + 64))).Flanguage_id)))
					}
					obj1 = int32(_FC_STYLE_OBJECT)
					objlang = int32(_FC_STYLELANG_OBJECT)
					np = bp + 16
					nlangp = bp + 20
				case int32(m_TT_NAME_ID_TRADEMARK):
					fallthrough
				case int32(m_TT_NAME_ID_MANUFACTURER):
					/* If the foundry wasn't found in the OS/2 table, look here */
					if !(foundry != 0) {
						utf8 = _FcSfntNameTranscode(tls, bp+64)
						foundry = _FcNoticeFoundry(tls, utf8)
						libc.Xfree(tls, utf8)
					}
					break
				}
				if obj1 != int32(_FC_INVALID_OBJECT) {
					utf81 = _FcSfntNameTranscode(tls, bp+64)
					lang = _FcSfntNameLanguage(tls, bp+64)
					if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
						if utf81 != 0 {
							v15 = utf81
						} else {
							v15 = __ccgo_ts + 4341
						}
						libc.Xprintf(tls, __ccgo_ts+4348, libc.VaList(bp+544, v15))
					}
					if !(utf81 != 0) {
						goto _14
					}
					/* Trim surrounding whitespace. */
					pp = utf81
					for libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(pp))) == int32(' ') {
						pp++
					}
					len1 = libc.Xstrlen(tls, pp)
					libc.X__builtin___memmove_chk(tls, utf81, pp, len1+uint64(1), ^t__predefined_size_t(0))
					pp = utf81 + uintptr(len1)
					for pp > utf81 && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(pp - libc.UintptrFromInt32(1)))) == int32(' ') {
						pp--
					}
					*(*TFcChar8)(unsafe.Pointer(pp)) = uint8(0)
					if _FcStringInPatternElement(tls, pat, obj1, utf81) != 0 {
						libc.Xfree(tls, utf81)
						goto _14
					}
					/* add new element */
					if !(XFcPatternObjectAddString(tls, pat, obj1, utf81) != 0) {
						libc.Xfree(tls, utf81)
						goto bail1
					}
					libc.Xfree(tls, utf81)
					if lang != 0 {
						/* pad lang list with 'und' to line up with elt */
						for *(*int32)(unsafe.Pointer(nlangp)) < *(*int32)(unsafe.Pointer(np)) {
							if !(XFcPatternObjectAddString(tls, pat, objlang, __ccgo_ts+1348) != 0) {
								goto bail1
							}
							*(*int32)(unsafe.Pointer(nlangp))++
						}
						if !(XFcPatternObjectAddString(tls, pat, objlang, lang) != 0) {
							goto bail1
						}
						*(*int32)(unsafe.Pointer(nlangp))++
					}
					*(*int32)(unsafe.Pointer(np))++
				}
				goto _14
			_14:
				;
				nameidx++
				v13 = nameidx
				if !(v13 < name_count && libfreetype.XFT_Get_Sfnt_Name(tls, face, (*(*TFcNameMapping)(unsafe.Pointer(name_mapping + uintptr(nameidx)*20))).Fidx, bp+64) == 0 && platform == libc.Int32FromUint16((*(*TFT_SfntName)(unsafe.Pointer(bp + 64))).Fplatform_id) && lookupid == libc.Int32FromUint16((*(*TFT_SfntName)(unsafe.Pointer(bp + 64))).Fname_id)) {
					break
				}
			}
			goto _11
		_11:
			;
			n++
		}
		goto _10
	_10:
		;
		p++
	}
	if !(nm_share != 0) {
		libc.Xfree(tls, name_mapping)
		name_mapping = libc.UintptrFromInt32(0)
	}
	if !(*(*int32)(unsafe.Pointer(bp + 8)) != 0) && (*TFT_FaceRec_)(unsafe.Pointer(face)).Ffamily_name != 0 && XFcStrCmpIgnoreBlanksAndCase(tls, (*TFT_FaceRec_)(unsafe.Pointer(face)).Ffamily_name, __ccgo_ts+110) != 0 {
		if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
			libc.Xprintf(tls, __ccgo_ts+4352, libc.VaList(bp+544, (*TFT_FaceRec_)(unsafe.Pointer(face)).Ffamily_name))
		}
		if !(XFcPatternObjectAddString(tls, pat, int32(_FC_FAMILY_OBJECT), (*TFT_FaceRec_)(unsafe.Pointer(face)).Ffamily_name) != 0) {
			goto bail1
		}
		if !(XFcPatternObjectAddString(tls, pat, int32(_FC_FAMILYLANG_OBJECT), __ccgo_ts+2752) != 0) {
			goto bail1
		}
		*(*int32)(unsafe.Pointer(bp + 8))++
	}
	if !(variable != 0) && !(*(*int32)(unsafe.Pointer(bp + 16)) != 0) {
		style_regular = __ccgo_ts + 4380
		if (*TFT_FaceRec_)(unsafe.Pointer(face)).Fstyle_name != 0 && XFcStrCmpIgnoreBlanksAndCase(tls, (*TFT_FaceRec_)(unsafe.Pointer(face)).Fstyle_name, __ccgo_ts+110) != 0 {
			if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
				libc.Xprintf(tls, __ccgo_ts+4388, libc.VaList(bp+544, (*TFT_FaceRec_)(unsafe.Pointer(face)).Fstyle_name))
			}
			ss = (*TFT_FaceRec_)(unsafe.Pointer(face)).Fstyle_name
		} else {
			if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
				libc.Xprintf(tls, __ccgo_ts+4415, 0)
			}
			ss = style_regular
		}
		if !(XFcPatternObjectAddString(tls, pat, int32(_FC_STYLE_OBJECT), ss) != 0) {
			goto bail1
		}
		if !(XFcPatternObjectAddString(tls, pat, int32(_FC_STYLELANG_OBJECT), __ccgo_ts+2752) != 0) {
			goto bail1
		}
		*(*int32)(unsafe.Pointer(bp + 16))++
	}
	if !(*(*int32)(unsafe.Pointer(bp + 8)) != 0) && file != 0 && *(*TFcChar8)(unsafe.Pointer(file)) != 0 {
		start = libc.Xstrrchr(tls, file, int32('/'))
		if start != 0 {
			start++
		} else {
			start = file
		}
		end = libc.Xstrrchr(tls, start, int32('.'))
		if !(end != 0) {
			end = start + uintptr(libc.Xstrlen(tls, start))
		}
		/* freed below */
		family = libc.Xmalloc(tls, libc.Uint64FromInt64(int64(end)-int64(start)+int64(1)))
		libc.X__builtin___strncpy_chk(tls, family, start, libc.Uint64FromInt64(int64(end)-int64(start)), ^t__predefined_size_t(0))
		*(*TFcChar8)(unsafe.Pointer(family + uintptr(int64(end)-int64(start)))) = uint8('\000')
		if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
			libc.Xprintf(tls, __ccgo_ts+4447, libc.VaList(bp+544, family))
		}
		if !(XFcPatternObjectAddString(tls, pat, int32(_FC_FAMILY_OBJECT), family) != 0) {
			libc.Xfree(tls, family)
			goto bail1
		}
		if !(XFcPatternObjectAddString(tls, pat, int32(_FC_FAMILYLANG_OBJECT), __ccgo_ts+2752) != 0) {
			libc.Xfree(tls, family)
			goto bail1
		}
		libc.Xfree(tls, family)
		*(*int32)(unsafe.Pointer(bp + 8))++
	}
	/* Add the fullname into the cache */
	if !(variable != 0) && !(*(*int32)(unsafe.Pointer(bp + 24)) != 0) {
		*(*uintptr)(unsafe.Pointer(bp + 104)) = libc.UintptrFromInt32(0)
		n1 = 0
		for XFcPatternObjectGetString(tls, pat, int32(_FC_FAMILYLANG_OBJECT), n1, bp+104) == int32(_FcResultMatch) {
			if XFcStrCmp(tls, *(*uintptr)(unsafe.Pointer(bp + 104)), __ccgo_ts+2752) == 0 {
				break
			}
			n1++
			*(*uintptr)(unsafe.Pointer(bp + 104)) = libc.UintptrFromInt32(0)
		}
		if !(*(*uintptr)(unsafe.Pointer(bp + 104)) != 0) {
			n1 = 0
		}
		if XFcPatternObjectGetString(tls, pat, int32(_FC_FAMILY_OBJECT), n1, bp+88) != int32(_FcResultMatch) {
			goto bail1
		}
		len11 = libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 88)))
		i4 = len11
		for {
			if !(i4 > uint64(0)) {
				break
			}
			v19 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)) + uintptr(i4-uint64(1)))))
			v20 = uint64(0x00004000)
			v24 = libc.BoolInt32(v19 & ^libc.Int32FromInt32(0x7F) == 0)
			goto _25
		_25:
			if v24 != 0 {
				v23 = libc.BoolInt32(!!(uint64(*(*t__uint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&libc.X_DefaultRuneLocale)) + 60 + uintptr(v19)*4)))&v20 != 0))
			} else {
				v23 = libc.BoolInt32(!!(libc.X__maskrune(tls, v19, v20) != 0))
			}
			v21 = v23
			goto _22
		_22:
			v17 = v21
			goto _18
		_18:
			if !(v17 != 0) {
				break
			}
			goto _16
		_16:
			;
			i4--
		}
		*(*TFcChar8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)) + uintptr(i4))) = uint8(0)
		n1 = 0
		for XFcPatternObjectGetString(tls, pat, int32(_FC_STYLELANG_OBJECT), n1, bp+104) == int32(_FcResultMatch) {
			if XFcStrCmp(tls, *(*uintptr)(unsafe.Pointer(bp + 104)), __ccgo_ts+2752) == 0 {
				break
			}
			n1++
			*(*uintptr)(unsafe.Pointer(bp + 104)) = libc.UintptrFromInt32(0)
		}
		if !(*(*uintptr)(unsafe.Pointer(bp + 104)) != 0) {
			n1 = 0
		}
		if XFcPatternObjectGetString(tls, pat, int32(_FC_STYLE_OBJECT), n1, bp+96) != int32(_FcResultMatch) {
			goto bail1
		}
		len11 = libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 96)))
		i4 = uint64(0)
		for {
			if v36 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + uintptr(i4)))) != 0; v36 {
				v29 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + uintptr(i4))))
				v30 = uint64(0x00004000)
				v34 = libc.BoolInt32(v29 & ^libc.Int32FromInt32(0x7F) == 0)
				goto _35
			_35:
				if v34 != 0 {
					v33 = libc.BoolInt32(!!(uint64(*(*t__uint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&libc.X_DefaultRuneLocale)) + 60 + uintptr(v29)*4)))&v30 != 0))
				} else {
					v33 = libc.BoolInt32(!!(libc.X__maskrune(tls, v29, v30) != 0))
				}
				v31 = v33
				goto _32
			_32:
				v27 = v31
				goto _28
			_28:
			}
			if !(v36 && v27 != 0) {
				break
			}
			goto _26
		_26:
			;
			i4++
		}
		libc.X__builtin___memcpy_chk(tls, *(*uintptr)(unsafe.Pointer(bp + 96)), *(*uintptr)(unsafe.Pointer(bp + 96))+uintptr(i4), len11-i4, ^t__predefined_size_t(0))
		XFcStrBufInit(tls, bp+112, libc.UintptrFromInt32(0), 0)
		XFcStrBufString(tls, bp+112, *(*uintptr)(unsafe.Pointer(bp + 88)))
		XFcStrBufChar(tls, bp+112, uint8(' '))
		XFcStrBufString(tls, bp+112, *(*uintptr)(unsafe.Pointer(bp + 96)))
		if !(XFcPatternObjectAddString(tls, pat, int32(_FC_FULLNAME_OBJECT), XFcStrBufDoneStatic(tls, bp+112)) != 0) {
			XFcStrBufDestroy(tls, bp+112)
			goto bail1
		}
		XFcStrBufDestroy(tls, bp+112)
		if !(XFcPatternObjectAddString(tls, pat, int32(_FC_FULLNAMELANG_OBJECT), __ccgo_ts+2752) != 0) {
			goto bail1
		}
		*(*int32)(unsafe.Pointer(bp + 24))++
	}
	/* Add the PostScript name into the cache */
	if !(variable != 0) {
		tmp = libfreetype.XFT_Get_Postscript_Name(tls, face)
		if !(tmp != 0) {
			*(*uintptr)(unsafe.Pointer(bp + 528)) = libc.UintptrFromInt32(0)
			n2 = 0
			/* Workaround when FT_Get_Postscript_Name didn't give any name.
			 * try to find out the English family name and convert.
			 */
			for XFcPatternObjectGetString(tls, pat, int32(_FC_FAMILYLANG_OBJECT), n2, bp+528) == int32(_FcResultMatch) {
				if XFcStrCmp(tls, *(*uintptr)(unsafe.Pointer(bp + 528)), __ccgo_ts+2752) == 0 {
					break
				}
				n2++
				*(*uintptr)(unsafe.Pointer(bp + 528)) = libc.UintptrFromInt32(0)
			}
			if !(*(*uintptr)(unsafe.Pointer(bp + 528)) != 0) {
				n2 = 0
			}
			if XFcPatternObjectGetString(tls, pat, int32(_FC_FAMILY_OBJECT), n2, bp+520) != int32(_FcResultMatch) {
				goto bail1
			}
			len2 = libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 520)))
			/* the literal name in PostScript Language is limited to 127 characters though,
			 * It is the architectural limit. so assuming 255 characters may works enough.
			 */
			i5 = uint32(0)
			for {
				if !(uint64(i5) < len2 && i5 < uint32(255)) {
					break
				}
				if libc.Xstrchr(tls, uintptr(unsafe.Pointer(&_exclusive_chars)), libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 520)) + uintptr(i5))))) != libc.UintptrFromInt32(0) {
					(*(*[256]int8)(unsafe.Pointer(bp + 264)))[i5] = int8('-')
				} else {
					(*(*[256]int8)(unsafe.Pointer(bp + 264)))[i5] = libc.Int8FromUint8(*(*TFcChar8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 520)) + uintptr(i5))))
				}
				goto _37
			_37:
				;
				i5++
			}
			(*(*[256]int8)(unsafe.Pointer(bp + 264)))[i5] = 0
		} else {
			libc.X__builtin___strncpy_chk(tls, bp+264, tmp, uint64(255), ^t__predefined_size_t(0))
			(*(*[256]int8)(unsafe.Pointer(bp + 264)))[int32(255)] = 0
		}
		if !(XFcPatternObjectAddString(tls, pat, int32(_FC_POSTSCRIPT_NAME_OBJECT), bp+264) != 0) {
			goto bail1
		}
	}
	if file != 0 && *(*TFcChar8)(unsafe.Pointer(file)) != 0 && !(XFcPatternObjectAddString(tls, pat, int32(_FC_FILE_OBJECT), file) != 0) {
		goto bail1
	}
	if !(XFcPatternObjectAddInteger(tls, pat, int32(_FC_INDEX_OBJECT), libc.Int32FromUint32(id)) != 0) {
		goto bail1
	}
	/*
	 * Find the font revision (if available)
	 */
	head = libfreetype.XFT_Get_Sfnt_Table(tls, face, int32(_FT_SFNT_HEAD))
	if head != 0 {
		if !(XFcPatternObjectAddInteger(tls, pat, int32(_FC_FONTVERSION_OBJECT), int32((*TTT_Header)(unsafe.Pointer(head)).FFont_Revision)) != 0) {
			goto bail1
		}
	} else {
		if !(XFcPatternObjectAddInteger(tls, pat, int32(_FC_FONTVERSION_OBJECT), 0) != 0) {
			goto bail1
		}
	}
	if !(XFcPatternObjectAddInteger(tls, pat, int32(_FC_ORDER_OBJECT), 0) != 0) {
		goto bail1
	}
	if os2 != 0 && libc.Int32FromUint16((*TTT_OS2)(unsafe.Pointer(os2)).Fversion) >= int32(0x0001) && libc.Int32FromUint16((*TTT_OS2)(unsafe.Pointer(os2)).Fversion) != int32(0xffff) {
		i6 = uint32(0)
		for {
			if !(i6 < libc.Uint32FromInt32(libc.Int32FromUint64(libc.Uint64FromInt64(28)/libc.Uint64FromInt64(7)))) {
				break
			}
			if int32(_FcCodePageRange[i6].Fbit) < int32(32) {
				bits = (*TTT_OS2)(unsafe.Pointer(os2)).FulCodePageRange1
				bit = int32(_FcCodePageRange[i6].Fbit)
			} else {
				bits = (*TTT_OS2)(unsafe.Pointer(os2)).FulCodePageRange2
				bit = int32(_FcCodePageRange[i6].Fbit) - int32(32)
			}
			if bits&uint64(libc.Uint32FromUint32(1)<<bit) != 0 {
				/*
				 * If the font advertises support for multiple
				 * "exclusive" languages, then include support
				 * for any language found to have coverage
				 */
				if exclusiveLang != 0 {
					exclusiveLang = uintptr(0)
					break
				}
				exclusiveLang = uintptr(unsafe.Pointer(&_FcCodePageRange)) + uintptr(i6)*7 + 1
			}
			goto _38
		_38:
			;
			i6++
		}
	}
	if os2 != 0 && libc.Int32FromUint16((*TTT_OS2)(unsafe.Pointer(os2)).Fversion) != int32(0xffff) {
		weight = float64((*TTT_OS2)(unsafe.Pointer(os2)).FusWeightClass)
		weight = XFcWeightFromOpenTypeDouble(tls, float64(weight*weight_mult))
		if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 && weight != float64(-libc.Int32FromInt32(1)) {
			libc.Xprintf(tls, __ccgo_ts+4477, libc.VaList(bp+544, libc.Int32FromUint16((*TTT_OS2)(unsafe.Pointer(os2)).FusWeightClass), weight_mult, weight))
		}
		switch libc.Int32FromUint16((*TTT_OS2)(unsafe.Pointer(os2)).FusWidthClass) {
		case int32(1):
			width = libc.Float64FromInt32(m_FC_WIDTH_ULTRACONDENSED)
		case int32(2):
			width = libc.Float64FromInt32(m_FC_WIDTH_EXTRACONDENSED)
		case int32(3):
			width = libc.Float64FromInt32(m_FC_WIDTH_CONDENSED)
		case int32(4):
			width = libc.Float64FromInt32(m_FC_WIDTH_SEMICONDENSED)
		case int32(5):
			width = libc.Float64FromInt32(m_FC_WIDTH_NORMAL)
		case int32(6):
			width = libc.Float64FromInt32(m_FC_WIDTH_SEMIEXPANDED)
		case int32(7):
			width = libc.Float64FromInt32(m_FC_WIDTH_EXPANDED)
		case int32(8):
			width = libc.Float64FromInt32(m_FC_WIDTH_EXTRAEXPANDED)
		case int32(9):
			width = libc.Float64FromInt32(m_FC_WIDTH_ULTRAEXPANDED)
			break
		}
		width *= width_mult
		if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 && width != float64(-libc.Int32FromInt32(1)) {
			libc.Xprintf(tls, __ccgo_ts+4531, libc.VaList(bp+544, libc.Int32FromUint16((*TTT_OS2)(unsafe.Pointer(os2)).FusWidthClass), width_mult, width))
		}
	}
	if v40 = os2 != 0; v40 {
		v39 = _FcFontCapabilities(tls, face)
		complex_ = v39
	}
	if v40 && v39 != 0 {
		if !(XFcPatternObjectAddString(tls, pat, int32(_FC_CAPABILITY_OBJECT), complex_) != 0) {
			libc.Xfree(tls, complex_)
			goto bail1
		}
		libc.Xfree(tls, complex_)
	}
	if !(XFcPatternObjectAddBool(tls, pat, int32(_FC_FONT_HAS_HINT_OBJECT), _FcFontHasHint(tls, face)) != 0) {
		goto bail1
	}
	if !(variable_size != 0) && os2 != 0 && libc.Int32FromUint16((*TTT_OS2)(unsafe.Pointer(os2)).Fversion) >= int32(0x0005) && libc.Int32FromUint16((*TTT_OS2)(unsafe.Pointer(os2)).Fversion) != int32(0xffff) {
		/* usLowerPointSize and usUpperPointSize is actually twips */
		lower_size = float64(float64((*TTT_OS2)(unsafe.Pointer(os2)).FusLowerOpticalPointSize) / libc.Float64FromFloat64(20))
		upper_size = float64(float64((*TTT_OS2)(unsafe.Pointer(os2)).FusUpperOpticalPointSize) / libc.Float64FromFloat64(20))
		if lower_size == upper_size {
			if !(XFcPatternObjectAddDouble(tls, pat, int32(_FC_SIZE_OBJECT), lower_size) != 0) {
				goto bail1
			}
		} else {
			r1 = XFcRangeCreateDouble(tls, lower_size, upper_size)
			if !(XFcPatternObjectAddRange(tls, pat, int32(_FC_SIZE_OBJECT), r1) != 0) {
				XFcRangeDestroy(tls, r1)
				goto bail1
			}
			XFcRangeDestroy(tls, r1)
		}
	}
	/*
	 * Type 1: Check for FontInfo dictionary information
	 * Code from g2@magestudios.net (Gerard Escalante)
	 */
	/*
	 * Look for weight, width and slant names in the style value
	 */
	st = 0
	for {
		if !(XFcPatternGetString(tls, pat, __ccgo_ts+4583, st, bp+32) == int32(_FcResultMatch)) {
			break
		}
		if weight == float64(-libc.Int32FromInt32(1)) {
			weight = float64(_FcStringContainsConst(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), uintptr(unsafe.Pointer(&_weightConsts)), libc.Int32FromUint64(libc.Uint64FromInt64(368)/libc.Uint64FromInt64(16))))
			if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
				libc.Xprintf(tls, __ccgo_ts+4589, libc.VaList(bp+544, *(*uintptr)(unsafe.Pointer(bp + 32)), weight))
			}
		}
		if width == float64(-libc.Int32FromInt32(1)) {
			width = float64(_FcStringContainsConst(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), uintptr(unsafe.Pointer(&_widthConsts)), libc.Int32FromUint64(libc.Uint64FromInt64(160)/libc.Uint64FromInt64(16))))
			if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
				libc.Xprintf(tls, __ccgo_ts+4618, libc.VaList(bp+544, *(*uintptr)(unsafe.Pointer(bp + 32)), width))
			}
		}
		if slant == -int32(1) {
			slant = _FcStringContainsConst(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), uintptr(unsafe.Pointer(&_slantConsts)), libc.Int32FromUint64(libc.Uint64FromInt64(48)/libc.Uint64FromInt64(16)))
			if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
				libc.Xprintf(tls, __ccgo_ts+4646, libc.VaList(bp+544, *(*uintptr)(unsafe.Pointer(bp + 32)), slant))
			}
		}
		if decorative == m_FcFalse {
			decorative = libc.BoolInt32(_FcStringContainsConst(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), uintptr(unsafe.Pointer(&_decorativeConsts)), libc.Int32FromUint64(libc.Uint64FromInt64(96)/libc.Uint64FromInt64(16))) > 0)
			if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
				libc.Xprintf(tls, __ccgo_ts+4674, libc.VaList(bp+544, *(*uintptr)(unsafe.Pointer(bp + 32)), decorative))
			}
		}
		goto _41
	_41:
		;
		st++
	}
	/*
	 * Pull default values from the FreeType flags if more
	 * specific values not found above
	 */
	if slant == -int32(1) {
		slant = m_FC_SLANT_ROMAN
		if (*TFT_FaceRec_)(unsafe.Pointer(face)).Fstyle_flags&int64(libc.Int32FromInt32(1)<<libc.Int32FromInt32(0)) != 0 {
			slant = int32(m_FC_SLANT_ITALIC)
		}
	}
	if weight == float64(-libc.Int32FromInt32(1)) {
		weight = libc.Float64FromInt32(m_FC_WEIGHT_MEDIUM)
		if (*TFT_FaceRec_)(unsafe.Pointer(face)).Fstyle_flags&int64(libc.Int32FromInt32(1)<<libc.Int32FromInt32(1)) != 0 {
			weight = libc.Float64FromInt32(m_FC_WEIGHT_BOLD)
		}
	}
	if width == float64(-libc.Int32FromInt32(1)) {
		width = libc.Float64FromInt32(m_FC_WIDTH_NORMAL)
	}
	if foundry == uintptr(0) {
		foundry = __ccgo_ts + 4707
	}
	if !(XFcPatternObjectAddInteger(tls, pat, int32(_FC_SLANT_OBJECT), slant) != 0) {
		goto bail1
	}
	if !(variable_weight != 0) && !(XFcPatternObjectAddDouble(tls, pat, int32(_FC_WEIGHT_OBJECT), weight) != 0) {
		goto bail1
	}
	if !(variable_width != 0) && !(XFcPatternObjectAddDouble(tls, pat, int32(_FC_WIDTH_OBJECT), width) != 0) {
		goto bail1
	}
	if !(XFcPatternObjectAddString(tls, pat, int32(_FC_FOUNDRY_OBJECT), foundry) != 0) {
		goto bail1
	}
	if !(XFcPatternObjectAddBool(tls, pat, int32(_FC_DECORATIVE_OBJECT), decorative) != 0) {
		goto bail1
	}
	/*
	 * Compute the unicode coverage for the font
	 */
	if cs_share != 0 && *(*uintptr)(unsafe.Pointer(cs_share)) != 0 {
		cs = XFcCharSetCopy(tls, *(*uintptr)(unsafe.Pointer(cs_share)))
	} else {
		cs = XFcFreeTypeCharSet(tls, face, libc.UintptrFromInt32(0))
		if cs_share != 0 {
			*(*uintptr)(unsafe.Pointer(cs_share)) = XFcCharSetCopy(tls, cs)
		}
	}
	if !(cs != 0) {
		goto bail1
	}
	/* The FcFreeTypeCharSet() chose the encoding; test it for symbol. */
	symbol = libc.BoolInt32((*TFT_FaceRec_)(unsafe.Pointer(face)).Fcharmap != 0 && (*TFT_CharMapRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fcharmap)).Fencoding == int32(_FT_ENCODING_MS_SYMBOL))
	if !(XFcPatternObjectAddBool(tls, pat, int32(_FC_SYMBOL_OBJECT), symbol) != 0) {
		goto bail1
	}
	spacing = _FcFreeTypeSpacing(tls, face)
	/*
	 * Skip over PCF fonts that have no encoded characters; they're
	 * usually just Unicode fonts transcoded to some legacy encoding
	 * FT forces us to approximate whether a font is a PCF font
	 * or not by whether it has any BDF properties.  Try PIXEL_SIZE;
	 * I don't know how to get a list of BDF properties on the font. -PL
	 */
	if XFcCharSetCount(tls, cs) == uint32(0) {
	}
	if !(XFcPatternObjectAddCharSet(tls, pat, int32(_FC_CHARSET_OBJECT), cs) != 0) {
		goto bail2
	}
	if !(symbol != 0) {
		if ls_share != 0 && *(*uintptr)(unsafe.Pointer(ls_share)) != 0 {
			ls = XFcLangSetCopy(tls, *(*uintptr)(unsafe.Pointer(ls_share)))
		} else {
			ls = XFcFreeTypeLangSet(tls, cs, exclusiveLang)
			if ls_share != 0 {
				*(*uintptr)(unsafe.Pointer(ls_share)) = XFcLangSetCopy(tls, ls)
			}
		}
		if !(ls != 0) {
			goto bail2
		}
	} else {
		/* Symbol fonts don't cover any language, even though they
		 * claim to support Latin1 range. */
		ls = XFcLangSetCreate(tls)
	}
	if !(XFcPatternObjectAddLangSet(tls, pat, int32(_FC_LANG_OBJECT), ls) != 0) {
		XFcLangSetDestroy(tls, ls)
		goto bail2
	}
	XFcLangSetDestroy(tls, ls)
	if spacing != m_FC_PROPORTIONAL {
		if !(XFcPatternObjectAddInteger(tls, pat, int32(_FC_SPACING_OBJECT), spacing) != 0) {
			goto bail2
		}
	}
	if !((*TFT_FaceRec_)(unsafe.Pointer(face)).Fface_flags&(libc.Int64FromInt64(1)<<libc.Int32FromInt32(0)) != 0) {
		i7 = 0
		for {
			if !(i7 < (*TFT_FaceRec_)(unsafe.Pointer(face)).Fnum_fixed_sizes) {
				break
			}
			if !(XFcPatternObjectAddDouble(tls, pat, int32(_FC_PIXEL_SIZE_OBJECT), _FcGetPixelSize(tls, face, i7)) != 0) {
				goto bail2
			}
			goto _42
		_42:
			;
			i7++
		}
		if !(XFcPatternObjectAddBool(tls, pat, int32(_FC_ANTIALIAS_OBJECT), m_FcFalse) != 0) {
			goto bail2
		}
	}
	/*
	 * Drop our reference to the charset
	 */
	XFcCharSetDestroy(tls, cs)
	if foundry_ != 0 {
		libc.Xfree(tls, foundry_)
	}
	if *(*uintptr)(unsafe.Pointer(bp)) != 0 {
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp)))
	}
	return pat
	goto bail2
bail2:
	;
	XFcCharSetDestroy(tls, cs)
	goto bail1
bail1:
	;
	XFcPatternDestroy(tls, pat)
	if *(*uintptr)(unsafe.Pointer(bp)) != 0 {
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp)))
	}
	if !(nm_share != 0) && name_mapping != 0 {
		libc.Xfree(tls, name_mapping)
	}
	if foundry_ != 0 {
		libc.Xfree(tls, foundry_)
	}
	goto bail0
bail0:
	;
	return libc.UintptrFromInt32(0)
	return r2
}

/* those characters are not allowed to be the literal name in PostScript */
var _exclusive_chars = [16]int8{4, '(', ')', '/', '<', '>', '[', ']', '{', '}', 9, 12, 13, 10, ' '}

func XFcFreeTypeQueryFace(tls *libc.TLS, face TFT_Face, file uintptr, id uint32, blanks uintptr) (r uintptr) {
	return _FcFreeTypeQueryFaceInternal(tls, face, file, id, libc.UintptrFromInt32(0), libc.UintptrFromInt32(0), libc.UintptrFromInt32(0))
}

func XFcFreeTypeQuery(tls *libc.TLS, file uintptr, id uint32, blanks uintptr, count uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var pat uintptr
	var _ /* face at bp+0 */ TFT_Face
	var _ /* ftLibrary at bp+8 */ TFT_Library
	_ = pat
	pat = libc.UintptrFromInt32(0)
	if libfreetype.XFT_Init_FreeType(tls, bp+8) != 0 {
		return libc.UintptrFromInt32(0)
	}
	if libfreetype.XFT_New_Face(tls, *(*TFT_Library)(unsafe.Pointer(bp + 8)), file, libc.Int64FromUint32(id&uint32(0x7FFFFFFF)), bp) != 0 {
		goto bail
	}
	if count != 0 {
		*(*int32)(unsafe.Pointer(count)) = int32((*TFT_FaceRec_)(unsafe.Pointer(*(*TFT_Face)(unsafe.Pointer(bp)))).Fnum_faces)
	}
	pat = _FcFreeTypeQueryFaceInternal(tls, *(*TFT_Face)(unsafe.Pointer(bp)), file, id, libc.UintptrFromInt32(0), libc.UintptrFromInt32(0), libc.UintptrFromInt32(0))
	libfreetype.XFT_Done_Face(tls, *(*TFT_Face)(unsafe.Pointer(bp)))
	goto bail
bail:
	;
	libfreetype.XFT_Done_FreeType(tls, *(*TFT_Library)(unsafe.Pointer(bp + 8)))
	return pat
}

func XFcFreeTypeQueryAll(tls *libc.TLS, file uintptr, id uint32, blanks uintptr, count uintptr, set uintptr) (r uint32) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var coords, instance, pat uintptr
	var err int32
	var face_num, i, instance_num, num_faces, num_instances, ret, set_face_num, set_instance_num, v1, v2 uint32
	var index_set, nonzero TFcBool
	var _ /* cs at bp+16 */ uintptr
	var _ /* face at bp+0 */ TFT_Face
	var _ /* ftLibrary at bp+8 */ TFT_Library
	var _ /* ls at bp+24 */ uintptr
	var _ /* mm_var at bp+40 */ uintptr
	var _ /* nm at bp+32 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = coords, err, face_num, i, index_set, instance, instance_num, nonzero, num_faces, num_instances, pat, ret, set_face_num, set_instance_num, v1, v2
	*(*TFT_Face)(unsafe.Pointer(bp)) = libc.UintptrFromInt32(0)
	*(*TFT_Library)(unsafe.Pointer(bp + 8)) = libc.UintptrFromInt32(0)
	*(*uintptr)(unsafe.Pointer(bp + 16)) = libc.UintptrFromInt32(0)
	*(*uintptr)(unsafe.Pointer(bp + 24)) = libc.UintptrFromInt32(0)
	*(*uintptr)(unsafe.Pointer(bp + 32)) = libc.UintptrFromInt32(0)
	*(*uintptr)(unsafe.Pointer(bp + 40)) = libc.UintptrFromInt32(0)
	index_set = libc.BoolInt32(id != libc.Uint32FromInt32(-libc.Int32FromInt32(1)))
	if index_set != 0 {
		v1 = id & uint32(0xFFFF)
	} else {
		v1 = uint32(0)
	}
	set_face_num = v1
	if index_set != 0 {
		v2 = id >> int32(16)
	} else {
		v2 = uint32(0)
	}
	set_instance_num = v2
	face_num = set_face_num
	instance_num = set_instance_num
	num_faces = uint32(0)
	num_instances = uint32(0)
	ret = uint32(0)
	err = 0
	if count != 0 {
		*(*int32)(unsafe.Pointer(count)) = 0
	}
	if libfreetype.XFT_Init_FreeType(tls, bp+8) != 0 {
		return uint32(0)
	}
	if libfreetype.XFT_New_Face(tls, *(*TFT_Library)(unsafe.Pointer(bp + 8)), file, libc.Int64FromUint32(face_num), bp) != 0 {
		goto bail
	}
	num_faces = libc.Uint32FromInt64((*TFT_FaceRec_)(unsafe.Pointer(*(*TFT_Face)(unsafe.Pointer(bp)))).Fnum_faces)
	num_instances = libc.Uint32FromInt64((*TFT_FaceRec_)(unsafe.Pointer(*(*TFT_Face)(unsafe.Pointer(bp)))).Fstyle_flags >> int32(16))
	if num_instances != 0 && (!(index_set != 0) || instance_num != 0) {
		libfreetype.XFT_Get_MM_Var(tls, *(*TFT_Face)(unsafe.Pointer(bp)), bp+40)
		if !(*(*uintptr)(unsafe.Pointer(bp + 40)) != 0) {
			num_instances = uint32(0)
		}
	}
	if count != 0 {
		*(*int32)(unsafe.Pointer(count)) = libc.Int32FromUint32(num_faces)
	}
	for cond := true; cond; cond = !(err != 0) && (!(index_set != 0) || face_num == set_face_num) && face_num < num_faces {
		pat = libc.UintptrFromInt32(0)
		if instance_num == uint32(0x8000) || instance_num > num_instances {
			libfreetype.XFT_Set_Var_Design_Coordinates(tls, *(*TFT_Face)(unsafe.Pointer(bp)), uint32(0), libc.UintptrFromInt32(0))
		} else {
			if instance_num != 0 {
				instance = (*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)))).Fnamedstyle + uintptr(instance_num-uint32(1))*16
				coords = (*TFT_Var_Named_Style)(unsafe.Pointer(instance)).Fcoords
				/* Skip named-instance that coincides with base instance. */
				nonzero = m_FcFalse
				i = uint32(0)
				for {
					if !(i < (*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)))).Fnum_axis) {
						break
					}
					if *(*TFT_Fixed)(unsafe.Pointer(coords + uintptr(i)*8)) != (*(*TFT_Var_Axis)(unsafe.Pointer((*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)))).Faxis + uintptr(i)*48))).Fdef {
						nonzero = int32(m_FcTrue)
						break
					}
					goto _3
				_3:
					;
					i++
				}
				if !(nonzero != 0) {
					goto skip
				}
				libfreetype.XFT_Set_Var_Design_Coordinates(tls, *(*TFT_Face)(unsafe.Pointer(bp)), (*TFT_MM_Var)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)))).Fnum_axis, coords)
			}
		}
		id = instance_num<<int32(16) + face_num
		pat = _FcFreeTypeQueryFaceInternal(tls, *(*TFT_Face)(unsafe.Pointer(bp)), file, id, bp+16, bp+24, bp+32)
		if pat != 0 {
			ret++
			if !(set != 0) || !(XFcFontSetAdd(tls, set, pat) != 0) {
				XFcPatternDestroy(tls, pat)
			}
		} else {
			if instance_num != uint32(0x8000) {
				err = int32(1)
			}
		}
		goto skip
	skip:
		;
		if !(index_set != 0) && instance_num < num_instances {
			instance_num++
		} else {
			if !(index_set != 0) && instance_num == num_instances {
				instance_num = uint32(0x8000)
			} else {
				libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
				*(*uintptr)(unsafe.Pointer(bp + 32)) = libc.UintptrFromInt32(0)
				XFcLangSetDestroy(tls, *(*uintptr)(unsafe.Pointer(bp + 24)))
				*(*uintptr)(unsafe.Pointer(bp + 24)) = libc.UintptrFromInt32(0)
				XFcCharSetDestroy(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
				*(*uintptr)(unsafe.Pointer(bp + 16)) = libc.UintptrFromInt32(0)
				libfreetype.XFT_Done_Face(tls, *(*TFT_Face)(unsafe.Pointer(bp)))
				*(*TFT_Face)(unsafe.Pointer(bp)) = libc.UintptrFromInt32(0)
				face_num++
				instance_num = set_instance_num
				if libfreetype.XFT_New_Face(tls, *(*TFT_Library)(unsafe.Pointer(bp + 8)), file, libc.Int64FromUint32(face_num), bp) != 0 {
					break
				}
			}
		}
	}
	goto bail
bail:
	;
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 40)))
	XFcLangSetDestroy(tls, *(*uintptr)(unsafe.Pointer(bp + 24)))
	XFcCharSetDestroy(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
	if *(*TFT_Face)(unsafe.Pointer(bp)) != 0 {
		libfreetype.XFT_Done_Face(tls, *(*TFT_Face)(unsafe.Pointer(bp)))
	}
	libfreetype.XFT_Done_FreeType(tls, *(*TFT_Library)(unsafe.Pointer(bp + 8)))
	if *(*uintptr)(unsafe.Pointer(bp + 32)) != 0 {
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	}
	return ret
}

var _fcFontEncodings = [2]TFT_Encoding{
	0: int32(_FT_ENCODING_UNICODE),
	1: int32(_FT_ENCODING_MS_SYMBOL),
}

/*
 * Map a UCS4 glyph to a glyph index.  Use all available encoding
 * tables to try and find one that works.  This information is expected
 * to be cached by higher levels, so performance isn't critical
 */

func XFcFreeTypeCharIndex(tls *libc.TLS, face TFT_Face, ucs4 TFcChar32) (r TFT_UInt) {
	var decode, initial, offset int32
	var glyphindex TFT_UInt
	_, _, _, _ = decode, glyphindex, initial, offset
	initial = 0
	if !(face != 0) {
		return uint32(0)
	}
	/*
	 * Find the current encoding
	 */
	if (*TFT_FaceRec_)(unsafe.Pointer(face)).Fcharmap != 0 {
		for {
			if !(initial < libc.Int32FromUint64(libc.Uint64FromInt64(8)/libc.Uint64FromInt64(4))) {
				break
			}
			if _fcFontEncodings[initial] == (*TFT_CharMapRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fcharmap)).Fencoding {
				break
			}
			goto _1
		_1:
			;
			initial++
		}
		if initial == libc.Int32FromUint64(libc.Uint64FromInt64(8)/libc.Uint64FromInt64(4)) {
			initial = 0
		}
	}
	/*
	 * Check each encoding for the glyph, starting with the current one
	 */
	offset = 0
	for {
		if !(offset < libc.Int32FromUint64(libc.Uint64FromInt64(8)/libc.Uint64FromInt64(4))) {
			break
		}
		decode = (initial + offset) % libc.Int32FromUint64(libc.Uint64FromInt64(8)/libc.Uint64FromInt64(4))
		if !((*TFT_FaceRec_)(unsafe.Pointer(face)).Fcharmap != 0) || (*TFT_CharMapRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fcharmap)).Fencoding != _fcFontEncodings[decode] {
			if libfreetype.XFT_Select_Charmap(tls, face, _fcFontEncodings[decode]) != 0 {
				goto _2
			}
		}
		glyphindex = libfreetype.XFT_Get_Char_Index(tls, face, uint64(ucs4))
		if glyphindex != 0 {
			return glyphindex
		}
		if ucs4 < uint32(0x100) && (*TFT_FaceRec_)(unsafe.Pointer(face)).Fcharmap != 0 && (*TFT_CharMapRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fcharmap)).Fencoding == int32(_FT_ENCODING_MS_SYMBOL) {
			/* For symbol-encoded OpenType fonts, we duplicate the
			 * U+F000..F0FF range at U+0000..U+00FF.  That's what
			 * Windows seems to do, and that's hinted about at:
			 * http://www.microsoft.com/typography/otspec/recom.htm
			 * under "Non-Standard (Symbol) Fonts".
			 *
			 * See thread with subject "Webdings and other MS symbol
			 * fonts don't display" on mailing list from May 2015.
			 */
			glyphindex = libfreetype.XFT_Get_Char_Index(tls, face, uint64(ucs4)+uint64(0xF000))
			if glyphindex != 0 {
				return glyphindex
			}
		}
		goto _2
	_2:
		;
		offset++
	}
	return uint32(0)
}

func _fc_min(tls *libc.TLS, a int32, b int32) (r int32) {
	var v1 int32
	_ = v1
	if a <= b {
		v1 = a
	} else {
		v1 = b
	}
	return v1
}

func _fc_max(tls *libc.TLS, a int32, b int32) (r int32) {
	var v1 int32
	_ = v1
	if a >= b {
		v1 = a
	} else {
		v1 = b
	}
	return v1
}

func _fc_approximately_equal(tls *libc.TLS, x int32, y int32) (r TFcBool) {
	return libc.BoolInt32(libc.Xabs(tls, x-y)*int32(33) <= _fc_max(tls, libc.Xabs(tls, x), libc.Xabs(tls, y)))
}

func _FcFreeTypeSpacing(tls *libc.TLS, face TFT_Face) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var advances [3]TFT_Pos
	var i, load_flags, strike_index TFT_Int
	var j, num_advances, v4 uint32
	var o int32
	var ucs4 TFcChar32
	var _ /* advance at bp+8 */ TFT_Pos
	var _ /* glyph at bp+0 */ TFT_UInt
	_, _, _, _, _, _, _, _, _ = advances, i, j, load_flags, num_advances, o, strike_index, ucs4, v4
	load_flags = int32(libc.Int64FromInt64(1)<<libc.Int32FromInt32(9) | libc.Int64FromInt64(1)<<libc.Int32FromInt32(0) | libc.Int64FromInt64(1)<<libc.Int32FromInt32(1))
	advances = [3]TFT_Pos{}
	num_advances = uint32(0)
	/* When using scalable fonts, only report those glyphs
	 * which can be scaled; otherwise those fonts will
	 * only be available at some sizes, and never when
	 * transformed.  Avoid this by simply reporting bitmap-only
	 * glyphs as missing
	 */
	if (*TFT_FaceRec_)(unsafe.Pointer(face)).Fface_flags&(libc.Int64FromInt64(1)<<libc.Int32FromInt32(0)) != 0 {
		load_flags = TFT_Int(int64(load_flags) | libc.Int64FromInt64(1)<<libc.Int32FromInt32(3))
	}
	if !((*TFT_FaceRec_)(unsafe.Pointer(face)).Fface_flags&(libc.Int64FromInt64(1)<<libc.Int32FromInt32(0)) != 0) && (*TFT_FaceRec_)(unsafe.Pointer(face)).Fnum_fixed_sizes > 0 && libfreetype.XFT_Get_Sfnt_Table(tls, face, int32(_FT_SFNT_HEAD)) != 0 {
		strike_index = 0
		/* Select the face closest to 16 pixels tall */
		i = int32(1)
		for {
			if !(i < (*TFT_FaceRec_)(unsafe.Pointer(face)).Fnum_fixed_sizes) {
				break
			}
			if libc.Xabs(tls, int32((*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(i)*32))).Fheight)-int32(16)) < libc.Xabs(tls, int32((*(*TFT_Bitmap_Size)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Favailable_sizes + uintptr(strike_index)*32))).Fheight)-int32(16)) {
				strike_index = i
			}
			goto _1
		_1:
			;
			i++
		}
		libfreetype.XFT_Select_Size(tls, face, strike_index)
	}
	o = 0
	for {
		if !(o < libc.Int32FromUint64(libc.Uint64FromInt64(8)/libc.Uint64FromInt64(4))) {
			break
		}
		if libfreetype.XFT_Select_Charmap(tls, face, _fcFontEncodings[o]) != 0 {
			goto _2
		}
		ucs4 = uint32(libfreetype.XFT_Get_First_Char(tls, face, bp))
		for *(*TFT_UInt)(unsafe.Pointer(bp)) != uint32(0) && num_advances < uint32(3) {
			*(*TFT_Pos)(unsafe.Pointer(bp + 8)) = 0
			if !(libfreetype.XFT_Get_Advance(tls, face, *(*TFT_UInt)(unsafe.Pointer(bp)), load_flags, bp+8) != 0) && *(*TFT_Pos)(unsafe.Pointer(bp + 8)) != 0 {
				j = uint32(0)
				for {
					if !(j < num_advances) {
						break
					}
					if _fc_approximately_equal(tls, int32(*(*TFT_Pos)(unsafe.Pointer(bp + 8))), int32(advances[j])) != 0 {
						break
					}
					goto _3
				_3:
					;
					j++
				}
				if j == num_advances {
					v4 = num_advances
					num_advances++
					advances[v4] = *(*TFT_Pos)(unsafe.Pointer(bp + 8))
				}
			}
			ucs4 = uint32(libfreetype.XFT_Get_Next_Char(tls, face, uint64(ucs4), bp))
		}
		break
		goto _2
	_2:
		;
		o++
	}
	if num_advances <= uint32(1) {
		return int32(m_FC_MONO)
	} else {
		if num_advances == uint32(2) && _fc_approximately_equal(tls, _fc_min(tls, int32(advances[0]), int32(advances[int32(1)]))*int32(2), _fc_max(tls, int32(advances[0]), int32(advances[int32(1)]))) != 0 {
			return int32(m_FC_DUAL)
		} else {
			return m_FC_PROPORTIONAL
		}
	}
	return r
}

func XFcFreeTypeCharSet(tls *libc.TLS, face TFT_Face, blanks uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var fcs, leaf uintptr
	var good TFcBool
	var load_flags TFT_Int
	var o int32
	var off, page, ucs4 TFcChar32
	var _ /* glyph at bp+0 */ TFT_UInt
	_, _, _, _, _, _, _, _ = fcs, good, leaf, load_flags, o, off, page, ucs4
	load_flags = int32(libc.Int64FromInt64(1)<<libc.Int32FromInt32(9) | libc.Int64FromInt64(1)<<libc.Int32FromInt32(0) | libc.Int64FromInt64(1)<<libc.Int32FromInt32(1))
	fcs = XFcCharSetCreate(tls)
	if !(fcs != 0) {
		goto bail
	}
	o = 0
	for {
		if !(o < libc.Int32FromUint64(libc.Uint64FromInt64(8)/libc.Uint64FromInt64(4))) {
			break
		}
		if libfreetype.XFT_Select_Charmap(tls, face, _fcFontEncodings[o]) != 0 {
			goto _1
		}
		page = libc.Uint32FromInt32(^libc.Int32FromInt32(0))
		leaf = libc.UintptrFromInt32(0)
		ucs4 = uint32(libfreetype.XFT_Get_First_Char(tls, face, bp))
		for *(*TFT_UInt)(unsafe.Pointer(bp)) != uint32(0) {
			good = int32(m_FcTrue)
			/* CID fonts built by Adobe used to make ASCII control chars to cid1
			 * (space glyph). As such, always check contour for those characters. */
			if ucs4 <= uint32(0x001F) {
				if libfreetype.XFT_Load_Glyph(tls, face, *(*TFT_UInt)(unsafe.Pointer(bp)), load_flags) != 0 || (*TFT_GlyphSlotRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fglyph)).Fformat == int32(_FT_GLYPH_FORMAT_OUTLINE) && int32((*TFT_GlyphSlotRec_)(unsafe.Pointer((*TFT_FaceRec_)(unsafe.Pointer(face)).Fglyph)).Foutline.Fn_contours) == 0 {
					good = m_FcFalse
				}
			}
			if good != 0 {
				XFcCharSetAddChar(tls, fcs, ucs4)
				if ucs4>>libc.Int32FromInt32(8) != page {
					page = ucs4 >> int32(8)
					leaf = XFcCharSetFindLeafCreate(tls, fcs, ucs4)
					if !(leaf != 0) {
						goto bail
					}
				}
				off = ucs4 & uint32(0xff)
				*(*TFcChar32)(unsafe.Pointer(leaf + uintptr(off>>int32(5))*4)) |= uint32(1) << (off & uint32(0x1f))
			}
			ucs4 = uint32(libfreetype.XFT_Get_Next_Char(tls, face, uint64(ucs4), bp))
		}
		if _fcFontEncodings[o] == int32(_FT_ENCODING_MS_SYMBOL) {
			/* For symbol-encoded OpenType fonts, we duplicate the
			 * U+F000..F0FF range at U+0000..U+00FF.  That's what
			 * Windows seems to do, and that's hinted about at:
			 * http://www.microsoft.com/typography/otspec/recom.htm
			 * under "Non-Standard (Symbol) Fonts".
			 *
			 * See thread with subject "Webdings and other MS symbol
			 * fonts don't display" on mailing list from May 2015.
			 */
			ucs4 = uint32(0xF000)
			for {
				if !(ucs4 < uint32(0xF100)) {
					break
				}
				if XFcCharSetHasChar(tls, fcs, ucs4) != 0 {
					XFcCharSetAddChar(tls, fcs, ucs4-uint32(0xF000))
				}
				goto _2
			_2:
				;
				ucs4++
			}
		}
		break
		goto _1
	_1:
		;
		o++
	}
	return fcs
	goto bail
bail:
	;
	XFcCharSetDestroy(tls, fcs)
	return uintptr(0)
}

func XFcFreeTypeCharSetAndSpacing(tls *libc.TLS, face TFT_Face, blanks uintptr, spacing uintptr) (r uintptr) {
	if spacing != 0 {
		*(*int32)(unsafe.Pointer(spacing)) = _FcFreeTypeSpacing(tls, face)
	}
	return XFcFreeTypeCharSet(tls, face, blanks)
}

/* space + head + id */

/*
 * This is a bit generous; the registry has only lower case and space
 * except for 'DFLT'.
 */
func _addtag(tls *libc.TLS, complex_ uintptr, tag TFT_ULong) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* tagstring at bp+0 */ [5]TFcChar8
	(*(*[5]TFcChar8)(unsafe.Pointer(bp)))[0] = uint8(tag >> libc.Int32FromInt32(24))
	(*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(1)] = uint8(tag >> libc.Int32FromInt32(16))
	(*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(2)] = uint8(tag >> libc.Int32FromInt32(8))
	(*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(3)] = uint8(tag)
	(*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(4)] = uint8('\000')
	/* skip tags which aren't alphanumeric, under the assumption that
	 * they're probably broken
	 */
	if !(int32(0141) <= libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[0]) && libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[0]) <= int32(0172) || int32(0101) <= libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[0]) && libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[0]) <= int32(0132) || int32('0') <= libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[0]) && libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[0]) <= int32('9') || int32(040) == libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[0])) || !(int32(0141) <= libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(1)]) && libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(1)]) <= int32(0172) || int32(0101) <= libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(1)]) && libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(1)]) <= int32(0132) || int32('0') <= libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(1)]) && libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(1)]) <= int32('9') || int32(040) == libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(1)])) || !(int32(0141) <= libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(2)]) && libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(2)]) <= int32(0172) || int32(0101) <= libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(2)]) && libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(2)]) <= int32(0132) || int32('0') <= libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(2)]) && libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(2)]) <= int32('9') || int32(040) == libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(2)])) || !(int32(0141) <= libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(3)]) && libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(3)]) <= int32(0172) || int32(0101) <= libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(3)]) && libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(3)]) <= int32(0132) || int32('0') <= libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(3)]) && libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(3)]) <= int32('9') || int32(040) == libc.Int32FromUint8((*(*[5]TFcChar8)(unsafe.Pointer(bp)))[int32(3)])) {
		return
	}
	if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(complex_))) != int32('\000') {
		libc.X__builtin___strcat_chk(tls, complex_, __ccgo_ts+1952, ^t__predefined_size_t(0))
	}
	libc.X__builtin___strcat_chk(tls, complex_, __ccgo_ts+4715, ^t__predefined_size_t(0))
	libc.X__builtin___strcat_chk(tls, complex_, bp, ^t__predefined_size_t(0))
}

func _compareulong(tls *libc.TLS, a uintptr, b uintptr) (r int32) {
	var ua, ub uintptr
	_, _ = ua, ub
	ua = a
	ub = b
	return libc.Int32FromUint64(*(*TFT_ULong)(unsafe.Pointer(ua)) - *(*TFT_ULong)(unsafe.Pointer(ub)))
}

func _FindTable(tls *libc.TLS, face TFT_Face, tabletag TFT_ULong) (r TFcBool) {
	var error1, v1 TFT_Error
	var stream TFT_Stream
	_, _, _ = error1, stream, v1
	stream = (*TFT_FaceRec_)(unsafe.Pointer(face)).Fstream
	if !(stream != 0) {
		return m_FcFalse
	}
	v1 = Xftglue_face_goto_table(tls, face, tabletag, stream)
	error1 = v1
	if v1 != 0 {
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

func _GetScriptTags(tls *libc.TLS, face TFT_Face, tabletag TFT_ULong, stags uintptr) (r int32) {
	var base_offset, cur_offset, new_offset TFT_ULong
	var error1, v1 TFT_Error
	var n, p TFT_UShort
	var script_count int32
	var stream TFT_Stream
	_, _, _, _, _, _, _, _, _ = base_offset, cur_offset, error1, n, new_offset, p, script_count, stream, v1
	stream = (*TFT_FaceRec_)(unsafe.Pointer(face)).Fstream
	if !(stream != 0) {
		return 0
	}
	v1 = Xftglue_face_goto_table(tls, face, tabletag, stream)
	error1 = v1
	if v1 != 0 {
		return 0
	}
	base_offset = libc.Uint64FromInt64(Xftglue_stream_pos(tls, stream))
	/* skip version */
	if Xftglue_stream_seek(tls, stream, libc.Int64FromUint64(base_offset+uint64(4))) != 0 || Xftglue_stream_frame_enter(tls, stream, uint64(2)) != 0 {
		return 0
	}
	*(*uintptr)(unsafe.Pointer(stream + 64)) += uintptr(2)
	new_offset = uint64(libc.Uint16FromInt16(libc.Int16FromUint64(uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(2))))<<libc.Int32FromInt32(8)|uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(1))))))) + base_offset
	Xftglue_stream_frame_exit(tls, stream)
	cur_offset = libc.Uint64FromInt64(Xftglue_stream_pos(tls, stream))
	if Xftglue_stream_seek(tls, stream, libc.Int64FromUint64(new_offset)) != int32(_FT_Err_Ok) {
		return 0
	}
	base_offset = libc.Uint64FromInt64(Xftglue_stream_pos(tls, stream))
	if Xftglue_stream_frame_enter(tls, stream, uint64(2)) != 0 {
		return 0
	}
	*(*uintptr)(unsafe.Pointer(stream + 64)) += uintptr(2)
	script_count = libc.Int32FromUint16(libc.Uint16FromInt16(libc.Int16FromUint64(uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(2))))<<libc.Int32FromInt32(8) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(1)))))))
	Xftglue_stream_frame_exit(tls, stream)
	*(*uintptr)(unsafe.Pointer(stags)) = libc.Xmalloc(tls, libc.Uint64FromInt32(script_count)*uint64(8))
	if !(*(*uintptr)(unsafe.Pointer(stags)) != 0) {
		return 0
	}
	p = uint16(0)
	n = uint16(0)
	for {
		if !(libc.Int32FromUint16(n) < script_count) {
			break
		}
		if Xftglue_stream_frame_enter(tls, stream, uint64(6)) != 0 {
			goto Fail
		}
		*(*uintptr)(unsafe.Pointer(stream + 64)) += uintptr(4)
		*(*TFT_ULong)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(stags)) + uintptr(p)*8)) = libc.Uint64FromInt64(libc.Int64FromUint64(uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(4))))<<libc.Int32FromInt32(24) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(3))))<<libc.Int32FromInt32(16) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(2))))<<libc.Int32FromInt32(8) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(1))))))
		*(*uintptr)(unsafe.Pointer(stream + 64)) += uintptr(2)
		new_offset = uint64(libc.Uint16FromInt16(libc.Int16FromUint64(uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(2))))<<libc.Int32FromInt32(8)|uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(1))))))) + base_offset
		Xftglue_stream_frame_exit(tls, stream)
		cur_offset = libc.Uint64FromInt64(Xftglue_stream_pos(tls, stream))
		error1 = Xftglue_stream_seek(tls, stream, libc.Int64FromUint64(new_offset))
		if error1 == int32(_FT_Err_Ok) {
			p++
		}
		Xftglue_stream_seek(tls, stream, libc.Int64FromUint64(cur_offset))
		goto _2
	_2:
		;
		n++
	}
	if !(p != 0) {
		goto Fail
	}
	/* sort the tag list before returning it */
	libc.Xqsort(tls, *(*uintptr)(unsafe.Pointer(stags)), libc.Uint64FromInt32(script_count), uint64(8), __ccgo_fp(_compareulong))
	return script_count
	goto Fail
Fail:
	;
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(stags)))
	*(*uintptr)(unsafe.Pointer(stags)) = libc.UintptrFromInt32(0)
	return 0
}

func _FcFontCapabilities(tls *libc.TLS, face TFT_Face) (r uintptr) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var complex_ uintptr
	var err TFT_Error
	var gpos_count, gsub_count TFT_UShort
	var indx1, indx2, v1 int32
	var issilgraphitefont TFcBool
	var maxsize TFT_ULong
	var _ /* gpostags at bp+16 */ uintptr
	var _ /* gsubtags at bp+8 */ uintptr
	var _ /* len at bp+0 */ TFT_ULong
	_, _, _, _, _, _, _, _, _ = complex_, err, gpos_count, gsub_count, indx1, indx2, issilgraphitefont, maxsize, v1
	issilgraphitefont = 0
	*(*TFT_ULong)(unsafe.Pointer(bp)) = uint64(0)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.UintptrFromInt32(0)
	*(*uintptr)(unsafe.Pointer(bp + 16)) = libc.UintptrFromInt32(0)
	gsub_count = uint16(0)
	gpos_count = uint16(0)
	complex_ = libc.UintptrFromInt32(0)
	indx1 = 0
	indx2 = 0
	err = libfreetype.XFT_Load_Sfnt_Table(tls, face, uint64(uint32(libc.Uint64FromUint8('S')<<libc.Int32FromInt32(24)|libc.Uint64FromUint8('i')<<libc.Int32FromInt32(16)|libc.Uint64FromUint8('l')<<libc.Int32FromInt32(8)|libc.Uint64FromUint8('f'))), 0, uintptr(0), bp)
	issilgraphitefont = libc.BoolInt32(err == int32(_FT_Err_Ok))
	gpos_count = libc.Uint16FromInt32(_GetScriptTags(tls, face, uint64(uint32(libc.Uint64FromUint8('G')<<libc.Int32FromInt32(24)|libc.Uint64FromUint8('P')<<libc.Int32FromInt32(16)|libc.Uint64FromUint8('O')<<libc.Int32FromInt32(8)|libc.Uint64FromUint8('S'))), bp+16))
	gsub_count = libc.Uint16FromInt32(_GetScriptTags(tls, face, uint64(uint32(libc.Uint64FromUint8('G')<<libc.Int32FromInt32(24)|libc.Uint64FromUint8('S')<<libc.Int32FromInt32(16)|libc.Uint64FromUint8('U')<<libc.Int32FromInt32(8)|libc.Uint64FromUint8('B'))), bp+8))
	if !(issilgraphitefont != 0) && !(gsub_count != 0) && !(gpos_count != 0) {
		goto bail
	}
	if issilgraphitefont != 0 {
		v1 = int32(13)
	} else {
		v1 = 0
	}
	maxsize = (uint64(gpos_count)+uint64(gsub_count))*libc.Uint64FromInt32(libc.Int32FromInt32(1)+libc.Int32FromInt32(m_OTLAYOUT_HEAD_LEN)+libc.Int32FromInt32(m_OTLAYOUT_ID_LEN)) + libc.Uint64FromInt32(v1)
	complex_ = libc.Xmalloc(tls, uint64(1)*maxsize)
	if !(complex_ != 0) {
		goto bail
	}
	*(*TFcChar8)(unsafe.Pointer(complex_)) = uint8('\000')
	if issilgraphitefont != 0 {
		libc.X__builtin___strcpy_chk(tls, complex_, __ccgo_ts+4725, ^t__predefined_size_t(0))
	}
	for indx1 < libc.Int32FromUint16(gsub_count) || indx2 < libc.Int32FromUint16(gpos_count) {
		if indx1 == libc.Int32FromUint16(gsub_count) {
			_addtag(tls, complex_, *(*TFT_ULong)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)) + uintptr(indx2)*8)))
			indx2++
		} else {
			if indx2 == libc.Int32FromUint16(gpos_count) || *(*TFT_ULong)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(indx1)*8)) < *(*TFT_ULong)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)) + uintptr(indx2)*8)) {
				_addtag(tls, complex_, *(*TFT_ULong)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(indx1)*8)))
				indx1++
			} else {
				if *(*TFT_ULong)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(indx1)*8)) == *(*TFT_ULong)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)) + uintptr(indx2)*8)) {
					_addtag(tls, complex_, *(*TFT_ULong)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(indx1)*8)))
					indx1++
					indx2++
				} else {
					_addtag(tls, complex_, *(*TFT_ULong)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)) + uintptr(indx2)*8)))
					indx2++
				}
			}
		}
	}
	if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
		libc.Xprintf(tls, __ccgo_ts+4738, libc.VaList(bp+32, complex_))
	}
	goto bail
bail:
	;
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
	return complex_
}

func _FcFontHasHint(tls *libc.TLS, face TFT_Face) (r TFcBool) {
	return _FindTable(tls, face, uint64(uint32(libc.Uint64FromUint8('p')<<libc.Int32FromInt32(24)|libc.Uint64FromUint8('r')<<libc.Int32FromInt32(16)|libc.Uint64FromUint8('e')<<libc.Int32FromInt32(8)|libc.Uint64FromUint8('p'))))
}

/*
 * Copyright (c) 2000, 2002 - 2008, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

func XFcFontSetCreate(tls *libc.TLS) (r uintptr) {
	var s uintptr
	_ = s
	s = libc.Xmalloc(tls, uint64(16))
	if !(s != 0) {
		return uintptr(0)
	}
	(*TFcFontSet)(unsafe.Pointer(s)).Fnfont = 0
	(*TFcFontSet)(unsafe.Pointer(s)).Fsfont = 0
	(*TFcFontSet)(unsafe.Pointer(s)).Ffonts = uintptr(0)
	return s
}

func XFcFontSetDestroy(tls *libc.TLS, s uintptr) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < (*TFcFontSet)(unsafe.Pointer(s)).Fnfont) {
			break
		}
		XFcPatternDestroy(tls, *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(s)).Ffonts + uintptr(i)*8)))
		goto _1
	_1:
		;
		i++
	}
	if (*TFcFontSet)(unsafe.Pointer(s)).Ffonts != 0 {
		libc.Xfree(tls, (*TFcFontSet)(unsafe.Pointer(s)).Ffonts)
	}
	libc.Xfree(tls, s)
}

func XFcFontSetAdd(tls *libc.TLS, s uintptr, font uintptr) (r TFcBool) {
	var f, v2 uintptr
	var sfont, v1 int32
	_, _, _, _ = f, sfont, v1, v2
	if (*TFcFontSet)(unsafe.Pointer(s)).Fnfont == (*TFcFontSet)(unsafe.Pointer(s)).Fsfont {
		sfont = (*TFcFontSet)(unsafe.Pointer(s)).Fsfont + int32(32)
		if (*TFcFontSet)(unsafe.Pointer(s)).Ffonts != 0 {
			f = libc.Xrealloc(tls, (*TFcFontSet)(unsafe.Pointer(s)).Ffonts, libc.Uint64FromInt32(sfont)*uint64(8))
		} else {
			f = libc.Xmalloc(tls, libc.Uint64FromInt32(sfont)*uint64(8))
		}
		if !(f != 0) {
			return m_FcFalse
		}
		(*TFcFontSet)(unsafe.Pointer(s)).Fsfont = sfont
		(*TFcFontSet)(unsafe.Pointer(s)).Ffonts = f
	}
	v2 = s
	v1 = *(*int32)(unsafe.Pointer(v2))
	*(*int32)(unsafe.Pointer(v2))++
	*(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(s)).Ffonts + uintptr(v1)*8)) = font
	return int32(m_FcTrue)
}

func XFcFontSetSerializeAlloc(tls *libc.TLS, serialize uintptr, s uintptr) (r TFcBool) {
	var i int32
	_ = i
	if !(XFcSerializeAlloc(tls, serialize, s, int32(16)) != 0) {
		return m_FcFalse
	}
	if !(XFcSerializeAlloc(tls, serialize, (*TFcFontSet)(unsafe.Pointer(s)).Ffonts, libc.Int32FromUint64(libc.Uint64FromInt32((*TFcFontSet)(unsafe.Pointer(s)).Fnfont)*uint64(8))) != 0) {
		return m_FcFalse
	}
	i = 0
	for {
		if !(i < (*TFcFontSet)(unsafe.Pointer(s)).Fnfont) {
			break
		}
		if !(XFcPatternSerializeAlloc(tls, serialize, *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(s)).Ffonts + uintptr(i)*8))) != 0) {
			return m_FcFalse
		}
		goto _1
	_1:
		;
		i++
	}
	return int32(m_FcTrue)
}

func XFcFontSetSerialize(tls *libc.TLS, serialize uintptr, s uintptr) (r uintptr) {
	var fonts_serialize, p_serialize, s_serialize uintptr
	var i int32
	_, _, _, _ = fonts_serialize, i, p_serialize, s_serialize
	s_serialize = XFcSerializePtr(tls, serialize, s)
	if !(s_serialize != 0) {
		return libc.UintptrFromInt32(0)
	}
	*(*TFcFontSet)(unsafe.Pointer(s_serialize)) = *(*TFcFontSet)(unsafe.Pointer(s))
	(*TFcFontSet)(unsafe.Pointer(s_serialize)).Fsfont = (*TFcFontSet)(unsafe.Pointer(s_serialize)).Fnfont
	fonts_serialize = XFcSerializePtr(tls, serialize, (*TFcFontSet)(unsafe.Pointer(s)).Ffonts)
	if !(fonts_serialize != 0) {
		return libc.UintptrFromInt32(0)
	}
	(*TFcFontSet)(unsafe.Pointer(s_serialize)).Ffonts = uintptr(int64(fonts_serialize) - int64(s_serialize) | libc.Int64FromInt32(1))
	i = 0
	for {
		if !(i < (*TFcFontSet)(unsafe.Pointer(s)).Fnfont) {
			break
		}
		p_serialize = XFcPatternSerialize(tls, serialize, *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(s)).Ffonts + uintptr(i)*8)))
		if !(p_serialize != 0) {
			return libc.UintptrFromInt32(0)
		}
		*(*uintptr)(unsafe.Pointer(fonts_serialize + uintptr(i)*8)) = uintptr(int64(p_serialize) - int64(s_serialize) | libc.Int64FromInt32(1))
		goto _1
	_1:
		;
		i++
	}
	return s_serialize
}

func XFcFontSetDeserialize(tls *libc.TLS, set uintptr) (r uintptr) {
	var i int32
	var new1, v2, v3 uintptr
	_, _, _, _ = i, new1, v2, v3
	new1 = XFcFontSetCreate(tls)
	if !(new1 != 0) {
		return libc.UintptrFromInt32(0)
	}
	i = 0
	for {
		if !(i < (*TFcFontSet)(unsafe.Pointer(set)).Fnfont) {
			break
		}
		if int64((*TFcFontSet)(unsafe.Pointer(set)).Ffonts)&int64(1) != 0 {
			if int64((*TFcFontSet)(unsafe.Pointer(set)).Ffonts)&int64(1) != 0 {
				v3 = uintptr(int64(set) + int64((*TFcFontSet)(unsafe.Pointer(set)).Ffonts)&int64(^libc.Int32FromInt32(1)))
			} else {
				v3 = (*TFcFontSet)(unsafe.Pointer(set)).Ffonts
			}
			v2 = uintptr(int64(set) + int64(*(*uintptr)(unsafe.Pointer(v3 + uintptr(i)*8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(set)).Ffonts + uintptr(i)*8))
		}
		if !(XFcFontSetAdd(tls, new1, XFcPatternDuplicate(tls, v2)) != 0) {
			goto bail
		}
		goto _1
	_1:
		;
		i++
	}
	return new1
	goto bail
bail:
	;
	XFcFontSetDestroy(tls, new1)
	return libc.UintptrFromInt32(0)
}

type TFcPtrList = struct {
	Fdestroy_func TFcDestroyFunc
	Flist         uintptr
}

type T_FcPtrList = TFcPtrList

type TFcPtrListEntry = struct {
	Fnext uintptr
	Fdata uintptr
}

type T_FcPtrListEntry = TFcPtrListEntry

type TFcPtrListIterPrivate = struct {
	Flist  uintptr
	Fentry uintptr
	Fprev  uintptr
}

type T_FcPtrListIterPrivate = TFcPtrListIterPrivate

type t__ccgo_fp__XFcPtrListCreate_0 = func(*libc.TLS, uintptr)

func XFcPtrListCreate(tls *libc.TLS, __ccgo_fp_func TFcDestroyFunc) (r uintptr) {
	var ret uintptr
	_ = ret
	ret = libc.Xmalloc(tls, uint64(16))
	if ret != 0 {
		(*TFcPtrList)(unsafe.Pointer(ret)).Fdestroy_func = __ccgo_fp_func
		(*TFcPtrList)(unsafe.Pointer(ret)).Flist = libc.UintptrFromInt32(0)
	}
	return ret
}

func XFcPtrListDestroy(tls *libc.TLS, list uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* iter at bp+0 */ TFcPtrListIter
	XFcPtrListIterInit(tls, list, bp)
	for cond := true; cond; cond = XFcPtrListIterIsValid(tls, list, bp) != 0 {
		if XFcPtrListIterGetValue(tls, list, bp) != 0 {
			(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{(*TFcPtrList)(unsafe.Pointer(list)).Fdestroy_func})))(tls, XFcPtrListIterGetValue(tls, list, bp))
		}
		XFcPtrListIterRemove(tls, list, bp)
	}
	libc.Xfree(tls, list)
}

func XFcPtrListIterInit(tls *libc.TLS, list uintptr, iter uintptr) {
	var priv uintptr
	_ = priv
	priv = iter
	(*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Flist = list
	(*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry = (*TFcPtrList)(unsafe.Pointer(list)).Flist
	(*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fprev = libc.UintptrFromInt32(0)
}

func XFcPtrListIterInitAtLast(tls *libc.TLS, list uintptr, iter uintptr) {
	var e, p, priv uintptr
	_, _, _ = e, p, priv
	priv = iter
	e = list + 8
	p = e
	for {
		if !(*(*uintptr)(unsafe.Pointer(e)) != 0) {
			break
		}
		goto _1
	_1:
		;
		p = e
		e = *(*uintptr)(unsafe.Pointer(e))
	}
	(*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Flist = list
	(*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry = *(*uintptr)(unsafe.Pointer(e))
	(*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fprev = *(*uintptr)(unsafe.Pointer(p))
}

func XFcPtrListIterNext(tls *libc.TLS, list uintptr, iter uintptr) (r TFcBool) {
	var priv uintptr
	_ = priv
	priv = iter
	if list != (*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Flist {
		return m_FcFalse
	}
	(*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fprev = (*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry
	(*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry = (*TFcPtrListEntry)(unsafe.Pointer((*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry)).Fnext
	return libc.BoolInt32((*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry != libc.UintptrFromInt32(0))
}

func XFcPtrListIterIsValid(tls *libc.TLS, list uintptr, iter uintptr) (r TFcBool) {
	var priv uintptr
	_ = priv
	priv = iter
	return libc.BoolInt32(list == (*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Flist && (*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry != 0)
}

func XFcPtrListIterGetValue(tls *libc.TLS, list uintptr, iter uintptr) (r uintptr) {
	var priv uintptr
	_ = priv
	priv = iter
	if list != (*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Flist || !((*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry != 0) {
		return libc.UintptrFromInt32(0)
	}
	return (*TFcPtrListEntry)(unsafe.Pointer((*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry)).Fdata
}

func XFcPtrListIterAdd(tls *libc.TLS, list uintptr, iter uintptr, data uintptr) (r TFcBool) {
	var e, priv uintptr
	_, _ = e, priv
	priv = iter
	if list != (*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Flist {
		return m_FcFalse
	}
	e = libc.Xmalloc(tls, uint64(16))
	if !(e != 0) {
		return m_FcFalse
	}
	(*TFcPtrListEntry)(unsafe.Pointer(e)).Fdata = data
	if (*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry != 0 {
		(*TFcPtrListEntry)(unsafe.Pointer(e)).Fnext = (*TFcPtrListEntry)(unsafe.Pointer((*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry)).Fnext
		(*TFcPtrListEntry)(unsafe.Pointer((*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry)).Fnext = e
	} else {
		(*TFcPtrListEntry)(unsafe.Pointer(e)).Fnext = libc.UintptrFromInt32(0)
		if (*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fprev != 0 {
			(*TFcPtrListEntry)(unsafe.Pointer((*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fprev)).Fnext = e
			(*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry = (*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fprev
		} else {
			(*TFcPtrList)(unsafe.Pointer(list)).Flist = e
			(*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry = e
			return int32(m_FcTrue)
		}
	}
	return XFcPtrListIterNext(tls, list, iter)
}

func XFcPtrListIterRemove(tls *libc.TLS, list uintptr, iter uintptr) (r TFcBool) {
	var e, priv uintptr
	_, _ = e, priv
	priv = iter
	if list != (*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Flist {
		return m_FcFalse
	}
	if !((*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry != 0) {
		return int32(m_FcTrue)
	}
	if (*TFcPtrList)(unsafe.Pointer(list)).Flist == (*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry {
		(*TFcPtrList)(unsafe.Pointer(list)).Flist = (*TFcPtrListEntry)(unsafe.Pointer((*TFcPtrList)(unsafe.Pointer(list)).Flist)).Fnext
	}
	e = (*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry
	if (*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fprev != 0 {
		(*TFcPtrListEntry)(unsafe.Pointer((*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fprev)).Fnext = (*TFcPtrListEntry)(unsafe.Pointer((*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry)).Fnext
	}
	(*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry = (*TFcPtrListEntry)(unsafe.Pointer((*TFcPtrListIterPrivate)(unsafe.Pointer(priv)).Fentry)).Fnext
	libc.Xfree(tls, e)
	return int32(m_FcTrue)
}

const m_FC_HASH_SIZE = 227

type TFcHashTable = struct {
	Fbuckets            [227]uintptr
	Fhash_func          TFcHashFunc
	Fcompare_func       TFcCompareFunc
	Fkey_copy_func      TFcCopyFunc
	Fvalue_copy_func    TFcCopyFunc
	Fkey_destroy_func   TFcDestroyFunc
	Fvalue_destroy_func TFcDestroyFunc
}

type T_FcHashTable = TFcHashTable

type TFcHashBucket = struct {
	Fnext  uintptr
	Fkey   uintptr
	Fvalue uintptr
}

type T_FcHashBucket = TFcHashBucket

func XFcHashStrCopy(tls *libc.TLS, src uintptr, dest uintptr) (r TFcBool) {
	*(*uintptr)(unsafe.Pointer(dest)) = libc.Xstrdup(tls, src)
	return libc.BoolInt32(*(*uintptr)(unsafe.Pointer(dest)) != libc.UintptrFromInt32(0))
}

type t__ccgo_fp__XFcHashTableCreate_0 = func(*libc.TLS, uintptr) uint32

type t__ccgo_fp__XFcHashTableCreate_1 = func(*libc.TLS, uintptr, uintptr) int32

type t__ccgo_fp__XFcHashTableCreate_2 = func(*libc.TLS, uintptr, uintptr) int32

type t__ccgo_fp__XFcHashTableCreate_3 = func(*libc.TLS, uintptr, uintptr) int32

type t__ccgo_fp__XFcHashTableCreate_4 = func(*libc.TLS, uintptr)

type t__ccgo_fp__XFcHashTableCreate_5 = func(*libc.TLS, uintptr)

func XFcHashTableCreate(tls *libc.TLS, __ccgo_fp_hash_func TFcHashFunc, __ccgo_fp_compare_func TFcCompareFunc, __ccgo_fp_key_copy_func TFcCopyFunc, __ccgo_fp_value_copy_func TFcCopyFunc, __ccgo_fp_key_destroy_func TFcDestroyFunc, __ccgo_fp_value_destroy_func TFcDestroyFunc) (r uintptr) {
	var ret uintptr
	_ = ret
	ret = libc.Xmalloc(tls, uint64(1864))
	if ret != 0 {
		libc.X__builtin___memset_chk(tls, ret, 0, libc.Uint64FromInt64(8)*libc.Uint64FromInt32(m_FC_HASH_SIZE), ^t__predefined_size_t(0))
		(*TFcHashTable)(unsafe.Pointer(ret)).Fhash_func = __ccgo_fp_hash_func
		(*TFcHashTable)(unsafe.Pointer(ret)).Fcompare_func = __ccgo_fp_compare_func
		(*TFcHashTable)(unsafe.Pointer(ret)).Fkey_copy_func = __ccgo_fp_key_copy_func
		(*TFcHashTable)(unsafe.Pointer(ret)).Fvalue_copy_func = __ccgo_fp_value_copy_func
		(*TFcHashTable)(unsafe.Pointer(ret)).Fkey_destroy_func = __ccgo_fp_key_destroy_func
		(*TFcHashTable)(unsafe.Pointer(ret)).Fvalue_destroy_func = __ccgo_fp_value_destroy_func
	}
	return ret
}

func XFcHashTableDestroy(tls *libc.TLS, table uintptr) {
	var bucket, prev uintptr
	var i int32
	_, _, _ = bucket, i, prev
	i = 0
	for {
		if !(i < int32(m_FC_HASH_SIZE)) {
			break
		}
		bucket = *(*uintptr)(unsafe.Pointer(table + uintptr(i)*8))
		for bucket != 0 {
			if (*TFcHashTable)(unsafe.Pointer(table)).Fkey_destroy_func != 0 {
				(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fkey_destroy_func})))(tls, (*TFcHashBucket)(unsafe.Pointer(bucket)).Fkey)
			}
			if (*TFcHashTable)(unsafe.Pointer(table)).Fvalue_destroy_func != 0 {
				(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fvalue_destroy_func})))(tls, (*TFcHashBucket)(unsafe.Pointer(bucket)).Fvalue)
			}
			prev = bucket
			bucket = (*TFcHashBucket)(unsafe.Pointer(bucket)).Fnext
			libc.Xfree(tls, prev)
		}
		*(*uintptr)(unsafe.Pointer(table + uintptr(i)*8)) = libc.UintptrFromInt32(0)
		goto _1
	_1:
		;
		i++
	}
	libc.Xfree(tls, table)
}

func XFcHashTableFind(tls *libc.TLS, table uintptr, key uintptr, value uintptr) (r TFcBool) {
	var bucket uintptr
	var hash TFcChar32
	_, _ = bucket, hash
	hash = (*(*func(*libc.TLS, uintptr) TFcChar32)(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fhash_func})))(tls, key)
	bucket = *(*uintptr)(unsafe.Pointer(table + uintptr(hash%uint32(m_FC_HASH_SIZE))*8))
	for {
		if !(bucket != 0) {
			break
		}
		if !((*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fcompare_func})))(tls, (*TFcHashBucket)(unsafe.Pointer(bucket)).Fkey, key) != 0) {
			if (*TFcHashTable)(unsafe.Pointer(table)).Fvalue_copy_func != 0 {
				if !((*(*func(*libc.TLS, uintptr, uintptr) TFcBool)(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fvalue_copy_func})))(tls, (*TFcHashBucket)(unsafe.Pointer(bucket)).Fvalue, value) != 0) {
					return m_FcFalse
				}
			} else {
				*(*uintptr)(unsafe.Pointer(value)) = (*TFcHashBucket)(unsafe.Pointer(bucket)).Fvalue
			}
			return int32(m_FcTrue)
		}
		goto _1
	_1:
		;
		bucket = (*TFcHashBucket)(unsafe.Pointer(bucket)).Fnext
	}
	return m_FcFalse
}

func _FcHashTableAddInternal(tls *libc.TLS, table uintptr, key uintptr, value uintptr, replace TFcBool) (r TFcBool) {
	var b, bucket, prev, v3 uintptr
	var hash TFcChar32
	var ret TFcBool
	var v4, v5 int32
	_, _, _, _, _, _, _, _ = b, bucket, hash, prev, ret, v3, v4, v5
	hash = (*(*func(*libc.TLS, uintptr) TFcChar32)(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fhash_func})))(tls, key)
	ret = m_FcFalse
	bucket = libc.Xmalloc(tls, uint64(24))
	if !(bucket != 0) {
		return m_FcFalse
	}
	libc.X__builtin___memset_chk(tls, bucket, 0, uint64(24), ^t__predefined_size_t(0))
	if (*TFcHashTable)(unsafe.Pointer(table)).Fkey_copy_func != 0 {
		ret |= libc.BoolInt32(!((*(*func(*libc.TLS, uintptr, uintptr) TFcBool)(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fkey_copy_func})))(tls, key, bucket+8) != 0))
	} else {
		(*TFcHashBucket)(unsafe.Pointer(bucket)).Fkey = key
	}
	if (*TFcHashTable)(unsafe.Pointer(table)).Fvalue_copy_func != 0 {
		ret |= libc.BoolInt32(!((*(*func(*libc.TLS, uintptr, uintptr) TFcBool)(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fvalue_copy_func})))(tls, value, bucket+16) != 0))
	} else {
		(*TFcHashBucket)(unsafe.Pointer(bucket)).Fvalue = value
	}
	if !(ret != 0) {
		goto _1
	}
	goto destroy
destroy:
	;
	if (*TFcHashBucket)(unsafe.Pointer(bucket)).Fkey != 0 && (*TFcHashTable)(unsafe.Pointer(table)).Fkey_destroy_func != 0 {
		(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fkey_destroy_func})))(tls, (*TFcHashBucket)(unsafe.Pointer(bucket)).Fkey)
	}
	if (*TFcHashBucket)(unsafe.Pointer(bucket)).Fvalue != 0 && (*TFcHashTable)(unsafe.Pointer(table)).Fvalue_destroy_func != 0 {
		(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fvalue_destroy_func})))(tls, (*TFcHashBucket)(unsafe.Pointer(bucket)).Fvalue)
	}
	libc.Xfree(tls, bucket)
	return libc.BoolInt32(!(ret != 0))
_1:
	;
	goto retry
retry:
	;
	prev = table + uintptr(hash%uint32(m_FC_HASH_SIZE))*8
	for {
		v3 = *(*uintptr)(unsafe.Pointer(prev))
		b = v3
		if !(v3 != 0) {
			break
		}
		if !((*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fcompare_func})))(tls, (*TFcHashBucket)(unsafe.Pointer(b)).Fkey, key) != 0) {
			if replace != 0 {
				(*TFcHashBucket)(unsafe.Pointer(bucket)).Fnext = (*TFcHashBucket)(unsafe.Pointer(b)).Fnext
				if *(*uintptr)(unsafe.Pointer(prev)) == b {
					*(*uintptr)(unsafe.Pointer(prev)) = bucket
					v4 = libc.Int32FromInt32(m_FcTrue)
				} else {
					v4 = m_FcFalse
				}
				if !(v4 != 0) {
					goto retry
				}
				bucket = b
			} else {
				ret = int32(m_FcTrue)
			}
			goto destroy
		}
		goto _2
	_2:
		;
		prev = b
	}
	(*TFcHashBucket)(unsafe.Pointer(bucket)).Fnext = libc.UintptrFromInt32(0)
	if *(*uintptr)(unsafe.Pointer(prev)) == b {
		*(*uintptr)(unsafe.Pointer(prev)) = bucket
		v5 = libc.Int32FromInt32(m_FcTrue)
	} else {
		v5 = m_FcFalse
	}
	if !(v5 != 0) {
		goto retry
	}
	return int32(m_FcTrue)
}

func XFcHashTableAdd(tls *libc.TLS, table uintptr, key uintptr, value uintptr) (r TFcBool) {
	return _FcHashTableAddInternal(tls, table, key, value, m_FcFalse)
}

func XFcHashTableReplace(tls *libc.TLS, table uintptr, key uintptr, value uintptr) (r TFcBool) {
	return _FcHashTableAddInternal(tls, table, key, value, int32(m_FcTrue))
}

func XFcHashTableRemove(tls *libc.TLS, table uintptr, key uintptr) (r TFcBool) {
	var bucket, prev, v2 uintptr
	var hash TFcChar32
	var ret TFcBool
	var v3 int32
	_, _, _, _, _, _ = bucket, hash, prev, ret, v2, v3
	hash = (*(*func(*libc.TLS, uintptr) TFcChar32)(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fhash_func})))(tls, key)
	ret = m_FcFalse
	goto retry
retry:
	;
	prev = table + uintptr(hash%uint32(m_FC_HASH_SIZE))*8
	for {
		v2 = *(*uintptr)(unsafe.Pointer(prev))
		bucket = v2
		if !(v2 != 0) {
			break
		}
		if !((*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fcompare_func})))(tls, (*TFcHashBucket)(unsafe.Pointer(bucket)).Fkey, key) != 0) {
			if *(*uintptr)(unsafe.Pointer(prev)) == bucket {
				*(*uintptr)(unsafe.Pointer(prev)) = (*TFcHashBucket)(unsafe.Pointer(bucket)).Fnext
				v3 = libc.Int32FromInt32(m_FcTrue)
			} else {
				v3 = m_FcFalse
			}
			if !(v3 != 0) {
				goto retry
			}
			if (*TFcHashTable)(unsafe.Pointer(table)).Fkey_destroy_func != 0 {
				(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fkey_destroy_func})))(tls, (*TFcHashBucket)(unsafe.Pointer(bucket)).Fkey)
			}
			if (*TFcHashTable)(unsafe.Pointer(table)).Fvalue_destroy_func != 0 {
				(*(*func(*libc.TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{(*TFcHashTable)(unsafe.Pointer(table)).Fvalue_destroy_func})))(tls, (*TFcHashBucket)(unsafe.Pointer(bucket)).Fvalue)
			}
			libc.Xfree(tls, bucket)
			ret = int32(m_FcTrue)
			break
		}
		goto _1
	_1:
		;
		prev = bucket
	}
	return ret
}

const m_FC_DIR_SEPARATOR_S3 = "/fontconfig"

/*
 * Copyright (c) 2000, 2002 - 2008, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

func _FcInitFallbackConfig(tls *libc.TLS, sysroot uintptr) (r uintptr) {
	var config, fallback uintptr
	_, _ = config, fallback
	fallback = __ccgo_ts + 4774
	config = XFcConfigCreate(tls)
	if !(config != 0) {
		goto bail0
	}
	XFcConfigSetSysRoot(tls, config, sysroot)
	if !(XFcConfigParseAndLoadFromMemory(tls, config, fallback, m_FcFalse) != 0) {
		goto bail1
	}
	return config
	goto bail1
bail1:
	;
	XFcConfigDestroy(tls, config)
	goto bail0
bail0:
	;
	return uintptr(0)
	return r
}

func XFcGetVersion(tls *libc.TLS) (r int32) {
	return libc.Int32FromInt32(m_FC_MAJOR)*libc.Int32FromInt32(10000) + libc.Int32FromInt32(m_FC_MINOR)*libc.Int32FromInt32(100) + libc.Int32FromInt32(m_FC_REVISION)
}

// C documentation
//
//	/*
//	 * Load the configuration files
//	 */
func XFcInitLoadOwnConfig(tls *libc.TLS, config uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var env_file, env_path, fallback, fallback1, p, prefix, sysroot, sysroot1 uintptr
	var have_own TFcBool
	var plen Tsize_t
	_, _, _, _, _, _, _, _, _, _ = env_file, env_path, fallback, fallback1, have_own, p, plen, prefix, sysroot, sysroot1
	if !(config != 0) {
		config = XFcConfigCreate(tls)
		if !(config != 0) {
			return libc.UintptrFromInt32(0)
		}
	}
	XFcInitDebug(tls)
	if !(XFcConfigParseAndLoad(tls, config, uintptr(0), int32(m_FcTrue)) != 0) {
		sysroot = XFcConfigGetSysRoot(tls, config)
		fallback = _FcInitFallbackConfig(tls, sysroot)
		XFcConfigDestroy(tls, config)
		return fallback
	}
	XFcConfigParseOnly(tls, config, __ccgo_ts+5341, m_FcFalse)
	if !((*TFcConfig)(unsafe.Pointer(config)).FcacheDirs != 0 && (*TFcStrSet)(unsafe.Pointer((*TFcConfig)(unsafe.Pointer(config)).FcacheDirs)).Fnum == 0) {
		goto _1
	}
	have_own = m_FcFalse
	env_file = libc.Xgetenv(tls, __ccgo_ts+1637)
	env_path = libc.Xgetenv(tls, __ccgo_ts+1487)
	if env_file != libc.UintptrFromInt32(0) && int32(*(*int8)(unsafe.Pointer(env_file))) != 0 || env_path != libc.UintptrFromInt32(0) && int32(*(*int8)(unsafe.Pointer(env_path))) != 0 {
		have_own = int32(m_FcTrue)
	}
	if !(have_own != 0) {
		libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+5374, 0)
		libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+5446, libc.VaList(bp+8, __ccgo_ts+5498))
	}
	prefix = XFcConfigXdgCacheHome(tls)
	if !(prefix != 0) {
		goto bail
	}
	plen = libc.Xstrlen(tls, prefix)
	p = libc.Xrealloc(tls, prefix, plen+uint64(12))
	if !(p != 0) {
		goto bail
	}
	prefix = p
	libc.X__builtin___memcpy_chk(tls, prefix+uintptr(plen), __ccgo_ts+5524, uint64(11), ^t__predefined_size_t(0))
	*(*TFcChar8)(unsafe.Pointer(prefix + uintptr(plen+uint64(11)))) = uint8(0)
	if !(have_own != 0) {
		libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+5536, 0)
	}
	if !(!(XFcConfigAddCacheDir(tls, config, __ccgo_ts+5498) != 0) || !(XFcConfigAddCacheDir(tls, config, prefix) != 0)) {
		goto _2
	}
	goto bail
bail:
	;
	sysroot1 = XFcConfigGetSysRoot(tls, config)
	libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+5609, 0)
	if prefix != 0 {
		XFcStrFree(tls, prefix)
	}
	fallback1 = _FcInitFallbackConfig(tls, sysroot1)
	XFcConfigDestroy(tls, config)
	return fallback1
_2:
	;
	XFcStrFree(tls, prefix)
_1:
	;
	return config
}

func XFcInitLoadConfig(tls *libc.TLS) (r uintptr) {
	return XFcInitLoadOwnConfig(tls, libc.UintptrFromInt32(0))
}

// C documentation
//
//	/*
//	 * Load the configuration files and scan for available fonts
//	 */
func XFcInitLoadOwnConfigAndFonts(tls *libc.TLS, config uintptr) (r uintptr) {
	config = XFcInitLoadOwnConfig(tls, config)
	if !(config != 0) {
		return uintptr(0)
	}
	if !(XFcConfigBuildFonts(tls, config) != 0) {
		XFcConfigDestroy(tls, config)
		return uintptr(0)
	}
	return config
}

func XFcInitLoadConfigAndFonts(tls *libc.TLS) (r uintptr) {
	return XFcInitLoadOwnConfigAndFonts(tls, libc.UintptrFromInt32(0))
}

// C documentation
//
//	/*
//	 * Initialize the default library configuration
//	 */
func XFcInit(tls *libc.TLS) (r TFcBool) {
	return XFcConfigInit(tls)
}

// C documentation
//
//	/*
//	 * Free all library-allocated data structures.
//	 */
func XFcFini(tls *libc.TLS) {
	XFcConfigFini(tls)
	XFcConfigPathFini(tls)
	XFcDefaultFini(tls)
	XFcObjectFini(tls)
	XFcCacheFini(tls)
}

// C documentation
//
//	/*
//	 * Reread the configuration and available font lists
//	 */
func XFcInitReinitialize(tls *libc.TLS) (r TFcBool) {
	var config uintptr
	var ret TFcBool
	_, _ = config, ret
	config = XFcInitLoadConfigAndFonts(tls)
	if !(config != 0) {
		return m_FcFalse
	}
	ret = XFcConfigSetCurrent(tls, config)
	/* FcConfigSetCurrent() increases the refcount.
	 * decrease it here to avoid the memory leak.
	 */
	XFcConfigDestroy(tls, config)
	return ret
}

func XFcInitBringUptoDate(tls *libc.TLS) (r TFcBool) {
	var config uintptr
	var now Ttime_t
	var ret TFcBool
	_, _, _ = config, now, ret
	config = XFcConfigReference(tls, libc.UintptrFromInt32(0))
	ret = int32(m_FcTrue)
	if !(config != 0) {
		return m_FcFalse
	}
	/*
	 * rescanInterval == 0 disables automatic up to date
	 */
	if (*TFcConfig)(unsafe.Pointer(config)).FrescanInterval == 0 {
		goto bail
	}
	/*
	 * Check no more often than rescanInterval seconds
	 */
	now = libc.Xtime(tls, uintptr(0))
	if (*TFcConfig)(unsafe.Pointer(config)).FrescanTime+int64((*TFcConfig)(unsafe.Pointer(config)).FrescanInterval)-now > 0 {
		goto bail
	}
	/*
	 * If up to date, don't reload configuration
	 */
	if XFcConfigUptoDate(tls, uintptr(0)) != 0 {
		goto bail
	}
	ret = XFcInitReinitialize(tls)
	goto bail
bail:
	;
	XFcConfigDestroy(tls, config)
	return ret
}

const m_FC_DIR_SEPARATOR_S4 = "/"
const m_NUM_COUNTRY_SET = 10
const m_NUM_LANG_CHAR_SET = 246
const m_NUM_LANG_SET_MAP = 8

type TFcLangSet = struct {
	Fextra    uintptr
	Fmap_size TFcChar32
	Fmap1     [8]TFcChar32
}

type T_FcLangSet = TFcLangSet

/* Objects MT-safe for readonly access. */

type TFcLangCharSet = struct {
	Flang    [16]TFcChar8
	Fcharset TFcCharSet
}

type TFcLangCharSetRange = struct {
	Fbegin int32
	Fend   int32
}

var _fcLangData = struct {
	FlangCharSets   [246]TFcLangCharSet
	Fleaves         [725]TFcCharLeaf
	Fleaf_offsets   [780]Tuintptr_t
	Fnumbers        [780]TFcChar16
	FlangIndices    [246]TFcChar8
	FlangIndicesInv [246]TFcChar8
}{
	FlangCharSets: [246]TFcLangCharSet{
		0: {
			Flang: [16]TFcChar8{'a', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(0)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(0)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(0)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(0)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		1: {
			Flang: [16]TFcChar8{'a', 'b'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(1)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(1)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(1)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(1)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		2: {
			Flang: [16]TFcChar8{'a', 'f'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(2)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(2)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(2)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		3: {
			Flang: [16]TFcChar8{'a', 'k'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(5),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(4)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(3)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(4)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(3)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		4: {
			Flang: [16]TFcChar8{'a', 'm'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(9)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(4)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(9)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(4)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		5: {
			Flang: [16]TFcChar8{'a', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(11)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(5)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(11)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(5)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		6: {
			Flang: [16]TFcChar8{'a', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(12)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(6)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(12)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(6)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		7: {
			Flang: [16]TFcChar8{'a', 's'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(13)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(7)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(13)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(7)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		8: {
			Flang: [16]TFcChar8{'a', 's', 't'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(14)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(8)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(14)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(8)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		9: {
			Flang: [16]TFcChar8{'a', 'v'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(16)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(9)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(16)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(9)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		10: {
			Flang: [16]TFcChar8{'a', 'y'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(17)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(10)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(17)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(10)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		11: {
			Flang: [16]TFcChar8{'a', 'z', '-', 'a', 'z'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(18)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(11)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(18)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(11)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		12: {
			Flang: [16]TFcChar8{'a', 'z', '-', 'i', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(21)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(12)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(21)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(12)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		13: {
			Flang: [16]TFcChar8{'b', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(22)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(13)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(22)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(13)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		14: {
			Flang: [16]TFcChar8{'b', 'e'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(14)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(14)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		15: {
			Flang: [16]TFcChar8{'b', 'e', 'r', '-', 'd', 'z'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(4),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(24)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(15)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(24)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(15)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		16: {
			Flang: [16]TFcChar8{'b', 'e', 'r', '-', 'm', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(28)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(16)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(28)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(16)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		17: {
			Flang: [16]TFcChar8{'b', 'g'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(29)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(17)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(29)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(17)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		18: {
			Flang: [16]TFcChar8{'b', 'h'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(18)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(18)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		19: {
			Flang: [16]TFcChar8{'b', 'h', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(19)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(19)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		20: {
			Flang: [16]TFcChar8{'b', 'i'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(31)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(20)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(31)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(20)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		21: {
			Flang: [16]TFcChar8{'b', 'i', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(32)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(21)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(32)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(21)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		22: {
			Flang: [16]TFcChar8{'b', 'm'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(35)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(22)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(35)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(22)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		23: {
			Flang: [16]TFcChar8{'b', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(38)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(23)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(38)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(23)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		24: {
			Flang: [16]TFcChar8{'b', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(39)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(24)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(39)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(24)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		25: {
			Flang: [16]TFcChar8{'b', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(40)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(25)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(40)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(25)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		26: {
			Flang: [16]TFcChar8{'b', 'r', 'x'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(41)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(26)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(41)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(26)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		27: {
			Flang: [16]TFcChar8{'b', 's'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(42)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(27)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(42)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(27)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		28: {
			Flang: [16]TFcChar8{'b', 'u', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(44)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(28)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(44)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(28)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		29: {
			Flang: [16]TFcChar8{'b', 'y', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(45)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(29)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(45)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(29)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		30: {
			Flang: [16]TFcChar8{'c', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(47)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(30)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(47)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(30)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		31: {
			Flang: [16]TFcChar8{'c', 'e'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(16)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(31)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(16)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(31)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		32: {
			Flang: [16]TFcChar8{'c', 'h'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(49)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(32)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(49)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(32)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		33: {
			Flang: [16]TFcChar8{'c', 'h', 'm'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(50)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(33)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(50)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(33)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		34: {
			Flang: [16]TFcChar8{'c', 'h', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(51)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(34)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(51)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(34)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		35: {
			Flang: [16]TFcChar8{'c', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(52)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(35)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(52)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(35)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		36: {
			Flang: [16]TFcChar8{'c', 'r', 'h'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(54)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(36)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(54)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(36)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		37: {
			Flang: [16]TFcChar8{'c', 's'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(56)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(37)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(56)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(37)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		38: {
			Flang: [16]TFcChar8{'c', 's', 'b'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(58)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(38)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(58)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(38)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		39: {
			Flang: [16]TFcChar8{'c', 'u'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(60)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(39)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(60)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(39)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		40: {
			Flang: [16]TFcChar8{'c', 'v'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(61)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(40)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(61)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(40)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		41: {
			Flang: [16]TFcChar8{'c', 'y'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(63)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(41)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(63)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(41)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		42: {
			Flang: [16]TFcChar8{'d', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(66)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(42)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(66)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(42)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		43: {
			Flang: [16]TFcChar8{'d', 'e'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(67)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(43)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(67)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(43)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		44: {
			Flang: [16]TFcChar8{'d', 'o', 'i'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(68)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(44)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(68)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(44)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		45: {
			Flang: [16]TFcChar8{'d', 'v'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(69)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(45)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(69)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(45)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		46: {
			Flang: [16]TFcChar8{'d', 'z'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(39)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(46)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(39)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(46)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		47: {
			Flang: [16]TFcChar8{'e', 'e'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(4),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(70)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(47)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(70)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(47)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		48: {
			Flang: [16]TFcChar8{'e', 'l'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(74)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(48)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(74)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(48)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		49: {
			Flang: [16]TFcChar8{'e', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(75)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(49)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(75)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(49)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		50: {
			Flang: [16]TFcChar8{'e', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(76)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(50)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(76)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(50)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		51: {
			Flang: [16]TFcChar8{'e', 's'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(11)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(51)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(11)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(51)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		52: {
			Flang: [16]TFcChar8{'e', 't'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(78)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(52)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(78)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(52)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		53: {
			Flang: [16]TFcChar8{'e', 'u'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(80)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(53)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(80)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(53)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		54: {
			Flang: [16]TFcChar8{'f', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(21)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(54)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(21)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(54)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		55: {
			Flang: [16]TFcChar8{'f', 'a', 't'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(5),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(4)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(55)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(4)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(55)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		56: {
			Flang: [16]TFcChar8{'f', 'f'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(81)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(56)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(81)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(56)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		57: {
			Flang: [16]TFcChar8{'f', 'i'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(84)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(57)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(84)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(57)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		58: {
			Flang: [16]TFcChar8{'f', 'i', 'l'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(86)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(58)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(86)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(58)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		59: {
			Flang: [16]TFcChar8{'f', 'j'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(59)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(59)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		60: {
			Flang: [16]TFcChar8{'f', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(88)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(60)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(88)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(60)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		61: {
			Flang: [16]TFcChar8{'f', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(52)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(61)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(52)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(61)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		62: {
			Flang: [16]TFcChar8{'f', 'u', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(89)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(62)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(89)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(62)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		63: {
			Flang: [16]TFcChar8{'f', 'y'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(90)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(63)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(90)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(63)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		64: {
			Flang: [16]TFcChar8{'g', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(91)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(64)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(91)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(64)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		65: {
			Flang: [16]TFcChar8{'g', 'd'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(94)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(65)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(94)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(65)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		66: {
			Flang: [16]TFcChar8{'g', 'e', 'z'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(95)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(66)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(95)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(66)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		67: {
			Flang: [16]TFcChar8{'g', 'l'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(11)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(67)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(11)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(67)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		68: {
			Flang: [16]TFcChar8{'g', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(97)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(68)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(97)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(68)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		69: {
			Flang: [16]TFcChar8{'g', 'u'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(100)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(69)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(100)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(69)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		70: {
			Flang: [16]TFcChar8{'g', 'v'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(101)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(70)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(101)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(70)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		71: {
			Flang: [16]TFcChar8{'h', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(102)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(71)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(102)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(71)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		72: {
			Flang: [16]TFcChar8{'h', 'a', 'w'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(105)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(72)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(105)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(72)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		73: {
			Flang: [16]TFcChar8{'h', 'e'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(108)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(73)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(108)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(73)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		74: {
			Flang: [16]TFcChar8{'h', 'i'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(74)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(74)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		75: {
			Flang: [16]TFcChar8{'h', 'n', 'e'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(75)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(75)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		76: {
			Flang: [16]TFcChar8{'h', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(76)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(76)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		77: {
			Flang: [16]TFcChar8{'h', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(42)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(77)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(42)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(77)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		78: {
			Flang: [16]TFcChar8{'h', 's', 'b'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(109)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(78)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(109)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(78)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		79: {
			Flang: [16]TFcChar8{'h', 't'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(111)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(79)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(111)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(79)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		80: {
			Flang: [16]TFcChar8{'h', 'u'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(112)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(80)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(112)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(80)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		81: {
			Flang: [16]TFcChar8{'h', 'y'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(114)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(81)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(114)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(81)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		82: {
			Flang: [16]TFcChar8{'h', 'z'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(115)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(82)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(115)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(82)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		83: {
			Flang: [16]TFcChar8{'i', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(83)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(83)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		84: {
			Flang: [16]TFcChar8{'i', 'd'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(118)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(84)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(118)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(84)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		85: {
			Flang: [16]TFcChar8{'i', 'e'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(119)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(85)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(119)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(85)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		86: {
			Flang: [16]TFcChar8{'i', 'g'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(120)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(86)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(120)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(86)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		87: {
			Flang: [16]TFcChar8{'i', 'i'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(5),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(122)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(87)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(122)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(87)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		88: {
			Flang: [16]TFcChar8{'i', 'k'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(127)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(88)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(127)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(88)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		89: {
			Flang: [16]TFcChar8{'i', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(89)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(89)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		90: {
			Flang: [16]TFcChar8{'i', 's'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(128)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(90)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(128)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(90)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		91: {
			Flang: [16]TFcChar8{'i', 't'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(129)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(91)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(129)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(91)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		92: {
			Flang: [16]TFcChar8{'i', 'u'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(130)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(92)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(130)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(92)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		93: {
			Flang: [16]TFcChar8{'j', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(83),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(93)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(93)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		94: {
			Flang: [16]TFcChar8{'j', 'v'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(216)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(94)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(216)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(94)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		95: {
			Flang: [16]TFcChar8{'k', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(217)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(95)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(217)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(95)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		96: {
			Flang: [16]TFcChar8{'k', 'a', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(218)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(96)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(218)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(96)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		97: {
			Flang: [16]TFcChar8{'k', 'a', 'b'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(4),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(24)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(97)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(24)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(97)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		98: {
			Flang: [16]TFcChar8{'k', 'i'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(219)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(98)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(219)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(98)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		99: {
			Flang: [16]TFcChar8{'k', 'j'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(99)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(99)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		100: {
			Flang: [16]TFcChar8{'k', 'k'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(221)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(100)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(221)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(100)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		101: {
			Flang: [16]TFcChar8{'k', 'l'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(222)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(101)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(222)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(101)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		102: {
			Flang: [16]TFcChar8{'k', 'm'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(224)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(102)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(224)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(102)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		103: {
			Flang: [16]TFcChar8{'k', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(225)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(103)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(225)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(103)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		104: {
			Flang: [16]TFcChar8{'k', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(45),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(104)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(104)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		105: {
			Flang: [16]TFcChar8{'k', 'o', 'k'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(105)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(105)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		106: {
			Flang: [16]TFcChar8{'k', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(271)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(106)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(271)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(106)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		107: {
			Flang: [16]TFcChar8{'k', 's'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(274)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(107)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(274)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(107)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		108: {
			Flang: [16]TFcChar8{'k', 'u', '-', 'a', 'm'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(275)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(108)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(275)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(108)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		109: {
			Flang: [16]TFcChar8{'k', 'u', '-', 'i', 'q'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(277)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(109)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(277)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(109)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		110: {
			Flang: [16]TFcChar8{'k', 'u', '-', 'i', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(277)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(110)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(277)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(110)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		111: {
			Flang: [16]TFcChar8{'k', 'u', '-', 't', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(278)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(111)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(278)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(111)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		112: {
			Flang: [16]TFcChar8{'k', 'u', 'm'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(280)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(112)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(280)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(112)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		113: {
			Flang: [16]TFcChar8{'k', 'v'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(281)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(113)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(281)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(113)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		114: {
			Flang: [16]TFcChar8{'k', 'w'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(282)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(114)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(282)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(114)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		115: {
			Flang: [16]TFcChar8{'k', 'w', 'm'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(115)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(115)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		116: {
			Flang: [16]TFcChar8{'k', 'y'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(285)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(116)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(285)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(116)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		117: {
			Flang: [16]TFcChar8{'l', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(286)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(117)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(286)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(117)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		118: {
			Flang: [16]TFcChar8{'l', 'a', 'h'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(288)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(118)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(288)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(118)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		119: {
			Flang: [16]TFcChar8{'l', 'b'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(289)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(119)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(289)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(119)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		120: {
			Flang: [16]TFcChar8{'l', 'e', 'z'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(16)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(120)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(16)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(120)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		121: {
			Flang: [16]TFcChar8{'l', 'g'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(290)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(121)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(290)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(121)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		122: {
			Flang: [16]TFcChar8{'l', 'i'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(292)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(122)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(292)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(122)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		123: {
			Flang: [16]TFcChar8{'l', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(4),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(293)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(123)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(293)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(123)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		124: {
			Flang: [16]TFcChar8{'l', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(297)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(124)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(297)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(124)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		125: {
			Flang: [16]TFcChar8{'l', 't'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(298)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(125)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(298)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(125)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		126: {
			Flang: [16]TFcChar8{'l', 'v'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(300)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(126)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(300)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(126)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		127: {
			Flang: [16]TFcChar8{'m', 'a', 'i'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(127)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(127)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		128: {
			Flang: [16]TFcChar8{'m', 'g'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(302)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(128)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(302)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(128)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		129: {
			Flang: [16]TFcChar8{'m', 'h'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(303)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(129)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(303)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(129)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		130: {
			Flang: [16]TFcChar8{'m', 'i'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(305)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(130)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(305)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(130)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		131: {
			Flang: [16]TFcChar8{'m', 'k'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(308)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(131)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(308)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(131)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		132: {
			Flang: [16]TFcChar8{'m', 'l'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(309)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(132)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(309)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(132)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		133: {
			Flang: [16]TFcChar8{'m', 'n', '-', 'c', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(310)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(133)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(310)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(133)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		134: {
			Flang: [16]TFcChar8{'m', 'n', '-', 'm', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(311)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(134)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(311)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(134)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		135: {
			Flang: [16]TFcChar8{'m', 'n', 'i'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(312)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(135)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(312)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(135)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		136: {
			Flang: [16]TFcChar8{'m', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(4),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(313)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(136)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(313)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(136)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		137: {
			Flang: [16]TFcChar8{'m', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(137)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(137)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		138: {
			Flang: [16]TFcChar8{'m', 's'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(138)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(138)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		139: {
			Flang: [16]TFcChar8{'m', 't'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(317)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(139)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(317)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(139)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		140: {
			Flang: [16]TFcChar8{'m', 'y'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(319)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(140)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(319)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(140)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		141: {
			Flang: [16]TFcChar8{'n', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(320)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(141)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(320)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(141)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		142: {
			Flang: [16]TFcChar8{'n', 'b'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(322)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(142)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(322)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(142)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		143: {
			Flang: [16]TFcChar8{'n', 'd', 's'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(67)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(143)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(67)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(143)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		144: {
			Flang: [16]TFcChar8{'n', 'e'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(323)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(144)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(323)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(144)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		145: {
			Flang: [16]TFcChar8{'n', 'g'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(145)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(145)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		146: {
			Flang: [16]TFcChar8{'n', 'l'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(324)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(146)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(324)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(146)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		147: {
			Flang: [16]TFcChar8{'n', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(325)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(147)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(325)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(147)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		148: {
			Flang: [16]TFcChar8{'n', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(322)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(148)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(322)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(148)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		149: {
			Flang: [16]TFcChar8{'n', 'q', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(326)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(149)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(326)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(149)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		150: {
			Flang: [16]TFcChar8{'n', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(150)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(150)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		151: {
			Flang: [16]TFcChar8{'n', 's', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(327)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(151)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(327)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(151)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		152: {
			Flang: [16]TFcChar8{'n', 'v'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(4),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(329)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(152)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(329)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(152)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		153: {
			Flang: [16]TFcChar8{'n', 'y'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(333)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(153)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(333)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(153)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		154: {
			Flang: [16]TFcChar8{'o', 'c'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(335)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(154)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(335)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(154)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		155: {
			Flang: [16]TFcChar8{'o', 'm'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(155)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(155)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		156: {
			Flang: [16]TFcChar8{'o', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(336)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(156)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(336)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(156)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		157: {
			Flang: [16]TFcChar8{'o', 's'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(280)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(157)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(280)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(157)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		158: {
			Flang: [16]TFcChar8{'o', 't', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(337)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(158)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(337)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(158)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		159: {
			Flang: [16]TFcChar8{'p', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(338)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(159)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(338)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(159)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		160: {
			Flang: [16]TFcChar8{'p', 'a', '-', 'p', 'k'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(288)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(160)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(288)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(160)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		161: {
			Flang: [16]TFcChar8{'p', 'a', 'p', '-', 'a', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(339)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(161)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(339)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(161)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		162: {
			Flang: [16]TFcChar8{'p', 'a', 'p', '-', 'a', 'w'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(340)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(162)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(340)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(162)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		163: {
			Flang: [16]TFcChar8{'p', 'l'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(341)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(163)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(341)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(163)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		164: {
			Flang: [16]TFcChar8{'p', 's', '-', 'a', 'f'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(343)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(164)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(343)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(164)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		165: {
			Flang: [16]TFcChar8{'p', 's', '-', 'p', 'k'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(344)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(165)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(344)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(165)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		166: {
			Flang: [16]TFcChar8{'p', 't'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(345)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(166)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(345)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(166)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		167: {
			Flang: [16]TFcChar8{'q', 'u'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(346)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(167)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(346)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(167)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		168: {
			Flang: [16]TFcChar8{'q', 'u', 'z'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(346)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(168)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(346)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(168)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		169: {
			Flang: [16]TFcChar8{'r', 'm'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(348)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(169)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(348)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(169)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		170: {
			Flang: [16]TFcChar8{'r', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(170)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(170)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		171: {
			Flang: [16]TFcChar8{'r', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(349)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(171)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(349)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(171)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		172: {
			Flang: [16]TFcChar8{'r', 'u'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(280)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(172)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(280)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(172)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		173: {
			Flang: [16]TFcChar8{'r', 'w'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(173)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(173)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		174: {
			Flang: [16]TFcChar8{'s', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(174)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(174)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		175: {
			Flang: [16]TFcChar8{'s', 'a', 'h'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(352)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(175)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(352)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(175)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		176: {
			Flang: [16]TFcChar8{'s', 'a', 't'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(353)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(176)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(353)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(176)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		177: {
			Flang: [16]TFcChar8{'s', 'c'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(354)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(177)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(354)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(177)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		178: {
			Flang: [16]TFcChar8{'s', 'c', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(355)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(178)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(355)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(178)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		179: {
			Flang: [16]TFcChar8{'s', 'd'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(358)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(179)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(358)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(179)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		180: {
			Flang: [16]TFcChar8{'s', 'e'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(359)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(180)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(359)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(180)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		181: {
			Flang: [16]TFcChar8{'s', 'e', 'l'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(280)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(181)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(280)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(181)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		182: {
			Flang: [16]TFcChar8{'s', 'g'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(361)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(182)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(361)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(182)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		183: {
			Flang: [16]TFcChar8{'s', 'h'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(362)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(183)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(362)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(183)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		184: {
			Flang: [16]TFcChar8{'s', 'h', 's'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(365)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(184)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(365)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(184)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		185: {
			Flang: [16]TFcChar8{'s', 'i'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(367)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(185)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(367)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(185)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		186: {
			Flang: [16]TFcChar8{'s', 'i', 'd'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(368)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(186)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(368)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(186)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		187: {
			Flang: [16]TFcChar8{'s', 'k'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(370)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(187)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(370)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(187)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		188: {
			Flang: [16]TFcChar8{'s', 'l'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(42)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(188)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(42)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(188)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		189: {
			Flang: [16]TFcChar8{'s', 'm'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(372)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(189)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(372)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(189)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		190: {
			Flang: [16]TFcChar8{'s', 'm', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(374)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(190)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(374)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(190)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		191: {
			Flang: [16]TFcChar8{'s', 'm', 'j'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(375)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(191)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(375)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(191)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		192: {
			Flang: [16]TFcChar8{'s', 'm', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(376)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(192)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(376)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(192)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		193: {
			Flang: [16]TFcChar8{'s', 'm', 's'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(378)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(193)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(378)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(193)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		194: {
			Flang: [16]TFcChar8{'s', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(194)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(194)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		195: {
			Flang: [16]TFcChar8{'s', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(195)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(195)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		196: {
			Flang: [16]TFcChar8{'s', 'q'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(381)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(196)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(381)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(196)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		197: {
			Flang: [16]TFcChar8{'s', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(382)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(197)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(382)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(197)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		198: {
			Flang: [16]TFcChar8{'s', 's'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(198)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(198)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		199: {
			Flang: [16]TFcChar8{'s', 't'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(199)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(199)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		200: {
			Flang: [16]TFcChar8{'s', 'u'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(118)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(200)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(118)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(200)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		201: {
			Flang: [16]TFcChar8{'s', 'v'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(383)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(201)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(383)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(201)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		202: {
			Flang: [16]TFcChar8{'s', 'w'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(202)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(202)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		203: {
			Flang: [16]TFcChar8{'s', 'y', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(384)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(203)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(384)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(203)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		204: {
			Flang: [16]TFcChar8{'t', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(385)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(204)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(385)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(204)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		205: {
			Flang: [16]TFcChar8{'t', 'e'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(386)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(205)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(386)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(205)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		206: {
			Flang: [16]TFcChar8{'t', 'g'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(387)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(206)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(387)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(206)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		207: {
			Flang: [16]TFcChar8{'t', 'h'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(388)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(207)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(388)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(207)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		208: {
			Flang: [16]TFcChar8{'t', 'i', '-', 'e', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(45)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(208)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(45)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(208)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		209: {
			Flang: [16]TFcChar8{'t', 'i', '-', 'e', 't'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(368)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(209)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(368)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(209)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		210: {
			Flang: [16]TFcChar8{'t', 'i', 'g'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(389)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(210)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(389)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(210)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		211: {
			Flang: [16]TFcChar8{'t', 'k'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(391)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(211)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(391)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(211)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		212: {
			Flang: [16]TFcChar8{'t', 'l'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(86)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(212)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(86)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(212)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		213: {
			Flang: [16]TFcChar8{'t', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(327)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(213)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(327)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(213)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		214: {
			Flang: [16]TFcChar8{'t', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(372)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(214)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(372)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(214)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		215: {
			Flang: [16]TFcChar8{'t', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(393)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(215)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(393)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(215)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		216: {
			Flang: [16]TFcChar8{'t', 's'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(216)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(216)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		217: {
			Flang: [16]TFcChar8{'t', 't'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(395)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(217)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(395)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(217)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		218: {
			Flang: [16]TFcChar8{'t', 'w'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(5),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(4)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(218)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(4)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(218)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		219: {
			Flang: [16]TFcChar8{'t', 'y'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(3),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(396)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(219)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(396)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(219)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		220: {
			Flang: [16]TFcChar8{'t', 'y', 'v'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(285)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(220)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(285)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(220)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		221: {
			Flang: [16]TFcChar8{'u', 'g'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(399)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(221)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(399)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(221)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		222: {
			Flang: [16]TFcChar8{'u', 'k'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(400)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(222)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(400)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(222)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		223: {
			Flang: [16]TFcChar8{'u', 'n', 'd', '-', 'z', 'm', 't', 'h'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(12),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(223)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(223)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		224: {
			Flang: [16]TFcChar8{'u', 'n', 'd', '-', 'z', 's', 'y', 'e'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(12),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(224)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(224)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		225: {
			Flang: [16]TFcChar8{'u', 'r'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(288)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(225)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(288)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(225)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		226: {
			Flang: [16]TFcChar8{'u', 'z'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(226)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(226)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		227: {
			Flang: [16]TFcChar8{'v', 'e'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(425)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(227)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(425)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(227)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		228: {
			Flang: [16]TFcChar8{'v', 'i'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(4),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(427)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(228)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(427)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(228)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		229: {
			Flang: [16]TFcChar8{'v', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(431)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(229)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(431)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(229)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		230: {
			Flang: [16]TFcChar8{'v', 'o', 't'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(432)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(230)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(432)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(230)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		231: {
			Flang: [16]TFcChar8{'w', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(434)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(231)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(434)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(231)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		232: {
			Flang: [16]TFcChar8{'w', 'a', 'l'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(368)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(232)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(368)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(232)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		233: {
			Flang: [16]TFcChar8{'w', 'e', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(435)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(233)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(435)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(233)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		234: {
			Flang: [16]TFcChar8{'w', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(2),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(437)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(234)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(437)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(234)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		235: {
			Flang: [16]TFcChar8{'x', 'h'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(235)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(235)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		236: {
			Flang: [16]TFcChar8{'y', 'a', 'p'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(439)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(236)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(439)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(236)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		237: {
			Flang: [16]TFcChar8{'y', 'i'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(108)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(237)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(108)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(237)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		238: {
			Flang: [16]TFcChar8{'y', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(4),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(440)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(238)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(440)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(238)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		239: {
			Flang: [16]TFcChar8{'z', 'a'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(239)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(239)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		240: {
			Flang: [16]TFcChar8{'z', 'h', '-', 'c', 'n'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(82),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(240)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(240)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		241: {
			Flang: [16]TFcChar8{'z', 'h', '-', 'h', 'k'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(171),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(241)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(241)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		242: {
			Flang: [16]TFcChar8{'z', 'h', '-', 'm', 'o'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(171),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(242)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(242)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		243: {
			Flang: [16]TFcChar8{'z', 'h', '-', 's', 'g'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(82),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(243)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(243)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		244: {
			Flang: [16]TFcChar8{'z', 'h', '-', 't', 'w'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(83),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(244)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(244)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
		245: {
			Flang: [16]TFcChar8{'z', 'u'},
			Fcharset: TFcCharSet{
				Fref: TFcRef{
					Fcount: -libc.Int32FromInt32(1),
				},
				Fnum:            int32(1),
				Fleaves_offset:  libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8) - (libc.Uint64FromInt32(245)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
				Fnumbers_offset: libc.Int64FromUint64(libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(780)*libc.Uint64FromInt64(8) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(2) - (libc.Uint64FromInt32(245)*libc.Uint64FromInt64(40) + uint64(libc.UintptrFromInt32(0)+16))),
			},
		},
	},
	Fleaves: [725]TFcCharLeaf{
		0: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x08104404),
				7: uint32(0x08104404),
			},
		},
		1: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff8002),
				1: uint32(0xffffffff),
				2: uint32(0x8002ffff),
				4: uint32(0xc0000000),
				5: uint32(0xf0fc33c0),
				6: uint32(0x03000000),
				7: uint32(0x00000003),
			},
		},
		2: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x0810cf00),
				7: uint32(0x0810cf00),
			},
		},
		3: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00000200),
			},
		},
		4: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00220008),
				7: uint32(0x00220008),
			},
		},
		5: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00000300),
				3: uint32(0x00000300),
				4: uint32(0x00010040),
			},
		},
		6: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x08100000),
			},
		},
		7: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000048),
				1: uint32(0x00000200),
			},
		},
		8: {
			Fmap1: [8]TFcChar32{
				5: uint32(0x30000000),
				7: uint32(0x03000000),
			},
		},
		9: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xff7fff7f),
				1: uint32(0xff01ff7f),
				2: uint32(0x00003d7f),
				3: uint32(0xffff7fff),
				4: uint32(0xffff3d7f),
				5: uint32(0x003d7fff),
				6: uint32(0xff7f7f00),
				7: uint32(0x00ff7fff),
			},
		},
		10: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x003d7fff),
				1: uint32(0xffffffff),
				2: uint32(0x007fff7f),
			},
		},
		11: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x140a2202),
				7: uint32(0x140a2202),
			},
		},
		12: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x07fffffe),
				2: uint32(0x000007fe),
			},
		},
		13: {
			Fmap1: [8]TFcChar32{
				4: uint32(0xfff99fee),
				5: uint32(0xd3c4fdff),
				6: uint32(0xb000399f),
				7: uint32(0x00030000),
			},
		},
		14: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00c00030),
			},
		},
		15: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0042),
				1: uint32(0xffffffff),
				2: uint32(0x0002ffff),
			},
		},
		16: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x10028010),
				7: uint32(0x10028010),
			},
		},
		17: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x10400080),
				7: uint32(0x10400080),
			},
		},
		18: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xc0000000),
				1: uint32(0x00030000),
				2: uint32(0xc0000000),
				4: uint32(0x00008000),
			},
		},
		19: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x02000000),
			},
		},
		20: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x07ffffde),
				2: uint32(0x001009f6),
				3: uint32(0x40000000),
				4: uint32(0x01000040),
				5: uint32(0x00008200),
				6: uint32(0x00001000),
			},
		},
		21: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0000),
				1: uint32(0xffffffff),
				2: uint32(0x0000ffff),
				4: uint32(0x030c0000),
				5: uint32(0x0c00cc0f),
				6: uint32(0x03000000),
				7: uint32(0x00000300),
			},
		},
		22: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff4040),
				1: uint32(0xffffffff),
				2: uint32(0x4040ffff),
			},
		},
		23: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
			},
		},
		24: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00003000),
				4: uint32(0x00110000),
				7: uint32(0x000000c0),
			},
		},
		25: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x08000000),
				3: uint32(0x00000008),
			},
		},
		26: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00003000),
				1: uint32(0x00000030),
				3: uint32(0x0000300c),
				4: uint32(0x000c0000),
			},
		},
		27: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x3a8b0000),
				2: uint32(0x9e78e6b9),
				3: uint32(0x0000802e),
			},
		},
		28: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0000),
				1: uint32(0xffffd7ff),
				2: uint32(0x0000d7ff),
			},
		},
		29: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffffffe0),
				1: uint32(0x83ffffff),
				2: uint32(0x00003fff),
			},
		},
		30: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x10008200),
				7: uint32(0x10008200),
			},
		},
		31: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x060c3303),
				7: uint32(0x060c3303),
			},
		},
		32: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000003),
			},
		},
		33: {
			Fmap1: [8]TFcChar32{
				5: uint32(0x03000000),
				6: uint32(0x00003000),
			},
		},
		34: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00000c00),
				4: uint32(0x20010040),
			},
		},
		35: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x08100000),
				3: uint32(0x00040000),
			},
		},
		36: {
			Fmap1: [8]TFcChar32{
				4: uint32(0xfff99fee),
				5: uint32(0xd3c5fdff),
				6: uint32(0xb000399f),
			},
		},
		37: {
			Fmap1: [8]TFcChar32{
				2: uint32(0xfffffeff),
				3: uint32(0x3d7e03ff),
				4: uint32(0xfeff0003),
				5: uint32(0x03ffffff),
			},
		},
		38: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x12120404),
				7: uint32(0x12120404),
			},
		},
		39: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfff99fee),
				1: uint32(0xf3e5fdff),
				2: uint32(0x0007399f),
				3: uint32(0x0001ffff),
			},
		},
		40: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x000330c0),
				3: uint32(0x60000003),
			},
		},
		41: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0002),
				1: uint32(0xffffffff),
				2: uint32(0x0002ffff),
				5: uint32(0x0c00c000),
			},
		},
		42: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xff7fff7f),
				1: uint32(0xff01ff00),
				2: uint32(0x3d7f3d7f),
				3: uint32(0xffff7fff),
				4: uint32(0xffff0000),
				5: uint32(0x003d7fff),
				6: uint32(0xff7f7f3d),
				7: uint32(0x00ff7fff),
			},
		},
		43: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x003d7fff),
				1: uint32(0xffffffff),
				2: uint32(0x007fff00),
			},
		},
		44: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x140ca381),
				7: uint32(0x140ca381),
			},
		},
		45: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x80000000),
				2: uint32(0x00000001),
			},
		},
		46: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x10020004),
				7: uint32(0x10020004),
			},
		},
		47: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0002),
				1: uint32(0xffffffff),
				2: uint32(0x0002ffff),
				5: uint32(0x00000030),
				6: uint32(0x000c0000),
				7: uint32(0x030300c0),
			},
		},
		48: {
			Fmap1: [8]TFcChar32{
				5: uint32(0xffffffff),
				6: uint32(0xffffffff),
				7: uint32(0x001fffff),
			},
		},
		49: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x1a10cfc5),
				7: uint32(0x9a10cfc5),
			},
		},
		50: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x000c0000),
				3: uint32(0x01000000),
			},
		},
		51: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x10420084),
				7: uint32(0x10420084),
			},
		},
		52: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xc0000000),
				1: uint32(0x00030000),
				2: uint32(0xc0000000),
			},
		},
		53: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x24082202),
				7: uint32(0x24082202),
			},
		},
		54: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0c00f000),
				2: uint32(0x03000180),
				3: uint32(0x6000c033),
			},
		},
		55: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x021c0a08),
				7: uint32(0x021c0a08),
			},
		},
		56: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000030),
				2: uint32(0x0000001e),
				3: uint32(0x18000000),
			},
		},
		57: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfdffa966),
				1: uint32(0xffffdfff),
				2: uint32(0xa965dfff),
				3: uint32(0x03ffffff),
			},
		},
		58: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0000000c),
			},
		},
		59: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0002),
				1: uint32(0xffffffff),
				2: uint32(0x0002ffff),
				5: uint32(0x00000c00),
				6: uint32(0x00c00000),
				7: uint32(0x000c0000),
			},
		},
		60: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x0010c604),
				7: uint32(0x8010c604),
			},
		},
		61: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x01f00000),
			},
		},
		62: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x0000003f),
				7: uint32(0x000c0000),
			},
		},
		63: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x25082262),
				7: uint32(0x25082262),
			},
		},
		64: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x90400010),
				7: uint32(0x10400010),
			},
		},
		65: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfff99fec),
				1: uint32(0xf3e5fdff),
				2: uint32(0xf807399f),
				3: uint32(0x0000ffff),
			},
		},
		66: {
			Fmap1: [8]TFcChar32{
				4: uint32(0xffffffff),
				5: uint32(0x0001ffff),
			},
		},
		67: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0c000000),
				2: uint32(0x00000c00),
				4: uint32(0x00170240),
				5: uint32(0x00040000),
				6: uint32(0x001fe000),
			},
		},
		68: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x08500000),
				3: uint32(0x00000008),
				4: uint32(0x00000800),
			},
		},
		69: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00001003),
			},
		},
		70: {
			Fmap1: [8]TFcChar32{
				4: uint32(0xffffd740),
				5: uint32(0xfffffffb),
				6: uint32(0x00007fff),
			},
		},
		71: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00528f81),
				7: uint32(0x00528f81),
			},
		},
		72: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x30000300),
				1: uint32(0x00300030),
				2: uint32(0x30000000),
				3: uint32(0x00003000),
			},
		},
		73: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x10600010),
				7: uint32(0x10600010),
			},
		},
		74: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x60000003),
			},
		},
		75: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x10020000),
				7: uint32(0x10020000),
			},
		},
		76: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00000c00),
				4: uint32(0x20000402),
				5: uint32(0x00180000),
			},
		},
		77: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00880000),
				3: uint32(0x00040000),
			},
		},
		78: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00400030),
				7: uint32(0x00400030),
			},
		},
		79: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x0e1e7707),
				7: uint32(0x0e1e7707),
			},
		},
		80: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x25092042),
				7: uint32(0x25092042),
			},
		},
		81: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x02041107),
				7: uint32(0x02041107),
			},
		},
		82: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x9c508e14),
				7: uint32(0x1c508e14),
			},
		},
		83: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x04082202),
				7: uint32(0x04082202),
			},
		},
		84: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000c00),
				1: uint32(0x00000003),
			},
		},
		85: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xc0000c0c),
				2: uint32(0x00c00003),
				3: uint32(0x00000c03),
			},
		},
		86: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x020c1383),
				7: uint32(0x020c1383),
			},
		},
		87: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xff7fff7f),
				1: uint32(0xff01ff7f),
				2: uint32(0x00003d7f),
				3: uint32(0x00ff00ff),
				4: uint32(0x00ff3d7f),
				5: uint32(0x003d7fff),
				6: uint32(0xff7f7f00),
				7: uint32(0x00ff7f00),
			},
		},
		88: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x003d7f00),
				1: uint32(0xffff01ff),
				2: uint32(0x007fff7f),
			},
		},
		89: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x040a2202),
				7: uint32(0x042a220a),
			},
		},
		90: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00000200),
				3: uint32(0x00000200),
			},
		},
		91: {
			Fmap1: [8]TFcChar32{
				5: uint32(0x20000000),
				7: uint32(0x02000000),
			},
		},
		92: {
			Fmap1: [8]TFcChar32{
				4: uint32(0xfffbafee),
				5: uint32(0xf3edfdff),
				6: uint32(0x00013bbf),
				7: uint32(0x00000001),
			},
		},
		93: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00000080),
				7: uint32(0x00000080),
			},
		},
		94: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x03000402),
				5: uint32(0x00180000),
			},
		},
		95: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00880000),
			},
		},
		96: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x000c0003),
				1: uint32(0x00000c00),
				2: uint32(0x00003000),
				3: uint32(0x00000c00),
			},
		},
		97: {
			Fmap1: [8]TFcChar32{
				5: uint32(0x08000000),
			},
		},
		98: {
			Fmap1: [8]TFcChar32{
				6: uint32(0xffff0000),
				7: uint32(0x000007ff),
			},
		},
		99: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00080000),
				7: uint32(0x00080000),
			},
		},
		100: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0c0030c0),
				2: uint32(0x0300001e),
				3: uint32(0x66000003),
			},
		},
		101: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00040100),
				7: uint32(0x00040100),
			},
		},
		102: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x14482202),
				7: uint32(0x14482202),
			},
		},
		103: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00030000),
				3: uint32(0x00030000),
			},
		},
		104: {
			Fmap1: [8]TFcChar32{
				1: uint32(0xfffe0000),
				2: uint32(0x007fffff),
				3: uint32(0xfffffffe),
				4: uint32(0x000000ff),
			},
		},
		105: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00008000),
			},
		},
		106: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x000c0000),
				2: uint32(0x00000c00),
			},
		},
		107: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00000200),
				7: uint32(0x00000200),
			},
		},
		108: {
			Fmap1: [8]TFcChar32{
				6: uint32(0x00003c00),
				7: uint32(0x00000030),
			},
		},
		109: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffffffff),
				1: uint32(0xffffffff),
				2: uint32(0xffffffff),
				3: uint32(0xffffffff),
				4: uint32(0xffffffff),
				5: uint32(0xffffffff),
				6: uint32(0xffffffff),
				7: uint32(0xffffffff),
			},
		},
		110: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffffffff),
				1: uint32(0xffffffff),
				2: uint32(0xffffffff),
				3: uint32(0xffffffff),
				4: uint32(0x00001fff),
			},
		},
		111: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff4002),
				1: uint32(0xffffffff),
				2: uint32(0x4002ffff),
			},
		},
		112: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x64092242),
				7: uint32(0x64092242),
			},
		},
		113: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x060cb301),
				7: uint32(0x060cb301),
			},
		},
		114: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000c7e),
				1: uint32(0x031f8000),
				2: uint32(0x0063f200),
				3: uint32(0x000df840),
				4: uint32(0x00037e08),
				5: uint32(0x08000dfa),
				6: uint32(0x0df901bf),
				7: uint32(0x5437e400),
			},
		},
		115: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000025),
				1: uint32(0x40006fc0),
				2: uint32(0x27f91be4),
				3: uint32(0xdee00000),
				4: uint32(0x007ff83f),
				5: uint32(0x00007f7f),
			},
		},
		116: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x007f8000),
			},
		},
		117: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x000000a7),
				2: uint32(0xfffffffe),
				3: uint32(0xffffffff),
				4: uint32(0x780fffff),
				5: uint32(0xfffffffe),
				6: uint32(0xffffffff),
				7: uint32(0x787fffff),
			},
		},
		118: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x03506f8b),
				1: uint32(0x1b042042),
				2: uint32(0x62808020),
				3: uint32(0x400a0000),
				4: uint32(0x10341b41),
				5: uint32(0x04003812),
				6: uint32(0x03608c02),
				7: uint32(0x08454038),
			},
		},
		119: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x2403c002),
				1: uint32(0x15108000),
				2: uint32(0x1229e040),
				3: uint32(0x80280000),
				4: uint32(0x28002800),
				5: uint32(0x8060c002),
				6: uint32(0x2080040c),
				7: uint32(0x05284002),
			},
		},
		120: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x82042a00),
				1: uint32(0x02000818),
				2: uint32(0x10008200),
				3: uint32(0x20700020),
				4: uint32(0x03022000),
				5: uint32(0x40a41000),
				6: uint32(0x0420a020),
				7: uint32(0x00000080),
			},
		},
		121: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x80040011),
				1: uint32(0x00000400),
				2: uint32(0x04012b78),
				3: uint32(0x11a23920),
				4: uint32(0x02842460),
				5: uint32(0x00c01021),
				6: uint32(0x20002050),
				7: uint32(0x07400042),
			},
		},
		122: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x208205c9),
				1: uint32(0x0fc10230),
				2: uint32(0x08402480),
				3: uint32(0x00258018),
				4: uint32(0x88000080),
				5: uint32(0x42120609),
				6: uint32(0xa32002a8),
				7: uint32(0x40040094),
			},
		},
		123: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00c00024),
				1: uint32(0x8e000001),
				2: uint32(0x059e058a),
				3: uint32(0x013b0001),
				4: uint32(0x85000010),
				5: uint32(0x08080000),
				6: uint32(0x02d07d04),
				7: uint32(0x018d9838),
			},
		},
		124: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x8803f310),
				1: uint32(0x03000840),
				2: uint32(0x00000704),
				3: uint32(0x30080500),
				4: uint32(0x00001000),
				5: uint32(0x20040000),
				6: uint32(0x00000003),
				7: uint32(0x04040002),
			},
		},
		125: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x000100d0),
				1: uint32(0x40028000),
				2: uint32(0x00088040),
				4: uint32(0x34000210),
				5: uint32(0x00400e00),
				6: uint32(0x00000020),
				7: uint32(0x00000008),
			},
		},
		126: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000040),
				1: uint32(0x00060000),
				3: uint32(0x00100100),
				4: uint32(0x00000080),
				6: uint32(0x4c000000),
				7: uint32(0x240d0009),
			},
		},
		127: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x80048000),
				1: uint32(0x00010180),
				2: uint32(0x00020484),
				3: uint32(0x00000400),
				4: uint32(0x00000804),
				5: uint32(0x00000008),
				6: uint32(0x80004800),
				7: uint32(0x16800000),
			},
		},
		128: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00200065),
				1: uint32(0x00120410),
				2: uint32(0x44920403),
				3: uint32(0x40000200),
				4: uint32(0x10880008),
				5: uint32(0x40080100),
				6: uint32(0x00001482),
				7: uint32(0x00074800),
			},
		},
		129: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x14608200),
				1: uint32(0x00024e84),
				2: uint32(0x00128380),
				3: uint32(0x20184520),
				4: uint32(0x0240041c),
				5: uint32(0x0a001120),
				6: uint32(0x00180a00),
				7: uint32(0x88000800),
			},
		},
		130: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x01000002),
				1: uint32(0x00008001),
				2: uint32(0x04000040),
				3: uint32(0x80000040),
				4: uint32(0x08040000),
				6: uint32(0x00001202),
				7: uint32(0x00000002),
			},
		},
		131: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00000004),
				2: uint32(0x21910000),
				3: uint32(0x00000858),
				4: uint32(0xbf8013a0),
				5: uint32(0x8279401c),
				6: uint32(0xa8041054),
				7: uint32(0xc5004282),
			},
		},
		132: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0402ce56),
				1: uint32(0xfc020000),
				2: uint32(0x40200d21),
				3: uint32(0x00028030),
				4: uint32(0x00010000),
				5: uint32(0x01081202),
				7: uint32(0x00410003),
			},
		},
		133: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00404080),
				1: uint32(0x00000200),
				2: uint32(0x00010000),
				6: uint32(0x60000000),
				7: uint32(0x480241ea),
			},
		},
		134: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x2000104c),
				1: uint32(0x2109a820),
				2: uint32(0x00200020),
				3: uint32(0x7b1c0008),
				4: uint32(0x10a0840a),
				5: uint32(0x01c028c0),
				6: uint32(0x00000608),
				7: uint32(0x04c00000),
			},
		},
		135: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x80398412),
				1: uint32(0x40a200e0),
				2: uint32(0x02080000),
				3: uint32(0x12030a04),
				4: uint32(0x008d1833),
				5: uint32(0x02184602),
				6: uint32(0x13803028),
				7: uint32(0x00200801),
			},
		},
		136: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x20440000),
				1: uint32(0x000005a1),
				2: uint32(0x00050800),
				3: uint32(0x0020a328),
				4: uint32(0x80100000),
				5: uint32(0x10040649),
				6: uint32(0x10020020),
				7: uint32(0x00090180),
			},
		},
		137: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x8c008202),
				2: uint32(0x00205910),
				3: uint32(0x0041410c),
				4: uint32(0x00004004),
				5: uint32(0x40441290),
				6: uint32(0x00010080),
				7: uint32(0x01040000),
			},
		},
		138: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x04070000),
				1: uint32(0x89108040),
				2: uint32(0x00282a81),
				3: uint32(0x82420000),
				4: uint32(0x51a20411),
				5: uint32(0x32220800),
				6: uint32(0x2b0d2220),
				7: uint32(0x40c83003),
			},
		},
		139: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x82020082),
				1: uint32(0x80008900),
				2: uint32(0x10a00200),
				3: uint32(0x08004100),
				4: uint32(0x09041108),
				5: uint32(0x000405a6),
				6: uint32(0x0c018000),
				7: uint32(0x04104002),
			},
		},
		140: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00002000),
				1: uint32(0x44003000),
				2: uint32(0x01000004),
				3: uint32(0x00008200),
				4: uint32(0x00000008),
				5: uint32(0x00044010),
				6: uint32(0x00002002),
				7: uint32(0x00001040),
			},
		},
		141: {
			Fmap1: [8]TFcChar32{
				1: uint32(0xca008000),
				2: uint32(0x02828020),
				3: uint32(0x00b1100c),
				4: uint32(0x12824280),
				5: uint32(0x22013030),
				6: uint32(0x00808820),
				7: uint32(0x040013e4),
			},
		},
		142: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x801840c0),
				1: uint32(0x1000a1a1),
				2: uint32(0x00000004),
				3: uint32(0x0050c200),
				4: uint32(0x00c20082),
				5: uint32(0x00104840),
				6: uint32(0x10400080),
				7: uint32(0xa3140000),
			},
		},
		143: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xa8a02301),
				1: uint32(0x24123d00),
				2: uint32(0x80030200),
				3: uint32(0xc0028022),
				4: uint32(0x34a10000),
				5: uint32(0x00408005),
				6: uint32(0x00190010),
				7: uint32(0x882a0000),
			},
		},
		144: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00080018),
				1: uint32(0x33000402),
				2: uint32(0x9002010a),
				4: uint32(0x00800020),
				5: uint32(0x00010100),
				6: uint32(0x84040810),
				7: uint32(0x04004000),
			},
		},
		145: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x10006020),
				3: uint32(0x30a02000),
				4: uint32(0x00000004),
				6: uint32(0x01000800),
				7: uint32(0x20000000),
			},
		},
		146: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x02000000),
				1: uint32(0x02000602),
				2: uint32(0x80000800),
			},
		},
		147: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000010),
				1: uint32(0x44040083),
				2: uint32(0x00081000),
				3: uint32(0x0818824c),
				4: uint32(0x00400e00),
				5: uint32(0x8c300000),
				6: uint32(0x08146001),
			},
		},
		148: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00828000),
				1: uint32(0x41900000),
				2: uint32(0x84804006),
				3: uint32(0x24010001),
				4: uint32(0x02400108),
				5: uint32(0x9b080006),
				6: uint32(0x00201602),
				7: uint32(0x0009012e),
			},
		},
		149: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x40800800),
				1: uint32(0x48000420),
				2: uint32(0x10000032),
				3: uint32(0x01904440),
				4: uint32(0x02000100),
				5: uint32(0x10048000),
				6: uint32(0x00020000),
				7: uint32(0x08820802),
			},
		},
		150: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x08080ba0),
				1: uint32(0x00009242),
				2: uint32(0x00400000),
				3: uint32(0xc0008080),
				4: uint32(0x20410001),
				5: uint32(0x04400000),
				6: uint32(0x60020820),
				7: uint32(0x00100000),
			},
		},
		151: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00108046),
				1: uint32(0x01001805),
				2: uint32(0x90100000),
				3: uint32(0x00014010),
				4: uint32(0x00000010),
				6: uint32(0x0000000b),
				7: uint32(0x00008800),
			},
		},
		152: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00001000),
				3: uint32(0x20018800),
				4: uint32(0x00004600),
				5: uint32(0x06002000),
				6: uint32(0x00000100),
			},
		},
		153: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x10400042),
				2: uint32(0x02004000),
				3: uint32(0x00004280),
				4: uint32(0x80000400),
				5: uint32(0x00020000),
				6: uint32(0x00000008),
				7: uint32(0x00000020),
			},
		},
		154: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000040),
				1: uint32(0x20600400),
				2: uint32(0x0a000180),
				3: uint32(0x02040280),
				5: uint32(0x00409001),
				6: uint32(0x02000004),
				7: uint32(0x00003200),
			},
		},
		155: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x88000000),
				1: uint32(0x80404800),
				2: uint32(0x00000010),
				3: uint32(0x00040008),
				4: uint32(0x00000a90),
				5: uint32(0x00000200),
				6: uint32(0x00002000),
				7: uint32(0x40002001),
			},
		},
		156: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000048),
				1: uint32(0x00100000),
				3: uint32(0x00000001),
				4: uint32(0x00000008),
				5: uint32(0x20010080),
				7: uint32(0x00400040),
			},
		},
		157: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x85000000),
				1: uint32(0x0c8f0108),
				2: uint32(0x32129000),
				3: uint32(0x80090420),
				4: uint32(0x00024000),
				5: uint32(0x40040800),
				6: uint32(0x092000a0),
				7: uint32(0x00100204),
			},
		},
		158: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00002000),
				2: uint32(0x00440004),
				3: uint32(0x6c000000),
				4: uint32(0x000000d0),
				5: uint32(0x80004000),
				6: uint32(0x88800440),
				7: uint32(0x41144018),
			},
		},
		159: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x80001a02),
				1: uint32(0x14000001),
				2: uint32(0x00000001),
				3: uint32(0x0000004a),
				5: uint32(0x00083000),
				6: uint32(0x08000000),
				7: uint32(0x0008a024),
			},
		},
		160: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00300004),
				1: uint32(0x00140000),
				2: uint32(0x20000000),
				3: uint32(0x00001800),
				4: uint32(0x00020002),
				5: uint32(0x04000000),
				6: uint32(0x00000002),
				7: uint32(0x00000100),
			},
		},
		161: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00004002),
				1: uint32(0x54000000),
				2: uint32(0x60400300),
				3: uint32(0x00002120),
				4: uint32(0x0000a022),
				6: uint32(0x81060803),
				7: uint32(0x08010200),
			},
		},
		162: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x04004800),
				1: uint32(0xb0044000),
				2: uint32(0x0000a005),
				3: uint32(0x04500800),
				4: uint32(0x800c000a),
				5: uint32(0x0000c000),
				6: uint32(0x10000800),
				7: uint32(0x02408021),
			},
		},
		163: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x08020000),
				1: uint32(0x00001040),
				2: uint32(0x00540a40),
				4: uint32(0x00800880),
				5: uint32(0x01020002),
				6: uint32(0x00000211),
				7: uint32(0x00000010),
			},
		},
		164: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x80000002),
				2: uint32(0x00002000),
				3: uint32(0x00080001),
				4: uint32(0x09840a00),
				5: uint32(0x40000080),
				6: uint32(0x00400000),
				7: uint32(0x49000080),
			},
		},
		165: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0e102831),
				1: uint32(0x06098807),
				2: uint32(0x40011014),
				3: uint32(0x02620042),
				4: uint32(0x06000000),
				5: uint32(0x88062000),
				6: uint32(0x04068400),
				7: uint32(0x08108301),
			},
		},
		166: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x08000012),
				1: uint32(0x40004840),
				2: uint32(0x00300402),
				3: uint32(0x00012000),
			},
		},
		167: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00400000),
				3: uint32(0x00a54400),
				4: uint32(0x40004420),
				5: uint32(0x20000310),
				6: uint32(0x00041002),
				7: uint32(0x18000000),
			},
		},
		168: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00a1002a),
				1: uint32(0x00080000),
				2: uint32(0x40400000),
				3: uint32(0x00900000),
				4: uint32(0x21401200),
				5: uint32(0x04048626),
				6: uint32(0x40005048),
				7: uint32(0x21100000),
			},
		},
		169: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x040005a4),
				1: uint32(0x000a0000),
				2: uint32(0x00214000),
				3: uint32(0x07010800),
				4: uint32(0x34000000),
				5: uint32(0x00080100),
				6: uint32(0x00080040),
				7: uint32(0x10182508),
			},
		},
		170: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xc0805100),
				1: uint32(0x02c01400),
				2: uint32(0x00000080),
				3: uint32(0x00448040),
				4: uint32(0x20000800),
				5: uint32(0x210a8000),
				6: uint32(0x08800000),
				7: uint32(0x00020060),
			},
		},
		171: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00004004),
				1: uint32(0x00400100),
				2: uint32(0x01040200),
				3: uint32(0x00800000),
				6: uint32(0x10081400),
				7: uint32(0x00008000),
			},
		},
		172: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00004000),
				1: uint32(0x20000000),
				2: uint32(0x08800200),
				3: uint32(0x00001000),
				5: uint32(0x01000000),
				6: uint32(0x00000810),
			},
		},
		173: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00020000),
				1: uint32(0x20200000),
				4: uint32(0x00000010),
				5: uint32(0x00001c40),
				6: uint32(0x00002000),
				7: uint32(0x08000210),
			},
		},
		174: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x54014000),
				3: uint32(0x02000800),
				4: uint32(0x00200400),
				6: uint32(0x00002080),
				7: uint32(0x00004000),
			},
		},
		175: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x10000004),
				4: uint32(0x00002000),
			},
		},
		176: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x28881041),
				3: uint32(0x0081010a),
				4: uint32(0x00400800),
				5: uint32(0x00000800),
				6: uint32(0x10208026),
				7: uint32(0x61000000),
			},
		},
		177: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00050080),
				2: uint32(0x80000000),
				3: uint32(0x80040000),
				4: uint32(0x044088c2),
				5: uint32(0x00080480),
				6: uint32(0x00040000),
				7: uint32(0x00000048),
			},
		},
		178: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x8188410d),
				1: uint32(0x141a2400),
				2: uint32(0x40310000),
				3: uint32(0x000f4249),
				4: uint32(0x41283280),
				5: uint32(0x80053011),
				6: uint32(0x00400880),
				7: uint32(0x410060c0),
			},
		},
		179: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x2a004013),
				1: uint32(0x02000002),
				2: uint32(0x11000000),
				3: uint32(0x00850040),
			},
		},
		180: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00800000),
				2: uint32(0x04000440),
				3: uint32(0x00000402),
				4: uint32(0x60001000),
				5: uint32(0x99909f87),
				6: uint32(0x5808049d),
				7: uint32(0x10002445),
			},
		},
		181: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000100),
				3: uint32(0x00910050),
				4: uint32(0x00000420),
				5: uint32(0x00080008),
				6: uint32(0x20000000),
				7: uint32(0x00288002),
			},
		},
		182: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00008400),
				1: uint32(0x00000400),
				3: uint32(0x00100000),
				4: uint32(0x00002000),
				5: uint32(0x00000800),
				6: uint32(0x80043400),
				7: uint32(0x21000004),
			},
		},
		183: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x20000208),
				1: uint32(0x01000600),
				2: uint32(0x00000010),
				4: uint32(0x48000000),
				5: uint32(0x14060008),
				6: uint32(0x00124020),
				7: uint32(0x20812800),
			},
		},
		184: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xa419804b),
				1: uint32(0x01064009),
				2: uint32(0x10386ca4),
				3: uint32(0x85a0620b),
				4: uint32(0x00000010),
				5: uint32(0x01000448),
				6: uint32(0x00004400),
				7: uint32(0x20a02102),
			},
		},
		185: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00147000),
				3: uint32(0x01a01404),
				4: uint32(0x10040000),
				5: uint32(0x01000000),
				6: uint32(0x3002f180),
				7: uint32(0x00000008),
			},
		},
		186: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00002000),
				1: uint32(0x00100000),
				2: uint32(0x08000010),
				3: uint32(0x00020004),
				4: uint32(0x01000029),
				5: uint32(0x00002000),
				7: uint32(0x10082000),
			},
		},
		187: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x0004d041),
				2: uint32(0x08000800),
				3: uint32(0x00200000),
				4: uint32(0x00401000),
				5: uint32(0x00004000),
				7: uint32(0x00000002),
			},
		},
		188: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x01000000),
				2: uint32(0x00020000),
			},
		},
		189: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x00800000),
				4: uint32(0x000a0a01),
				5: uint32(0x0004002c),
				6: uint32(0x01000080),
			},
		},
		190: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x10000000),
				1: uint32(0x08040400),
				2: uint32(0x08012010),
				3: uint32(0x2569043c),
				4: uint32(0x1a10c460),
				5: uint32(0x08800009),
				6: uint32(0x000210f0),
				7: uint32(0x08c5050c),
			},
		},
		191: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x10000481),
				1: uint32(0x00040080),
				2: uint32(0x42040000),
				3: uint32(0x00100204),
				6: uint32(0x00080000),
				7: uint32(0x88080000),
			},
		},
		192: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x010f016c),
				1: uint32(0x18002000),
				2: uint32(0x41307000),
				3: uint32(0x00000080),
				5: uint32(0x00000100),
				6: uint32(0x88000000),
				7: uint32(0x70048004),
			},
		},
		193: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00081420),
				1: uint32(0x00000100),
				4: uint32(0x02400000),
				5: uint32(0x00001000),
				6: uint32(0x00050070),
			},
		},
		194: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x000c4000),
				1: uint32(0x00010000),
				2: uint32(0x04000000),
				5: uint32(0x01000100),
				6: uint32(0x01000010),
				7: uint32(0x00000400),
			},
		},
		195: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x10020000),
				2: uint32(0x04100024),
				5: uint32(0x00004000),
				7: uint32(0x00000100),
			},
		},
		196: {
			Fmap1: [8]TFcChar32{
				7: uint32(0x00100020),
			},
		},
		197: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x00008000),
				5: uint32(0x00100000),
			},
		},
		198: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x80000000),
				4: uint32(0x00880000),
				5: uint32(0x0c000040),
				6: uint32(0x02040010),
			},
		},
		199: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00080000),
				1: uint32(0x08000000),
				3: uint32(0x00000004),
			},
		},
		200: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00000300),
				7: uint32(0x00000300),
			},
		},
		201: {
			Fmap1: [8]TFcChar32{
				6: uint32(0xffff0000),
				7: uint32(0x0001ffff),
			},
		},
		202: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0002),
				1: uint32(0xffffffff),
				2: uint32(0x0002ffff),
				4: uint32(0x0c0c0000),
				5: uint32(0x000cc00c),
				6: uint32(0x03000000),
			},
		},
		203: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00000300),
				3: uint32(0x00000300),
			},
		},
		204: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0000),
				1: uint32(0xffffffff),
				2: uint32(0x0040ffff),
				4: uint32(0x0c0c0000),
				5: uint32(0x0c00000c),
				6: uint32(0x03000000),
				7: uint32(0x00000300),
			},
		},
		205: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x0d10646e),
				7: uint32(0x0d10646e),
			},
		},
		206: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x01000300),
				3: uint32(0x00000300),
			},
		},
		207: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x9fffffff),
				5: uint32(0xffcffee7),
				6: uint32(0x0000003f),
			},
		},
		208: {
			Fmap1: [8]TFcChar32{
				4: uint32(0xfffddfec),
				5: uint32(0xc3effdff),
				6: uint32(0x40603ddf),
				7: uint32(0x00000003),
			},
		},
		209: {
			Fmap1: [8]TFcChar32{
				1: uint32(0xfffe0000),
				2: uint32(0xffffffff),
				3: uint32(0xffffffef),
				4: uint32(0x00007fff),
			},
		},
		210: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x3eff0793),
				1: uint32(0x1303b011),
				2: uint32(0x11102801),
				3: uint32(0x05930000),
				4: uint32(0xb0111e7b),
				5: uint32(0x3b019703),
				6: uint32(0x00a01112),
				7: uint32(0x306b9593),
			},
		},
		211: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x1102b051),
				1: uint32(0x11303201),
				2: uint32(0x011102b0),
				3: uint32(0xb879300a),
				4: uint32(0x30011306),
				5: uint32(0x00800010),
				6: uint32(0x100b0113),
				7: uint32(0x93000011),
			},
		},
		212: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00102b03),
				1: uint32(0x05930000),
				2: uint32(0xb051746b),
				3: uint32(0x3b011323),
				4: uint32(0x00001030),
				5: uint32(0x70000000),
				6: uint32(0x1303b011),
				7: uint32(0x11102900),
			},
		},
		213: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00012180),
				1: uint32(0xb0153000),
				2: uint32(0x3001030e),
				3: uint32(0x02000030),
				4: uint32(0x10230111),
				5: uint32(0x13000000),
				6: uint32(0x10106b81),
				7: uint32(0x01130300),
			},
		},
		214: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x30111013),
				1: uint32(0x00000100),
				2: uint32(0x22b85530),
				3: uint32(0x30000000),
				4: uint32(0x9702b011),
				5: uint32(0x113afb07),
				6: uint32(0x011303b0),
				7: uint32(0x00000021),
			},
		},
		215: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x3b0d1b00),
				1: uint32(0x03b01138),
				2: uint32(0x11330113),
				3: uint32(0x13000001),
				4: uint32(0x111c2b05),
				5: uint32(0x00000100),
				6: uint32(0xb0111000),
				7: uint32(0x2a011300),
			},
		},
		216: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x02b01930),
				1: uint32(0x10100001),
				2: uint32(0x11000000),
				3: uint32(0x10300301),
				4: uint32(0x07130230),
				5: uint32(0x0011146b),
				6: uint32(0x2b051300),
				7: uint32(0x8fb8f974),
			},
		},
		217: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x103b0113),
				2: uint32(0xd9700000),
				3: uint32(0x01134ab0),
				4: uint32(0x0011103b),
				5: uint32(0x00001103),
				6: uint32(0x2ab15930),
				7: uint32(0x10000111),
			},
		},
		218: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x11010000),
				1: uint32(0x00100b01),
				2: uint32(0x01130000),
				3: uint32(0x0000102b),
				4: uint32(0x20000101),
				5: uint32(0x02a01110),
				6: uint32(0x30210111),
				7: uint32(0x0102b059),
			},
		},
		219: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x19300000),
				1: uint32(0x011307b0),
				2: uint32(0xb011383b),
				3: uint32(0x00000003),
				5: uint32(0x383b0d13),
				6: uint32(0x0103b011),
				7: uint32(0x00001000),
			},
		},
		220: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x01130000),
				1: uint32(0x00101020),
				2: uint32(0x00000100),
				3: uint32(0x00000110),
				4: uint32(0x30000000),
				5: uint32(0x00021811),
				6: uint32(0x00100000),
				7: uint32(0x01110000),
			},
		},
		221: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000023),
				1: uint32(0x0b019300),
				2: uint32(0x00301110),
				3: uint32(0x302b0111),
				4: uint32(0x13c7b011),
				5: uint32(0x01303b01),
				6: uint32(0x00000280),
				7: uint32(0xb0113000),
			},
		},
		222: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x2b011383),
				1: uint32(0x03b01130),
				2: uint32(0x300a0011),
				3: uint32(0x1102b011),
				4: uint32(0x00002000),
				5: uint32(0x01110100),
				6: uint32(0xa011102b),
				7: uint32(0x2b011302),
			},
		},
		223: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x01000010),
				1: uint32(0x30000001),
				2: uint32(0x13029011),
				3: uint32(0x11302b01),
				4: uint32(0x000066b0),
				5: uint32(0xb0113000),
				6: uint32(0x6b07d302),
				7: uint32(0x07b0113a),
			},
		},
		224: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00200103),
				1: uint32(0x13000000),
				2: uint32(0x11386b05),
				3: uint32(0x011303b0),
				4: uint32(0x000010b8),
				5: uint32(0x2b051b00),
				6: uint32(0x03000110),
				7: uint32(0x10000000),
			},
		},
		225: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x1102a011),
				1: uint32(0x79700a01),
				2: uint32(0x0111a2b0),
				3: uint32(0x0000100a),
				4: uint32(0x00011100),
				5: uint32(0x00901110),
				6: uint32(0x00090111),
				7: uint32(0x93000000),
			},
		},
		226: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xf9f2bb05),
				1: uint32(0x011322b0),
				2: uint32(0x2001323b),
				4: uint32(0x06b05930),
				5: uint32(0x303b0193),
				6: uint32(0x1123a011),
				7: uint32(0x11700000),
			},
		},
		227: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x001102b0),
				1: uint32(0x00001010),
				2: uint32(0x03011301),
				3: uint32(0x00000110),
				4: uint32(0x162b0793),
				5: uint32(0x01010010),
				6: uint32(0x11300000),
				7: uint32(0x01110200),
			},
		},
		228: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xb0113029),
				2: uint32(0x0eb05130),
				3: uint32(0x383b0513),
				4: uint32(0x0303b011),
				5: uint32(0x00000100),
				6: uint32(0x01930000),
				7: uint32(0x00001039),
			},
		},
		229: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x3b000302),
				2: uint32(0x00230113),
				4: uint32(0x00100000),
				5: uint32(0x00010000),
				6: uint32(0x90113020),
				7: uint32(0x00000002),
			},
		},
		230: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x10000000),
				2: uint32(0x11020000),
				3: uint32(0x00000301),
				4: uint32(0x01130000),
				5: uint32(0xb079b02b),
				6: uint32(0x3b011323),
				7: uint32(0x02b01130),
			},
		},
		231: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xf0210111),
				1: uint32(0x1343b0d9),
				2: uint32(0x11303b01),
				3: uint32(0x011103b0),
				4: uint32(0xb0517020),
				5: uint32(0x20011322),
				6: uint32(0x01901110),
				7: uint32(0x300b0111),
			},
		},
		232: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x9302b011),
				1: uint32(0x0016ab01),
				2: uint32(0x01130100),
				3: uint32(0xb0113021),
				4: uint32(0x29010302),
				5: uint32(0x02b03130),
				6: uint32(0x30000000),
				7: uint32(0x1b42b819),
			},
		},
		233: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x11383301),
				1: uint32(0x00000330),
				2: uint32(0x00000020),
				3: uint32(0x33051300),
				4: uint32(0x00001110),
				6: uint32(0x93000000),
				7: uint32(0x01302305),
			},
		},
		234: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00010100),
				1: uint32(0x30111010),
				2: uint32(0x00000100),
				3: uint32(0x02301130),
				4: uint32(0x10100001),
				5: uint32(0x11000000),
				7: uint32(0x85130200),
			},
		},
		235: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x10111003),
				1: uint32(0x2b011300),
				2: uint32(0x63b87730),
				3: uint32(0x303b0113),
				4: uint32(0x11a2b091),
				5: uint32(0x7b300201),
				6: uint32(0x011357f0),
				7: uint32(0xf0d1702b),
			},
		},
		236: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x1b0111e3),
				1: uint32(0x0ab97130),
				2: uint32(0x303b0113),
				3: uint32(0x13029001),
				4: uint32(0x11302b01),
				5: uint32(0x071302b0),
				6: uint32(0x3011302b),
				7: uint32(0x23011303),
			},
		},
		237: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x02b01130),
				1: uint32(0x30ab0113),
				2: uint32(0x11feb411),
				3: uint32(0x71300901),
				4: uint32(0x05d347b8),
				5: uint32(0xb011307b),
				6: uint32(0x21015303),
				7: uint32(0x00001110),
			},
		},
		238: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x306b0513),
				1: uint32(0x1102b011),
				2: uint32(0x00103301),
				3: uint32(0x05130000),
				4: uint32(0xa01038eb),
				5: uint32(0x30000102),
				6: uint32(0x02b01110),
				7: uint32(0x30200013),
			},
		},
		239: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0102b071),
				1: uint32(0x00101000),
				2: uint32(0x01130000),
				3: uint32(0x1011100b),
				4: uint32(0x2b011300),
				6: uint32(0x366b0593),
				7: uint32(0x1303b095),
			},
		},
		240: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x01103b01),
				1: uint32(0x00000200),
				2: uint32(0xb0113000),
				3: uint32(0x20000103),
				4: uint32(0x01000010),
				5: uint32(0x30000000),
				6: uint32(0x030ab011),
				7: uint32(0x00101001),
			},
		},
		241: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x01110100),
				1: uint32(0x00000003),
				2: uint32(0x23011302),
				3: uint32(0x03000010),
				4: uint32(0x10000000),
				5: uint32(0x01000000),
				6: uint32(0x00100000),
				7: uint32(0x00000290),
			},
		},
		242: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x30113000),
				1: uint32(0x7b015386),
				2: uint32(0x03b01130),
				3: uint32(0x00210151),
				4: uint32(0x13000000),
				5: uint32(0x11303b01),
				6: uint32(0x001102b0),
				7: uint32(0x00011010),
			},
		},
		243: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x2b011302),
				1: uint32(0x02001110),
				2: uint32(0x10000000),
				3: uint32(0x0102b011),
				4: uint32(0x11300100),
				5: uint32(0x000102b0),
				6: uint32(0x00011010),
				7: uint32(0x2b011100),
			},
		},
		244: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x02101110),
				1: uint32(0x002b0113),
				2: uint32(0x93000000),
				3: uint32(0x11302b03),
				4: uint32(0x011302b0),
				5: uint32(0x0000303b),
				6: uint32(0x00000002),
				7: uint32(0x03b01930),
			},
		},
		245: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x102b0113),
				1: uint32(0x0103b011),
				2: uint32(0x11300000),
				3: uint32(0x011302b0),
				4: uint32(0x00001021),
				5: uint32(0x00010102),
				6: uint32(0x00000010),
				7: uint32(0x102b0113),
			},
		},
		246: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x01020011),
				1: uint32(0x11302000),
				2: uint32(0x011102b0),
				3: uint32(0x30113001),
				4: uint32(0x00000002),
				5: uint32(0x02b01130),
				6: uint32(0x303b0313),
				7: uint32(0x0103b011),
			},
		},
		247: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00002000),
				1: uint32(0x05130000),
				2: uint32(0xb011303b),
				3: uint32(0x10001102),
				4: uint32(0x00000110),
				5: uint32(0x142b0113),
				6: uint32(0x01000001),
				7: uint32(0x01100000),
			},
		},
		248: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00010280),
				1: uint32(0xb0113000),
				2: uint32(0x10000102),
				3: uint32(0x00000010),
				4: uint32(0x10230113),
				5: uint32(0x93021011),
				6: uint32(0x11100b05),
				7: uint32(0x01130030),
			},
		},
		249: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xb051702b),
				1: uint32(0x3b011323),
				2: uint32(0x00000030),
				3: uint32(0x30000000),
				4: uint32(0x1303b011),
				5: uint32(0x11102b01),
				6: uint32(0x01010330),
				7: uint32(0xb011300a),
			},
		},
		250: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x20000102),
				2: uint32(0x10000011),
				3: uint32(0x9300a011),
				4: uint32(0x00102b05),
				5: uint32(0x00000200),
				6: uint32(0x90111000),
				7: uint32(0x29011100),
			},
		},
		251: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00b01110),
				1: uint32(0x30000000),
				2: uint32(0x1302b011),
				3: uint32(0x11302b21),
				4: uint32(0x000103b0),
				5: uint32(0x00000020),
				6: uint32(0x2b051300),
				7: uint32(0x02b01130),
			},
		},
		252: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x103b0113),
				1: uint32(0x13002011),
				2: uint32(0x11322b21),
				3: uint32(0x00130280),
				4: uint32(0xa0113028),
				5: uint32(0x0a011102),
				6: uint32(0x02921130),
				7: uint32(0x30210111),
			},
		},
		253: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x13020011),
				1: uint32(0x11302b01),
				2: uint32(0x03d30290),
				3: uint32(0x3011122b),
				4: uint32(0x2b011302),
			},
		},
		254: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x00004000),
				6: uint32(0x20000000),
			},
		},
		255: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00003000),
			},
		},
		256: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x040001df),
				2: uint32(0x80800176),
				3: uint32(0x420c0000),
				4: uint32(0x01020140),
				5: uint32(0x44008200),
				6: uint32(0x00041018),
			},
		},
		257: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0000),
				1: uint32(0xffff27bf),
				2: uint32(0x000027bf),
				5: uint32(0x0c000000),
				6: uint32(0x03000000),
				7: uint32(0x000000c0),
			},
		},
		258: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x3c000000),
			},
		},
		259: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x061ef5c0),
				2: uint32(0x000001f6),
				3: uint32(0x40000000),
				4: uint32(0x01040040),
				5: uint32(0x00208210),
				6: uint32(0x00005040),
			},
		},
		260: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x08004480),
				7: uint32(0x08004480),
			},
		},
		261: {
			Fmap1: [8]TFcChar32{
				2: uint32(0xc0000000),
			},
		},
		262: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0002),
				1: uint32(0xffffffff),
				2: uint32(0x0002ffff),
			},
		},
		263: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0042),
				1: uint32(0xffffffff),
				2: uint32(0x0042ffff),
				7: uint32(0x000000c0),
			},
		},
		264: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x000c0000),
			},
		},
		265: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0002),
				1: uint32(0xffffffff),
				2: uint32(0x0002ffff),
				5: uint32(0x0000c00c),
			},
		},
		266: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x000c0003),
				1: uint32(0x00003c00),
				2: uint32(0x0000f000),
				3: uint32(0x00003c00),
			},
		},
		267: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x040001de),
				2: uint32(0x00000176),
				3: uint32(0x42000000),
				4: uint32(0x01020140),
				5: uint32(0x44008200),
				6: uint32(0x00041008),
			},
		},
		268: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x98504f14),
				7: uint32(0x18504f14),
			},
		},
		269: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00000c00),
			},
		},
		270: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00480910),
				7: uint32(0x00480910),
			},
		},
		271: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x0c186606),
				7: uint32(0x0c186606),
			},
		},
		272: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0c000000),
				4: uint32(0x00010040),
			},
		},
		273: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00001006),
			},
		},
		274: {
			Fmap1: [8]TFcChar32{
				4: uint32(0xfef02596),
				5: uint32(0x3bffecae),
				6: uint32(0x30003f5f),
			},
		},
		275: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x03c03030),
				1: uint32(0x0000c000),
				3: uint32(0x600c0c03),
			},
		},
		276: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x000c3003),
				1: uint32(0x18c00c0c),
				2: uint32(0x00c03060),
				3: uint32(0x60000c03),
			},
		},
		277: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00100002),
				7: uint32(0x00100002),
			},
		},
		278: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000003),
				1: uint32(0x18000000),
				2: uint32(0x00003060),
				3: uint32(0x00000c00),
			},
		},
		279: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00300000),
			},
		},
		280: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfdffb729),
				1: uint32(0x000001ff),
				2: uint32(0xb7290000),
			},
		},
		281: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfffddfec),
				1: uint32(0xc3fffdff),
				2: uint32(0x00803dcf),
				3: uint32(0x00000003),
			},
		},
		282: {
			Fmap1: [8]TFcChar32{
				1: uint32(0xffffffff),
				2: uint32(0xffffffff),
				3: uint32(0x00ffffff),
				4: uint32(0xffffffff),
				5: uint32(0x000003ff),
			},
		},
		283: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0002),
				1: uint32(0xffffffff),
				2: uint32(0x0002ffff),
				5: uint32(0x0000c000),
				7: uint32(0x00000300),
			},
		},
		284: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x00000010),
				4: uint32(0xfff99fee),
				5: uint32(0xf3c5fdff),
				6: uint32(0xb000798f),
				7: uint32(0x0002ffc0),
			},
		},
		285: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00004004),
				7: uint32(0x00004004),
			},
		},
		286: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0f000000),
			},
		},
		287: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x02045101),
				7: uint32(0x02045101),
			},
		},
		288: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000c00),
				1: uint32(0x000000c3),
				3: uint32(0x18000000),
			},
		},
		289: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffffffff),
				1: uint32(0x0007f6fb),
			},
		},
		290: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x00000300),
			},
		},
		291: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x011c0661),
				7: uint32(0x011c0661),
			},
		},
		292: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfff98fee),
				1: uint32(0xc3e5fdff),
				2: uint32(0x0001398f),
				3: uint32(0x0001fff0),
			},
		},
		293: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x1c58af16),
				7: uint32(0x1c58af16),
			},
		},
		294: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x115c0671),
				7: uint32(0x115c0671),
			},
		},
		295: {
			Fmap1: [8]TFcChar32{
				6: uint32(0xffffffff),
				7: uint32(0x07ffffff),
			},
		},
		296: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00100400),
				7: uint32(0x00100400),
			},
		},
		297: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x00000003),
			},
		},
		298: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00082202),
				7: uint32(0x00082202),
			},
		},
		299: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x03000030),
				1: uint32(0x0000c000),
				2: uint32(0x00000006),
				7: uint32(0x00000c00),
			},
		},
		300: {
			Fmap1: [8]TFcChar32{
				5: uint32(0x10000000),
			},
		},
		301: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000002),
			},
		},
		302: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x00300000),
			},
		},
		303: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x040c2383),
				7: uint32(0x040c2383),
			},
		},
		304: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfff99fee),
				1: uint32(0xf3cdfdff),
				2: uint32(0xb0c0398f),
				3: uint32(0x00000003),
			},
		},
		305: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x07ffffc6),
				2: uint32(0x000001fe),
				3: uint32(0x40000000),
				4: uint32(0x01000040),
				5: uint32(0x0000a000),
				6: uint32(0x00001000),
			},
		},
		306: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfff987e0),
				1: uint32(0xd36dfdff),
				2: uint32(0x1e003987),
				3: uint32(0x001f0000),
			},
		},
		307: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x160e2302),
				7: uint32(0x160e2302),
			},
		},
		308: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00020000),
				7: uint32(0x00020000),
			},
		},
		309: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x030000f0),
				2: uint32(0x0c00001e),
				3: uint32(0x1e000000),
			},
		},
		310: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x07ffffde),
				2: uint32(0x000005f6),
				3: uint32(0x50000000),
				4: uint32(0x05480262),
				5: uint32(0x10000a00),
				6: uint32(0x00013000),
			},
		},
		311: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x07ffffde),
				2: uint32(0x000005f6),
				3: uint32(0x50000000),
				4: uint32(0x05480262),
				5: uint32(0x10000a00),
				6: uint32(0x00052000),
			},
		},
		312: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x143c278f),
				7: uint32(0x143c278f),
			},
		},
		313: {
			Fmap1: [8]TFcChar32{
				6: uint32(0x00000100),
			},
		},
		314: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x02045301),
				7: uint32(0x02045301),
			},
		},
		315: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0002),
				1: uint32(0xffffffff),
				2: uint32(0x0002ffff),
				4: uint32(0x00300000),
				5: uint32(0x0c00c030),
				6: uint32(0x03000000),
			},
		},
		316: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfff987ee),
				1: uint32(0xf325fdff),
				2: uint32(0x00013987),
				3: uint32(0x0001fff0),
			},
		},
		317: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x02041101),
				7: uint32(0x02041101),
			},
		},
		318: {
			Fmap1: [8]TFcChar32{
				5: uint32(0x00800000),
			},
		},
		319: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x30000000),
				4: uint32(0x00040000),
			},
		},
		320: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x07fffdd6),
				2: uint32(0x000005f6),
				3: uint32(0xec000000),
				4: uint32(0x0200b4d9),
				5: uint32(0x480a8640),
			},
		},
		321: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00000002),
				7: uint32(0x00000002),
			},
		},
		322: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00033000),
				2: uint32(0x00000c00),
				3: uint32(0x600000c3),
			},
		},
		323: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x1850cc14),
				7: uint32(0x1850cc14),
			},
		},
		324: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff8f04),
				1: uint32(0xffffffff),
				2: uint32(0x8f04ffff),
				4: uint32(0x030c0000),
				5: uint32(0x0c00cc0f),
				6: uint32(0x03000000),
				7: uint32(0x00000300),
			},
		},
		325: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00800000),
				2: uint32(0x03bffbaa),
				3: uint32(0x03bffbaa),
				6: uint32(0x00002202),
				7: uint32(0x00002202),
			},
		},
		326: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00080000),
			},
		},
		327: {
			Fmap1: [8]TFcChar32{
				4: uint32(0xfc7e3fec),
				5: uint32(0x2ffbffbf),
				6: uint32(0x7f5f847f),
				7: uint32(0x00040000),
			},
		},
		328: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xff7fff7f),
				1: uint32(0xff01ff7f),
				2: uint32(0x3d7f3d7f),
				3: uint32(0xffff7fff),
				4: uint32(0xffff3d7f),
				5: uint32(0x003d7fff),
				6: uint32(0xff7f7f3d),
				7: uint32(0x00ff7fff),
			},
		},
		329: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x24182212),
				7: uint32(0x24182212),
			},
		},
		330: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0000f000),
				1: uint32(0x66000000),
				2: uint32(0x00300180),
				3: uint32(0x60000033),
			},
		},
		331: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00408030),
				7: uint32(0x00408030),
			},
		},
		332: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00020032),
				7: uint32(0x00020032),
			},
		},
		333: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00000016),
				7: uint32(0x00000016),
			},
		},
		334: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00033000),
				2: uint32(0x00000c00),
				3: uint32(0x60000003),
			},
		},
		335: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00200034),
				7: uint32(0x00200034),
			},
		},
		336: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00033000),
				2: uint32(0x00000c00),
				3: uint32(0x60000003),
				5: uint32(0x00800000),
				7: uint32(0x0000c3f0),
			},
		},
		337: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x00040000),
			},
		},
		338: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00000880),
				7: uint32(0x00000880),
			},
		},
		339: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfdff8f04),
				1: uint32(0xfdff01ff),
				2: uint32(0x8f0401ff),
			},
		},
		340: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x10400a33),
				7: uint32(0x10400a33),
			},
		},
		341: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0000),
				1: uint32(0xffff1fff),
			},
		},
		342: {
			Fmap1: [8]TFcChar32{
				4: uint32(0xd63dc7e8),
				5: uint32(0xc3bfc718),
				6: uint32(0x00803dc7),
			},
		},
		343: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfffddfee),
				1: uint32(0xc3effdff),
				2: uint32(0x00603ddf),
				3: uint32(0x00000003),
			},
		},
		344: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0002),
				1: uint32(0xffffffff),
				2: uint32(0x0002ffff),
				4: uint32(0x0c0c0000),
				5: uint32(0x00cc0000),
				7: uint32(0x0000c00c),
			},
		},
		345: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfffffffe),
				1: uint32(0x87ffffff),
				2: uint32(0x00007fff),
			},
		},
		346: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xff7fff7f),
				1: uint32(0xff01ff00),
				2: uint32(0x00003d7f),
				3: uint32(0xffff7fff),
				4: uint32(0x00ff0000),
				5: uint32(0x003d7f7f),
				6: uint32(0xff7f7f00),
				7: uint32(0x00ff7f00),
			},
		},
		347: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x30400090),
				7: uint32(0x30400090),
			},
		},
		348: {
			Fmap1: [8]TFcChar32{
				2: uint32(0xc0000180),
				3: uint32(0x60000000),
			},
		},
		349: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x18404084),
				7: uint32(0x18404084),
			},
		},
		350: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff0002),
				1: uint32(0xffffffff),
				2: uint32(0x0002ffff),
				4: uint32(0x00c00000),
				5: uint32(0x0c00c00c),
				6: uint32(0x03000000),
			},
		},
		351: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00008000),
				7: uint32(0x00008000),
			},
		},
		352: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x041ed5c0),
				2: uint32(0x0000077e),
				3: uint32(0x40000000),
				4: uint32(0x01000040),
				5: uint32(0x4000a000),
				6: uint32(0x002109c0),
			},
		},
		353: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffff00d0),
				1: uint32(0xffffffff),
				2: uint32(0x00d0ffff),
				4: uint32(0x00030000),
			},
		},
		354: {
			Fmap1: [8]TFcChar32{
				1: uint32(0xffffff7b),
				2: uint32(0x7fffffff),
				3: uint32(0x7ffffffe),
				5: uint32(0x80e310fe),
				6: uint32(0x00800000),
				7: uint32(0x00800000),
			},
		},
		355: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00020000),
			},
		},
		356: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00001500),
				1: uint32(0x01000000),
				4: uint32(0xfffe0000),
				5: uint32(0xfffe03db),
				6: uint32(0x006003fb),
				7: uint32(0x00030000),
			},
		},
		357: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00400000),
				1: uint32(0x00000047),
				2: uint32(0x00800010),
				7: uint32(0x00000002),
			},
		},
		358: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x3f2fc004),
				1: uint32(0x00000010),
			},
		},
		359: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xe3ffbfff),
				1: uint32(0xfff007ff),
				2: uint32(0x00000001),
				4: uint32(0xfffff000),
				5: uint32(0x0000003f),
				6: uint32(0x0000e10f),
			},
		},
		360: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000f00),
				1: uint32(0x0000000c),
			},
		},
		361: {
			Fmap1: [8]TFcChar32{
				5: uint32(0x00000003),
			},
		},
		362: {
			Fmap1: [8]TFcChar32{
				7: uint32(0x000003c0),
			},
		},
		363: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffffffff),
				1: uint32(0xffffffff),
				2: uint32(0xffdfffff),
				3: uint32(0xffffffff),
				4: uint32(0xdfffffff),
				5: uint32(0x00001e64),
			},
		},
		364: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x78000000),
				2: uint32(0x0001fc5f),
			},
		},
		365: {
			Fmap1: [8]TFcChar32{
				5: uint32(0x00000030),
			},
		},
		366: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0c000000),
				7: uint32(0x00091e00),
			},
		},
		367: {
			Fmap1: [8]TFcChar32{
				7: uint32(0x60000000),
			},
		},
		368: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00300000),
				2: uint32(0x000fff00),
				3: uint32(0x80000000),
				4: uint32(0x00080000),
				5: uint32(0x60000c02),
				6: uint32(0x00104030),
				7: uint32(0x242c0400),
			},
		},
		369: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000c20),
				1: uint32(0x00000100),
				2: uint32(0x00b85000),
				4: uint32(0x00e00000),
				5: uint32(0x80010000),
			},
		},
		370: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x18000000),
				2: uint32(0x00210000),
			},
		},
		371: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000010),
				6: uint32(0x00008000),
			},
		},
		372: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x07fe4000),
				7: uint32(0xffffffc0),
			},
		},
		373: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x04000002),
				1: uint32(0x077c8000),
				2: uint32(0x00030000),
			},
		},
		374: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffffffff),
				1: uint32(0xffbf0001),
				2: uint32(0xffffffff),
				3: uint32(0x1fffffff),
				4: uint32(0x000fffff),
				5: uint32(0xffffffff),
				6: uint32(0x000007df),
				7: uint32(0x0001ffff),
			},
		},
		375: {
			Fmap1: [8]TFcChar32{
				2: uint32(0xfffffffd),
				3: uint32(0xffffffff),
				4: uint32(0xffffffff),
				5: uint32(0xffffffff),
				6: uint32(0xffffffff),
				7: uint32(0x1effffff),
			},
		},
		376: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffffffff),
				1: uint32(0x3fffffff),
				2: uint32(0xffff0000),
				3: uint32(0x000000ff),
				7: uint32(0xf8000000),
			},
		},
		377: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x755dfffe),
				1: uint32(0xffef2f3f),
				2: uint32(0x0000ffe1),
			},
		},
		378: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x000c0000),
				1: uint32(0x30000000),
				2: uint32(0x00000c30),
				3: uint32(0x00030000),
			},
		},
		379: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x263c370f),
				7: uint32(0x263c370f),
			},
		},
		380: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0003000c),
				1: uint32(0x00000300),
				3: uint32(0x00000300),
				5: uint32(0x00018003),
			},
		},
		381: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0800024f),
				1: uint32(0x00000008),
			},
		},
		382: {
			Fmap1: [8]TFcChar32{
				5: uint32(0xffffffff),
				6: uint32(0xffffffff),
				7: uint32(0x03ffffff),
			},
		},
		383: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x077dfffe),
				3: uint32(0x077dfffe),
				6: uint32(0x10400010),
				7: uint32(0x10400010),
			},
		},
		384: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x10400010),
				7: uint32(0x10400010),
			},
		},
		385: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x081047a4),
				7: uint32(0x081047a4),
			},
		},
		386: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0c0030c0),
				2: uint32(0x0f30001e),
				3: uint32(0x66000003),
			},
		},
		387: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x000a0a09),
				7: uint32(0x000a0a09),
			},
		},
		388: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x00400810),
				7: uint32(0x00400810),
			},
		},
		389: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x07fffffe),
				3: uint32(0x07fffffe),
				6: uint32(0x0e3c770f),
				7: uint32(0x0e3c770f),
			},
		},
		390: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0c000000),
				1: uint32(0x00000300),
				2: uint32(0x00000018),
				3: uint32(0x00000300),
				6: uint32(0x001fe000),
				7: uint32(0x03000000),
			},
		},
		391: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0000100f),
			},
		},
		392: {
			Fmap1: [8]TFcChar32{
				1: uint32(0xc0000000),
				3: uint32(0x0000000c),
				5: uint32(0x33000000),
				6: uint32(0x00003000),
			},
		},
		393: {
			Fmap1: [8]TFcChar32{
				6: uint32(0x00000280),
			},
		},
		394: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x7f7b7f8b),
				1: uint32(0xef553db4),
				2: uint32(0xf35dfba8),
				3: uint32(0x400b0243),
				4: uint32(0x8d3efb40),
				5: uint32(0x8c2c7bf7),
				6: uint32(0xe3fa6eff),
				7: uint32(0xa8ed1d3a),
			},
		},
		395: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xcf83e602),
				1: uint32(0x35558cf5),
				2: uint32(0xffabe048),
				3: uint32(0xd85992b9),
				4: uint32(0x2892ab18),
				5: uint32(0x8020d7e9),
				6: uint32(0xf583c438),
				7: uint32(0x450ae74a),
			},
		},
		396: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x9714b000),
				1: uint32(0x54007762),
				2: uint32(0x1420d188),
				3: uint32(0xc8c01020),
				4: uint32(0x00002121),
				5: uint32(0x0c0413a8),
				6: uint32(0x04408000),
				7: uint32(0x082870c0),
			},
		},
		397: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x000408c0),
				1: uint32(0x80000002),
				2: uint32(0x14722b7b),
				3: uint32(0x3bfb7924),
				4: uint32(0x1ae43327),
				5: uint32(0x38ef9835),
				6: uint32(0x28029ad1),
				7: uint32(0xbf69a813),
			},
		},
		398: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x2fc665cf),
				1: uint32(0xafc96b11),
				2: uint32(0x5053340f),
				3: uint32(0xa00486a2),
				4: uint32(0xe8090106),
				5: uint32(0xc00e3f0f),
				6: uint32(0x81450a88),
				7: uint32(0xc6010010),
			},
		},
		399: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x26e1a161),
				1: uint32(0xce00444b),
				2: uint32(0xd4eec7aa),
				3: uint32(0x85bbcadf),
				4: uint32(0xa5203a74),
				5: uint32(0x8840436c),
				6: uint32(0x8bd23f06),
				7: uint32(0x3befff79),
			},
		},
		400: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xe8eff75a),
				1: uint32(0x5b36fbcb),
				2: uint32(0x1bfd0d49),
				3: uint32(0x39ee0154),
				4: uint32(0x2e75d855),
				5: uint32(0xa91abfd8),
				6: uint32(0xf6bff3d7),
				7: uint32(0xb40c67e0),
			},
		},
		401: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x081382c2),
				1: uint32(0xd08bd49d),
				2: uint32(0x1061065a),
				3: uint32(0x59e074f2),
				4: uint32(0xb3128f9f),
				5: uint32(0x6aaa0080),
				6: uint32(0xb05e3230),
				7: uint32(0x60ac9d7a),
			},
		},
		402: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xc900d303),
				1: uint32(0x8a563098),
				2: uint32(0x13907000),
				3: uint32(0x18421f14),
				4: uint32(0x0008c060),
				5: uint32(0x10808008),
				6: uint32(0xec900400),
				7: uint32(0xe6332817),
			},
		},
		403: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x90000758),
				1: uint32(0x4e09f708),
				2: uint32(0xfc83f485),
				3: uint32(0x18c8af53),
				4: uint32(0x080c187c),
				5: uint32(0x01146adf),
				6: uint32(0xa734c80c),
				7: uint32(0x2710a011),
			},
		},
		404: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x422228c5),
				1: uint32(0x00210413),
				2: uint32(0x41123010),
				3: uint32(0x40001820),
				4: uint32(0xc60c022b),
				5: uint32(0x10000300),
				6: uint32(0x00220022),
				7: uint32(0x02495810),
			},
		},
		405: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x9670a094),
				1: uint32(0x1792eeb0),
				2: uint32(0x05f2cb96),
				3: uint32(0x23580025),
				4: uint32(0x42cc25de),
				5: uint32(0x4a04cf38),
				6: uint32(0x359f0c40),
				7: uint32(0x8a001128),
			},
		},
		406: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x910a13fa),
				1: uint32(0x10560229),
				2: uint32(0x04200641),
				3: uint32(0x84f00484),
				4: uint32(0x0c040000),
				5: uint32(0x412c0400),
				6: uint32(0x11541206),
				7: uint32(0x00020a4b),
			},
		},
		407: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00c00200),
				1: uint32(0x00940000),
				2: uint32(0xbfbb0001),
				3: uint32(0x242b167c),
				4: uint32(0x7fa89bbb),
				5: uint32(0xe3790c7f),
				6: uint32(0xe00d10f4),
				7: uint32(0x9f014132),
			},
		},
		408: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x35728652),
				1: uint32(0xff1210b4),
				2: uint32(0x4223cf27),
				3: uint32(0x8602c06b),
				4: uint32(0x1fd33106),
				5: uint32(0xa1aa3a0c),
				6: uint32(0x02040812),
				7: uint32(0x08012572),
			},
		},
		409: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x485040cc),
				1: uint32(0x601062d0),
				2: uint32(0x29001c80),
				3: uint32(0x00109a00),
				4: uint32(0x22000004),
				5: uint32(0x00800000),
				6: uint32(0x68002020),
				7: uint32(0x609ecbe6),
			},
		},
		410: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x3f73916e),
				1: uint32(0x398260c0),
				2: uint32(0x48301034),
				3: uint32(0xbd5c0006),
				4: uint32(0xd6fb8cd1),
				5: uint32(0x43e820e1),
				6: uint32(0x084e0600),
				7: uint32(0xc4d00500),
			},
		},
		411: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x89aa8d1f),
				1: uint32(0x1602a6e1),
				2: uint32(0x21ed0001),
				3: uint32(0x1a8b3656),
				4: uint32(0x13a51fb7),
				5: uint32(0x30a06502),
				6: uint32(0x23c7b278),
				7: uint32(0xe9226c93),
			},
		},
		412: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x3a74e47f),
				1: uint32(0x98208fe3),
				2: uint32(0x2625280e),
				3: uint32(0xbf49bf9c),
				4: uint32(0xac543218),
				5: uint32(0x1916b949),
				6: uint32(0xb5220c60),
				7: uint32(0x0659fbc1),
			},
		},
		413: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x8420e343),
				1: uint32(0x800008d9),
				2: uint32(0x20225500),
				3: uint32(0x00a10184),
				4: uint32(0x20104800),
				5: uint32(0x40801380),
				6: uint32(0x00160d04),
				7: uint32(0x80200040),
			},
		},
		414: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x8de7fd40),
				1: uint32(0xe0985436),
				2: uint32(0x091e7b8b),
				3: uint32(0xd249fec8),
				4: uint32(0x8dee0611),
				5: uint32(0xba221937),
				6: uint32(0x9fdd77f4),
				7: uint32(0xf0daf3ec),
			},
		},
		415: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xec424386),
				1: uint32(0x26048d3f),
				2: uint32(0xc021fa6c),
				3: uint32(0x0cc2628e),
				4: uint32(0x0145d785),
				5: uint32(0x559977ad),
				6: uint32(0x4045e250),
				7: uint32(0xa154260b),
			},
		},
		416: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x58199827),
				1: uint32(0xa4103443),
				2: uint32(0x411405f2),
				3: uint32(0x07002280),
				4: uint32(0x426600b4),
				5: uint32(0x15a17210),
				6: uint32(0x41856025),
				7: uint32(0x00000054),
			},
		},
		417: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x01040201),
				1: uint32(0xcb70c820),
				2: uint32(0x6a629320),
				3: uint32(0x0095184c),
				4: uint32(0x9a8b1880),
				5: uint32(0x3201aab2),
				6: uint32(0x00c4d87a),
				7: uint32(0x04c3f3e5),
			},
		},
		418: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xa238d44d),
				1: uint32(0x5072a1a1),
				2: uint32(0x84fc980a),
				3: uint32(0x44d1c152),
				4: uint32(0x20c21094),
				5: uint32(0x42104180),
				6: uint32(0x3a000000),
				7: uint32(0xd29d0240),
			},
		},
		419: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xa8b12f01),
				1: uint32(0x2432bd40),
				2: uint32(0xd04bd34d),
				3: uint32(0xd0ada723),
				4: uint32(0x75a10a92),
				5: uint32(0x01e9adac),
				6: uint32(0x771f801a),
				7: uint32(0xa01b9225),
			},
		},
		420: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x20cadfa1),
				1: uint32(0x738c0602),
				2: uint32(0x003b577f),
				3: uint32(0x00d00bff),
				4: uint32(0x0088806a),
				5: uint32(0x0029a1c4),
				6: uint32(0x05242a05),
				7: uint32(0x16234009),
			},
		},
		421: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x80056822),
				1: uint32(0xa2112011),
				2: uint32(0x64900004),
				3: uint32(0x13824849),
				4: uint32(0x193023d5),
				5: uint32(0x08922980),
				6: uint32(0x88115402),
				7: uint32(0xa0042001),
			},
		},
		422: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x81800400),
				1: uint32(0x60228502),
				2: uint32(0x0b010090),
				3: uint32(0x12020022),
				4: uint32(0x00834011),
				5: uint32(0x00001a01),
			},
		},
		423: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x4684009f),
				2: uint32(0x020012c8),
				3: uint32(0x1a0004fc),
				4: uint32(0x0c4c2ede),
				5: uint32(0x80b80402),
				6: uint32(0x0afca826),
				7: uint32(0x22288c02),
			},
		},
		424: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x8f7ba0e0),
				1: uint32(0x2135c7d6),
				2: uint32(0xf8b106c7),
				3: uint32(0x62550713),
				4: uint32(0x8a19936e),
				5: uint32(0xfb0e6efa),
				6: uint32(0x48f91630),
				7: uint32(0x7debcd2f),
			},
		},
		425: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x4e845892),
				1: uint32(0x7a2e4ca0),
				2: uint32(0x561eedea),
				3: uint32(0x1190c649),
				4: uint32(0xe83a5324),
				5: uint32(0x8124cfdb),
				6: uint32(0x634218f1),
				7: uint32(0x1a8a5853),
			},
		},
		426: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x24d37420),
				1: uint32(0x0514aa3b),
				2: uint32(0x89586018),
				3: uint32(0xc0004800),
				4: uint32(0x91018268),
				5: uint32(0x2cd684a4),
				6: uint32(0xc4ba8886),
				7: uint32(0x02100377),
			},
		},
		427: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00388244),
				1: uint32(0x404aae11),
				2: uint32(0x510028c0),
				3: uint32(0x15146044),
				4: uint32(0x10007310),
				5: uint32(0x02480082),
				6: uint32(0x40060205),
				7: uint32(0x0000c003),
			},
		},
		428: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0c020000),
				1: uint32(0x02200008),
				2: uint32(0x40009000),
				3: uint32(0xd161b800),
				4: uint32(0x32744621),
				5: uint32(0x3b8af800),
				6: uint32(0x8b00050f),
				7: uint32(0x2280bbd0),
			},
		},
		429: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x07690600),
				1: uint32(0x00438040),
				2: uint32(0x50005420),
				3: uint32(0x250c41d0),
				4: uint32(0x83108410),
				5: uint32(0x02281101),
				6: uint32(0x00304008),
				7: uint32(0x020040a1),
			},
		},
		430: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x20000040),
				1: uint32(0xabe31500),
				2: uint32(0xaa443180),
				3: uint32(0xc624c2c6),
				4: uint32(0x8004ac13),
				5: uint32(0x03d1b000),
				6: uint32(0x4285611e),
				7: uint32(0x1d9ff303),
			},
		},
		431: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x78e8440a),
				1: uint32(0xc3925e26),
				2: uint32(0x00852000),
				3: uint32(0x4000b001),
				4: uint32(0x88424a90),
				5: uint32(0x0c8dca04),
				6: uint32(0x4203a705),
				7: uint32(0x000422a1),
			},
		},
		432: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0c018668),
				1: uint32(0x10795564),
				2: uint32(0xdea00002),
				3: uint32(0x40c12000),
				4: uint32(0x5001488b),
				5: uint32(0x04000380),
				6: uint32(0x50040000),
				7: uint32(0x80d0c05d),
			},
		},
		433: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x970aa010),
				1: uint32(0x4dafbb20),
				2: uint32(0x1e10d921),
				3: uint32(0x83140460),
				4: uint32(0xa6d68848),
				5: uint32(0x733fd83b),
				6: uint32(0x497427bc),
				7: uint32(0x92130ddc),
			},
		},
		434: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x8ba1142b),
				1: uint32(0xd1392e75),
				2: uint32(0x50503009),
				3: uint32(0x69008808),
				4: uint32(0x024a49d4),
				5: uint32(0x80164010),
				6: uint32(0x89d7e564),
				7: uint32(0x5316c020),
			},
		},
		435: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x86002b92),
				1: uint32(0x15e0a345),
				2: uint32(0x0c03008b),
				3: uint32(0xe200196e),
				4: uint32(0x80067031),
				5: uint32(0xa82916a5),
				6: uint32(0x18802000),
				7: uint32(0xe1487aac),
			},
		},
		436: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xb5d63207),
				1: uint32(0x5f9132e8),
				2: uint32(0x20e550a1),
				3: uint32(0x10807c00),
				4: uint32(0x9d8a7280),
				5: uint32(0x421f00aa),
				6: uint32(0x02310e22),
				7: uint32(0x04941100),
			},
		},
		437: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x40080022),
				1: uint32(0x5c100010),
				2: uint32(0xfcc80343),
				3: uint32(0x0580a1a5),
				4: uint32(0x04008433),
				5: uint32(0x6e080080),
				6: uint32(0x81262a4b),
				7: uint32(0x2901aad8),
			},
		},
		438: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x4490684d),
				1: uint32(0xba880009),
				2: uint32(0x00820040),
				3: uint32(0x87d10000),
				4: uint32(0xb1e6215b),
				5: uint32(0x80083161),
				6: uint32(0xc2400800),
				7: uint32(0xa600a069),
			},
		},
		439: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x4a328d58),
				1: uint32(0x550a5d71),
				2: uint32(0x2d579aa0),
				3: uint32(0x4aa64005),
				4: uint32(0x30b12021),
				5: uint32(0x01123fc6),
				6: uint32(0x260a10c2),
				7: uint32(0x50824462),
			},
		},
		440: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x80409880),
				1: uint32(0x810004c0),
				2: uint32(0x00002003),
				3: uint32(0x38180000),
				4: uint32(0xf1a60200),
				5: uint32(0x720e4434),
				6: uint32(0x92e035a2),
				7: uint32(0x09008101),
			},
		},
		441: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000400),
				1: uint32(0x00008885),
				3: uint32(0x00804000),
				5: uint32(0x00004040),
			},
		},
		442: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x08000000),
				2: uint32(0x00000082),
				4: uint32(0x88000004),
				5: uint32(0xe7efbfff),
				6: uint32(0xffbfffff),
				7: uint32(0xfdffefef),
			},
		},
		443: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xbffefbff),
				1: uint32(0x057fffff),
				2: uint32(0x85b30034),
				3: uint32(0x42164706),
				4: uint32(0xe4105402),
				5: uint32(0xb3058092),
				6: uint32(0x81305422),
				7: uint32(0x180b4263),
			},
		},
		444: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x13f5387b),
				1: uint32(0xa9ea07e5),
				2: uint32(0x05143c4c),
				3: uint32(0x80020600),
				4: uint32(0xbd481ad9),
				5: uint32(0xf496ee37),
				6: uint32(0x7ec0705f),
				7: uint32(0x355fbfb2),
			},
		},
		445: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x455fe644),
				1: uint32(0x41469000),
				2: uint32(0x063b1d40),
				3: uint32(0xfe1362a1),
				4: uint32(0x39028505),
				5: uint32(0x0c080548),
				6: uint32(0x0000144f),
				7: uint32(0x58183488),
			},
		},
		446: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xd8153077),
				1: uint32(0x4bfbbd0e),
				2: uint32(0x85008a90),
				3: uint32(0xe61dc100),
				4: uint32(0xb386ed14),
				5: uint32(0x639bff72),
				6: uint32(0xd9befd92),
				7: uint32(0x0a92887b),
			},
		},
		447: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x1cb2d3fe),
				1: uint32(0x177ab980),
				2: uint32(0xdc1782c9),
				3: uint32(0x3980fffb),
				4: uint32(0x590c4260),
				5: uint32(0x37df0f01),
				6: uint32(0xb15094a3),
				7: uint32(0x23070623),
			},
		},
		448: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x3102f85a),
				1: uint32(0x310201f0),
				2: uint32(0x1e820040),
				3: uint32(0x056a3a0a),
				4: uint32(0x12805b84),
				5: uint32(0xa7148002),
				6: uint32(0xa04b2612),
				7: uint32(0x90011069),
			},
		},
		449: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x848a1000),
				1: uint32(0x3f801802),
				2: uint32(0x42400708),
				3: uint32(0x4e140110),
				4: uint32(0x180080b0),
				5: uint32(0x0281c510),
				6: uint32(0x10298202),
				7: uint32(0x88000210),
			},
		},
		450: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00420020),
				1: uint32(0x11000280),
				2: uint32(0x4413e000),
				3: uint32(0xfe025804),
				4: uint32(0x30283c07),
				5: uint32(0x04739798),
				6: uint32(0xcb13ced1),
				7: uint32(0x431f6210),
			},
		},
		451: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x55ac278d),
				1: uint32(0xc892422e),
				2: uint32(0x02885380),
				3: uint32(0x78514039),
				4: uint32(0x8088292c),
				5: uint32(0x2428b900),
				6: uint32(0x080e0c41),
				7: uint32(0x42004421),
			},
		},
		452: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x08680408),
				1: uint32(0x12040006),
				2: uint32(0x02903031),
				3: uint32(0xe0855b3e),
				4: uint32(0x10442936),
				5: uint32(0x10822814),
				6: uint32(0x83344266),
				7: uint32(0x531b013c),
			},
		},
		453: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0e0d0404),
				1: uint32(0x00510c22),
				2: uint32(0xc0000012),
				3: uint32(0x88000040),
				4: uint32(0x0000004a),
				6: uint32(0x5447dff6),
				7: uint32(0x00088868),
			},
		},
		454: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000081),
				1: uint32(0x40000000),
				2: uint32(0x00000100),
				3: uint32(0x02000000),
				4: uint32(0x00080600),
			},
		},
		455: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000080),
				1: uint32(0x00000040),
				3: uint32(0x00001040),
				5: uint32(0xf7fdefff),
				6: uint32(0xfffeff7f),
				7: uint32(0xfffffbff),
			},
		},
		456: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xbffffdff),
				1: uint32(0x00ffffff),
				2: uint32(0x042012c2),
				3: uint32(0x07080c06),
				4: uint32(0x01101624),
			},
		},
		457: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xe0000000),
				1: uint32(0xfffffffe),
				2: uint32(0x7f79ffff),
				3: uint32(0x00f928df),
				4: uint32(0x80120c32),
				5: uint32(0xd53a0008),
				6: uint32(0xecc2d858),
				7: uint32(0x2fa89d18),
			},
		},
		458: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xe0109620),
				1: uint32(0x2622d60c),
				2: uint32(0x02060f97),
				3: uint32(0x9055b240),
				4: uint32(0x501180a2),
				5: uint32(0x04049800),
				6: uint32(0x00004000),
			},
		},
		459: {
			Fmap1: [8]TFcChar32{
				3: uint32(0xfffffbc0),
				4: uint32(0xdffbeffe),
				5: uint32(0x62430b08),
				6: uint32(0xfb3b41b6),
				7: uint32(0x23896f74),
			},
		},
		460: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xecd7ae7f),
				1: uint32(0x5960e047),
				2: uint32(0x098fa096),
				3: uint32(0xa030612c),
				4: uint32(0x2aaa090d),
				5: uint32(0x4f7bd44e),
				6: uint32(0x388bc4b2),
				7: uint32(0x6110a9c6),
			},
		},
		461: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x42000014),
				1: uint32(0x0202800c),
				2: uint32(0x6485fe48),
				3: uint32(0xe3f7d63e),
				4: uint32(0x0c073aa0),
				5: uint32(0x0430e40c),
				6: uint32(0x1002f680),
			},
		},
		462: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x00100000),
				4: uint32(0x00004000),
				5: uint32(0x00004000),
				6: uint32(0x00000100),
			},
		},
		463: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x40000000),
				3: uint32(0x00000400),
				4: uint32(0x00008000),
				6: uint32(0x00400400),
			},
		},
		464: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x40000000),
				3: uint32(0x00000800),
				4: uint32(0xfebdffe0),
				5: uint32(0xffffffff),
				6: uint32(0xfbe77f7f),
				7: uint32(0xf7ffffbf),
			},
		},
		465: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xefffffff),
				1: uint32(0xdff7ff7e),
				2: uint32(0xfbdff6f7),
				3: uint32(0x804fbffe),
				7: uint32(0x7fffef00),
			},
		},
		466: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xb6f7ff7f),
				1: uint32(0xb87e4406),
				2: uint32(0x88313bf5),
				3: uint32(0x00f41796),
				4: uint32(0x1391a960),
				5: uint32(0x72490080),
				6: uint32(0x0024f2f3),
				7: uint32(0x42c88701),
			},
		},
		467: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x5048e3d3),
				1: uint32(0x43052400),
				2: uint32(0x4a4c0000),
				3: uint32(0x10580227),
				4: uint32(0x01162820),
				5: uint32(0x0014a809),
				7: uint32(0x00683ec0),
			},
		},
		468: {
			Fmap1: [8]TFcChar32{
				3: uint32(0xffe00000),
				4: uint32(0xfddbb7ff),
				5: uint32(0x000000f7),
				6: uint32(0xc72e4000),
				7: uint32(0x00000180),
			},
		},
		469: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00012000),
				1: uint32(0x00004000),
				2: uint32(0x00300000),
				3: uint32(0xb4f7ffa8),
				4: uint32(0x03ffadf3),
				5: uint32(0x00000120),
			},
		},
		470: {
			Fmap1: [8]TFcChar32{
				3: uint32(0xfffbf000),
				4: uint32(0xfdcf9df7),
				5: uint32(0x15c301bf),
				6: uint32(0x810a1827),
				7: uint32(0x0a00a842),
			},
		},
		471: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x80088108),
				1: uint32(0x18048008),
				2: uint32(0x0012a3be),
			},
		},
		472: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x90000000),
				4: uint32(0xdc3769e6),
				5: uint32(0x3dff6bff),
				6: uint32(0xf3f9fcf8),
				7: uint32(0x00000004),
			},
		},
		473: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x80000000),
				1: uint32(0xe7eebf6f),
				2: uint32(0x5da2dffe),
				3: uint32(0xc00b3fd8),
				4: uint32(0xa00c0984),
				5: uint32(0x69100040),
				6: uint32(0xb912e210),
				7: uint32(0x5a0086a5),
			},
		},
		474: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x02896800),
				1: uint32(0x6a809005),
				2: uint32(0x00030010),
				3: uint32(0x80000000),
				4: uint32(0x8e001ff9),
				5: uint32(0x00000001),
			},
		},
		475: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000080),
			},
		},
		476: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00001000),
				3: uint32(0x64080010),
				4: uint32(0x00480000),
				5: uint32(0x10000020),
				6: uint32(0x80000102),
				7: uint32(0x08000010),
			},
		},
		477: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000040),
				1: uint32(0x40000000),
				2: uint32(0x00020000),
				3: uint32(0x01852002),
				4: uint32(0x00800010),
				5: uint32(0x80002022),
				6: uint32(0x084444a2),
				7: uint32(0x480e0000),
			},
		},
		478: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x04000200),
				1: uint32(0x02202008),
				2: uint32(0x80004380),
				3: uint32(0x04000000),
				4: uint32(0x00000002),
				5: uint32(0x12231420),
				6: uint32(0x2058003a),
				7: uint32(0x00200060),
			},
		},
		479: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x10002508),
				1: uint32(0x040d0028),
				2: uint32(0x00000009),
				3: uint32(0x00008004),
				4: uint32(0x00800000),
				5: uint32(0x42000001),
				7: uint32(0x09040000),
			},
		},
		480: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x02008000),
				1: uint32(0x01402001),
				3: uint32(0x00000008),
				5: uint32(0x00000001),
				6: uint32(0x00021008),
				7: uint32(0x04000000),
			},
		},
		481: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00100100),
				1: uint32(0x80040080),
				2: uint32(0x00002000),
				3: uint32(0x00000008),
				4: uint32(0x08040601),
				5: uint32(0x01000012),
				6: uint32(0x10000000),
				7: uint32(0x49001024),
			},
		},
		482: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0180004a),
				1: uint32(0x00100600),
				2: uint32(0x50840800),
				3: uint32(0x000000c0),
				4: uint32(0x00800000),
				5: uint32(0x20000800),
				6: uint32(0x40000000),
				7: uint32(0x08050000),
			},
		},
		483: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x02004000),
				1: uint32(0x02000804),
				2: uint32(0x01000004),
				3: uint32(0x18060001),
				4: uint32(0x02400001),
				5: uint32(0x40000002),
				6: uint32(0x20800014),
				7: uint32(0x000c1000),
			},
		},
		484: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00222000),
				2: uint32(0x00100000),
				6: uint32(0x10422800),
				7: uint32(0x00000800),
			},
		},
		485: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x20080000),
				1: uint32(0x00040000),
				2: uint32(0x80025040),
				3: uint32(0x20208604),
				4: uint32(0x00028020),
				5: uint32(0x80102020),
				6: uint32(0x080820c0),
				7: uint32(0x10880800),
			},
		},
		486: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00200109),
				3: uint32(0x00100000),
				5: uint32(0x81022700),
				6: uint32(0x40c21404),
				7: uint32(0x84010882),
			},
		},
		487: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00004010),
				2: uint32(0x03000000),
				3: uint32(0x00000008),
				4: uint32(0x00080000),
				6: uint32(0x10800001),
				7: uint32(0x06002020),
			},
		},
		488: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000010),
				1: uint32(0x02000000),
				2: uint32(0x00880020),
				3: uint32(0x00008424),
				5: uint32(0x88000000),
				6: uint32(0x81000100),
				7: uint32(0x04000000),
			},
		},
		489: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00004218),
				1: uint32(0x00040000),
				3: uint32(0x80005080),
				4: uint32(0x00010000),
				5: uint32(0x00040000),
				6: uint32(0x08008000),
				7: uint32(0x02008000),
			},
		},
		490: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00020000),
				2: uint32(0x00000001),
				3: uint32(0x04000401),
				4: uint32(0x00100000),
				5: uint32(0x12200004),
				7: uint32(0x18100000),
			},
		},
		491: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00000800),
				3: uint32(0x00004000),
				4: uint32(0x00800000),
				5: uint32(0x04000000),
				6: uint32(0x82000002),
				7: uint32(0x00042000),
			},
		},
		492: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00080006),
				3: uint32(0x04000000),
				4: uint32(0x80008000),
				5: uint32(0x00810001),
				6: uint32(0xa0000000),
				7: uint32(0x00100410),
			},
		},
		493: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00400218),
				1: uint32(0x88084080),
				2: uint32(0x00260008),
				3: uint32(0x00800404),
				4: uint32(0x00000020),
				7: uint32(0x00000200),
			},
		},
		494: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00a08048),
				2: uint32(0x08000000),
				3: uint32(0x04000000),
				6: uint32(0x00018000),
				7: uint32(0x00200000),
			},
		},
		495: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x01000000),
				3: uint32(0x10000000),
				6: uint32(0x00200000),
				7: uint32(0x00102000),
			},
		},
		496: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000801),
				3: uint32(0x00020000),
				4: uint32(0x08000000),
				5: uint32(0x00002000),
				6: uint32(0x20010000),
				7: uint32(0x04002000),
			},
		},
		497: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x40000040),
				1: uint32(0x50202400),
				2: uint32(0x000a0020),
				3: uint32(0x00040420),
				4: uint32(0x00000200),
				5: uint32(0x00000080),
				6: uint32(0x80000000),
				7: uint32(0x00000020),
			},
		},
		498: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x20008000),
				1: uint32(0x00200010),
				4: uint32(0x00400000),
				5: uint32(0x01100000),
				6: uint32(0x00020000),
				7: uint32(0x80000010),
			},
		},
		499: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x02000000),
				1: uint32(0x00801000),
				3: uint32(0x48058000),
				4: uint32(0x20c94000),
				5: uint32(0x60000000),
				6: uint32(0x00000001),
			},
		},
		500: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00004090),
				1: uint32(0x48000000),
				2: uint32(0x08000000),
				3: uint32(0x28802000),
				4: uint32(0x00000002),
				5: uint32(0x00014000),
				6: uint32(0x00002000),
				7: uint32(0x00002002),
			},
		},
		501: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00010200),
				1: uint32(0x00100000),
				3: uint32(0x00800000),
				4: uint32(0x10020000),
			},
		},
		502: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000010),
				1: uint32(0x00000402),
				2: uint32(0x0c000000),
				3: uint32(0x01000400),
				4: uint32(0x01000021),
				6: uint32(0x00004000),
				7: uint32(0x00004000),
			},
		},
		503: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00800000),
				7: uint32(0x02000020),
			},
		},
		504: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000100),
				1: uint32(0x08000000),
				6: uint32(0x00002000),
			},
		},
		505: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00006000),
				3: uint32(0x00000400),
				4: uint32(0x04000040),
				5: uint32(0x003c0180),
				6: uint32(0x00000200),
				7: uint32(0x00102000),
			},
		},
		506: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000800),
				1: uint32(0x101000c0),
				2: uint32(0x00800000),
				4: uint32(0x00008000),
				5: uint32(0x02200000),
				6: uint32(0x00020020),
			},
		},
		507: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x01000000),
				3: uint32(0x20100000),
				4: uint32(0x00080000),
				5: uint32(0x00000141),
				6: uint32(0x02001002),
				7: uint32(0x40400001),
			},
		},
		508: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00580000),
				1: uint32(0x00000002),
				2: uint32(0x00003000),
				3: uint32(0x00002400),
				4: uint32(0x00988000),
				5: uint32(0x00040010),
				6: uint32(0x00002800),
				7: uint32(0x00000008),
			},
		},
		509: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x40080004),
				1: uint32(0x00000020),
				2: uint32(0x20080000),
				3: uint32(0x02060a00),
				4: uint32(0x00010040),
				5: uint32(0x14010200),
				6: uint32(0x40800000),
				7: uint32(0x08031000),
			},
		},
		510: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x40020020),
				1: uint32(0x0000202c),
				2: uint32(0x2014a008),
				4: uint32(0x80040200),
				5: uint32(0x82020012),
				6: uint32(0x00400000),
				7: uint32(0x20000000),
			},
		},
		511: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00000004),
				3: uint32(0x04000000),
				6: uint32(0x40800100),
			},
		},
		512: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000008),
				1: uint32(0x04000040),
				2: uint32(0x00000001),
				3: uint32(0x000c0200),
				5: uint32(0x08000400),
				7: uint32(0x080c0001),
			},
		},
		513: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000400),
				3: uint32(0x00200000),
				4: uint32(0x80000000),
				5: uint32(0x00001000),
				6: uint32(0x00000200),
				7: uint32(0x01000800),
			},
		},
		514: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00000800),
				3: uint32(0x40000000),
				7: uint32(0x04040000),
			},
		},
		515: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00000040),
				3: uint32(0x00002000),
				4: uint32(0xa0000000),
				6: uint32(0x08000008),
				7: uint32(0x00080000),
			},
		},
		516: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000020),
				2: uint32(0x40000400),
				7: uint32(0x00008000),
			},
		},
		517: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x00000800),
				7: uint32(0x00200000),
			},
		},
		518: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x04000000),
				4: uint32(0x00000008),
				6: uint32(0x00010000),
				7: uint32(0x1b000000),
			},
		},
		519: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00007000),
				2: uint32(0x10000000),
				5: uint32(0x00000080),
				6: uint32(0x80000000),
			},
		},
		520: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00020000),
				3: uint32(0x00200000),
				4: uint32(0x40000000),
				5: uint32(0x00000010),
				6: uint32(0x00800000),
				7: uint32(0x00000008),
			},
		},
		521: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x02000000),
				3: uint32(0x20000010),
				4: uint32(0x00000080),
				6: uint32(0x00010000),
			},
		},
		522: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x02000000),
				4: uint32(0x20000000),
				5: uint32(0x00000040),
				6: uint32(0x00200028),
			},
		},
		523: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00020000),
				3: uint32(0x02000000),
				5: uint32(0x02000000),
				6: uint32(0x40020000),
				7: uint32(0x51000040),
			},
		},
		524: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000080),
				1: uint32(0x04040000),
				3: uint32(0x10000000),
				4: uint32(0x00022000),
				5: uint32(0x00100000),
				6: uint32(0x20000000),
				7: uint32(0x00000082),
			},
		},
		525: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x40000000),
				1: uint32(0x00010000),
				2: uint32(0x00002000),
				4: uint32(0x00000240),
				7: uint32(0x00000008),
			},
		},
		526: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00010000),
				2: uint32(0x00000810),
				3: uint32(0x00080880),
				4: uint32(0x00004000),
				7: uint32(0x00020000),
			},
		},
		527: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00400020),
				3: uint32(0x00000082),
				5: uint32(0x00020001),
			},
		},
		528: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x40000018),
				1: uint32(0x00000004),
				4: uint32(0x01000000),
				5: uint32(0x00400000),
			},
		},
		529: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000001),
				1: uint32(0x00400000),
				3: uint32(0x00080002),
				4: uint32(0x00000400),
				5: uint32(0x00040000),
			},
		},
		530: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000800),
				1: uint32(0x00000800),
				6: uint32(0x00000100),
			},
		},
		531: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00200000),
				3: uint32(0x04108000),
				7: uint32(0x00000002),
			},
		},
		532: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x02800000),
				2: uint32(0x04000000),
				5: uint32(0x00000004),
				7: uint32(0x00000400),
			},
		},
		533: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x10000000),
				3: uint32(0x00040000),
				4: uint32(0x00400000),
			},
		},
		534: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00200000),
				1: uint32(0x00000200),
				3: uint32(0x10000000),
				6: uint32(0x2a000000),
			},
		},
		535: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00400000),
				2: uint32(0x00400000),
				4: uint32(0x00000002),
				5: uint32(0x40000000),
				7: uint32(0x00400000),
			},
		},
		536: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x40000000),
				1: uint32(0x00001000),
				4: uint32(0x00000202),
				5: uint32(0x02000000),
				6: uint32(0x80000000),
				7: uint32(0x00020000),
			},
		},
		537: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000020),
				1: uint32(0x00000800),
				2: uint32(0x00020421),
				3: uint32(0x00020000),
				7: uint32(0x00400000),
			},
		},
		538: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00200000),
				2: uint32(0x00000001),
				4: uint32(0x00000084),
			},
		},
		539: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00004400),
				2: uint32(0x00000002),
				3: uint32(0x00100000),
				6: uint32(0x00008200),
			},
		},
		540: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x12000000),
				2: uint32(0x00000100),
				3: uint32(0x00000001),
			},
		},
		541: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000020),
				1: uint32(0x08100000),
				2: uint32(0x000a0400),
				3: uint32(0x00000081),
				4: uint32(0x00006000),
				5: uint32(0x00120000),
			},
		},
		542: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000004),
				1: uint32(0x08000000),
				2: uint32(0x00004000),
				3: uint32(0x044000c0),
			},
		},
		543: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x40001000),
				2: uint32(0x01000001),
				3: uint32(0x05000000),
				4: uint32(0x00080000),
				5: uint32(0x02000000),
				6: uint32(0x00000800),
			},
		},
		544: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000100),
				4: uint32(0x00002002),
				5: uint32(0x01020000),
				6: uint32(0x00800000),
			},
		},
		545: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000040),
				1: uint32(0x00004000),
				2: uint32(0x01000000),
				3: uint32(0x00000004),
				4: uint32(0x00020000),
				6: uint32(0x00000010),
			},
		},
		546: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x00080000),
				5: uint32(0x00010000),
				6: uint32(0x30000300),
				7: uint32(0x00000400),
			},
		},
		547: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000800),
				1: uint32(0x02000000),
				3: uint32(0x00008000),
			},
		},
		548: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00200000),
				5: uint32(0x000040c0),
				6: uint32(0x00002200),
				7: uint32(0x12002000),
			},
		},
		549: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00000020),
				2: uint32(0x20000000),
				4: uint32(0x00000200),
				5: uint32(0x00080800),
				6: uint32(0x1000a000),
			},
		},
		550: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x00004000),
			},
		},
		551: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00004280),
				3: uint32(0x01000000),
				4: uint32(0x00800000),
				5: uint32(0x00000008),
			},
		},
		552: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x00000002),
				5: uint32(0x20400000),
				6: uint32(0x00000040),
			},
		},
		553: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00800080),
				1: uint32(0x00800000),
				5: uint32(0x00400020),
				7: uint32(0x00008000),
			},
		},
		554: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x01000000),
				1: uint32(0x00000040),
				3: uint32(0x00400000),
				5: uint32(0x00000440),
				7: uint32(0x00800000),
			},
		},
		555: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x01000000),
				6: uint32(0x00080000),
			},
		},
		556: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x01000000),
				1: uint32(0x00000001),
				3: uint32(0x00020000),
				5: uint32(0x20002000),
				7: uint32(0x00000004),
			},
		},
		557: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000008),
				1: uint32(0x00100000),
				3: uint32(0x00010000),
			},
		},
		558: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000004),
				1: uint32(0x00008000),
				7: uint32(0x00008000),
			},
		},
		559: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x00000040),
				6: uint32(0x00004000),
			},
		},
		560: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000010),
				1: uint32(0x00002000),
				2: uint32(0x40000040),
				4: uint32(0x10000000),
				6: uint32(0x00008080),
			},
		},
		561: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00000080),
				4: uint32(0x00100080),
				5: uint32(0x000000a0),
			},
		},
		562: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x00100000),
			},
		},
		563: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00001000),
				4: uint32(0x0001000a),
			},
		},
		564: {
			Fmap1: [8]TFcChar32{
				6: uint32(0x08002000),
			},
		},
		565: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000808),
			},
		},
		566: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00004000),
				1: uint32(0x00002400),
				2: uint32(0x00008000),
				3: uint32(0x40000000),
				4: uint32(0x00000001),
				5: uint32(0x00002000),
				6: uint32(0x04000000),
				7: uint32(0x00040004),
			},
		},
		567: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00002000),
				5: uint32(0x1c200000),
				7: uint32(0x02000000),
			},
		},
		568: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00080000),
				2: uint32(0x00400000),
				3: uint32(0x00000002),
				5: uint32(0x00000100),
			},
		},
		569: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x00400000),
			},
		},
		570: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00004100),
				1: uint32(0x00000400),
				2: uint32(0x20200010),
				3: uint32(0x00004004),
				5: uint32(0x42000000),
			},
		},
		571: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000080),
				2: uint32(0x00000121),
				3: uint32(0x00000200),
				4: uint32(0x000000b0),
				5: uint32(0x80002000),
				7: uint32(0x00010000),
			},
		},
		572: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000010),
				1: uint32(0x000000c0),
				2: uint32(0x08100000),
				3: uint32(0x00000020),
			},
		},
		573: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x02000000),
				5: uint32(0x00000404),
			},
		},
		574: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x00400000),
				5: uint32(0x00000008),
			},
		},
		575: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00000002),
				2: uint32(0x00020000),
				3: uint32(0x00002000),
				7: uint32(0x00204000),
			},
		},
		576: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00100000),
				5: uint32(0x00800000),
				6: uint32(0x00000100),
				7: uint32(0x00000001),
			},
		},
		577: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x10000000),
				1: uint32(0x01000000),
				2: uint32(0x00002400),
				3: uint32(0x00000004),
				6: uint32(0x00000020),
				7: uint32(0x00000002),
			},
		},
		578: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00010000),
			},
		},
		579: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00002400),
				4: uint32(0x00004802),
				7: uint32(0x80022000),
			},
		},
		580: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00001004),
				1: uint32(0x04208000),
				2: uint32(0x20000020),
				3: uint32(0x00040000),
			},
		},
		581: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00100000),
				2: uint32(0x40010000),
				4: uint32(0x00080000),
				6: uint32(0x00100211),
			},
		},
		582: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00001400),
				4: uint32(0x00610000),
				5: uint32(0x80008c00),
			},
		},
		583: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000100),
				1: uint32(0x00000040),
				3: uint32(0x00000004),
				4: uint32(0x00004000),
			},
		},
		584: {
			Fmap1: [8]TFcChar32{
				6: uint32(0x00000400),
			},
		},
		585: {
			Fmap1: [8]TFcChar32{
				5: uint32(0x00000210),
			},
		},
		586: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00000020),
				2: uint32(0x00000002),
			},
		},
		587: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00004000),
				3: uint32(0x02000000),
			},
		},
		588: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00080002),
				3: uint32(0x01000020),
				4: uint32(0x00400000),
				5: uint32(0x00200000),
				6: uint32(0x00008000),
			},
		},
		589: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00020000),
				3: uint32(0xc0020000),
				4: uint32(0x10000000),
				5: uint32(0x00000080),
			},
		},
		590: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000210),
				2: uint32(0x00001000),
				3: uint32(0x04480000),
				4: uint32(0x20000000),
				5: uint32(0x00000004),
				6: uint32(0x00800000),
				7: uint32(0x02000000),
			},
		},
		591: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x08006000),
				2: uint32(0x00001000),
				5: uint32(0x00100000),
				7: uint32(0x00000400),
			},
		},
		592: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00100000),
				2: uint32(0x10000000),
				3: uint32(0x08608000),
				6: uint32(0x00080002),
			},
		},
		593: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x20000000),
				2: uint32(0x00008020),
			},
		},
		594: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x10000000),
			},
		},
		595: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00100000),
			},
		},
		596: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00000400),
			},
		},
		597: {
			Fmap1: [8]TFcChar32{
				7: uint32(0x02000000),
			},
		},
		598: {
			Fmap1: [8]TFcChar32{
				6: uint32(0x00000080),
			},
		},
		599: {
			Fmap1: [8]TFcChar32{
				5: uint32(0x00000002),
			},
		},
		600: {
			Fmap1: [8]TFcChar32{
				6: uint32(0x00008000),
			},
		},
		601: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00000008),
				6: uint32(0x00000400),
			},
		},
		602: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00220000),
				3: uint32(0x00000004),
				5: uint32(0x00040000),
				6: uint32(0x00000004),
			},
		},
		603: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00001000),
				3: uint32(0x00000080),
				4: uint32(0x00002000),
				7: uint32(0x00004000),
			},
		},
		604: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x00100000),
			},
		},
		605: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x00200000),
			},
		},
		606: {
			Fmap1: [8]TFcChar32{
				5: uint32(0x04000000),
			},
		},
		607: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x00000200),
			},
		},
		608: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x00000001),
			},
		},
		609: {
			Fmap1: [8]TFcChar32{
				6: uint32(0x00080000),
			},
		},
		610: {
			Fmap1: [8]TFcChar32{
				5: uint32(0x01000000),
				7: uint32(0x00000400),
			},
		},
		611: {
			Fmap1: [8]TFcChar32{
				5: uint32(0x00000080),
			},
		},
		612: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00000800),
				2: uint32(0x00000100),
				3: uint32(0x40000000),
			},
		},
		613: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00200000),
			},
		},
		614: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x01000000),
			},
		},
		615: {
			Fmap1: [8]TFcChar32{
				6: uint32(0x04000000),
			},
		},
		616: {
			Fmap1: [8]TFcChar32{
				6: uint32(0x00001000),
			},
		},
		617: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x00000400),
			},
		},
		618: {
			Fmap1: [8]TFcChar32{
				7: uint32(0x04040000),
			},
		},
		619: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x00000020),
			},
		},
		620: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00800000),
			},
		},
		621: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00200000),
				2: uint32(0x40000000),
			},
		},
		622: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x20000000),
			},
		},
		623: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x04000000),
				5: uint32(0x00000001),
			},
		},
		624: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x40000000),
				2: uint32(0x02000000),
			},
		},
		625: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x00080000),
			},
		},
		626: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00000010),
				5: uint32(0x20000000),
			},
		},
		627: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x20000000),
			},
		},
		628: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00000080),
				7: uint32(0x00000004),
			},
		},
		629: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x00002000),
			},
		},
		630: {
			Fmap1: [8]TFcChar32{
				6: uint32(0x10000001),
			},
		},
		631: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00008000),
			},
		},
		632: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00004040),
			},
		},
		633: {
			Fmap1: [8]TFcChar32{
				6: uint32(0x00042400),
			},
		},
		634: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x02000000),
			},
		},
		635: {
			Fmap1: [8]TFcChar32{
				7: uint32(0x00000080),
			},
		},
		636: {
			Fmap1: [8]TFcChar32{
				7: uint32(0x00000020),
			},
		},
		637: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00000001),
			},
		},
		638: {
			Fmap1: [8]TFcChar32{
				6: uint32(0x00020000),
			},
		},
		639: {
			Fmap1: [8]TFcChar32{
				2: uint32(0x00002000),
			},
		},
		640: {
			Fmap1: [8]TFcChar32{
				4: uint32(0x01000000),
			},
		},
		641: {
			Fmap1: [8]TFcChar32{
				1: uint32(0x00040000),
				2: uint32(0x08000000),
			},
		},
		642: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xc373ff8b),
				1: uint32(0x1b0f6840),
				2: uint32(0xf34ce9ac),
				3: uint32(0xc0080200),
				4: uint32(0xca3e795c),
				5: uint32(0x06487976),
				6: uint32(0xf7f02fdf),
				7: uint32(0xa8ff033a),
			},
		},
		643: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x233fef37),
				1: uint32(0xfd59b004),
				2: uint32(0xfffff3ca),
				3: uint32(0xfff9de9f),
				4: uint32(0x7df7abff),
				5: uint32(0x8eecc000),
				6: uint32(0xffdbeebf),
				7: uint32(0x45fad003),
			},
		},
		644: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xdffefae1),
				1: uint32(0x10abbfef),
				2: uint32(0xfcaaffeb),
				3: uint32(0x24fdef3f),
				4: uint32(0x7f7678ad),
				5: uint32(0xedfff00c),
				6: uint32(0x2cfacff6),
				7: uint32(0xeb6bf7f9),
			},
		},
		645: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x95bf1ffd),
				1: uint32(0xbfbf6677),
				2: uint32(0xfeb43bfb),
				3: uint32(0x11e27bae),
				4: uint32(0x41bea681),
				5: uint32(0x72c31435),
				6: uint32(0x71917d70),
				7: uint32(0x276b0003),
			},
		},
		646: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x70cf57cb),
				1: uint32(0x0def4732),
				2: uint32(0xfc747eda),
				3: uint32(0xbdb4fe06),
				4: uint32(0x8bca3f9f),
				5: uint32(0x58007e49),
				6: uint32(0xebec228f),
				7: uint32(0xddbb8a5c),
			},
		},
		647: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xb6e7ef60),
				1: uint32(0xf293a40f),
				2: uint32(0x549e37bb),
				3: uint32(0x9bafd04b),
				4: uint32(0xf7d4c414),
				5: uint32(0x0a1430b0),
				6: uint32(0x88d02f08),
				7: uint32(0x192fff7e),
			},
		},
		648: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfb07ffda),
				1: uint32(0x7beb7ff1),
				2: uint32(0x0010c5ef),
				3: uint32(0xfdff99ff),
				4: uint32(0x056779d7),
				5: uint32(0xfdcbffe7),
				6: uint32(0x4040c3ff),
				7: uint32(0xbd8e6ff7),
			},
		},
		649: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0497dffa),
				1: uint32(0x5bfff4c0),
				2: uint32(0xd0e7ed7b),
				3: uint32(0xf8e0047e),
				4: uint32(0xb73eff9f),
				5: uint32(0x882e7dfe),
				6: uint32(0xbe7ffffd),
				7: uint32(0xf6c483fe),
			},
		},
		650: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xb8fdf357),
				1: uint32(0xef7dd680),
				2: uint32(0x47885767),
				3: uint32(0xc3dfff7d),
				4: uint32(0x37a9f0ff),
				5: uint32(0x70fc7de0),
				6: uint32(0xec9a3f6f),
				7: uint32(0x86814cb3),
			},
		},
		651: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xdd5c3f9e),
				1: uint32(0x4819f70d),
				2: uint32(0x0007fea3),
				3: uint32(0x38ffaf56),
				4: uint32(0xefb8980d),
				5: uint32(0xb760403d),
				6: uint32(0x9035d8ce),
				7: uint32(0x3fff72bf),
			},
		},
		652: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x7a117ff7),
				1: uint32(0xabfff7bb),
				2: uint32(0x6fbeff00),
				3: uint32(0xfe72a93c),
				4: uint32(0xf11bcfef),
				5: uint32(0xf40adb6b),
				6: uint32(0xef7ec3e6),
				7: uint32(0xf6109b9c),
			},
		},
		653: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x16f4f048),
				1: uint32(0x5182feb5),
				2: uint32(0x15bbc7b1),
				3: uint32(0xfbdf6e87),
				4: uint32(0x63cde43f),
				5: uint32(0x7e7ec1ff),
				6: uint32(0x7d5ffdeb),
				7: uint32(0xfcfe777b),
			},
		},
		654: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xdbea960b),
				1: uint32(0x53e86229),
				2: uint32(0xfdef37df),
				3: uint32(0xbd8136f5),
				4: uint32(0xfcbddc18),
				5: uint32(0xffffd2e4),
				6: uint32(0xffe03fd7),
				7: uint32(0xabf87f6f),
			},
		},
		655: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x6ed99bae),
				1: uint32(0xf115f5fb),
				2: uint32(0xbdfb79a9),
				3: uint32(0xadaf5a3c),
				4: uint32(0x1facdbba),
				5: uint32(0x837971fc),
				6: uint32(0xc35f7cf7),
				7: uint32(0x0567dfff),
			},
		},
		656: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x8467ff9a),
				1: uint32(0xdf8b1534),
				2: uint32(0x3373f9f3),
				3: uint32(0x5e1af7bd),
				4: uint32(0xa03fbf40),
				5: uint32(0x01ebffff),
				6: uint32(0xcfdddfc0),
				7: uint32(0xabd37500),
			},
		},
		657: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xeed6f8c3),
				1: uint32(0xb7ff43fd),
				2: uint32(0x42275eaf),
				3: uint32(0xf6869bac),
				4: uint32(0xf6bc27d7),
				5: uint32(0x35b7f787),
				6: uint32(0xe176aacd),
				7: uint32(0xe29f49e7),
			},
		},
		658: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xaff2545c),
				1: uint32(0x61d82b3f),
				2: uint32(0xbbb8fc3b),
				3: uint32(0x7b7dffcf),
				4: uint32(0x1ce0bf95),
				5: uint32(0x43ff7dfd),
				6: uint32(0xfffe5ff6),
				7: uint32(0xc4ced3ef),
			},
		},
		659: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xadbc8db6),
				1: uint32(0x11eb63dc),
				2: uint32(0x23d0df59),
				3: uint32(0xf3dbbeb4),
				4: uint32(0xdbc71fe7),
				5: uint32(0xfae4ff63),
				6: uint32(0x63f7b22b),
				7: uint32(0xadbaed3b),
			},
		},
		660: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x7efffe01),
				1: uint32(0x02bcfff7),
				2: uint32(0xef3932ff),
				3: uint32(0x8005fffc),
				4: uint32(0xbcf577fb),
				5: uint32(0xfff7010d),
				6: uint32(0xbf3afffb),
				7: uint32(0xdfff0057),
			},
		},
		661: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xbd7def7b),
				1: uint32(0xc8d4db88),
				2: uint32(0xed7cfff3),
				3: uint32(0x56ff5dee),
				4: uint32(0xac5f7e0d),
				5: uint32(0xd57fff96),
				6: uint32(0xc1403fee),
				7: uint32(0xffe76ff9),
			},
		},
		662: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x8e77779b),
				1: uint32(0xe45d6ebf),
				2: uint32(0x5f1f6fcf),
				3: uint32(0xfedfe07f),
				4: uint32(0x01fed7db),
				5: uint32(0xfb7bff00),
				6: uint32(0x1fdfffd4),
				7: uint32(0xfffff800),
			},
		},
		663: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x007bfb8f),
				1: uint32(0x7f5cbf00),
				2: uint32(0x07f3ffff),
				3: uint32(0x3de7eba0),
				4: uint32(0xfbd7f7bf),
				5: uint32(0x6003ffbf),
				6: uint32(0xbfedfffd),
				7: uint32(0x027fefbb),
			},
		},
		664: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xddfdfe40),
				1: uint32(0xe2f9fdff),
				2: uint32(0xfb1f680b),
				3: uint32(0xaffdfbe3),
				4: uint32(0xf7ed9fa4),
				5: uint32(0xf80f7a7d),
				6: uint32(0x0fd5eebe),
				7: uint32(0xfd9fbb5d),
			},
		},
		665: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x3bf9f2db),
				1: uint32(0xebccfe7f),
				2: uint32(0x73fa876a),
				3: uint32(0x9ffc95fc),
				4: uint32(0xfaf7109f),
				5: uint32(0xbbcdddb7),
				6: uint32(0xeccdf87e),
				7: uint32(0x3c3ff366),
			},
		},
		666: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xb03ffffd),
				1: uint32(0x067ee9f7),
				2: uint32(0xfe0696ae),
				3: uint32(0x5fd7d576),
				4: uint32(0xa3f33fd1),
				5: uint32(0x6fb7cf07),
				6: uint32(0x7f449fd1),
				7: uint32(0xd3dd7b59),
			},
		},
		667: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xa9bdaf3b),
				1: uint32(0xff3a7dcf),
				2: uint32(0xf6ebfbe0),
				3: uint32(0xffffb401),
				4: uint32(0xb7bf7afa),
				5: uint32(0x0ffdc000),
				6: uint32(0xff1fff7f),
				7: uint32(0x95fffefc),
			},
		},
		668: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xb5dc0000),
				1: uint32(0x3f3eef63),
				2: uint32(0x001bfb7f),
				3: uint32(0xfbf6e800),
				4: uint32(0xb8df9eef),
				5: uint32(0x003fff9f),
				6: uint32(0xf5ff7bd0),
				7: uint32(0x3fffdfdb),
			},
		},
		669: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00bffdf0),
				1: uint32(0xbbbd8420),
				2: uint32(0xffdedf37),
				3: uint32(0x0ff3ff6d),
				4: uint32(0x5efb604c),
				5: uint32(0xfafbfffb),
				6: uint32(0x0219fe5e),
				7: uint32(0xf9de79f4),
			},
		},
		670: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xebfaa7f7),
				1: uint32(0xff3401eb),
				2: uint32(0xef73ebd3),
				3: uint32(0xc040afd7),
				4: uint32(0xdcff72bb),
				5: uint32(0x2fd8f17f),
				6: uint32(0xfe0bb8ec),
				7: uint32(0x1f0bdda3),
			},
		},
		671: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x47cf8f1d),
				1: uint32(0xffdeb12b),
				2: uint32(0xda737fee),
				3: uint32(0xcbc424ff),
				4: uint32(0xcbf2f75d),
				5: uint32(0xb4edecfd),
				6: uint32(0x4dddbff9),
				7: uint32(0xfb8d99dd),
			},
		},
		672: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xaf7bbb7f),
				1: uint32(0xc959ddfb),
				2: uint32(0xfab5fc4f),
				3: uint32(0x6d5fafe3),
				4: uint32(0x3f7dffff),
				5: uint32(0xffdb7800),
				6: uint32(0x7effb6ff),
				7: uint32(0x022ffbaf),
			},
		},
		673: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xefc7ff9b),
				1: uint32(0xffffffa5),
				2: uint32(0xc7000007),
				3: uint32(0xfff1f7ff),
				4: uint32(0x01bf7ffd),
				5: uint32(0xfdbcdc00),
				6: uint32(0xffffbff5),
				7: uint32(0x3effff7f),
			},
		},
		674: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xbe000029),
				1: uint32(0xff7ff9ff),
				2: uint32(0xfd7e6efb),
				3: uint32(0x039ecbff),
				4: uint32(0xfbdde300),
				5: uint32(0xf6dfccff),
				6: uint32(0x117fffff),
				7: uint32(0xfbf6f800),
			},
		},
		675: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xd73ce7ef),
				1: uint32(0xdfeffeef),
				2: uint32(0xedbfc00b),
				3: uint32(0xfdcdfedf),
				4: uint32(0x40fd7bf5),
				5: uint32(0xb75fffff),
				6: uint32(0xf930ffdf),
				7: uint32(0xdc97fbdf),
			},
		},
		676: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xbff2fef3),
				1: uint32(0xdfbf8fdf),
				2: uint32(0xede6177f),
				3: uint32(0x35530f7f),
				4: uint32(0x877e447c),
				5: uint32(0x45bbfa12),
				6: uint32(0x779eede0),
				7: uint32(0xbfd98017),
			},
		},
		677: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xde897e55),
				1: uint32(0x0447c16f),
				2: uint32(0xf75d7ade),
				3: uint32(0x290557ff),
				4: uint32(0xfe9586f7),
				5: uint32(0xf32f97b3),
				6: uint32(0x9f75cfff),
				7: uint32(0xfb1771f7),
			},
		},
		678: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xee1934ee),
				1: uint32(0xef6137cc),
				2: uint32(0xef4c9fd6),
				3: uint32(0xfbddd68f),
				4: uint32(0x6def7b73),
				5: uint32(0xa431d7fe),
				6: uint32(0x97d75e7f),
				7: uint32(0xffd80f5b),
			},
		},
		679: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x7bce9d83),
				1: uint32(0xdcff22ec),
				2: uint32(0xef87763d),
				3: uint32(0xfdeddfe7),
				4: uint32(0xa0fc4fff),
				5: uint32(0xdbfc3b77),
				6: uint32(0x7fdc3ded),
				7: uint32(0xf5706fa9),
			},
		},
		680: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x2c403ffb),
				1: uint32(0x847fff7f),
				2: uint32(0xdeb7ec57),
				3: uint32(0xf22fe69c),
				4: uint32(0xd5b50feb),
				5: uint32(0xede7afeb),
				6: uint32(0xfff08c2f),
				7: uint32(0xe8f0537f),
			},
		},
		681: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xb5ffb99d),
				1: uint32(0xe78fff66),
				2: uint32(0xbe10d981),
				3: uint32(0xe3c19c7c),
				4: uint32(0x27339cd1),
				5: uint32(0xff6d0cbc),
				6: uint32(0xefb7fcb7),
				7: uint32(0xffffa0df),
			},
		},
		682: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfe7bbf0b),
				1: uint32(0x353fa3ff),
				2: uint32(0x97cd13cc),
				3: uint32(0xfb277637),
				4: uint32(0x7e6ccfd6),
				5: uint32(0xed31ec50),
				6: uint32(0xfc1c677c),
				7: uint32(0x5fbff6fa),
			},
		},
		683: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xae2f0fba),
				1: uint32(0x7ffea3ad),
				2: uint32(0xde74fcf0),
				3: uint32(0xf200ffef),
				4: uint32(0xfea2fbbf),
				5: uint32(0xbcff3daf),
				6: uint32(0x5fb9f694),
				7: uint32(0x3f8ff3ad),
			},
		},
		684: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xa01ff26c),
				1: uint32(0x01bfffef),
				2: uint32(0x70057728),
				3: uint32(0xda03ff35),
				4: uint32(0xc7fad2f9),
				5: uint32(0x5c1d3fbf),
				6: uint32(0xec33ff3a),
				7: uint32(0xfe9cb7af),
			},
		},
		685: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x7a9f5236),
				1: uint32(0xe722bffa),
				2: uint32(0xfcff9ff7),
				3: uint32(0xb61d2fbb),
				4: uint32(0x1dfded06),
				5: uint32(0xefdf7dd7),
				6: uint32(0xf166eb23),
				7: uint32(0x0dc07ed9),
			},
		},
		686: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xdfbf3d3d),
				1: uint32(0xba83c945),
				2: uint32(0x9dd07dd1),
				3: uint32(0xcf737b87),
				4: uint32(0xc3f59ff3),
				5: uint32(0xc5fedf0d),
				6: uint32(0x83020cb3),
				7: uint32(0xaec0e879),
			},
		},
		687: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x6f0fc773),
				1: uint32(0x093ffd7d),
				2: uint32(0x0157fff1),
				3: uint32(0x01ff62fb),
				4: uint32(0x3bf3fdb4),
				5: uint32(0x43b2b013),
				6: uint32(0xff305ed3),
				7: uint32(0xeb9f0fff),
			},
		},
		688: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xf203feef),
				1: uint32(0xfb893fef),
				2: uint32(0x9e9937a9),
				3: uint32(0xa72cdef9),
				4: uint32(0xc1f63733),
				5: uint32(0xfe3e812e),
				6: uint32(0xf2f75d20),
				7: uint32(0x69d7d585),
			},
		},
		689: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffffffff),
				1: uint32(0xff6fdb07),
				2: uint32(0xd97fc4ff),
				3: uint32(0xbe0fefce),
				4: uint32(0xf05ef17b),
				5: uint32(0xffb7f6cf),
				6: uint32(0xef845ef7),
				7: uint32(0x0edfd7cb),
			},
		},
		690: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfcffff08),
				1: uint32(0xffffee3f),
				2: uint32(0xd7ff13ff),
				3: uint32(0x7ffdaf0f),
				4: uint32(0x1ffabdc7),
			},
		},
		691: {
			Fmap1: [8]TFcChar32{
				1: uint32(0xe7400000),
				2: uint32(0xf933bd38),
				3: uint32(0xfeed7feb),
				4: uint32(0x7c767fe8),
				5: uint32(0xffefb3f7),
				6: uint32(0xd8b7feaf),
				7: uint32(0xfbbfff6f),
			},
		},
		692: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xdbf7f8fb),
				1: uint32(0xe2f91752),
				2: uint32(0x754785c8),
				3: uint32(0xe3ef9090),
				4: uint32(0x3f6d9ef4),
				5: uint32(0x0536ee2e),
				6: uint32(0x7ff3f7bc),
				7: uint32(0x7f3fa07b),
			},
		},
		693: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xeb600567),
				1: uint32(0x6601babe),
				2: uint32(0x583ffcd8),
				3: uint32(0x87dfcaf7),
				4: uint32(0xffa0bfcd),
				5: uint32(0xfebf5bcd),
				6: uint32(0xefa7b6fd),
				7: uint32(0xdf9c77ef),
			},
		},
		694: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xf8773fb7),
				1: uint32(0xb7fc9d27),
				2: uint32(0xdfefcab5),
				3: uint32(0xf1b6fb5a),
				4: uint32(0xef1fec39),
				5: uint32(0x7ffbfbbf),
				6: uint32(0xdafe000d),
				7: uint32(0x4e7fbdfb),
			},
		},
		695: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x5ac033ff),
				1: uint32(0x9ffebff5),
				2: uint32(0x005fffbf),
				3: uint32(0xfdf80000),
				4: uint32(0x6ffdffca),
				5: uint32(0xa001cffd),
				6: uint32(0xfbf2dfff),
				7: uint32(0xff7fdfbf),
			},
		},
		696: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x080ffeda),
				1: uint32(0xbfffba08),
				2: uint32(0xeed77afd),
				3: uint32(0x67f9fbeb),
				4: uint32(0xff93e044),
				5: uint32(0x9f57df97),
				6: uint32(0x08dffef7),
				7: uint32(0xfedfdf80),
			},
		},
		697: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xf7feffc5),
				1: uint32(0x6803fffb),
				2: uint32(0x6bfa67fb),
				3: uint32(0x5fe27fff),
				4: uint32(0xff73ffff),
				5: uint32(0xe7fb87df),
				6: uint32(0xf7a7ebfd),
				7: uint32(0xefc7bf7e),
			},
		},
		698: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xdf821ef3),
				1: uint32(0xdf7e76ff),
				2: uint32(0xda7d79c9),
				3: uint32(0x1e9befbe),
				4: uint32(0x77fb7ce0),
				5: uint32(0xfffb87be),
				6: uint32(0xffdb1bff),
				7: uint32(0x4fe03f5c),
			},
		},
		699: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x5f0e7fff),
				1: uint32(0xddbf77ff),
				2: uint32(0xfffff04f),
				3: uint32(0x0ff8ffff),
				4: uint32(0xfddfa3be),
				5: uint32(0xfffdfc1c),
				6: uint32(0xfb9e1f7d),
				7: uint32(0xdedcbdff),
			},
		},
		700: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xbafb3f6f),
				1: uint32(0xfbefdf7f),
				2: uint32(0x2eec7d1b),
				3: uint32(0xf2f7af8e),
				4: uint32(0xcfee7b0f),
				5: uint32(0x77c61d96),
				6: uint32(0xfff57e07),
				7: uint32(0x7fdfd982),
			},
		},
		701: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xc7ff5ee6),
				1: uint32(0x79effeee),
				2: uint32(0xffcf9a56),
				3: uint32(0xde5efe5f),
				4: uint32(0xf9e8896e),
				5: uint32(0xe6c4f45e),
				6: uint32(0xbe7c0001),
				7: uint32(0xdddf3b7f),
			},
		},
		702: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xe9efd59d),
				1: uint32(0xde5334ac),
				2: uint32(0x4bf7f573),
				3: uint32(0x9eff7b4f),
				4: uint32(0x476eb8fe),
				5: uint32(0xff450dfb),
				6: uint32(0xfbfeabfd),
				7: uint32(0xddffe9d7),
			},
		},
		703: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x7fffedf7),
				1: uint32(0x7eebddfd),
				2: uint32(0xb7ffcfe7),
				3: uint32(0xef91bde9),
				4: uint32(0xd77c5d75),
			},
		},
		704: {
			Fmap1: [8]TFcChar32{
				1: uint32(0xfa800000),
				2: uint32(0xb4f1ffee),
				3: uint32(0x2fefbf76),
				4: uint32(0x77bfb677),
				5: uint32(0xfffd9fbf),
				6: uint32(0xf6ae95bf),
				7: uint32(0x7f3b75ff),
			},
		},
		705: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x0af9a7f5),
				3: uint32(0x2bddfbd0),
				4: uint32(0x9a7ff633),
				5: uint32(0xd6fcfdab),
				6: uint32(0xbfebf9e6),
				7: uint32(0xf41fdfdf),
			},
		},
		706: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffffa6fd),
				1: uint32(0xf37b4aff),
				2: uint32(0xfef97fb7),
				3: uint32(0x1d5cb6ff),
				4: uint32(0xe5ff7ff6),
				5: uint32(0x24041f7b),
				6: uint32(0xf99ebe05),
				7: uint32(0xdff2dbe3),
			},
		},
		707: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfdff6fef),
				1: uint32(0xcbfcd679),
				2: uint32(0xefffebfd),
				3: uint32(0x0000001f),
				4: uint32(0x98000000),
				5: uint32(0x8017e148),
				6: uint32(0x00fe6a74),
				7: uint32(0xfdf16d7f),
			},
		},
		708: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xfef3b87f),
				1: uint32(0xf176e01f),
				2: uint32(0x7b3fee96),
				3: uint32(0xfffdeb8d),
				4: uint32(0xcbb3adff),
				5: uint32(0xe17f84ef),
				6: uint32(0xbff04daa),
				7: uint32(0xfe3fbf3f),
			},
		},
		709: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xffd7ebff),
				1: uint32(0xcf7fffdf),
				2: uint32(0x85edfffb),
				3: uint32(0x07bcd73f),
				4: uint32(0xfe0faeff),
				5: uint32(0x76bffdaf),
				6: uint32(0x37bbfaef),
				7: uint32(0xa3ba7fdc),
			},
		},
		710: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x56f7b6ff),
				1: uint32(0xe7df60f8),
				2: uint32(0x4cdfff61),
				3: uint32(0xff45b0fb),
				4: uint32(0x3ffa7ded),
				5: uint32(0x18fc1fff),
				6: uint32(0xe3afffff),
				7: uint32(0xdf83c7d3),
			},
		},
		711: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xef7dfb57),
				1: uint32(0x1378efff),
				2: uint32(0x5ff7fec0),
				3: uint32(0x5ee334bb),
				4: uint32(0xeff6f70d),
				5: uint32(0x00bfd7fe),
				6: uint32(0xf7f7f59d),
				7: uint32(0xffe051de),
			},
		},
		712: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x037ffec9),
				1: uint32(0xbfef5f01),
				2: uint32(0x60a79ff1),
				3: uint32(0xf1ffef1d),
				4: uint32(0x0000000f),
			},
		},
		713: {
			Fmap1: [8]TFcChar32{
				3: uint32(0x3c800000),
				4: uint32(0xd91ffb4d),
				5: uint32(0xfee37b3a),
				6: uint32(0xdc7f3fe9),
				7: uint32(0x0000003f),
			},
		},
		714: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x50000000),
				1: uint32(0xbe07f51f),
				2: uint32(0xf91bfc1d),
				3: uint32(0x71ffbc1e),
				4: uint32(0x5bbe6ff9),
				5: uint32(0x9b1b5796),
				6: uint32(0xfffc7fff),
				7: uint32(0xafe7872e),
			},
		},
		715: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xf34febf5),
				1: uint32(0xe725dffd),
				2: uint32(0x5d440bdc),
				3: uint32(0xfddd5747),
				4: uint32(0x7790ed3f),
				5: uint32(0x8ac87d7f),
				6: uint32(0xf3f9fafa),
				7: uint32(0xef4b202a),
			},
		},
		716: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x79cff5ff),
				1: uint32(0x0ba5abd3),
				2: uint32(0xfb8ff77a),
				3: uint32(0x001f8ebd),
				5: uint32(0xfd4ef300),
				6: uint32(0x88001a57),
				7: uint32(0x7654aeac),
			},
		},
		717: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xcdff17ad),
				1: uint32(0xf42fffb2),
				2: uint32(0xdbff5baa),
				3: uint32(0x00000002),
				4: uint32(0x73c00000),
				5: uint32(0x2e3ff9ea),
				6: uint32(0xbbfffa8e),
				7: uint32(0xffd376bc),
			},
		},
		718: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x7e72eefe),
				1: uint32(0xe7f77ebd),
				2: uint32(0xcefdf77f),
				3: uint32(0x00000ff5),
				5: uint32(0xdb9ba900),
				6: uint32(0x917fa4c7),
				7: uint32(0x7ecef8ca),
			},
		},
		719: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xc7e77d7a),
				1: uint32(0xdcaecbbd),
				2: uint32(0x8f76fd7e),
				3: uint32(0x7cf391d3),
				4: uint32(0x4c2f01e5),
				5: uint32(0xa360ed77),
				6: uint32(0x5ef807db),
				7: uint32(0x21811df7),
			},
		},
		720: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x309c6be0),
				1: uint32(0xfade3b3a),
				2: uint32(0xc3f57f53),
				3: uint32(0x07ba61cd),
				7: uint32(0xbefe26e0),
			},
		},
		721: {
			Fmap1: [8]TFcChar32{
				0: uint32(0xebb503f9),
				1: uint32(0xe9cbe36d),
				2: uint32(0xbfde9c2f),
				3: uint32(0xabbf9f83),
				4: uint32(0xffd51ff7),
				5: uint32(0xdffeb7df),
				6: uint32(0xffeffdae),
				7: uint32(0xeffdfb7e),
			},
		},
		722: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x6ebfaaff),
				3: uint32(0xb6200000),
				4: uint32(0xbe9e7fcd),
				5: uint32(0x58f162b3),
				6: uint32(0xfd7bf10d),
				7: uint32(0xbefde9f1),
			},
		},
		723: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x5f6dc6c3),
				1: uint32(0x69ffff3d),
				2: uint32(0xfbf4ffcf),
				3: uint32(0x4ff7dcfb),
				4: uint32(0x11372000),
				5: uint32(0x00000015),
			},
		},
		724: {
			Fmap1: [8]TFcChar32{
				0: uint32(0x00003000),
			},
		},
	},
	Fleaf_offsets: [780]Tuintptr_t{
		0:   libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(0)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(0)*libc.Uint64FromInt64(8)),
		1:   libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(1)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(1)*libc.Uint64FromInt64(8)),
		2:   libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(2)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(2)*libc.Uint64FromInt64(8)),
		3:   libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(3)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(2)*libc.Uint64FromInt64(8)),
		4:   libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(4)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(4)*libc.Uint64FromInt64(8)),
		5:   libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(5)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(4)*libc.Uint64FromInt64(8)),
		6:   libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(6)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(4)*libc.Uint64FromInt64(8)),
		7:   libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(7)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(4)*libc.Uint64FromInt64(8)),
		8:   libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(8)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(4)*libc.Uint64FromInt64(8)),
		9:   libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(9)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(9)*libc.Uint64FromInt64(8)),
		10:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(10)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(9)*libc.Uint64FromInt64(8)),
		11:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(11)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(11)*libc.Uint64FromInt64(8)),
		12:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(12)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(12)*libc.Uint64FromInt64(8)),
		13:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(13)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(13)*libc.Uint64FromInt64(8)),
		14:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(11)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(14)*libc.Uint64FromInt64(8)),
		15:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(14)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(14)*libc.Uint64FromInt64(8)),
		16:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(15)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(16)*libc.Uint64FromInt64(8)),
		17:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(16)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(17)*libc.Uint64FromInt64(8)),
		18:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(17)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(18)*libc.Uint64FromInt64(8)),
		19:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(18)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(18)*libc.Uint64FromInt64(8)),
		20:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(19)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(18)*libc.Uint64FromInt64(8)),
		21:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(20)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(21)*libc.Uint64FromInt64(8)),
		22:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(21)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(22)*libc.Uint64FromInt64(8)),
		23:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(22)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(8)),
		24:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(24)*libc.Uint64FromInt64(8)),
		25:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(24)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(24)*libc.Uint64FromInt64(8)),
		26:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(25)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(24)*libc.Uint64FromInt64(8)),
		27:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(26)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(24)*libc.Uint64FromInt64(8)),
		28:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(27)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(28)*libc.Uint64FromInt64(8)),
		29:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(28)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(29)*libc.Uint64FromInt64(8)),
		30:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(29)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(8)),
		31:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(30)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(31)*libc.Uint64FromInt64(8)),
		32:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(31)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(32)*libc.Uint64FromInt64(8)),
		33:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(32)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(32)*libc.Uint64FromInt64(8)),
		34:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(33)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(32)*libc.Uint64FromInt64(8)),
		35:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(35)*libc.Uint64FromInt64(8)),
		36:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(34)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(35)*libc.Uint64FromInt64(8)),
		37:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(35)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(35)*libc.Uint64FromInt64(8)),
		38:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(36)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(38)*libc.Uint64FromInt64(8)),
		39:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(37)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(39)*libc.Uint64FromInt64(8)),
		40:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(38)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(40)*libc.Uint64FromInt64(8)),
		41:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(39)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(41)*libc.Uint64FromInt64(8)),
		42:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(42)*libc.Uint64FromInt64(8)),
		43:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(40)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(42)*libc.Uint64FromInt64(8)),
		44:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(41)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(44)*libc.Uint64FromInt64(8)),
		45:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(42)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(45)*libc.Uint64FromInt64(8)),
		46:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(43)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(45)*libc.Uint64FromInt64(8)),
		47:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(44)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(47)*libc.Uint64FromInt64(8)),
		48:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(45)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(47)*libc.Uint64FromInt64(8)),
		49:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(46)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(49)*libc.Uint64FromInt64(8)),
		50:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(47)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(50)*libc.Uint64FromInt64(8)),
		51:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(48)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(51)*libc.Uint64FromInt64(8)),
		52:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(49)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(52)*libc.Uint64FromInt64(8)),
		53:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(50)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(52)*libc.Uint64FromInt64(8)),
		54:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(51)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(54)*libc.Uint64FromInt64(8)),
		55:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(52)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(54)*libc.Uint64FromInt64(8)),
		56:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(53)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(56)*libc.Uint64FromInt64(8)),
		57:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(54)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(56)*libc.Uint64FromInt64(8)),
		58:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(55)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(58)*libc.Uint64FromInt64(8)),
		59:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(56)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(58)*libc.Uint64FromInt64(8)),
		60:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(57)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(60)*libc.Uint64FromInt64(8)),
		61:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(58)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(61)*libc.Uint64FromInt64(8)),
		62:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(59)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(61)*libc.Uint64FromInt64(8)),
		63:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(60)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(63)*libc.Uint64FromInt64(8)),
		64:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(61)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(63)*libc.Uint64FromInt64(8)),
		65:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(62)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(63)*libc.Uint64FromInt64(8)),
		66:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(63)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(66)*libc.Uint64FromInt64(8)),
		67:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(64)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(67)*libc.Uint64FromInt64(8)),
		68:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(65)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(68)*libc.Uint64FromInt64(8)),
		69:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(66)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(69)*libc.Uint64FromInt64(8)),
		70:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(31)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(70)*libc.Uint64FromInt64(8)),
		71:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(67)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(70)*libc.Uint64FromInt64(8)),
		72:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(68)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(70)*libc.Uint64FromInt64(8)),
		73:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(69)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(70)*libc.Uint64FromInt64(8)),
		74:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(70)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(74)*libc.Uint64FromInt64(8)),
		75:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(71)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(75)*libc.Uint64FromInt64(8)),
		76:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(76)*libc.Uint64FromInt64(8)),
		77:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(72)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(76)*libc.Uint64FromInt64(8)),
		78:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(73)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(78)*libc.Uint64FromInt64(8)),
		79:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(74)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(78)*libc.Uint64FromInt64(8)),
		80:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(75)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(80)*libc.Uint64FromInt64(8)),
		81:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(81)*libc.Uint64FromInt64(8)),
		82:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(76)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(81)*libc.Uint64FromInt64(8)),
		83:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(77)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(81)*libc.Uint64FromInt64(8)),
		84:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(78)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(84)*libc.Uint64FromInt64(8)),
		85:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(74)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(84)*libc.Uint64FromInt64(8)),
		86:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(79)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(86)*libc.Uint64FromInt64(8)),
		87:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(8)),
		88:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(80)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(88)*libc.Uint64FromInt64(8)),
		89:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(81)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(89)*libc.Uint64FromInt64(8)),
		90:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(82)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(90)*libc.Uint64FromInt64(8)),
		91:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(83)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(91)*libc.Uint64FromInt64(8)),
		92:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(84)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(91)*libc.Uint64FromInt64(8)),
		93:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(85)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(91)*libc.Uint64FromInt64(8)),
		94:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(86)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(94)*libc.Uint64FromInt64(8)),
		95:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(87)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(95)*libc.Uint64FromInt64(8)),
		96:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(88)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(95)*libc.Uint64FromInt64(8)),
		97:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(89)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(97)*libc.Uint64FromInt64(8)),
		98:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(90)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(97)*libc.Uint64FromInt64(8)),
		99:  libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(91)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(97)*libc.Uint64FromInt64(8)),
		100: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(92)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(100)*libc.Uint64FromInt64(8)),
		101: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(93)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(101)*libc.Uint64FromInt64(8)),
		102: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(102)*libc.Uint64FromInt64(8)),
		103: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(94)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(102)*libc.Uint64FromInt64(8)),
		104: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(95)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(102)*libc.Uint64FromInt64(8)),
		105: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(105)*libc.Uint64FromInt64(8)),
		106: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(96)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(105)*libc.Uint64FromInt64(8)),
		107: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(97)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(105)*libc.Uint64FromInt64(8)),
		108: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(98)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(108)*libc.Uint64FromInt64(8)),
		109: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(99)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(109)*libc.Uint64FromInt64(8)),
		110: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(100)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(109)*libc.Uint64FromInt64(8)),
		111: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(101)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(111)*libc.Uint64FromInt64(8)),
		112: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(102)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(112)*libc.Uint64FromInt64(8)),
		113: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(103)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(112)*libc.Uint64FromInt64(8)),
		114: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(104)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(114)*libc.Uint64FromInt64(8)),
		115: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(115)*libc.Uint64FromInt64(8)),
		116: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(105)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(115)*libc.Uint64FromInt64(8)),
		117: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(106)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(115)*libc.Uint64FromInt64(8)),
		118: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(107)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(118)*libc.Uint64FromInt64(8)),
		119: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(53)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(119)*libc.Uint64FromInt64(8)),
		120: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(120)*libc.Uint64FromInt64(8)),
		121: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(108)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(120)*libc.Uint64FromInt64(8)),
		122: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(109)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(122)*libc.Uint64FromInt64(8)),
		123: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(109)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(122)*libc.Uint64FromInt64(8)),
		124: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(109)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(122)*libc.Uint64FromInt64(8)),
		125: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(109)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(122)*libc.Uint64FromInt64(8)),
		126: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(110)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(122)*libc.Uint64FromInt64(8)),
		127: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(111)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(127)*libc.Uint64FromInt64(8)),
		128: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(112)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(128)*libc.Uint64FromInt64(8)),
		129: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(113)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(129)*libc.Uint64FromInt64(8)),
		130: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(114)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(130)*libc.Uint64FromInt64(8)),
		131: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(115)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(130)*libc.Uint64FromInt64(8)),
		132: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(116)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(130)*libc.Uint64FromInt64(8)),
		133: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(117)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		134: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(118)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		135: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(119)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		136: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(120)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		137: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(121)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		138: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(122)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		139: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(123)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		140: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(124)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		141: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(125)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		142: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(126)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		143: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(127)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		144: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(128)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		145: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(129)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		146: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(130)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		147: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(131)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		148: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(132)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		149: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		150: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(134)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		151: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(135)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		152: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(136)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		153: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(137)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		154: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(138)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		155: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(139)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		156: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(140)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		157: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(141)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		158: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(142)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		159: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(143)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		160: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(144)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		161: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(145)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		162: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(146)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		163: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(147)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		164: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(148)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		165: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(149)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		166: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(150)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		167: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(151)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		168: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(152)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		169: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(153)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		170: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(154)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		171: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(155)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		172: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(156)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		173: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(157)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		174: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(158)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		175: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(159)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		176: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(160)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		177: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(161)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		178: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(162)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		179: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(163)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		180: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(164)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		181: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(165)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		182: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(166)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		183: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(167)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		184: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(168)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		185: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(169)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		186: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(170)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		187: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(171)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		188: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(172)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		189: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(173)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		190: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(174)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		191: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(175)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		192: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(176)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		193: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(177)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		194: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(178)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		195: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(179)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		196: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(180)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		197: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(181)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		198: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(182)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		199: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(183)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		200: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(184)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		201: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(185)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		202: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(186)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		203: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(187)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		204: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(188)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		205: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(189)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		206: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(190)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		207: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(191)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		208: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(192)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		209: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(193)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		210: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(194)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		211: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(195)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		212: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(196)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		213: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(197)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		214: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(198)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		215: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(199)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(133)*libc.Uint64FromInt64(8)),
		216: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(200)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(216)*libc.Uint64FromInt64(8)),
		217: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(201)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(217)*libc.Uint64FromInt64(8)),
		218: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(202)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(218)*libc.Uint64FromInt64(8)),
		219: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(219)*libc.Uint64FromInt64(8)),
		220: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(203)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(219)*libc.Uint64FromInt64(8)),
		221: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(204)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(221)*libc.Uint64FromInt64(8)),
		222: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(205)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(222)*libc.Uint64FromInt64(8)),
		223: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(206)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(222)*libc.Uint64FromInt64(8)),
		224: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(207)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(224)*libc.Uint64FromInt64(8)),
		225: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(208)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(225)*libc.Uint64FromInt64(8)),
		226: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(209)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		227: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(210)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		228: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(211)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		229: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(212)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		230: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(213)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		231: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(214)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		232: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(215)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		233: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(216)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		234: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(217)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		235: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(218)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		236: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(219)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		237: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(220)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		238: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(221)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		239: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(222)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		240: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(223)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		241: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(224)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		242: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(225)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		243: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		244: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(227)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		245: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(228)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		246: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(229)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		247: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(230)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		248: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(231)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		249: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(232)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		250: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(233)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		251: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(234)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		252: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(235)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		253: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(236)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		254: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(237)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		255: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(238)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		256: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(239)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		257: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(240)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		258: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(241)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		259: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(242)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		260: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(243)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		261: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(244)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		262: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(245)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		263: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(246)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		264: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(247)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		265: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(248)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		266: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(249)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		267: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(250)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		268: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(251)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		269: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(252)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		270: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(253)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(226)*libc.Uint64FromInt64(8)),
		271: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(271)*libc.Uint64FromInt64(8)),
		272: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(254)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(271)*libc.Uint64FromInt64(8)),
		273: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(255)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(271)*libc.Uint64FromInt64(8)),
		274: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(256)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(274)*libc.Uint64FromInt64(8)),
		275: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(257)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(275)*libc.Uint64FromInt64(8)),
		276: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(258)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(275)*libc.Uint64FromInt64(8)),
		277: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(259)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(277)*libc.Uint64FromInt64(8)),
		278: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(260)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(278)*libc.Uint64FromInt64(8)),
		279: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(261)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(278)*libc.Uint64FromInt64(8)),
		280: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(262)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(280)*libc.Uint64FromInt64(8)),
		281: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(263)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(281)*libc.Uint64FromInt64(8)),
		282: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(282)*libc.Uint64FromInt64(8)),
		283: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(96)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(282)*libc.Uint64FromInt64(8)),
		284: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(264)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(282)*libc.Uint64FromInt64(8)),
		285: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(265)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(285)*libc.Uint64FromInt64(8)),
		286: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(286)*libc.Uint64FromInt64(8)),
		287: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(266)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(286)*libc.Uint64FromInt64(8)),
		288: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(267)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(288)*libc.Uint64FromInt64(8)),
		289: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(268)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(289)*libc.Uint64FromInt64(8)),
		290: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(290)*libc.Uint64FromInt64(8)),
		291: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(269)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(290)*libc.Uint64FromInt64(8)),
		292: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(270)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(292)*libc.Uint64FromInt64(8)),
		293: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(271)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(293)*libc.Uint64FromInt64(8)),
		294: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(272)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(293)*libc.Uint64FromInt64(8)),
		295: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(6)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(293)*libc.Uint64FromInt64(8)),
		296: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(273)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(293)*libc.Uint64FromInt64(8)),
		297: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(274)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(297)*libc.Uint64FromInt64(8)),
		298: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(298)*libc.Uint64FromInt64(8)),
		299: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(275)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(298)*libc.Uint64FromInt64(8)),
		300: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(300)*libc.Uint64FromInt64(8)),
		301: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(276)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(300)*libc.Uint64FromInt64(8)),
		302: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(277)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(302)*libc.Uint64FromInt64(8)),
		303: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(303)*libc.Uint64FromInt64(8)),
		304: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(278)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(303)*libc.Uint64FromInt64(8)),
		305: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(305)*libc.Uint64FromInt64(8)),
		306: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(96)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(305)*libc.Uint64FromInt64(8)),
		307: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(279)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(305)*libc.Uint64FromInt64(8)),
		308: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(280)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(308)*libc.Uint64FromInt64(8)),
		309: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(281)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(309)*libc.Uint64FromInt64(8)),
		310: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(282)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(310)*libc.Uint64FromInt64(8)),
		311: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(283)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(311)*libc.Uint64FromInt64(8)),
		312: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(284)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(312)*libc.Uint64FromInt64(8)),
		313: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(285)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(313)*libc.Uint64FromInt64(8)),
		314: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(58)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(313)*libc.Uint64FromInt64(8)),
		315: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(286)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(313)*libc.Uint64FromInt64(8)),
		316: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(262)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(313)*libc.Uint64FromInt64(8)),
		317: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(287)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(317)*libc.Uint64FromInt64(8)),
		318: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(288)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(317)*libc.Uint64FromInt64(8)),
		319: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(289)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(319)*libc.Uint64FromInt64(8)),
		320: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(4)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(320)*libc.Uint64FromInt64(8)),
		321: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(290)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(320)*libc.Uint64FromInt64(8)),
		322: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(291)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(322)*libc.Uint64FromInt64(8)),
		323: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(292)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(323)*libc.Uint64FromInt64(8)),
		324: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(293)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(324)*libc.Uint64FromInt64(8)),
		325: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(294)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(325)*libc.Uint64FromInt64(8)),
		326: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(295)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(326)*libc.Uint64FromInt64(8)),
		327: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(296)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(327)*libc.Uint64FromInt64(8)),
		328: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(297)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(327)*libc.Uint64FromInt64(8)),
		329: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(298)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(329)*libc.Uint64FromInt64(8)),
		330: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(299)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(329)*libc.Uint64FromInt64(8)),
		331: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(300)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(329)*libc.Uint64FromInt64(8)),
		332: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(301)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(329)*libc.Uint64FromInt64(8)),
		333: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(333)*libc.Uint64FromInt64(8)),
		334: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(302)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(333)*libc.Uint64FromInt64(8)),
		335: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(303)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(335)*libc.Uint64FromInt64(8)),
		336: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(304)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(336)*libc.Uint64FromInt64(8)),
		337: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(305)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(337)*libc.Uint64FromInt64(8)),
		338: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(306)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(338)*libc.Uint64FromInt64(8)),
		339: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(307)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(339)*libc.Uint64FromInt64(8)),
		340: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(308)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(340)*libc.Uint64FromInt64(8)),
		341: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(99)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(341)*libc.Uint64FromInt64(8)),
		342: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(309)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(341)*libc.Uint64FromInt64(8)),
		343: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(310)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(343)*libc.Uint64FromInt64(8)),
		344: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(311)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(344)*libc.Uint64FromInt64(8)),
		345: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(312)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(345)*libc.Uint64FromInt64(8)),
		346: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(308)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(346)*libc.Uint64FromInt64(8)),
		347: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(313)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(346)*libc.Uint64FromInt64(8)),
		348: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(314)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(348)*libc.Uint64FromInt64(8)),
		349: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(285)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(349)*libc.Uint64FromInt64(8)),
		350: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(58)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(349)*libc.Uint64FromInt64(8)),
		351: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(286)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(349)*libc.Uint64FromInt64(8)),
		352: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(315)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(352)*libc.Uint64FromInt64(8)),
		353: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(316)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(353)*libc.Uint64FromInt64(8)),
		354: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(317)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(354)*libc.Uint64FromInt64(8)),
		355: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(355)*libc.Uint64FromInt64(8)),
		356: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(318)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(355)*libc.Uint64FromInt64(8)),
		357: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(319)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(355)*libc.Uint64FromInt64(8)),
		358: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(320)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(358)*libc.Uint64FromInt64(8)),
		359: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(321)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(359)*libc.Uint64FromInt64(8)),
		360: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(322)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(359)*libc.Uint64FromInt64(8)),
		361: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(323)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(361)*libc.Uint64FromInt64(8)),
		362: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(362)*libc.Uint64FromInt64(8)),
		363: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(40)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(362)*libc.Uint64FromInt64(8)),
		364: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(324)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(362)*libc.Uint64FromInt64(8)),
		365: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(325)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(365)*libc.Uint64FromInt64(8)),
		366: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(326)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(365)*libc.Uint64FromInt64(8)),
		367: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(327)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(367)*libc.Uint64FromInt64(8)),
		368: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(328)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(368)*libc.Uint64FromInt64(8)),
		369: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(10)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(368)*libc.Uint64FromInt64(8)),
		370: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(329)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(370)*libc.Uint64FromInt64(8)),
		371: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(330)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(370)*libc.Uint64FromInt64(8)),
		372: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(372)*libc.Uint64FromInt64(8)),
		373: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(97)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(372)*libc.Uint64FromInt64(8)),
		374: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(331)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(374)*libc.Uint64FromInt64(8)),
		375: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(332)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(375)*libc.Uint64FromInt64(8)),
		376: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(333)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(376)*libc.Uint64FromInt64(8)),
		377: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(334)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(376)*libc.Uint64FromInt64(8)),
		378: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(335)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(378)*libc.Uint64FromInt64(8)),
		379: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(336)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(378)*libc.Uint64FromInt64(8)),
		380: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(337)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(378)*libc.Uint64FromInt64(8)),
		381: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(338)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(381)*libc.Uint64FromInt64(8)),
		382: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(339)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(382)*libc.Uint64FromInt64(8)),
		383: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(340)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(383)*libc.Uint64FromInt64(8)),
		384: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(341)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(384)*libc.Uint64FromInt64(8)),
		385: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(342)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(385)*libc.Uint64FromInt64(8)),
		386: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(343)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(386)*libc.Uint64FromInt64(8)),
		387: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(344)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(387)*libc.Uint64FromInt64(8)),
		388: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(345)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(388)*libc.Uint64FromInt64(8)),
		389: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(346)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(389)*libc.Uint64FromInt64(8)),
		390: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(43)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(389)*libc.Uint64FromInt64(8)),
		391: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(347)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(391)*libc.Uint64FromInt64(8)),
		392: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(348)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(391)*libc.Uint64FromInt64(8)),
		393: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(349)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(393)*libc.Uint64FromInt64(8)),
		394: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(52)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(393)*libc.Uint64FromInt64(8)),
		395: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(350)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(395)*libc.Uint64FromInt64(8)),
		396: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(351)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(396)*libc.Uint64FromInt64(8)),
		397: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(96)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(396)*libc.Uint64FromInt64(8)),
		398: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(300)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(396)*libc.Uint64FromInt64(8)),
		399: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(352)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(399)*libc.Uint64FromInt64(8)),
		400: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(353)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(400)*libc.Uint64FromInt64(8)),
		401: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(354)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(8)),
		402: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(355)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(8)),
		403: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(356)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(8)),
		404: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(357)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(8)),
		405: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(358)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(8)),
		406: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(359)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(8)),
		407: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(360)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(8)),
		408: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(361)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(8)),
		409: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(362)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(8)),
		410: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(363)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(8)),
		411: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(364)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(8)),
		412: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(365)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(8)),
		413: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(366)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(8)),
		414: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(367)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(8)),
		415: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(368)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(8)),
		416: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(369)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(8)),
		417: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(370)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(8)),
		418: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(371)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(8)),
		419: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(372)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(8)),
		420: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(373)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(8)),
		421: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(374)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(8)),
		422: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(375)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(8)),
		423: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(376)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(8)),
		424: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(377)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(8)),
		425: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(23)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(425)*libc.Uint64FromInt64(8)),
		426: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(378)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(425)*libc.Uint64FromInt64(8)),
		427: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(379)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(427)*libc.Uint64FromInt64(8)),
		428: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(380)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(427)*libc.Uint64FromInt64(8)),
		429: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(381)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(427)*libc.Uint64FromInt64(8)),
		430: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(382)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(427)*libc.Uint64FromInt64(8)),
		431: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(383)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(431)*libc.Uint64FromInt64(8)),
		432: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(384)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(432)*libc.Uint64FromInt64(8)),
		433: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(74)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(432)*libc.Uint64FromInt64(8)),
		434: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(385)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(434)*libc.Uint64FromInt64(8)),
		435: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(99)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(435)*libc.Uint64FromInt64(8)),
		436: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(386)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(435)*libc.Uint64FromInt64(8)),
		437: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(387)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(437)*libc.Uint64FromInt64(8)),
		438: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(269)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(437)*libc.Uint64FromInt64(8)),
		439: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(388)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(439)*libc.Uint64FromInt64(8)),
		440: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(389)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(440)*libc.Uint64FromInt64(8)),
		441: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(390)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(440)*libc.Uint64FromInt64(8)),
		442: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(391)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(440)*libc.Uint64FromInt64(8)),
		443: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(392)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(440)*libc.Uint64FromInt64(8)),
		444: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(393)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		445: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(394)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		446: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(395)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		447: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(396)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		448: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(397)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		449: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(398)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		450: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(399)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		451: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(400)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		452: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(401)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		453: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(402)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		454: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(403)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		455: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(404)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		456: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(405)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		457: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(406)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		458: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(407)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		459: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(408)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		460: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(409)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		461: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(410)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		462: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(411)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		463: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(412)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		464: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(413)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		465: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(414)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		466: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(415)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		467: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(416)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		468: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(417)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		469: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(418)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		470: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(419)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		471: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(420)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		472: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(421)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		473: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(422)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		474: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(423)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		475: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(424)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		476: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(425)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		477: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(426)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		478: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(427)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		479: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(428)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		480: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(429)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		481: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(430)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		482: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(431)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		483: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(432)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		484: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(433)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		485: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(434)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		486: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(435)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		487: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(436)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		488: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(437)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		489: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(438)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		490: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(439)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		491: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(440)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		492: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(441)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		493: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(442)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		494: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(443)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		495: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		496: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(445)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		497: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(446)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		498: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(447)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		499: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(448)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		500: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(449)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		501: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(450)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		502: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(451)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		503: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(452)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		504: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(453)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		505: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(454)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		506: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(455)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		507: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(456)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		508: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(457)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		509: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(458)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		510: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(459)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		511: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(460)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		512: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(461)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		513: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(462)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		514: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(463)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		515: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(464)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		516: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(465)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		517: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(466)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		518: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(467)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		519: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(468)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		520: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(469)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		521: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(470)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		522: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(471)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		523: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(472)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		524: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(473)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		525: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(474)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(444)*libc.Uint64FromInt64(8)),
		526: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(475)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		527: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(476)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		528: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(477)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		529: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(478)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		530: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(479)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		531: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(480)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		532: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(481)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		533: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(482)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		534: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(483)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		535: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(484)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		536: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(485)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		537: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(486)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		538: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(487)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		539: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(488)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		540: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(489)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		541: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(490)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		542: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(491)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		543: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(492)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		544: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(493)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		545: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(494)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		546: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(495)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		547: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(496)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		548: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(497)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		549: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(498)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		550: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(499)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		551: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(500)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		552: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(501)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		553: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(502)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		554: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(503)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		555: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(504)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		556: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(505)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		557: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(506)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		558: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(507)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		559: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(508)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		560: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(509)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		561: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(510)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		562: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(511)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		563: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(512)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		564: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(513)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		565: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(514)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		566: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(515)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		567: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(516)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		568: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(517)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		569: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(518)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		570: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(519)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		571: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(520)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		572: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(521)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		573: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(522)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		574: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(523)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		575: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(524)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		576: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(525)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		577: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		578: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(527)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		579: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(528)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		580: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(529)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		581: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(530)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		582: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(531)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		583: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(532)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		584: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(533)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		585: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(534)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		586: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(535)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		587: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(536)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		588: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(537)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		589: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(538)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		590: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(539)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		591: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(540)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		592: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(541)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		593: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(542)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		594: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(543)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		595: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(544)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		596: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(545)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		597: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(546)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		598: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(547)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		599: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(548)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		600: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(549)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		601: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(550)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		602: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(551)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		603: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(552)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		604: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(553)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		605: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(554)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		606: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(555)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		607: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(556)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		608: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(557)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		609: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(558)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		610: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(559)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		611: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(560)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		612: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(561)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		613: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(562)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		614: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(563)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		615: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(564)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		616: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(565)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		617: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(566)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		618: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(567)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		619: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(568)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		620: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(569)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		621: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(570)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		622: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(571)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		623: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(572)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		624: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(573)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		625: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(574)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		626: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(575)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		627: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(576)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		628: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(577)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		629: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(578)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		630: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(579)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		631: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(580)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		632: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(581)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		633: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(582)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		634: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(583)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		635: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(584)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		636: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(585)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		637: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(586)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		638: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(587)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		639: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(588)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		640: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(589)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		641: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(590)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		642: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(591)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		643: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(592)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		644: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(593)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		645: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(594)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		646: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(595)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		647: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(596)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		648: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(597)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		649: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(598)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		650: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(599)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		651: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(600)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		652: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(601)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		653: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(602)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		654: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(603)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		655: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(604)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		656: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(355)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		657: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(605)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		658: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(606)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		659: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(318)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		660: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(607)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		661: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(608)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		662: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(609)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		663: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(610)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		664: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(611)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		665: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(612)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		666: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(613)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		667: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(3)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		668: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(614)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		669: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(615)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		670: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(616)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		671: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(617)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		672: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(618)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		673: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(619)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		674: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(604)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		675: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(620)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		676: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(621)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		677: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(622)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		678: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(623)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		679: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(624)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		680: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(625)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		681: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(626)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		682: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(627)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		683: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(628)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		684: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(629)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		685: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(630)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		686: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(631)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		687: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(632)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		688: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(633)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		689: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(634)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		690: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(635)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		691: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(636)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		692: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(637)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		693: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(638)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		694: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(639)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		695: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(640)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		696: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(641)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(526)*libc.Uint64FromInt64(8)),
		697: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(642)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		698: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(643)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		699: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(644)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		700: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(645)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		701: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(646)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		702: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(647)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		703: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(648)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		704: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(649)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		705: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(650)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		706: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(651)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		707: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(652)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		708: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(653)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		709: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(654)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		710: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(655)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		711: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(656)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		712: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(657)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		713: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(658)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		714: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(659)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		715: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(660)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		716: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(661)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		717: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(662)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		718: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(663)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		719: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(664)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		720: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(665)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		721: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(666)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		722: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(667)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		723: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(668)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		724: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(669)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		725: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(670)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		726: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(671)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		727: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(672)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		728: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(673)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		729: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(674)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		730: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(675)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		731: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(676)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		732: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(677)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		733: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(678)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		734: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(679)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		735: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(680)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		736: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(681)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		737: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(682)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		738: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(683)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		739: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(684)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		740: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(685)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		741: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(686)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		742: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(687)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		743: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(688)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		744: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(689)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		745: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(690)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		746: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(691)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		747: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(692)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		748: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(693)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		749: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(694)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		750: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(695)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		751: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(696)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		752: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		753: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(698)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		754: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(699)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		755: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(700)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		756: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(701)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		757: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(702)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		758: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(703)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		759: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(704)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		760: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(705)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		761: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(706)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		762: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(707)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		763: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(708)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		764: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(709)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		765: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(710)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		766: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(711)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		767: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(712)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		768: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(713)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		769: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(714)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		770: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(715)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		771: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(716)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		772: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(717)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		773: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(718)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		774: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(719)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		775: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(720)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		776: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(721)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		777: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(722)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		778: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(723)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
		779: libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(724)*libc.Uint64FromInt64(32) - (libc.Uint64FromInt32(246)*libc.Uint64FromInt64(40) + libc.Uint64FromInt32(725)*libc.Uint64FromInt64(32) + libc.Uint64FromInt32(697)*libc.Uint64FromInt64(8)),
	},
	Fnumbers: [780]TFcChar16{
		1:   uint16(0x0004),
		3:   uint16(0x0001),
		5:   uint16(0x0001),
		6:   uint16(0x0002),
		7:   uint16(0x0003),
		8:   uint16(0x001e),
		9:   uint16(0x0012),
		10:  uint16(0x0013),
		12:  uint16(0x0006),
		13:  uint16(0x0009),
		15:  uint16(0x001e),
		16:  uint16(0x0004),
		19:  uint16(0x0001),
		20:  uint16(0x0002),
		21:  uint16(0x0006),
		22:  uint16(0x0004),
		23:  uint16(0x0004),
		25:  uint16(0x0001),
		26:  uint16(0x0002),
		27:  uint16(0x001e),
		28:  uint16(0x002d),
		29:  uint16(0x0004),
		30:  uint16(0x0009),
		33:  uint16(0x0003),
		34:  uint16(0x001e),
		36:  uint16(0x0001),
		37:  uint16(0x0002),
		38:  uint16(0x0009),
		39:  uint16(0x000f),
		41:  uint16(0x0009),
		43:  uint16(0x0001),
		44:  uint16(0x0004),
		45:  uint16(0x0012),
		46:  uint16(0x0013),
		48:  uint16(0x0001),
		50:  uint16(0x0004),
		51:  uint16(0x0013),
		53:  uint16(0x0001),
		55:  uint16(0x0001),
		57:  uint16(0x0001),
		59:  uint16(0x0001),
		60:  uint16(0x0004),
		61:  uint16(0x0001),
		62:  uint16(0x0004),
		64:  uint16(0x0001),
		65:  uint16(0x001e),
		68:  uint16(0x0009),
		69:  uint16(0x0007),
		71:  uint16(0x0001),
		72:  uint16(0x0002),
		73:  uint16(0x0003),
		74:  uint16(0x0003),
		77:  uint16(0x0001),
		79:  uint16(0x0001),
		82:  uint16(0x0001),
		83:  uint16(0x0002),
		85:  uint16(0x0001),
		92:  uint16(0x0001),
		93:  uint16(0x001e),
		95:  uint16(0x0012),
		96:  uint16(0x0013),
		98:  uint16(0x0001),
		99:  uint16(0x001e),
		100: uint16(0x000a),
		103: uint16(0x0001),
		104: uint16(0x0002),
		106: uint16(0x0001),
		107: uint16(0x0002),
		108: uint16(0x0005),
		110: uint16(0x0001),
		113: uint16(0x0001),
		114: uint16(0x0005),
		116: uint16(0x0003),
		117: uint16(0x001e),
		121: uint16(0x001e),
		122: uint16(0x00a0),
		123: uint16(0x00a1),
		124: uint16(0x00a2),
		125: uint16(0x00a3),
		126: uint16(0x00a4),
		127: uint16(0x0004),
		130: uint16(0x0014),
		131: uint16(0x0015),
		132: uint16(0x0016),
		133: uint16(0x0030),
		134: uint16(0x004e),
		135: uint16(0x004f),
		136: uint16(0x0050),
		137: uint16(0x0051),
		138: uint16(0x0052),
		139: uint16(0x0053),
		140: uint16(0x0054),
		141: uint16(0x0055),
		142: uint16(0x0056),
		143: uint16(0x0057),
		144: uint16(0x0058),
		145: uint16(0x0059),
		146: uint16(0x005a),
		147: uint16(0x005b),
		148: uint16(0x005c),
		149: uint16(0x005d),
		150: uint16(0x005e),
		151: uint16(0x005f),
		152: uint16(0x0060),
		153: uint16(0x0061),
		154: uint16(0x0062),
		155: uint16(0x0063),
		156: uint16(0x0064),
		157: uint16(0x0065),
		158: uint16(0x0066),
		159: uint16(0x0067),
		160: uint16(0x0068),
		161: uint16(0x0069),
		162: uint16(0x006a),
		163: uint16(0x006b),
		164: uint16(0x006c),
		165: uint16(0x006d),
		166: uint16(0x006e),
		167: uint16(0x006f),
		168: uint16(0x0070),
		169: uint16(0x0071),
		170: uint16(0x0072),
		171: uint16(0x0073),
		172: uint16(0x0074),
		173: uint16(0x0075),
		174: uint16(0x0076),
		175: uint16(0x0077),
		176: uint16(0x0078),
		177: uint16(0x0079),
		178: uint16(0x007a),
		179: uint16(0x007b),
		180: uint16(0x007c),
		181: uint16(0x007d),
		182: uint16(0x007e),
		183: uint16(0x007f),
		184: uint16(0x0080),
		185: uint16(0x0081),
		186: uint16(0x0082),
		187: uint16(0x0083),
		188: uint16(0x0084),
		189: uint16(0x0085),
		190: uint16(0x0086),
		191: uint16(0x0087),
		192: uint16(0x0088),
		193: uint16(0x0089),
		194: uint16(0x008a),
		195: uint16(0x008b),
		196: uint16(0x008c),
		197: uint16(0x008d),
		198: uint16(0x008e),
		199: uint16(0x008f),
		200: uint16(0x0090),
		201: uint16(0x0091),
		202: uint16(0x0092),
		203: uint16(0x0093),
		204: uint16(0x0094),
		205: uint16(0x0095),
		206: uint16(0x0096),
		207: uint16(0x0097),
		208: uint16(0x0098),
		209: uint16(0x0099),
		210: uint16(0x009a),
		211: uint16(0x009b),
		212: uint16(0x009c),
		213: uint16(0x009d),
		214: uint16(0x009e),
		215: uint16(0x009f),
		217: uint16(0x0010),
		218: uint16(0x0004),
		220: uint16(0x0001),
		221: uint16(0x0004),
		223: uint16(0x0001),
		224: uint16(0x0017),
		225: uint16(0x000c),
		226: uint16(0x0031),
		227: uint16(0x00ac),
		228: uint16(0x00ad),
		229: uint16(0x00ae),
		230: uint16(0x00af),
		231: uint16(0x00b0),
		232: uint16(0x00b1),
		233: uint16(0x00b2),
		234: uint16(0x00b3),
		235: uint16(0x00b4),
		236: uint16(0x00b5),
		237: uint16(0x00b6),
		238: uint16(0x00b7),
		239: uint16(0x00b8),
		240: uint16(0x00b9),
		241: uint16(0x00ba),
		242: uint16(0x00bb),
		243: uint16(0x00bc),
		244: uint16(0x00bd),
		245: uint16(0x00be),
		246: uint16(0x00bf),
		247: uint16(0x00c0),
		248: uint16(0x00c1),
		249: uint16(0x00c2),
		250: uint16(0x00c3),
		251: uint16(0x00c4),
		252: uint16(0x00c5),
		253: uint16(0x00c6),
		254: uint16(0x00c7),
		255: uint16(0x00c8),
		256: uint16(0x00c9),
		257: uint16(0x00ca),
		258: uint16(0x00cb),
		259: uint16(0x00cc),
		260: uint16(0x00cd),
		261: uint16(0x00ce),
		262: uint16(0x00cf),
		263: uint16(0x00d0),
		264: uint16(0x00d1),
		265: uint16(0x00d2),
		266: uint16(0x00d3),
		267: uint16(0x00d4),
		268: uint16(0x00d5),
		269: uint16(0x00d6),
		270: uint16(0x00d7),
		272: uint16(0x0001),
		273: uint16(0x0002),
		274: uint16(0x0006),
		275: uint16(0x0004),
		276: uint16(0x0005),
		277: uint16(0x0006),
		279: uint16(0x0001),
		280: uint16(0x0004),
		281: uint16(0x0004),
		283: uint16(0x0001),
		284: uint16(0x0002),
		285: uint16(0x0004),
		287: uint16(0x0001),
		288: uint16(0x0006),
		291: uint16(0x0001),
		294: uint16(0x0001),
		295: uint16(0x0002),
		296: uint16(0x0003),
		297: uint16(0x000e),
		299: uint16(0x0001),
		301: uint16(0x0001),
		304: uint16(0x0001),
		306: uint16(0x0001),
		307: uint16(0x001e),
		308: uint16(0x0004),
		309: uint16(0x000d),
		310: uint16(0x0018),
		311: uint16(0x0004),
		312: uint16(0x0009),
		314: uint16(0x0001),
		315: uint16(0x0002),
		316: uint16(0x0004),
		318: uint16(0x0001),
		319: uint16(0x0010),
		321: uint16(0x0001),
		323: uint16(0x0009),
		326: uint16(0x0007),
		328: uint16(0x0001),
		330: uint16(0x0001),
		331: uint16(0x0002),
		332: uint16(0x0003),
		334: uint16(0x0001),
		336: uint16(0x000b),
		337: uint16(0x0006),
		338: uint16(0x000a),
		342: uint16(0x0001),
		343: uint16(0x0006),
		344: uint16(0x0006),
		347: uint16(0x0002),
		350: uint16(0x0001),
		351: uint16(0x0002),
		352: uint16(0x0004),
		353: uint16(0x0009),
		356: uint16(0x0001),
		357: uint16(0x0002),
		358: uint16(0x0006),
		360: uint16(0x0001),
		363: uint16(0x0001),
		364: uint16(0x0004),
		366: uint16(0x0003),
		367: uint16(0x000d),
		368: uint16(0x0012),
		369: uint16(0x0013),
		371: uint16(0x0001),
		373: uint16(0x0002),
		377: uint16(0x0001),
		379: uint16(0x0001),
		380: uint16(0x0002),
		382: uint16(0x0004),
		384: uint16(0x0007),
		385: uint16(0x000b),
		386: uint16(0x000c),
		387: uint16(0x0004),
		388: uint16(0x000e),
		389: uint16(0x0012),
		390: uint16(0x0013),
		392: uint16(0x0001),
		394: uint16(0x0001),
		395: uint16(0x0004),
		397: uint16(0x0001),
		398: uint16(0x0002),
		399: uint16(0x0006),
		400: uint16(0x0004),
		402: uint16(0x0001),
		403: uint16(0x0003),
		404: uint16(0x0020),
		405: uint16(0x0021),
		406: uint16(0x0022),
		407: uint16(0x0023),
		408: uint16(0x0025),
		409: uint16(0x0027),
		410: uint16(0x01d4),
		411: uint16(0x01d5),
		412: uint16(0x01d6),
		413: uint16(0x0023),
		414: uint16(0x0025),
		415: uint16(0x0026),
		416: uint16(0x0027),
		417: uint16(0x002b),
		418: uint16(0x01f0),
		419: uint16(0x01f1),
		420: uint16(0x01f2),
		421: uint16(0x01f3),
		422: uint16(0x01f4),
		423: uint16(0x01f5),
		424: uint16(0x01f6),
		426: uint16(0x001e),
		428: uint16(0x0001),
		429: uint16(0x0003),
		430: uint16(0x001e),
		433: uint16(0x0001),
		436: uint16(0x0001),
		438: uint16(0x0001),
		441: uint16(0x0001),
		442: uint16(0x0003),
		443: uint16(0x001e),
		444: uint16(0x0002),
		445: uint16(0x004e),
		446: uint16(0x004f),
		447: uint16(0x0050),
		448: uint16(0x0051),
		449: uint16(0x0052),
		450: uint16(0x0053),
		451: uint16(0x0054),
		452: uint16(0x0055),
		453: uint16(0x0056),
		454: uint16(0x0057),
		455: uint16(0x0058),
		456: uint16(0x0059),
		457: uint16(0x005a),
		458: uint16(0x005b),
		459: uint16(0x005c),
		460: uint16(0x005d),
		461: uint16(0x005e),
		462: uint16(0x005f),
		463: uint16(0x0060),
		464: uint16(0x0061),
		465: uint16(0x0062),
		466: uint16(0x0063),
		467: uint16(0x0064),
		468: uint16(0x0065),
		469: uint16(0x0066),
		470: uint16(0x0067),
		471: uint16(0x0068),
		472: uint16(0x0069),
		473: uint16(0x006a),
		474: uint16(0x006b),
		475: uint16(0x006c),
		476: uint16(0x006d),
		477: uint16(0x006e),
		478: uint16(0x006f),
		479: uint16(0x0070),
		480: uint16(0x0071),
		481: uint16(0x0072),
		482: uint16(0x0073),
		483: uint16(0x0074),
		484: uint16(0x0075),
		485: uint16(0x0076),
		486: uint16(0x0077),
		487: uint16(0x0078),
		488: uint16(0x0079),
		489: uint16(0x007a),
		490: uint16(0x007b),
		491: uint16(0x007c),
		492: uint16(0x007d),
		493: uint16(0x007e),
		494: uint16(0x007f),
		495: uint16(0x0080),
		496: uint16(0x0081),
		497: uint16(0x0082),
		498: uint16(0x0083),
		499: uint16(0x0084),
		500: uint16(0x0085),
		501: uint16(0x0086),
		502: uint16(0x0087),
		503: uint16(0x0088),
		504: uint16(0x0089),
		505: uint16(0x008a),
		506: uint16(0x008b),
		507: uint16(0x008c),
		508: uint16(0x008d),
		509: uint16(0x008e),
		510: uint16(0x008f),
		511: uint16(0x0090),
		512: uint16(0x0091),
		513: uint16(0x0092),
		514: uint16(0x0093),
		515: uint16(0x0094),
		516: uint16(0x0095),
		517: uint16(0x0096),
		518: uint16(0x0097),
		519: uint16(0x0098),
		520: uint16(0x0099),
		521: uint16(0x009a),
		522: uint16(0x009b),
		523: uint16(0x009c),
		524: uint16(0x009e),
		525: uint16(0x009f),
		526: uint16(0x0030),
		527: uint16(0x0034),
		528: uint16(0x0035),
		529: uint16(0x0036),
		530: uint16(0x0037),
		531: uint16(0x0038),
		532: uint16(0x0039),
		533: uint16(0x003a),
		534: uint16(0x003b),
		535: uint16(0x003c),
		536: uint16(0x003d),
		537: uint16(0x003e),
		538: uint16(0x003f),
		539: uint16(0x0040),
		540: uint16(0x0041),
		541: uint16(0x0042),
		542: uint16(0x0043),
		543: uint16(0x0044),
		544: uint16(0x0045),
		545: uint16(0x0046),
		546: uint16(0x0047),
		547: uint16(0x0048),
		548: uint16(0x0049),
		549: uint16(0x004a),
		550: uint16(0x004b),
		551: uint16(0x004c),
		552: uint16(0x004d),
		553: uint16(0x004e),
		554: uint16(0x004f),
		555: uint16(0x0050),
		556: uint16(0x0051),
		557: uint16(0x0052),
		558: uint16(0x0053),
		559: uint16(0x0054),
		560: uint16(0x0055),
		561: uint16(0x0056),
		562: uint16(0x0057),
		563: uint16(0x0058),
		564: uint16(0x0059),
		565: uint16(0x005a),
		566: uint16(0x005b),
		567: uint16(0x005c),
		568: uint16(0x005d),
		569: uint16(0x005e),
		570: uint16(0x005f),
		571: uint16(0x0060),
		572: uint16(0x0061),
		573: uint16(0x0062),
		574: uint16(0x0063),
		575: uint16(0x0064),
		576: uint16(0x0065),
		577: uint16(0x0066),
		578: uint16(0x0067),
		579: uint16(0x0068),
		580: uint16(0x0069),
		581: uint16(0x006a),
		582: uint16(0x006b),
		583: uint16(0x006c),
		584: uint16(0x006d),
		585: uint16(0x006e),
		586: uint16(0x006f),
		587: uint16(0x0070),
		588: uint16(0x0071),
		589: uint16(0x0072),
		590: uint16(0x0073),
		591: uint16(0x0074),
		592: uint16(0x0075),
		593: uint16(0x0076),
		594: uint16(0x0077),
		595: uint16(0x0078),
		596: uint16(0x0079),
		597: uint16(0x007a),
		598: uint16(0x007b),
		599: uint16(0x007c),
		600: uint16(0x007d),
		601: uint16(0x007e),
		602: uint16(0x007f),
		603: uint16(0x0080),
		604: uint16(0x0081),
		605: uint16(0x0082),
		606: uint16(0x0083),
		607: uint16(0x0084),
		608: uint16(0x0085),
		609: uint16(0x0086),
		610: uint16(0x0087),
		611: uint16(0x0088),
		612: uint16(0x0089),
		613: uint16(0x008a),
		614: uint16(0x008b),
		615: uint16(0x008c),
		616: uint16(0x008d),
		617: uint16(0x008e),
		618: uint16(0x008f),
		619: uint16(0x0090),
		620: uint16(0x0091),
		621: uint16(0x0092),
		622: uint16(0x0093),
		623: uint16(0x0094),
		624: uint16(0x0095),
		625: uint16(0x0096),
		626: uint16(0x0097),
		627: uint16(0x0098),
		628: uint16(0x0099),
		629: uint16(0x009a),
		630: uint16(0x009b),
		631: uint16(0x009c),
		632: uint16(0x009d),
		633: uint16(0x009e),
		634: uint16(0x009f),
		635: uint16(0x0200),
		636: uint16(0x0201),
		637: uint16(0x0203),
		638: uint16(0x0207),
		639: uint16(0x020c),
		640: uint16(0x020d),
		641: uint16(0x020e),
		642: uint16(0x020f),
		643: uint16(0x0210),
		644: uint16(0x0211),
		645: uint16(0x0219),
		646: uint16(0x021a),
		647: uint16(0x021c),
		648: uint16(0x021d),
		649: uint16(0x0220),
		650: uint16(0x0221),
		651: uint16(0x022a),
		652: uint16(0x022b),
		653: uint16(0x022c),
		654: uint16(0x022d),
		655: uint16(0x022f),
		656: uint16(0x0232),
		657: uint16(0x0235),
		658: uint16(0x0236),
		659: uint16(0x023c),
		660: uint16(0x023e),
		661: uint16(0x023f),
		662: uint16(0x0244),
		663: uint16(0x024d),
		664: uint16(0x024e),
		665: uint16(0x0251),
		666: uint16(0x0255),
		667: uint16(0x025e),
		668: uint16(0x0262),
		669: uint16(0x0266),
		670: uint16(0x0267),
		671: uint16(0x0268),
		672: uint16(0x0269),
		673: uint16(0x0272),
		674: uint16(0x0275),
		675: uint16(0x0276),
		676: uint16(0x0277),
		677: uint16(0x0278),
		678: uint16(0x0279),
		679: uint16(0x027a),
		680: uint16(0x027d),
		681: uint16(0x0280),
		682: uint16(0x0281),
		683: uint16(0x0282),
		684: uint16(0x0283),
		685: uint16(0x0289),
		686: uint16(0x028a),
		687: uint16(0x028b),
		688: uint16(0x028c),
		689: uint16(0x028d),
		690: uint16(0x028e),
		691: uint16(0x0294),
		692: uint16(0x0297),
		693: uint16(0x0298),
		694: uint16(0x029a),
		695: uint16(0x029d),
		696: uint16(0x02a6),
		697: uint16(0x004e),
		698: uint16(0x004f),
		699: uint16(0x0050),
		700: uint16(0x0051),
		701: uint16(0x0052),
		702: uint16(0x0053),
		703: uint16(0x0054),
		704: uint16(0x0055),
		705: uint16(0x0056),
		706: uint16(0x0057),
		707: uint16(0x0058),
		708: uint16(0x0059),
		709: uint16(0x005a),
		710: uint16(0x005b),
		711: uint16(0x005c),
		712: uint16(0x005d),
		713: uint16(0x005e),
		714: uint16(0x005f),
		715: uint16(0x0060),
		716: uint16(0x0061),
		717: uint16(0x0062),
		718: uint16(0x0063),
		719: uint16(0x0064),
		720: uint16(0x0065),
		721: uint16(0x0066),
		722: uint16(0x0067),
		723: uint16(0x0068),
		724: uint16(0x0069),
		725: uint16(0x006a),
		726: uint16(0x006b),
		727: uint16(0x006c),
		728: uint16(0x006d),
		729: uint16(0x006e),
		730: uint16(0x006f),
		731: uint16(0x0070),
		732: uint16(0x0071),
		733: uint16(0x0072),
		734: uint16(0x0073),
		735: uint16(0x0074),
		736: uint16(0x0075),
		737: uint16(0x0076),
		738: uint16(0x0077),
		739: uint16(0x0078),
		740: uint16(0x0079),
		741: uint16(0x007a),
		742: uint16(0x007b),
		743: uint16(0x007c),
		744: uint16(0x007d),
		745: uint16(0x007e),
		746: uint16(0x007f),
		747: uint16(0x0080),
		748: uint16(0x0081),
		749: uint16(0x0082),
		750: uint16(0x0083),
		751: uint16(0x0084),
		752: uint16(0x0085),
		753: uint16(0x0086),
		754: uint16(0x0087),
		755: uint16(0x0088),
		756: uint16(0x0089),
		757: uint16(0x008a),
		758: uint16(0x008b),
		759: uint16(0x008c),
		760: uint16(0x008d),
		761: uint16(0x008e),
		762: uint16(0x008f),
		763: uint16(0x0090),
		764: uint16(0x0091),
		765: uint16(0x0092),
		766: uint16(0x0093),
		767: uint16(0x0094),
		768: uint16(0x0095),
		769: uint16(0x0096),
		770: uint16(0x0097),
		771: uint16(0x0098),
		772: uint16(0x0099),
		773: uint16(0x009a),
		774: uint16(0x009b),
		775: uint16(0x009c),
		776: uint16(0x009d),
		777: uint16(0x009e),
		778: uint16(0x009f),
		779: uint16(0x00fa),
	},
	FlangIndices: [246]TFcChar8{
		1:   uint8(1),
		2:   uint8(2),
		3:   uint8(190),
		4:   uint8(3),
		5:   uint8(191),
		6:   uint8(4),
		7:   uint8(5),
		8:   uint8(6),
		9:   uint8(7),
		10:  uint8(8),
		11:  uint8(9),
		12:  uint8(10),
		13:  uint8(11),
		14:  uint8(13),
		15:  uint8(192),
		16:  uint8(193),
		17:  uint8(14),
		18:  uint8(15),
		19:  uint8(16),
		20:  uint8(17),
		21:  uint8(18),
		22:  uint8(12),
		23:  uint8(19),
		24:  uint8(20),
		25:  uint8(21),
		26:  uint8(240),
		27:  uint8(22),
		28:  uint8(23),
		29:  uint8(194),
		30:  uint8(24),
		31:  uint8(25),
		32:  uint8(26),
		33:  uint8(27),
		34:  uint8(28),
		35:  uint8(29),
		36:  uint8(195),
		37:  uint8(30),
		38:  uint8(196),
		39:  uint8(31),
		40:  uint8(32),
		41:  uint8(33),
		42:  uint8(34),
		43:  uint8(35),
		44:  uint8(242),
		45:  uint8(197),
		46:  uint8(36),
		47:  uint8(198),
		48:  uint8(37),
		49:  uint8(38),
		50:  uint8(39),
		51:  uint8(40),
		52:  uint8(41),
		53:  uint8(42),
		54:  uint8(43),
		55:  uint8(199),
		56:  uint8(48),
		57:  uint8(44),
		58:  uint8(200),
		59:  uint8(45),
		60:  uint8(46),
		61:  uint8(47),
		62:  uint8(49),
		63:  uint8(50),
		64:  uint8(51),
		65:  uint8(52),
		66:  uint8(53),
		67:  uint8(54),
		68:  uint8(55),
		69:  uint8(56),
		70:  uint8(57),
		71:  uint8(58),
		72:  uint8(59),
		73:  uint8(60),
		74:  uint8(61),
		75:  uint8(201),
		76:  uint8(62),
		77:  uint8(63),
		78:  uint8(202),
		79:  uint8(203),
		80:  uint8(64),
		81:  uint8(65),
		82:  uint8(204),
		83:  uint8(66),
		84:  uint8(68),
		85:  uint8(69),
		86:  uint8(67),
		87:  uint8(205),
		88:  uint8(70),
		89:  uint8(71),
		90:  uint8(72),
		91:  uint8(73),
		92:  uint8(74),
		93:  uint8(75),
		94:  uint8(206),
		95:  uint8(76),
		96:  uint8(77),
		97:  uint8(207),
		98:  uint8(78),
		99:  uint8(208),
		100: uint8(79),
		101: uint8(80),
		102: uint8(81),
		103: uint8(82),
		104: uint8(83),
		105: uint8(84),
		106: uint8(209),
		107: uint8(85),
		108: uint8(86),
		109: uint8(210),
		110: uint8(87),
		111: uint8(211),
		112: uint8(88),
		113: uint8(89),
		114: uint8(90),
		115: uint8(212),
		116: uint8(91),
		117: uint8(92),
		118: uint8(238),
		119: uint8(93),
		120: uint8(94),
		121: uint8(213),
		122: uint8(214),
		123: uint8(95),
		124: uint8(96),
		125: uint8(97),
		126: uint8(98),
		127: uint8(215),
		128: uint8(99),
		129: uint8(100),
		130: uint8(101),
		131: uint8(102),
		132: uint8(103),
		133: uint8(104),
		134: uint8(216),
		135: uint8(243),
		136: uint8(105),
		137: uint8(106),
		138: uint8(217),
		139: uint8(107),
		140: uint8(108),
		141: uint8(218),
		142: uint8(109),
		143: uint8(110),
		144: uint8(111),
		145: uint8(219),
		146: uint8(112),
		147: uint8(113),
		148: uint8(114),
		149: uint8(239),
		150: uint8(115),
		151: uint8(116),
		152: uint8(220),
		153: uint8(117),
		154: uint8(118),
		155: uint8(119),
		156: uint8(120),
		157: uint8(121),
		158: uint8(221),
		159: uint8(122),
		160: uint8(222),
		161: uint8(223),
		162: uint8(224),
		163: uint8(123),
		164: uint8(124),
		165: uint8(125),
		166: uint8(126),
		167: uint8(225),
		168: uint8(226),
		169: uint8(127),
		170: uint8(227),
		171: uint8(128),
		172: uint8(129),
		173: uint8(228),
		174: uint8(130),
		175: uint8(131),
		176: uint8(241),
		177: uint8(229),
		178: uint8(132),
		179: uint8(230),
		180: uint8(133),
		181: uint8(134),
		182: uint8(231),
		183: uint8(135),
		184: uint8(136),
		185: uint8(137),
		186: uint8(232),
		187: uint8(138),
		188: uint8(139),
		189: uint8(140),
		190: uint8(141),
		191: uint8(142),
		192: uint8(143),
		193: uint8(144),
		194: uint8(233),
		195: uint8(145),
		196: uint8(146),
		197: uint8(147),
		198: uint8(148),
		199: uint8(149),
		200: uint8(234),
		201: uint8(150),
		202: uint8(151),
		203: uint8(152),
		204: uint8(153),
		205: uint8(154),
		206: uint8(155),
		207: uint8(156),
		208: uint8(157),
		209: uint8(158),
		210: uint8(159),
		211: uint8(160),
		212: uint8(161),
		213: uint8(162),
		214: uint8(163),
		215: uint8(164),
		216: uint8(165),
		217: uint8(166),
		218: uint8(167),
		219: uint8(235),
		220: uint8(168),
		221: uint8(169),
		222: uint8(170),
		223: uint8(245),
		224: uint8(244),
		225: uint8(171),
		226: uint8(172),
		227: uint8(173),
		228: uint8(174),
		229: uint8(175),
		230: uint8(176),
		231: uint8(177),
		232: uint8(236),
		233: uint8(178),
		234: uint8(179),
		235: uint8(180),
		236: uint8(181),
		237: uint8(182),
		238: uint8(183),
		239: uint8(237),
		240: uint8(184),
		241: uint8(185),
		242: uint8(186),
		243: uint8(187),
		244: uint8(188),
		245: uint8(189),
	},
	FlangIndicesInv: [246]TFcChar8{
		1:   uint8(1),
		2:   uint8(2),
		3:   uint8(4),
		4:   uint8(6),
		5:   uint8(7),
		6:   uint8(8),
		7:   uint8(9),
		8:   uint8(10),
		9:   uint8(11),
		10:  uint8(12),
		11:  uint8(13),
		12:  uint8(22),
		13:  uint8(14),
		14:  uint8(17),
		15:  uint8(18),
		16:  uint8(19),
		17:  uint8(20),
		18:  uint8(21),
		19:  uint8(23),
		20:  uint8(24),
		21:  uint8(25),
		22:  uint8(27),
		23:  uint8(28),
		24:  uint8(30),
		25:  uint8(31),
		26:  uint8(32),
		27:  uint8(33),
		28:  uint8(34),
		29:  uint8(35),
		30:  uint8(37),
		31:  uint8(39),
		32:  uint8(40),
		33:  uint8(41),
		34:  uint8(42),
		35:  uint8(43),
		36:  uint8(46),
		37:  uint8(48),
		38:  uint8(49),
		39:  uint8(50),
		40:  uint8(51),
		41:  uint8(52),
		42:  uint8(53),
		43:  uint8(54),
		44:  uint8(57),
		45:  uint8(59),
		46:  uint8(60),
		47:  uint8(61),
		48:  uint8(56),
		49:  uint8(62),
		50:  uint8(63),
		51:  uint8(64),
		52:  uint8(65),
		53:  uint8(66),
		54:  uint8(67),
		55:  uint8(68),
		56:  uint8(69),
		57:  uint8(70),
		58:  uint8(71),
		59:  uint8(72),
		60:  uint8(73),
		61:  uint8(74),
		62:  uint8(76),
		63:  uint8(77),
		64:  uint8(80),
		65:  uint8(81),
		66:  uint8(83),
		67:  uint8(86),
		68:  uint8(84),
		69:  uint8(85),
		70:  uint8(88),
		71:  uint8(89),
		72:  uint8(90),
		73:  uint8(91),
		74:  uint8(92),
		75:  uint8(93),
		76:  uint8(95),
		77:  uint8(96),
		78:  uint8(98),
		79:  uint8(100),
		80:  uint8(101),
		81:  uint8(102),
		82:  uint8(103),
		83:  uint8(104),
		84:  uint8(105),
		85:  uint8(107),
		86:  uint8(108),
		87:  uint8(110),
		88:  uint8(112),
		89:  uint8(113),
		90:  uint8(114),
		91:  uint8(116),
		92:  uint8(117),
		93:  uint8(119),
		94:  uint8(120),
		95:  uint8(123),
		96:  uint8(124),
		97:  uint8(125),
		98:  uint8(126),
		99:  uint8(128),
		100: uint8(129),
		101: uint8(130),
		102: uint8(131),
		103: uint8(132),
		104: uint8(133),
		105: uint8(136),
		106: uint8(137),
		107: uint8(139),
		108: uint8(140),
		109: uint8(142),
		110: uint8(143),
		111: uint8(144),
		112: uint8(146),
		113: uint8(147),
		114: uint8(148),
		115: uint8(150),
		116: uint8(151),
		117: uint8(153),
		118: uint8(154),
		119: uint8(155),
		120: uint8(156),
		121: uint8(157),
		122: uint8(159),
		123: uint8(163),
		124: uint8(164),
		125: uint8(165),
		126: uint8(166),
		127: uint8(169),
		128: uint8(171),
		129: uint8(172),
		130: uint8(174),
		131: uint8(175),
		132: uint8(178),
		133: uint8(180),
		134: uint8(181),
		135: uint8(183),
		136: uint8(184),
		137: uint8(185),
		138: uint8(187),
		139: uint8(188),
		140: uint8(189),
		141: uint8(190),
		142: uint8(191),
		143: uint8(192),
		144: uint8(193),
		145: uint8(195),
		146: uint8(196),
		147: uint8(197),
		148: uint8(198),
		149: uint8(199),
		150: uint8(201),
		151: uint8(202),
		152: uint8(203),
		153: uint8(204),
		154: uint8(205),
		155: uint8(206),
		156: uint8(207),
		157: uint8(208),
		158: uint8(209),
		159: uint8(210),
		160: uint8(211),
		161: uint8(212),
		162: uint8(213),
		163: uint8(214),
		164: uint8(215),
		165: uint8(216),
		166: uint8(217),
		167: uint8(218),
		168: uint8(220),
		169: uint8(221),
		170: uint8(222),
		171: uint8(225),
		172: uint8(226),
		173: uint8(227),
		174: uint8(228),
		175: uint8(229),
		176: uint8(230),
		177: uint8(231),
		178: uint8(233),
		179: uint8(234),
		180: uint8(235),
		181: uint8(236),
		182: uint8(237),
		183: uint8(238),
		184: uint8(240),
		185: uint8(241),
		186: uint8(242),
		187: uint8(243),
		188: uint8(244),
		189: uint8(245),
		190: uint8(3),
		191: uint8(5),
		192: uint8(15),
		193: uint8(16),
		194: uint8(29),
		195: uint8(36),
		196: uint8(38),
		197: uint8(45),
		198: uint8(47),
		199: uint8(55),
		200: uint8(58),
		201: uint8(75),
		202: uint8(78),
		203: uint8(79),
		204: uint8(82),
		205: uint8(87),
		206: uint8(94),
		207: uint8(97),
		208: uint8(99),
		209: uint8(106),
		210: uint8(109),
		211: uint8(111),
		212: uint8(115),
		213: uint8(121),
		214: uint8(122),
		215: uint8(127),
		216: uint8(134),
		217: uint8(138),
		218: uint8(141),
		219: uint8(145),
		220: uint8(152),
		221: uint8(158),
		222: uint8(160),
		223: uint8(161),
		224: uint8(162),
		225: uint8(167),
		226: uint8(168),
		227: uint8(170),
		228: uint8(173),
		229: uint8(177),
		230: uint8(179),
		231: uint8(182),
		232: uint8(186),
		233: uint8(194),
		234: uint8(200),
		235: uint8(219),
		236: uint8(232),
		237: uint8(239),
		238: uint8(118),
		239: uint8(149),
		240: uint8(26),
		241: uint8(176),
		242: uint8(44),
		243: uint8(135),
		244: uint8(224),
		245: uint8(223),
	},
}
var _fcLangCountrySets = [10][8]TFcChar32{
	0: {
		0: uint32(0x00000600),
	},
	1: {
		6: uint32(0x00000003),
	},
	2: {
		2: uint32(0x00c00000),
		6: uint32(0x000c0000),
	},
	3: {
		3: uint32(0x00000100),
		6: uint32(0x01000000),
	},
	4: {
		6: uint32(0x40000000),
	},
	5: {
		6: uint32(0x80000000),
		7: uint32(0x00000001),
	},
	6: {
		3: uint32(0x30000000),
	},
	7: {
		4: uint32(0x60000000),
	},
	8: {
		7: uint32(0x00300000),
	},
	9: {
		5: uint32(0x1f000000),
	},
}
var _fcLangCharSetRanges = [26]TFcLangCharSetRange{
	0: {
		Fend: int32(12),
	},
	1: {
		Fbegin: int32(13),
		Fend:   int32(29),
	},
	2: {
		Fbegin: int32(30),
		Fend:   int32(41),
	},
	3: {
		Fbegin: int32(42),
		Fend:   int32(46),
	},
	4: {
		Fbegin: int32(47),
		Fend:   int32(53),
	},
	5: {
		Fbegin: int32(54),
		Fend:   int32(63),
	},
	6: {
		Fbegin: int32(64),
		Fend:   int32(70),
	},
	7: {
		Fbegin: int32(71),
		Fend:   int32(82),
	},
	8: {
		Fbegin: int32(83),
		Fend:   int32(92),
	},
	9: {
		Fbegin: int32(93),
		Fend:   int32(94),
	},
	10: {
		Fbegin: int32(95),
		Fend:   int32(116),
	},
	11: {
		Fbegin: int32(117),
		Fend:   int32(126),
	},
	12: {
		Fbegin: int32(127),
		Fend:   int32(140),
	},
	13: {
		Fbegin: int32(141),
		Fend:   int32(153),
	},
	14: {
		Fbegin: int32(154),
		Fend:   int32(158),
	},
	15: {
		Fbegin: int32(159),
		Fend:   int32(166),
	},
	16: {
		Fbegin: int32(167),
		Fend:   int32(168),
	},
	17: {
		Fbegin: int32(169),
		Fend:   int32(173),
	},
	18: {
		Fbegin: int32(174),
		Fend:   int32(203),
	},
	19: {
		Fbegin: int32(204),
		Fend:   int32(220),
	},
	20: {
		Fbegin: int32(221),
		Fend:   int32(226),
	},
	21: {
		Fbegin: int32(227),
		Fend:   int32(230),
	},
	22: {
		Fbegin: int32(231),
		Fend:   int32(234),
	},
	23: {
		Fbegin: int32(235),
		Fend:   int32(235),
	},
	24: {
		Fbegin: int32(236),
		Fend:   int32(238),
	},
	25: {
		Fbegin: int32(239),
		Fend:   int32(245),
	},
}

func _FcLangSetBitSet(tls *libc.TLS, ls uintptr, id uint32) {
	var bucket uint32
	_ = bucket
	id = uint32(*(*TFcChar8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangData)) + 40840 + uintptr(id))))
	bucket = id >> int32(5)
	if bucket >= (*TFcLangSet)(unsafe.Pointer(ls)).Fmap_size {
		return
	} /* shouldn't happen really */
	*(*TFcChar32)(unsafe.Pointer(ls + 12 + uintptr(bucket)*4)) |= libc.Uint32FromUint32(1) << (id & libc.Uint32FromInt32(0x1f))
}

func _FcLangSetBitGet(tls *libc.TLS, ls uintptr, id uint32) (r TFcBool) {
	var bucket uint32
	var v1 int32
	_, _ = bucket, v1
	id = uint32(*(*TFcChar8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangData)) + 40840 + uintptr(id))))
	bucket = id >> int32(5)
	if bucket >= (*TFcLangSet)(unsafe.Pointer(ls)).Fmap_size {
		return m_FcFalse
	}
	if *(*TFcChar32)(unsafe.Pointer(ls + 12 + uintptr(bucket)*4))>>(id&libc.Uint32FromInt32(0x1f))&uint32(1) != 0 {
		v1 = int32(m_FcTrue)
	} else {
		v1 = m_FcFalse
	}
	return v1
}

func _FcLangSetBitReset(tls *libc.TLS, ls uintptr, id uint32) {
	var bucket uint32
	_ = bucket
	id = uint32(*(*TFcChar8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangData)) + 40840 + uintptr(id))))
	bucket = id >> int32(5)
	if bucket >= (*TFcLangSet)(unsafe.Pointer(ls)).Fmap_size {
		return
	} /* shouldn't happen really */
	*(*TFcChar32)(unsafe.Pointer(ls + 12 + uintptr(bucket)*4)) &= ^(libc.Uint32FromUint32(1) << (id & libc.Uint32FromInt32(0x1f)))
}

func XFcFreeTypeLangSet(tls *libc.TLS, charset uintptr, exclusiveLang uintptr) (r uintptr) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var exclusiveCharset, ls, missed uintptr
	var i, i1, j, j1 int32
	var missing, ucs4 TFcChar32
	var _ /* map at bp+0 */ [8]TFcChar32
	var _ /* next at bp+32 */ TFcChar32
	_, _, _, _, _, _, _, _, _ = exclusiveCharset, i, i1, j, j1, ls, missed, missing, ucs4
	exclusiveCharset = uintptr(0)
	if exclusiveLang != 0 {
		exclusiveCharset = XFcLangGetCharSet(tls, exclusiveLang)
	}
	ls = XFcLangSetCreate(tls)
	if !(ls != 0) {
		return uintptr(0)
	}
	if XFcDebugVal&int32(m_FC_DBG_LANGSET) != 0 {
		libc.Xprintf(tls, __ccgo_ts+5641, 0)
		XFcCharSetPrint(tls, charset)
		libc.Xprintf(tls, __ccgo_ts+1266, 0)
	}
	i = 0
	for {
		if !(i < int32(m_NUM_LANG_CHAR_SET)) {
			break
		}
		if XFcDebugVal&int32(m_FC_DBG_LANGSET) != 0 {
			libc.Xprintf(tls, __ccgo_ts+5654, libc.VaList(bp+48, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40))
			XFcCharSetPrint(tls, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40+16)
			libc.Xprintf(tls, __ccgo_ts+1266, 0)
		}
		/*
		 * Check for Han charsets to make fonts
		 * which advertise support for a single language
		 * not support other Han languages
		 */
		if exclusiveCharset != 0 && XFcFreeTypeIsExclusiveLang(tls, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40) != 0 {
			if (*(*TFcLangCharSet)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangData)) + uintptr(i)*40))).Fcharset.Fnum != (*TFcCharSet)(unsafe.Pointer(exclusiveCharset)).Fnum {
				goto _1
			}
			j = 0
			for {
				if !(j < (*(*TFcLangCharSet)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangData)) + uintptr(i)*40))).Fcharset.Fnum) {
					break
				}
				if uintptr(int64(uintptr(Tintptr_t(uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40+16)+(*TFcCharSet)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40+16)).Fleaves_offset))+*(*Tintptr_t)(unsafe.Pointer(uintptr(Tintptr_t(uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40+16)+(*TFcCharSet)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40+16)).Fleaves_offset) + uintptr(j)*8))) != uintptr(int64(uintptr(int64(exclusiveCharset)+(*TFcCharSet)(unsafe.Pointer(exclusiveCharset)).Fleaves_offset))+*(*Tintptr_t)(unsafe.Pointer(uintptr(int64(exclusiveCharset)+(*TFcCharSet)(unsafe.Pointer(exclusiveCharset)).Fleaves_offset) + uintptr(j)*8))) {
					goto _2
				}
				goto _2
			_2:
				;
				j++
			}
		}
		missing = XFcCharSetSubtractCount(tls, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40+16, charset)
		if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
			if missing != 0 && missing < uint32(10) {
				missed = XFcCharSetSubtract(tls, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40+16, charset)
				libc.Xprintf(tls, __ccgo_ts+5665, libc.VaList(bp+48, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40, missing))
				libc.Xprintf(tls, __ccgo_ts+5674, 0)
				ucs4 = XFcCharSetFirstPage(tls, missed, bp, bp+32)
				for {
					if !(ucs4 != libc.Uint32FromInt32(-libc.Int32FromInt32(1))) {
						break
					}
					i1 = 0
					for {
						if !(i1 < libc.Int32FromInt32(256)/libc.Int32FromInt32(32)) {
							break
						}
						if (*(*[8]TFcChar32)(unsafe.Pointer(bp)))[i1] != 0 {
							j1 = 0
							for {
								if !(j1 < int32(32)) {
									break
								}
								if (*(*[8]TFcChar32)(unsafe.Pointer(bp)))[i1]&(uint32(1)<<j1) != 0 {
									libc.Xprintf(tls, __ccgo_ts+5676, libc.VaList(bp+48, ucs4+libc.Uint32FromInt32(i1*int32(32))+libc.Uint32FromInt32(j1)))
								}
								goto _5
							_5:
								;
								j1++
							}
						}
						goto _4
					_4:
						;
						i1++
					}
					goto _3
				_3:
					;
					ucs4 = XFcCharSetNextPage(tls, missed, bp, bp+32)
				}
				libc.Xprintf(tls, __ccgo_ts+5682, 0)
				XFcCharSetDestroy(tls, missed)
			} else {
				libc.Xprintf(tls, __ccgo_ts+5687, libc.VaList(bp+48, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40, missing))
			}
		}
		if !(missing != 0) {
			_FcLangSetBitSet(tls, ls, libc.Uint32FromInt32(i))
		}
		goto _1
	_1:
		;
		i++
	}
	if XFcDebugVal&int32(m_FC_DBG_SCANV) != 0 {
		libc.Xprintf(tls, __ccgo_ts+1266, 0)
	}
	return ls
}

func XFcLangNormalize(tls *libc.TLS, lang uintptr) (r uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var encoding, modifier, orig, result, s, territory uintptr
	var llen, mlen, tlen Tsize_t
	var v1 uint64
	_, _, _, _, _, _, _, _, _, _ = encoding, llen, mlen, modifier, orig, result, s, territory, tlen, v1
	result = libc.UintptrFromInt32(0)
	tlen = uint64(0)
	mlen = uint64(0)
	if !(lang != 0) || !(*(*TFcChar8)(unsafe.Pointer(lang)) != 0) {
		return libc.UintptrFromInt32(0)
	}
	/* might be called without initialization */
	XFcInitDebug(tls)
	if XFcStrCmpIgnoreCase(tls, lang, __ccgo_ts+5695) == 0 || XFcStrCmpIgnoreCase(tls, lang, __ccgo_ts+5697) == 0 || XFcStrCmpIgnoreCase(tls, lang, __ccgo_ts+5705) == 0 || XFcStrCmpIgnoreCase(tls, lang, __ccgo_ts+5712) == 0 {
		result = XFcStrCopy(tls, __ccgo_ts+2752)
		goto bail
	}
	s = XFcStrCopy(tls, lang)
	if !(s != 0) {
		goto bail
	}
	/* from the comments in glibc:
	 *
	 * LOCALE can consist of up to four recognized parts for the XPG syntax:
	 *
	 *            language[_territory[.codeset]][@modifier]
	 *
	 * Beside the first all of them are allowed to be missing.  If the
	 * full specified locale is not found, the less specific one are
	 * looked for.  The various part will be stripped off according to
	 * the following order:
	 *            (1) codeset
	 *            (2) normalized codeset
	 *            (3) territory
	 *            (4) modifier
	 *
	 * So since we don't take care of the codeset part here, what patterns
	 * we need to deal with is:
	 *
	 *   1. language_territory@modifier
	 *   2. language@modifier
	 *   3. language
	 *
	 * then. and maybe no need to try language_territory here.
	 */
	modifier = libc.Xstrchr(tls, s, int32('@'))
	if modifier != 0 {
		*(*int8)(unsafe.Pointer(modifier)) = 0
		modifier++
		mlen = libc.Xstrlen(tls, modifier)
	}
	encoding = libc.Xstrchr(tls, s, int32('.'))
	if encoding != 0 {
		*(*int8)(unsafe.Pointer(encoding)) = 0
		encoding++
		if modifier != 0 {
			libc.X__builtin___memmove_chk(tls, encoding, modifier, mlen+uint64(1), ^t__predefined_size_t(0))
			modifier = encoding
		}
	}
	territory = libc.Xstrchr(tls, s, int32('_'))
	if !(territory != 0) {
		territory = libc.Xstrchr(tls, s, int32('-'))
	}
	if territory != 0 {
		*(*int8)(unsafe.Pointer(territory)) = 0
		territory++
		tlen = libc.Xstrlen(tls, territory)
	}
	llen = libc.Xstrlen(tls, s)
	if llen < uint64(2) || llen > uint64(3) {
		libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+5718, libc.VaList(bp+8, lang))
		goto bail0
	}
	if territory != 0 && (tlen < uint64(2) || tlen > uint64(3)) && !(int32(*(*int8)(unsafe.Pointer(territory))) == int32('z') && tlen < uint64(5)) {
		libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+5777, libc.VaList(bp+8, lang))
		goto bail0
	}
	if territory != 0 {
		*(*int8)(unsafe.Pointer(territory + uintptr(-libc.Int32FromInt32(1)))) = int8('-')
	}
	if modifier != 0 {
		*(*int8)(unsafe.Pointer(modifier + uintptr(-libc.Int32FromInt32(1)))) = int8('@')
	}
	orig = XFcStrDowncase(tls, s)
	if !(orig != 0) {
		goto bail0
	}
	if territory != 0 {
		if XFcDebugVal&int32(m_FC_DBG_LANGSET) != 0 {
			libc.Xprintf(tls, __ccgo_ts+5834, libc.VaList(bp+8, s))
		}
		if _FcLangSetIndex(tls, s) < 0 {
			if mlen > uint64(0) {
				v1 = mlen + uint64(1)
			} else {
				v1 = uint64(0)
			}
			libc.X__builtin___memmove_chk(tls, territory-uintptr(1), territory+uintptr(tlen), v1+uint64(1), ^t__predefined_size_t(0))
			if modifier != 0 {
				modifier = territory
			}
		} else {
			result = s
			/* we'll miss the opportunity to reduce the correct size
			 * of the allocated memory for the string after that.
			 */
			s = libc.UintptrFromInt32(0)
			goto bail1
		}
	}
	if modifier != 0 {
		if XFcDebugVal&int32(m_FC_DBG_LANGSET) != 0 {
			libc.Xprintf(tls, __ccgo_ts+5834, libc.VaList(bp+8, s))
		}
		if _FcLangSetIndex(tls, s) < 0 {
			*(*int8)(unsafe.Pointer(modifier + uintptr(-libc.Int32FromInt32(1)))) = 0
		} else {
			result = s
			/* we'll miss the opportunity to reduce the correct size
			 * of the allocated memory for the string after that.
			 */
			s = libc.UintptrFromInt32(0)
			goto bail1
		}
	}
	if XFcDebugVal&int32(m_FC_DBG_LANGSET) != 0 {
		libc.Xprintf(tls, __ccgo_ts+5834, libc.VaList(bp+8, s))
	}
	if _FcLangSetIndex(tls, s) < 0 {
		/* there seems no languages matched in orth.
		 * add the language as is for fallback.
		 */
		result = orig
		orig = libc.UintptrFromInt32(0)
	} else {
		result = s
		/* we'll miss the opportunity to reduce the correct size
		 * of the allocated memory for the string after that.
		 */
		s = libc.UintptrFromInt32(0)
	}
	goto bail1
bail1:
	;
	if orig != 0 {
		XFcStrFree(tls, orig)
	}
	goto bail0
bail0:
	;
	if s != 0 {
		libc.Xfree(tls, s)
	}
	goto bail
bail:
	;
	if XFcDebugVal&int32(m_FC_DBG_LANGSET) != 0 {
		if result != 0 {
			libc.Xprintf(tls, __ccgo_ts+5869, libc.VaList(bp+8, lang, result))
		} else {
			libc.Xprintf(tls, __ccgo_ts+5891, libc.VaList(bp+8, lang))
		}
	}
	return result
}

func XFcLangCompare(tls *libc.TLS, s1 uintptr, s2 uintptr) (r TFcLangResult) {
	var c1, c2 TFcChar8
	var is_und TFcBool
	var result TFcLangResult
	var s1_orig, v7, v8 uintptr
	var v1, v10, v11, v2, v4, v9 int32
	var v3, v5 bool
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c1, c2, is_und, result, s1_orig, v1, v10, v11, v2, v3, v4, v5, v7, v8, v9
	result = int32(_FcLangDifferentLang)
	s1_orig = s1
	if int32(0101) <= libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s1))) && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s1))) <= int32(0132) {
		v1 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s1))) - int32(0101) + int32(0141)
	} else {
		v1 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s1)))
	}
	if v3 = v1 == int32('u'); v3 {
		if int32(0101) <= libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s1 + 1))) && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s1 + 1))) <= int32(0132) {
			v2 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s1 + 1))) - int32(0101) + int32(0141)
		} else {
			v2 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s1 + 1)))
		}
	}
	if v5 = v3 && v2 == int32('n'); v5 {
		if int32(0101) <= libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s1 + 2))) && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s1 + 2))) <= int32(0132) {
			v4 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s1 + 2))) - int32(0101) + int32(0141)
		} else {
			v4 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s1 + 2)))
		}
	}
	is_und = libc.BoolInt32(v5 && v4 == int32('d') && (libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s1 + 3))) == int32('-') || libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s1 + 3))) == int32('\000')))
	for {
		v7 = s1
		s1++
		c1 = *(*TFcChar8)(unsafe.Pointer(v7))
		v8 = s2
		s2++
		c2 = *(*TFcChar8)(unsafe.Pointer(v8))
		if int32(0101) <= libc.Int32FromUint8(c1) && libc.Int32FromUint8(c1) <= int32(0132) {
			v9 = libc.Int32FromUint8(c1) - int32(0101) + int32(0141)
		} else {
			v9 = libc.Int32FromUint8(c1)
		}
		c1 = libc.Uint8FromInt32(v9)
		if int32(0101) <= libc.Int32FromUint8(c2) && libc.Int32FromUint8(c2) <= int32(0132) {
			v10 = libc.Int32FromUint8(c2) - int32(0101) + int32(0141)
		} else {
			v10 = libc.Int32FromUint8(c2)
		}
		c2 = libc.Uint8FromInt32(v10)
		if libc.Int32FromUint8(c1) != libc.Int32FromUint8(c2) {
			if !(is_und != 0) && (libc.Int32FromUint8(c1) == int32('-') || libc.Int32FromUint8(c1) == int32('\000')) && (libc.Int32FromUint8(c2) == int32('-') || libc.Int32FromUint8(c2) == int32('\000')) {
				result = int32(_FcLangDifferentTerritory)
			}
			return result
		} else {
			if !(c1 != 0) {
				if is_und != 0 {
					v11 = result
				} else {
					v11 = int32(_FcLangEqual)
				}
				return v11
			} else {
				if libc.Int32FromUint8(c1) == int32('-') {
					if !(is_und != 0) {
						result = int32(_FcLangDifferentTerritory)
					}
				}
			}
		}
		/* If we parsed past "und-", then do not consider it undefined anymore,
		 * as there's *something* specified. */
		if is_und != 0 && int64(s1)-int64(s1_orig) == int64(4) {
			is_und = m_FcFalse
		}
		goto _6
	_6:
	}
	return r
}

/*
 * Return FcTrue when super contains sub.
 *
 * super contains sub if super and sub have the same
 * language and either the same country or one
 * is missing the country
 */

func _FcLangContains(tls *libc.TLS, super uintptr, sub uintptr) (r TFcBool) {
	var c1, c2 TFcChar8
	var v2, v3 uintptr
	var v4, v5 int32
	_, _, _, _, _, _ = c1, c2, v2, v3, v4, v5
	for {
		v2 = super
		super++
		c1 = *(*TFcChar8)(unsafe.Pointer(v2))
		v3 = sub
		sub++
		c2 = *(*TFcChar8)(unsafe.Pointer(v3))
		if int32(0101) <= libc.Int32FromUint8(c1) && libc.Int32FromUint8(c1) <= int32(0132) {
			v4 = libc.Int32FromUint8(c1) - int32(0101) + int32(0141)
		} else {
			v4 = libc.Int32FromUint8(c1)
		}
		c1 = libc.Uint8FromInt32(v4)
		if int32(0101) <= libc.Int32FromUint8(c2) && libc.Int32FromUint8(c2) <= int32(0132) {
			v5 = libc.Int32FromUint8(c2) - int32(0101) + int32(0141)
		} else {
			v5 = libc.Int32FromUint8(c2)
		}
		c2 = libc.Uint8FromInt32(v5)
		if libc.Int32FromUint8(c1) != libc.Int32FromUint8(c2) {
			/* see if super has a country while sub is missing one */
			if libc.Int32FromUint8(c1) == int32('-') && libc.Int32FromUint8(c2) == int32('\000') {
				return int32(m_FcTrue)
			}
			/* see if sub has a country while super is missing one */
			if libc.Int32FromUint8(c1) == int32('\000') && libc.Int32FromUint8(c2) == int32('-') {
				return int32(m_FcTrue)
			}
			return m_FcFalse
		} else {
			if !(c1 != 0) {
				return int32(m_FcTrue)
			}
		}
		goto _1
	_1:
	}
	return r
}

func XFcLangGetCharSet(tls *libc.TLS, lang uintptr) (r uintptr) {
	var country, i int32
	_, _ = country, i
	country = -int32(1)
	i = 0
	for {
		if !(i < int32(m_NUM_LANG_CHAR_SET)) {
			break
		}
		switch XFcLangCompare(tls, lang, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40) {
		case int32(_FcLangEqual):
			return uintptr(unsafe.Pointer(&_fcLangData)) + uintptr(i)*40 + 16
		case int32(_FcLangDifferentTerritory):
			if country == -int32(1) {
				country = i
			}
			fallthrough
		case int32(_FcLangDifferentLang):
			fallthrough
		default:
			break
		}
		goto _1
	_1:
		;
		i++
	}
	if country == -int32(1) {
		return uintptr(0)
	}
	return uintptr(unsafe.Pointer(&_fcLangData)) + uintptr(country)*40 + 16
}

func XFcGetLangs(tls *libc.TLS) (r uintptr) {
	var i int32
	var langs uintptr
	_, _ = i, langs
	langs = XFcStrSetCreate(tls)
	if !(langs != 0) {
		return uintptr(0)
	}
	i = 0
	for {
		if !(i < int32(m_NUM_LANG_CHAR_SET)) {
			break
		}
		XFcStrSetAdd(tls, langs, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40)
		goto _1
	_1:
		;
		i++
	}
	return langs
}

func XFcLangSetCreate(tls *libc.TLS) (r uintptr) {
	var ls uintptr
	_ = ls
	ls = libc.Xmalloc(tls, uint64(48))
	if !(ls != 0) {
		return uintptr(0)
	}
	libc.X__builtin___memset_chk(tls, ls+12, int32('\000'), uint64(32), ^t__predefined_size_t(0))
	(*TFcLangSet)(unsafe.Pointer(ls)).Fmap_size = uint32(m_NUM_LANG_SET_MAP)
	(*TFcLangSet)(unsafe.Pointer(ls)).Fextra = uintptr(0)
	return ls
}

func XFcLangSetDestroy(tls *libc.TLS, ls uintptr) {
	if !(ls != 0) {
		return
	}
	if (*TFcLangSet)(unsafe.Pointer(ls)).Fextra != 0 {
		XFcStrSetDestroy(tls, (*TFcLangSet)(unsafe.Pointer(ls)).Fextra)
	}
	libc.Xfree(tls, ls)
}

func XFcLangSetCopy(tls *libc.TLS, ls uintptr) (r uintptr) {
	var extra, list, new1, v2 uintptr
	var v1 uint64
	_, _, _, _, _ = extra, list, new1, v1, v2
	if !(ls != 0) {
		return libc.UintptrFromInt32(0)
	}
	new1 = XFcLangSetCreate(tls)
	if !(new1 != 0) {
		goto bail0
	}
	libc.X__builtin___memset_chk(tls, new1+12, int32('\000'), uint64(32), ^t__predefined_size_t(0))
	if libc.Uint64FromInt64(32) < uint64((*TFcLangSet)(unsafe.Pointer(ls)).Fmap_size)*uint64(4) {
		v1 = libc.Uint64FromInt64(32)
	} else {
		v1 = uint64((*TFcLangSet)(unsafe.Pointer(ls)).Fmap_size) * uint64(4)
	}
	libc.X__builtin___memcpy_chk(tls, new1+12, ls+12, v1, ^t__predefined_size_t(0))
	if (*TFcLangSet)(unsafe.Pointer(ls)).Fextra != 0 {
		(*TFcLangSet)(unsafe.Pointer(new1)).Fextra = XFcStrSetCreate(tls)
		if !((*TFcLangSet)(unsafe.Pointer(new1)).Fextra != 0) {
			goto bail1
		}
		list = XFcStrListCreate(tls, (*TFcLangSet)(unsafe.Pointer(ls)).Fextra)
		if !(list != 0) {
			goto bail1
		}
		for {
			v2 = XFcStrListNext(tls, list)
			extra = v2
			if !(v2 != 0) {
				break
			}
			if !(XFcStrSetAdd(tls, (*TFcLangSet)(unsafe.Pointer(new1)).Fextra, extra) != 0) {
				XFcStrListDone(tls, list)
				goto bail1
			}
		}
		XFcStrListDone(tls, list)
	}
	return new1
	goto bail1
bail1:
	;
	XFcLangSetDestroy(tls, new1)
	goto bail0
bail0:
	;
	return uintptr(0)
	return r
}

// C documentation
//
//	/* When the language isn't found, the return value r is such that:
//	 *  1) r < 0
//	 *  2) -r -1 is the index of the first language in fcLangCharSets that comes
//	 *     after the 'lang' argument in lexicographic order.
//	 *
//	 *  The -1 is necessary to avoid problems with language id 0 (otherwise, we
//	 *  wouldn't be able to distinguish between language found, id is 0 and
//	 *  language not found, sorts right before the language with id 0).
//	 */
func _FcLangSetIndex(tls *libc.TLS, lang uintptr) (r int32) {
	var cmp, high, low, mid, v1, v2, v3 int32
	var firstChar, secondChar TFcChar8
	_, _, _, _, _, _, _, _, _ = cmp, firstChar, high, low, mid, secondChar, v1, v2, v3
	mid = 0
	cmp = 0
	if int32(0101) <= libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(lang))) && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(lang))) <= int32(0132) {
		v1 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(lang))) - int32(0101) + int32(0141)
	} else {
		v1 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(lang)))
	}
	firstChar = libc.Uint8FromInt32(v1)
	if firstChar != 0 {
		if int32(0101) <= libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(lang + 1))) && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(lang + 1))) <= int32(0132) {
			v3 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(lang + 1))) - int32(0101) + int32(0141)
		} else {
			v3 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(lang + 1)))
		}
		v2 = v3
	} else {
		v2 = int32('\000')
	}
	secondChar = libc.Uint8FromInt32(v2)
	if libc.Int32FromUint8(firstChar) < int32('a') {
		low = 0
		high = _fcLangCharSetRanges[0].Fbegin
	} else {
		if libc.Int32FromUint8(firstChar) > int32('z') {
			low = _fcLangCharSetRanges[int32(25)].Fbegin
			high = libc.Int32FromInt32(m_NUM_LANG_CHAR_SET) - libc.Int32FromInt32(1)
		} else {
			low = _fcLangCharSetRanges[libc.Int32FromUint8(firstChar)-int32('a')].Fbegin
			high = _fcLangCharSetRanges[libc.Int32FromUint8(firstChar)-int32('a')].Fend
			/* no matches */
			if low > high {
				return -(low + int32(1))
			} /* one past next entry after where it would be */
		}
	}
	for low <= high {
		mid = (high + low) >> int32(1)
		if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangData)) + uintptr(mid)*40))) != libc.Int32FromUint8(firstChar) {
			cmp = XFcStrCmpIgnoreCase(tls, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(mid)*40, lang)
		} else {
			/* fast path for resolving 2-letter languages (by far the most common) after
			 * finding the first char (probably already true because of the hash table) */
			cmp = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangData)) + uintptr(mid)*40 + 1))) - libc.Int32FromUint8(secondChar)
			if cmp == 0 && (libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangData)) + uintptr(mid)*40 + 2))) != int32('\000') || libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(lang + 2))) != int32('\000')) {
				cmp = XFcStrCmpIgnoreCase(tls, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(mid)*40+uintptr(2), lang+uintptr(2))
			}
		}
		if cmp == 0 {
			return mid
		}
		if cmp < 0 {
			low = mid + int32(1)
		} else {
			high = mid - int32(1)
		}
	}
	if cmp < 0 {
		mid++
	}
	return -(mid + int32(1))
}

func XFcLangSetAdd(tls *libc.TLS, ls uintptr, lang uintptr) (r TFcBool) {
	var id int32
	_ = id
	id = _FcLangSetIndex(tls, lang)
	if id >= 0 {
		_FcLangSetBitSet(tls, ls, libc.Uint32FromInt32(id))
		return int32(m_FcTrue)
	}
	if !((*TFcLangSet)(unsafe.Pointer(ls)).Fextra != 0) {
		(*TFcLangSet)(unsafe.Pointer(ls)).Fextra = XFcStrSetCreate(tls)
		if !((*TFcLangSet)(unsafe.Pointer(ls)).Fextra != 0) {
			return m_FcFalse
		}
	}
	return XFcStrSetAdd(tls, (*TFcLangSet)(unsafe.Pointer(ls)).Fextra, lang)
}

func XFcLangSetDel(tls *libc.TLS, ls uintptr, lang uintptr) (r TFcBool) {
	var id int32
	_ = id
	id = _FcLangSetIndex(tls, lang)
	if id >= 0 {
		_FcLangSetBitReset(tls, ls, libc.Uint32FromInt32(id))
	} else {
		if (*TFcLangSet)(unsafe.Pointer(ls)).Fextra != 0 {
			XFcStrSetDel(tls, (*TFcLangSet)(unsafe.Pointer(ls)).Fextra, lang)
		}
	}
	return int32(m_FcTrue)
}

func XFcLangSetHasLang(tls *libc.TLS, ls uintptr, lang uintptr) (r1 TFcLangResult) {
	var best, r TFcLangResult
	var extra, list, v3 uintptr
	var i, id int32
	var v4 bool
	_, _, _, _, _, _, _, _ = best, extra, i, id, list, r, v3, v4
	id = _FcLangSetIndex(tls, lang)
	if id < 0 {
		id = -id - int32(1)
	} else {
		if _FcLangSetBitGet(tls, ls, libc.Uint32FromInt32(id)) != 0 {
			return int32(_FcLangEqual)
		}
	}
	best = int32(_FcLangDifferentLang)
	i = id - int32(1)
	for {
		if !(i >= 0) {
			break
		}
		r = XFcLangCompare(tls, lang, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40)
		if r == int32(_FcLangDifferentLang) {
			break
		}
		if _FcLangSetBitGet(tls, ls, libc.Uint32FromInt32(i)) != 0 && r < best {
			best = r
		}
		goto _1
	_1:
		;
		i--
	}
	i = id
	for {
		if !(i < int32(m_NUM_LANG_CHAR_SET)) {
			break
		}
		r = XFcLangCompare(tls, lang, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40)
		if r == int32(_FcLangDifferentLang) {
			break
		}
		if _FcLangSetBitGet(tls, ls, libc.Uint32FromInt32(i)) != 0 && r < best {
			best = r
		}
		goto _2
	_2:
		;
		i++
	}
	if (*TFcLangSet)(unsafe.Pointer(ls)).Fextra != 0 {
		list = XFcStrListCreate(tls, (*TFcLangSet)(unsafe.Pointer(ls)).Fextra)
		if list != 0 {
			for {
				if v4 = best > int32(_FcLangEqual); v4 {
					v3 = XFcStrListNext(tls, list)
					extra = v3
				}
				if !(v4 && v3 != 0) {
					break
				}
				r = XFcLangCompare(tls, lang, extra)
				if r < best {
					best = r
				}
			}
			XFcStrListDone(tls, list)
		}
	}
	return best
}

func _FcLangSetCompareStrSet(tls *libc.TLS, ls uintptr, set uintptr) (r1 TFcLangResult) {
	var best, r TFcLangResult
	var extra, list, v1 uintptr
	var v2 bool
	_, _, _, _, _, _ = best, extra, list, r, v1, v2
	list = XFcStrListCreate(tls, set)
	best = int32(_FcLangDifferentLang)
	if list != 0 {
		for {
			if v2 = best > int32(_FcLangEqual); v2 {
				v1 = XFcStrListNext(tls, list)
				extra = v1
			}
			if !(v2 && v1 != 0) {
				break
			}
			r = XFcLangSetHasLang(tls, ls, extra)
			if r < best {
				best = r
			}
		}
		XFcStrListDone(tls, list)
	}
	return best
}

func XFcLangSetCompare(tls *libc.TLS, lsa uintptr, lsb uintptr) (r1 TFcLangResult) {
	var aInCountrySet, bInCountrySet TFcChar32
	var best, r TFcLangResult
	var count, i, j, v2 int32
	var v1 uint32
	_, _, _, _, _, _, _, _, _ = aInCountrySet, bInCountrySet, best, count, i, j, r, v1, v2
	if (*TFcLangSet)(unsafe.Pointer(lsa)).Fmap_size < (*TFcLangSet)(unsafe.Pointer(lsb)).Fmap_size {
		v1 = (*TFcLangSet)(unsafe.Pointer(lsa)).Fmap_size
	} else {
		v1 = (*TFcLangSet)(unsafe.Pointer(lsb)).Fmap_size
	}
	count = libc.Int32FromUint32(v1)
	if int32(m_NUM_LANG_SET_MAP) < count {
		v2 = int32(m_NUM_LANG_SET_MAP)
	} else {
		v2 = count
	}
	count = v2
	i = 0
	for {
		if !(i < count) {
			break
		}
		if *(*TFcChar32)(unsafe.Pointer(lsa + 12 + uintptr(i)*4))&*(*TFcChar32)(unsafe.Pointer(lsb + 12 + uintptr(i)*4)) != 0 {
			return int32(_FcLangEqual)
		}
		goto _3
	_3:
		;
		i++
	}
	best = int32(_FcLangDifferentLang)
	j = 0
	for {
		if !(j < int32(m_NUM_COUNTRY_SET)) {
			break
		}
		aInCountrySet = uint32(0)
		bInCountrySet = uint32(0)
		i = 0
		for {
			if !(i < count) {
				break
			}
			aInCountrySet |= *(*TFcChar32)(unsafe.Pointer(lsa + 12 + uintptr(i)*4)) & *(*TFcChar32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangCountrySets)) + uintptr(j)*32 + uintptr(i)*4))
			bInCountrySet |= *(*TFcChar32)(unsafe.Pointer(lsb + 12 + uintptr(i)*4)) & *(*TFcChar32)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangCountrySets)) + uintptr(j)*32 + uintptr(i)*4))
			if aInCountrySet != 0 && bInCountrySet != 0 {
				best = int32(_FcLangDifferentTerritory)
				break
			}
			goto _5
		_5:
			;
			i++
		}
		goto _4
	_4:
		;
		j++
	}
	if (*TFcLangSet)(unsafe.Pointer(lsa)).Fextra != 0 {
		r = _FcLangSetCompareStrSet(tls, lsb, (*TFcLangSet)(unsafe.Pointer(lsa)).Fextra)
		if r < best {
			best = r
		}
	}
	if best > int32(_FcLangEqual) && (*TFcLangSet)(unsafe.Pointer(lsb)).Fextra != 0 {
		r = _FcLangSetCompareStrSet(tls, lsa, (*TFcLangSet)(unsafe.Pointer(lsb)).Fextra)
		if r < best {
			best = r
		}
	}
	return best
}

// C documentation
//
//	/*
//	 * Used in computing values -- mustn't allocate any storage
//	 */
func XFcLangSetPromote(tls *libc.TLS, lang uintptr, vbuf uintptr) (r uintptr) {
	var buf uintptr
	var id int32
	_, _ = buf, id
	buf = vbuf
	libc.X__builtin___memset_chk(tls, buf+12, int32('\000'), uint64(32), ^t__predefined_size_t(0))
	(*struct {
		Fls   TFcLangSet
		Fstrs TFcStrSet
		Fstr  uintptr
	})(unsafe.Pointer(buf)).Fls.Fmap_size = uint32(m_NUM_LANG_SET_MAP)
	(*struct {
		Fls   TFcLangSet
		Fstrs TFcStrSet
		Fstr  uintptr
	})(unsafe.Pointer(buf)).Fls.Fextra = uintptr(0)
	if lang != 0 {
		id = _FcLangSetIndex(tls, lang)
		if id >= 0 {
			_FcLangSetBitSet(tls, buf, libc.Uint32FromInt32(id))
		} else {
			(*struct {
				Fls   TFcLangSet
				Fstrs TFcStrSet
				Fstr  uintptr
			})(unsafe.Pointer(buf)).Fls.Fextra = buf + 48
			(*struct {
				Fls   TFcLangSet
				Fstrs TFcStrSet
				Fstr  uintptr
			})(unsafe.Pointer(buf)).Fstrs.Fnum = int32(1)
			(*struct {
				Fls   TFcLangSet
				Fstrs TFcStrSet
				Fstr  uintptr
			})(unsafe.Pointer(buf)).Fstrs.Fsize = int32(1)
			(*struct {
				Fls   TFcLangSet
				Fstrs TFcStrSet
				Fstr  uintptr
			})(unsafe.Pointer(buf)).Fstrs.Fstrs = buf + 80
			(*TFcRef)(unsafe.Pointer(buf + 48)).Fcount = int32(1)
			(*struct {
				Fls   TFcLangSet
				Fstrs TFcStrSet
				Fstr  uintptr
			})(unsafe.Pointer(buf)).Fstr = lang
		}
	}
	return buf
}

func XFcLangSetHash(tls *libc.TLS, ls uintptr) (r TFcChar32) {
	var count, i int32
	var h TFcChar32
	var v1 uint32
	_, _, _, _ = count, h, i, v1
	h = uint32(0)
	if (*TFcLangSet)(unsafe.Pointer(ls)).Fmap_size < libc.Uint32FromInt32(libc.Int32FromInt32(m_NUM_LANG_SET_MAP)) {
		v1 = (*TFcLangSet)(unsafe.Pointer(ls)).Fmap_size
	} else {
		v1 = libc.Uint32FromInt32(libc.Int32FromInt32(m_NUM_LANG_SET_MAP))
	}
	count = libc.Int32FromUint32(v1)
	i = 0
	for {
		if !(i < count) {
			break
		}
		h ^= *(*TFcChar32)(unsafe.Pointer(ls + 12 + uintptr(i)*4))
		goto _2
	_2:
		;
		i++
	}
	if (*TFcLangSet)(unsafe.Pointer(ls)).Fextra != 0 {
		h ^= libc.Uint32FromInt32((*TFcStrSet)(unsafe.Pointer((*TFcLangSet)(unsafe.Pointer(ls)).Fextra)).Fnum)
	}
	return h
}

func XFcNameParseLangSet(tls *libc.TLS, string1 uintptr) (r uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var c TFcChar8
	var i int32
	var ls, v3 uintptr
	var _ /* lang at bp+0 */ [32]TFcChar8
	_, _, _, _ = c, i, ls, v3
	c = uint8(0)
	ls = XFcLangSetCreate(tls)
	if !(ls != 0) {
		goto bail0
	}
	for {
		i = 0
		for {
			if !(i < int32(31)) {
				break
			}
			v3 = string1
			string1++
			c = *(*TFcChar8)(unsafe.Pointer(v3))
			if libc.Int32FromUint8(c) == int32('\000') || libc.Int32FromUint8(c) == int32('|') {
				break
			} /* end of this code */
			(*(*[32]TFcChar8)(unsafe.Pointer(bp)))[i] = c
			goto _2
		_2:
			;
			i++
		}
		(*(*[32]TFcChar8)(unsafe.Pointer(bp)))[i] = uint8('\000')
		if !(XFcLangSetAdd(tls, ls, bp) != 0) {
			goto bail1
		}
		if libc.Int32FromUint8(c) == int32('\000') {
			break
		}
		goto _1
	_1:
	}
	return ls
	goto bail1
bail1:
	;
	XFcLangSetDestroy(tls, ls)
	goto bail0
bail0:
	;
	return uintptr(0)
	return r
}

func XFcNameUnparseLangSet(tls *libc.TLS, buf uintptr, ls uintptr) (r TFcBool) {
	var bit, count, i, id int32
	var bits, v3 TFcChar32
	var extra, list, v5 uintptr
	var first TFcBool
	var v1 uint32
	_, _, _, _, _, _, _, _, _, _, _ = bit, bits, count, extra, first, i, id, list, v1, v3, v5
	first = int32(m_FcTrue)
	if (*TFcLangSet)(unsafe.Pointer(ls)).Fmap_size < libc.Uint32FromInt32(libc.Int32FromInt32(m_NUM_LANG_SET_MAP)) {
		v1 = (*TFcLangSet)(unsafe.Pointer(ls)).Fmap_size
	} else {
		v1 = libc.Uint32FromInt32(libc.Int32FromInt32(m_NUM_LANG_SET_MAP))
	}
	count = libc.Int32FromUint32(v1)
	i = 0
	for {
		if !(i < count) {
			break
		}
		v3 = *(*TFcChar32)(unsafe.Pointer(ls + 12 + uintptr(i)*4))
		bits = v3
		if v3 != 0 {
			bit = 0
			for {
				if !(bit <= int32(31)) {
					break
				}
				if bits&(uint32(1)<<bit) != 0 {
					id = i<<int32(5) | bit
					if !(first != 0) {
						if !(XFcStrBufChar(tls, buf, uint8('|')) != 0) {
							return m_FcFalse
						}
					}
					if !(XFcStrBufString(tls, buf, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(*(*TFcChar8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangData)) + 41086 + uintptr(id))))*40) != 0) {
						return m_FcFalse
					}
					first = m_FcFalse
				}
				goto _4
			_4:
				;
				bit++
			}
		}
		goto _2
	_2:
		;
		i++
	}
	if (*TFcLangSet)(unsafe.Pointer(ls)).Fextra != 0 {
		list = XFcStrListCreate(tls, (*TFcLangSet)(unsafe.Pointer(ls)).Fextra)
		if !(list != 0) {
			return m_FcFalse
		}
		for {
			v5 = XFcStrListNext(tls, list)
			extra = v5
			if !(v5 != 0) {
				break
			}
			if !(first != 0) {
				if !(XFcStrBufChar(tls, buf, uint8('|')) != 0) {
					XFcStrListDone(tls, list)
					return m_FcFalse
				}
			}
			if !(XFcStrBufString(tls, buf, extra) != 0) {
				XFcStrListDone(tls, list)
				return m_FcFalse
			}
			first = m_FcFalse
		}
		XFcStrListDone(tls, list)
	}
	return int32(m_FcTrue)
}

func XFcLangSetEqual(tls *libc.TLS, lsa uintptr, lsb uintptr) (r TFcBool) {
	var count, i, v2 int32
	var v1 uint32
	_, _, _, _ = count, i, v1, v2
	if (*TFcLangSet)(unsafe.Pointer(lsa)).Fmap_size < (*TFcLangSet)(unsafe.Pointer(lsb)).Fmap_size {
		v1 = (*TFcLangSet)(unsafe.Pointer(lsa)).Fmap_size
	} else {
		v1 = (*TFcLangSet)(unsafe.Pointer(lsb)).Fmap_size
	}
	count = libc.Int32FromUint32(v1)
	if int32(m_NUM_LANG_SET_MAP) < count {
		v2 = int32(m_NUM_LANG_SET_MAP)
	} else {
		v2 = count
	}
	count = v2
	i = 0
	for {
		if !(i < count) {
			break
		}
		if *(*TFcChar32)(unsafe.Pointer(lsa + 12 + uintptr(i)*4)) != *(*TFcChar32)(unsafe.Pointer(lsb + 12 + uintptr(i)*4)) {
			return m_FcFalse
		}
		goto _3
	_3:
		;
		i++
	}
	if !((*TFcLangSet)(unsafe.Pointer(lsa)).Fextra != 0) && !((*TFcLangSet)(unsafe.Pointer(lsb)).Fextra != 0) {
		return int32(m_FcTrue)
	}
	if (*TFcLangSet)(unsafe.Pointer(lsa)).Fextra != 0 && (*TFcLangSet)(unsafe.Pointer(lsb)).Fextra != 0 {
		return XFcStrSetEqual(tls, (*TFcLangSet)(unsafe.Pointer(lsa)).Fextra, (*TFcLangSet)(unsafe.Pointer(lsb)).Fextra)
	}
	return m_FcFalse
}

func _FcLangSetContainsLang(tls *libc.TLS, ls uintptr, lang uintptr) (r TFcBool) {
	var extra, list, v3 uintptr
	var i, id int32
	_, _, _, _, _ = extra, i, id, list, v3
	id = _FcLangSetIndex(tls, lang)
	if id < 0 {
		id = -id - int32(1)
	} else {
		if _FcLangSetBitGet(tls, ls, libc.Uint32FromInt32(id)) != 0 {
			return int32(m_FcTrue)
		}
	}
	/*
	 * search up and down among equal languages for a match
	 */
	i = id - int32(1)
	for {
		if !(i >= 0) {
			break
		}
		if XFcLangCompare(tls, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40, lang) == int32(_FcLangDifferentLang) {
			break
		}
		if _FcLangSetBitGet(tls, ls, libc.Uint32FromInt32(i)) != 0 && _FcLangContains(tls, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40, lang) != 0 {
			return int32(m_FcTrue)
		}
		goto _1
	_1:
		;
		i--
	}
	i = id
	for {
		if !(i < int32(m_NUM_LANG_CHAR_SET)) {
			break
		}
		if XFcLangCompare(tls, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40, lang) == int32(_FcLangDifferentLang) {
			break
		}
		if _FcLangSetBitGet(tls, ls, libc.Uint32FromInt32(i)) != 0 && _FcLangContains(tls, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40, lang) != 0 {
			return int32(m_FcTrue)
		}
		goto _2
	_2:
		;
		i++
	}
	if (*TFcLangSet)(unsafe.Pointer(ls)).Fextra != 0 {
		list = XFcStrListCreate(tls, (*TFcLangSet)(unsafe.Pointer(ls)).Fextra)
		if list != 0 {
			for {
				v3 = XFcStrListNext(tls, list)
				extra = v3
				if !(v3 != 0) {
					break
				}
				if _FcLangContains(tls, extra, lang) != 0 {
					break
				}
			}
			XFcStrListDone(tls, list)
			if extra != 0 {
				return int32(m_FcTrue)
			}
		}
	}
	return m_FcFalse
}

// C documentation
//
//	/*
//	 * return FcTrue if lsa contains every language in lsb
//	 */
func XFcLangSetContains(tls *libc.TLS, lsa uintptr, lsb uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var count, i, j, v2 int32
	var extra, list, v5 uintptr
	var missing TFcChar32
	var v1 uint32
	_, _, _, _, _, _, _, _, _ = count, extra, i, j, list, missing, v1, v2, v5
	if XFcDebugVal&int32(m_FC_DBG_MATCHV) != 0 {
		libc.Xprintf(tls, __ccgo_ts+5915, 0)
		XFcLangSetPrint(tls, lsa)
		libc.Xprintf(tls, __ccgo_ts+5926, 0)
		XFcLangSetPrint(tls, lsb)
		libc.Xprintf(tls, __ccgo_ts+1266, 0)
	}
	/*
	 * check bitmaps for missing language support
	 */
	if (*TFcLangSet)(unsafe.Pointer(lsa)).Fmap_size < (*TFcLangSet)(unsafe.Pointer(lsb)).Fmap_size {
		v1 = (*TFcLangSet)(unsafe.Pointer(lsa)).Fmap_size
	} else {
		v1 = (*TFcLangSet)(unsafe.Pointer(lsb)).Fmap_size
	}
	count = libc.Int32FromUint32(v1)
	if int32(m_NUM_LANG_SET_MAP) < count {
		v2 = int32(m_NUM_LANG_SET_MAP)
	} else {
		v2 = count
	}
	count = v2
	i = 0
	for {
		if !(i < count) {
			break
		}
		missing = *(*TFcChar32)(unsafe.Pointer(lsb + 12 + uintptr(i)*4)) & ^*(*TFcChar32)(unsafe.Pointer(lsa + 12 + uintptr(i)*4))
		if missing != 0 {
			j = 0
			for {
				if !(j < int32(32)) {
					break
				}
				if missing&(uint32(1)<<j) != 0 {
					if !(_FcLangSetContainsLang(tls, lsa, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(*(*TFcChar8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangData)) + 41086 + uintptr(i*int32(32)+j))))*40) != 0) {
						if XFcDebugVal&int32(m_FC_DBG_MATCHV) != 0 {
							libc.Xprintf(tls, __ccgo_ts+5937, libc.VaList(bp+8, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(*(*TFcChar8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcLangData)) + 41086 + uintptr(i*int32(32)+j))))*40))
						}
						return m_FcFalse
					}
				}
				goto _4
			_4:
				;
				j++
			}
		}
		goto _3
	_3:
		;
		i++
	}
	if (*TFcLangSet)(unsafe.Pointer(lsb)).Fextra != 0 {
		list = XFcStrListCreate(tls, (*TFcLangSet)(unsafe.Pointer(lsb)).Fextra)
		if list != 0 {
			for {
				v5 = XFcStrListNext(tls, list)
				extra = v5
				if !(v5 != 0) {
					break
				}
				if !(_FcLangSetContainsLang(tls, lsa, extra) != 0) {
					if XFcDebugVal&int32(m_FC_DBG_MATCHV) != 0 {
						libc.Xprintf(tls, __ccgo_ts+5957, libc.VaList(bp+8, extra))
					}
					break
				}
			}
			XFcStrListDone(tls, list)
			if extra != 0 {
				return m_FcFalse
			}
		}
	}
	return int32(m_FcTrue)
}

func XFcLangSetSerializeAlloc(tls *libc.TLS, serialize uintptr, l uintptr) (r TFcBool) {
	if !(XFcSerializeAlloc(tls, serialize, l, int32(48)) != 0) {
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

func XFcLangSetSerialize(tls *libc.TLS, serialize uintptr, l uintptr) (r uintptr) {
	var l_serialize uintptr
	var v1 uint64
	_, _ = l_serialize, v1
	l_serialize = XFcSerializePtr(tls, serialize, l)
	if !(l_serialize != 0) {
		return libc.UintptrFromInt32(0)
	}
	libc.X__builtin___memset_chk(tls, l_serialize+12, int32('\000'), uint64(32), ^t__predefined_size_t(0))
	if libc.Uint64FromInt64(32) < uint64((*TFcLangSet)(unsafe.Pointer(l)).Fmap_size)*uint64(4) {
		v1 = libc.Uint64FromInt64(32)
	} else {
		v1 = uint64((*TFcLangSet)(unsafe.Pointer(l)).Fmap_size) * uint64(4)
	}
	libc.X__builtin___memcpy_chk(tls, l_serialize+12, l+12, v1, ^t__predefined_size_t(0))
	(*TFcLangSet)(unsafe.Pointer(l_serialize)).Fmap_size = uint32(m_NUM_LANG_SET_MAP)
	(*TFcLangSet)(unsafe.Pointer(l_serialize)).Fextra = libc.UintptrFromInt32(0) /* We don't serialize ls->extra */
	return l_serialize
}

func XFcLangSetGetLangs(tls *libc.TLS, ls uintptr) (r uintptr) {
	var extra, langs, list, v2 uintptr
	var i int32
	_, _, _, _, _ = extra, i, langs, list, v2
	langs = XFcStrSetCreate(tls)
	if !(langs != 0) {
		return uintptr(0)
	}
	i = 0
	for {
		if !(i < int32(m_NUM_LANG_CHAR_SET)) {
			break
		}
		if _FcLangSetBitGet(tls, ls, libc.Uint32FromInt32(i)) != 0 {
			XFcStrSetAdd(tls, langs, uintptr(unsafe.Pointer(&_fcLangData))+uintptr(i)*40)
		}
		goto _1
	_1:
		;
		i++
	}
	if (*TFcLangSet)(unsafe.Pointer(ls)).Fextra != 0 {
		list = XFcStrListCreate(tls, (*TFcLangSet)(unsafe.Pointer(ls)).Fextra)
		if list != 0 {
			for {
				v2 = XFcStrListNext(tls, list)
				extra = v2
				if !(v2 != 0) {
					break
				}
				XFcStrSetAdd(tls, langs, extra)
			}
			XFcStrListDone(tls, list)
		}
	}
	return langs
}

func _FcLangSetOperate(tls *libc.TLS, a uintptr, b uintptr, __ccgo_fp_func uintptr) (r uintptr) {
	var langset, set, sl, str, v1 uintptr
	_, _, _, _, _ = langset, set, sl, str, v1
	langset = XFcLangSetCopy(tls, a)
	set = XFcLangSetGetLangs(tls, b)
	sl = XFcStrListCreate(tls, set)
	XFcStrSetDestroy(tls, set)
	for {
		v1 = XFcStrListNext(tls, sl)
		str = v1
		if !(v1 != 0) {
			break
		}
		(*(*func(*libc.TLS, uintptr, uintptr) TFcBool)(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_func})))(tls, langset, str)
	}
	XFcStrListDone(tls, sl)
	return langset
}

func XFcLangSetUnion(tls *libc.TLS, a uintptr, b uintptr) (r uintptr) {
	return _FcLangSetOperate(tls, a, b, __ccgo_fp(XFcLangSetAdd))
}

func XFcLangSetSubtract(tls *libc.TLS, a uintptr, b uintptr) (r uintptr) {
	return _FcLangSetOperate(tls, a, b, __ccgo_fp(XFcLangSetDel))
}

const m_FC_LIST_HASH_SIZE = 4099

/*
 * Copyright (c) 2000, 2002 - 2008, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

func XFcObjectSetCreate(tls *libc.TLS) (r uintptr) {
	var os uintptr
	_ = os
	os = libc.Xmalloc(tls, uint64(16))
	if !(os != 0) {
		return uintptr(0)
	}
	(*TFcObjectSet)(unsafe.Pointer(os)).Fnobject = 0
	(*TFcObjectSet)(unsafe.Pointer(os)).Fsobject = 0
	(*TFcObjectSet)(unsafe.Pointer(os)).Fobjects = uintptr(0)
	return os
}

func XFcObjectSetAdd(tls *libc.TLS, os uintptr, object uintptr) (r TFcBool) {
	var c, high, low, mid, s int32
	var objects uintptr
	_, _, _, _, _, _ = c, high, low, mid, objects, s
	if (*TFcObjectSet)(unsafe.Pointer(os)).Fnobject == (*TFcObjectSet)(unsafe.Pointer(os)).Fsobject {
		s = (*TFcObjectSet)(unsafe.Pointer(os)).Fsobject + int32(4)
		if (*TFcObjectSet)(unsafe.Pointer(os)).Fobjects != 0 {
			objects = libc.Xrealloc(tls, (*TFcObjectSet)(unsafe.Pointer(os)).Fobjects, libc.Uint64FromInt32(s)*uint64(8))
		} else {
			objects = libc.Xmalloc(tls, libc.Uint64FromInt32(s)*uint64(8))
		}
		if !(objects != 0) {
			return m_FcFalse
		}
		(*TFcObjectSet)(unsafe.Pointer(os)).Fobjects = objects
		(*TFcObjectSet)(unsafe.Pointer(os)).Fsobject = s
	}
	high = (*TFcObjectSet)(unsafe.Pointer(os)).Fnobject - int32(1)
	low = 0
	mid = 0
	c = int32(1)
	object = libc.Xstrdup(tls, object)
	for low <= high {
		mid = (low + high) >> int32(1)
		c = int32(int64(*(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(mid)*8))) - int64(object))
		if c == 0 {
			libc.Xfree(tls, object)
			return int32(m_FcTrue)
		}
		if c < 0 {
			low = mid + int32(1)
		} else {
			high = mid - int32(1)
		}
	}
	if c < 0 {
		mid++
	}
	libc.X__builtin___memmove_chk(tls, (*TFcObjectSet)(unsafe.Pointer(os)).Fobjects+uintptr(mid)*8+uintptr(1)*8, (*TFcObjectSet)(unsafe.Pointer(os)).Fobjects+uintptr(mid)*8, libc.Uint64FromInt32((*TFcObjectSet)(unsafe.Pointer(os)).Fnobject-mid)*uint64(8), ^t__predefined_size_t(0))
	*(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(mid)*8)) = object
	(*TFcObjectSet)(unsafe.Pointer(os)).Fnobject++
	return int32(m_FcTrue)
}

func XFcObjectSetDestroy(tls *libc.TLS, os uintptr) {
	var i int32
	_ = i
	if (*TFcObjectSet)(unsafe.Pointer(os)).Fobjects != 0 {
		i = 0
		for {
			if !(i < (*TFcObjectSet)(unsafe.Pointer(os)).Fnobject) {
				break
			}
			libc.Xfree(tls, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(i)*8)))
			goto _1
		_1:
			;
			i++
		}
		libc.Xfree(tls, (*TFcObjectSet)(unsafe.Pointer(os)).Fobjects)
	}
	libc.Xfree(tls, os)
}

func XFcObjectSetVaBuild(tls *libc.TLS, first uintptr, va Tva_list) (r uintptr) {
	var __ob__, __os__, ret uintptr
	_, _, _ = __ob__, __os__, ret
	ret = uintptr(0)
	__os__ = XFcObjectSetCreate(tls)
	if !(__os__ != 0) {
		goto _FcObjectSetVapBuild_bail0
	}
	__ob__ = first
	for __ob__ != 0 {
		if !(XFcObjectSetAdd(tls, __os__, __ob__) != 0) {
			goto _FcObjectSetVapBuild_bail1
		}
		__ob__ = libc.VaUintptr(&va)
	}
	ret = __os__
	goto _FcObjectSetVapBuild_bail1
_FcObjectSetVapBuild_bail1:
	;
	if !(ret != 0) && __os__ != 0 {
		XFcObjectSetDestroy(tls, __os__)
	}
	goto _FcObjectSetVapBuild_bail0
_FcObjectSetVapBuild_bail0:
	;
	return ret
}

func XFcObjectSetBuild(tls *libc.TLS, first uintptr, va1 uintptr) (r uintptr) {
	var __ob__, __os__, os uintptr
	var va Tva_list
	_, _, _, _ = __ob__, __os__, os, va
	va = va1
	os = uintptr(0)
	__os__ = XFcObjectSetCreate(tls)
	if !(__os__ != 0) {
		goto _FcObjectSetVapBuild_bail0
	}
	__ob__ = first
	for __ob__ != 0 {
		if !(XFcObjectSetAdd(tls, __os__, __ob__) != 0) {
			goto _FcObjectSetVapBuild_bail1
		}
		__ob__ = libc.VaUintptr(&va)
	}
	os = __os__
	goto _FcObjectSetVapBuild_bail1
_FcObjectSetVapBuild_bail1:
	;
	if !(os != 0) && __os__ != 0 {
		XFcObjectSetDestroy(tls, __os__)
	}
	goto _FcObjectSetVapBuild_bail0
_FcObjectSetVapBuild_bail0:
	;
	_ = va
	return os
}

// C documentation
//
//	/*
//	 * Font must have a containing value for every value in the pattern
//	 */
func _FcListValueListMatchAny(tls *libc.TLS, patOrig TFcValueListPtr, fntOrig TFcValueListPtr) (r TFcBool) {
	/* font */
	var fnt, pat TFcValueListPtr
	var v3, v4 uintptr
	_, _, _, _ = fnt, pat, v3, v4
	pat = patOrig
	for {
		if !(pat != libc.UintptrFromInt32(0)) {
			break
		}
		fnt = fntOrig
		for {
			if !(fnt != libc.UintptrFromInt32(0)) {
				break
			}
			/*
			 * make sure the font 'contains' the pattern.
			 * (OpListing is OpContains except for strings
			 *  where it requires an exact match)
			 */
			if XFcConfigCompareValue(tls, fnt+8, libc.Uint32FromInt32(int32(_FcOpListing)&libc.Int32FromInt32(0xffff)|int32(_FcOpFlagIgnoreBlanks)<<libc.Int32FromInt32(16)), pat+8) != 0 {
				break
			}
			goto _2
		_2:
			;
			if int64((*T_FcValueList)(unsafe.Pointer(fnt)).Fnext)&int64(1) != 0 {
				v3 = uintptr(int64(fnt) + int64((*T_FcValueList)(unsafe.Pointer(fnt)).Fnext)&int64(^libc.Int32FromInt32(1)))
			} else {
				v3 = (*T_FcValueList)(unsafe.Pointer(fnt)).Fnext
			}
			fnt = v3
		}
		if fnt == libc.UintptrFromInt32(0) {
			return m_FcFalse
		}
		goto _1
	_1:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(pat)).Fnext)&int64(1) != 0 {
			v4 = uintptr(int64(pat) + int64((*T_FcValueList)(unsafe.Pointer(pat)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v4 = (*T_FcValueList)(unsafe.Pointer(pat)).Fnext
		}
		pat = v4
	}
	return int32(m_FcTrue)
}

func _FcListValueListEqual(tls *libc.TLS, v1orig TFcValueListPtr, v2orig TFcValueListPtr) (r TFcBool) {
	var v1, v2 TFcValueListPtr
	var v3, v4, v7, v8 uintptr
	_, _, _, _, _, _ = v1, v2, v3, v4, v7, v8
	v1 = v1orig
	for {
		if !(v1 != libc.UintptrFromInt32(0)) {
			break
		}
		v2 = v2orig
		for {
			if !(v2 != libc.UintptrFromInt32(0)) {
				break
			}
			if XFcValueEqual(tls, XFcValueCanonicalize(tls, v1+8), XFcValueCanonicalize(tls, v2+8)) != 0 {
				break
			}
			goto _2
		_2:
			;
			if int64((*T_FcValueList)(unsafe.Pointer(v2)).Fnext)&int64(1) != 0 {
				v3 = uintptr(int64(v2) + int64((*T_FcValueList)(unsafe.Pointer(v2)).Fnext)&int64(^libc.Int32FromInt32(1)))
			} else {
				v3 = (*T_FcValueList)(unsafe.Pointer(v2)).Fnext
			}
			v2 = v3
		}
		if v2 == libc.UintptrFromInt32(0) {
			return m_FcFalse
		}
		goto _1
	_1:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(v1)).Fnext)&int64(1) != 0 {
			v4 = uintptr(int64(v1) + int64((*T_FcValueList)(unsafe.Pointer(v1)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v4 = (*T_FcValueList)(unsafe.Pointer(v1)).Fnext
		}
		v1 = v4
	}
	v2 = v2orig
	for {
		if !(v2 != libc.UintptrFromInt32(0)) {
			break
		}
		v1 = v1orig
		for {
			if !(v1 != libc.UintptrFromInt32(0)) {
				break
			}
			if XFcValueEqual(tls, XFcValueCanonicalize(tls, v1+8), XFcValueCanonicalize(tls, v2+8)) != 0 {
				break
			}
			goto _6
		_6:
			;
			if int64((*T_FcValueList)(unsafe.Pointer(v1)).Fnext)&int64(1) != 0 {
				v7 = uintptr(int64(v1) + int64((*T_FcValueList)(unsafe.Pointer(v1)).Fnext)&int64(^libc.Int32FromInt32(1)))
			} else {
				v7 = (*T_FcValueList)(unsafe.Pointer(v1)).Fnext
			}
			v1 = v7
		}
		if v1 == libc.UintptrFromInt32(0) {
			return m_FcFalse
		}
		goto _5
	_5:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(v2)).Fnext)&int64(1) != 0 {
			v8 = uintptr(int64(v2) + int64((*T_FcValueList)(unsafe.Pointer(v2)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v8 = (*T_FcValueList)(unsafe.Pointer(v2)).Fnext
		}
		v2 = v8
	}
	return int32(m_FcTrue)
}

func _FcListPatternEqual(tls *libc.TLS, p1 uintptr, p2 uintptr, os uintptr) (r TFcBool) {
	var e1, e2, v2, v3 uintptr
	var i int32
	_, _, _, _, _ = e1, e2, i, v2, v3
	i = 0
	for {
		if !(i < (*TFcObjectSet)(unsafe.Pointer(os)).Fnobject) {
			break
		}
		e1 = XFcPatternObjectFindElt(tls, p1, XFcObjectFromName(tls, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(i)*8))))
		e2 = XFcPatternObjectFindElt(tls, p2, XFcObjectFromName(tls, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(i)*8))))
		if !(e1 != 0) && !(e2 != 0) {
			goto _1
		}
		if !(e1 != 0) || !(e2 != 0) {
			return m_FcFalse
		}
		if int64((*TFcPatternElt)(unsafe.Pointer(e1)).Fvalues)&int64(1) != 0 {
			v2 = uintptr(int64(e1) + int64((*TFcPatternElt)(unsafe.Pointer(e1)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*TFcPatternElt)(unsafe.Pointer(e1)).Fvalues
		}
		if int64((*TFcPatternElt)(unsafe.Pointer(e2)).Fvalues)&int64(1) != 0 {
			v3 = uintptr(int64(e2) + int64((*TFcPatternElt)(unsafe.Pointer(e2)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v3 = (*TFcPatternElt)(unsafe.Pointer(e2)).Fvalues
		}
		if !(_FcListValueListEqual(tls, v2, v3) != 0) {
			return m_FcFalse
		}
		goto _1
	_1:
		;
		i++
	}
	return int32(m_FcTrue)
}

/*
 * FcTrue iff all objects in "p" match "font"
 */

func XFcListPatternMatchAny(tls *libc.TLS, p uintptr, font uintptr) (r TFcBool) {
	var fe, pe, v2, v3 uintptr
	var i int32
	_, _, _, _, _ = fe, i, pe, v2, v3
	if !(p != 0) {
		return m_FcFalse
	}
	i = 0
	for {
		if !(i < (*TFcPattern)(unsafe.Pointer(p)).Fnum) {
			break
		}
		pe = uintptr(int64(p)+(*TFcPattern)(unsafe.Pointer(p)).Felts_offset) + uintptr(i)*16
		if (*TFcPatternElt)(unsafe.Pointer(pe)).Fobject == int32(_FC_NAMELANG_OBJECT) {
			/* "namelang" object is the alias object to change "familylang",
			 * "stylelang" and "fullnamelang" object all together. it won't be
			 * available on the font pattern. so checking its availability
			 * causes no results. we should ignore it here.
			 */
			goto _1
		}
		fe = XFcPatternObjectFindElt(tls, font, (*TFcPatternElt)(unsafe.Pointer(pe)).Fobject)
		if !(fe != 0) {
			return m_FcFalse
		}
		if int64((*TFcPatternElt)(unsafe.Pointer(pe)).Fvalues)&int64(1) != 0 {
			v2 = uintptr(int64(pe) + int64((*TFcPatternElt)(unsafe.Pointer(pe)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*TFcPatternElt)(unsafe.Pointer(pe)).Fvalues
		}
		if int64((*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues)&int64(1) != 0 {
			v3 = uintptr(int64(fe) + int64((*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v3 = (*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues
		}
		if !(_FcListValueListMatchAny(tls, v2, v3) != 0) { /* font elts */
			return m_FcFalse
		}
		goto _1
	_1:
		;
		i++
	}
	return int32(m_FcTrue)
}

func _FcListMatrixHash(tls *libc.TLS, m uintptr) (r TFcChar32) {
	var xx, xy, yx, yy int32
	_, _, _, _ = xx, xy, yx, yy
	xx = int32(float64((*TFcMatrix)(unsafe.Pointer(m)).Fxx * libc.Float64FromInt32(100)))
	xy = int32(float64((*TFcMatrix)(unsafe.Pointer(m)).Fxy * libc.Float64FromInt32(100)))
	yx = int32(float64((*TFcMatrix)(unsafe.Pointer(m)).Fyx * libc.Float64FromInt32(100)))
	yy = int32(float64((*TFcMatrix)(unsafe.Pointer(m)).Fyy * libc.Float64FromInt32(100)))
	return libc.Uint32FromInt32(xx) ^ libc.Uint32FromInt32(xy) ^ libc.Uint32FromInt32(yx) ^ libc.Uint32FromInt32(yy)
}

func _FcListValueHash(tls *libc.TLS, value uintptr) (r TFcChar32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* v at bp+0 */ TFcValue
	*(*TFcValue)(unsafe.Pointer(bp)) = TFcValue{}
	*(*T_FcValue)(unsafe.Pointer(bp)) = XFcValueCanonicalize(tls, value)
	switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
	case int32(_FcTypeUnknown):
		fallthrough
	case int32(_FcTypeVoid):
		return uint32(0)
	case int32(_FcTypeInteger):
		return libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(bp + 8)))
	case int32(_FcTypeDouble):
		return libc.Uint32FromInt32(int32(*(*float64)(unsafe.Pointer(bp + 8))))
	case int32(_FcTypeString):
		return XFcStrHashIgnoreCase(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	case int32(_FcTypeBool):
		return libc.Uint32FromInt32(*(*TFcBool)(unsafe.Pointer(bp + 8)))
	case int32(_FcTypeMatrix):
		return _FcListMatrixHash(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	case int32(_FcTypeCharSet):
		return XFcCharSetCount(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	case int32(_FcTypeFTFace):
		return libc.Uint32FromInt64(int64(*(*uintptr)(unsafe.Pointer(bp + 8))))
	case int32(_FcTypeLangSet):
		return XFcLangSetHash(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	case int32(_FcTypeRange):
		return XFcRangeHash(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	}
	return uint32(0)
}

func _FcListValueListHash(tls *libc.TLS, list TFcValueListPtr) (r TFcChar32) {
	var h TFcChar32
	var v1 uintptr
	_, _ = h, v1
	h = uint32(0)
	for list != libc.UintptrFromInt32(0) {
		h = h ^ _FcListValueHash(tls, list+8)
		if int64((*T_FcValueList)(unsafe.Pointer(list)).Fnext)&int64(1) != 0 {
			v1 = uintptr(int64(list) + int64((*T_FcValueList)(unsafe.Pointer(list)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v1 = (*T_FcValueList)(unsafe.Pointer(list)).Fnext
		}
		list = v1
	}
	return h
}

func _FcListPatternHash(tls *libc.TLS, font uintptr, os uintptr) (r TFcChar32) {
	var e, v2 uintptr
	var h TFcChar32
	var n int32
	_, _, _, _ = e, h, n, v2
	h = uint32(0)
	n = 0
	for {
		if !(n < (*TFcObjectSet)(unsafe.Pointer(os)).Fnobject) {
			break
		}
		e = XFcPatternObjectFindElt(tls, font, XFcObjectFromName(tls, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(n)*8))))
		if e != 0 {
			if int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(1) != 0 {
				v2 = uintptr(int64(e) + int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(^libc.Int32FromInt32(1)))
			} else {
				v2 = (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues
			}
			h = h ^ _FcListValueListHash(tls, v2)
		}
		goto _1
	_1:
		;
		n++
	}
	return h
}

type TFcListBucket = struct {
	Fnext    uintptr
	Fhash    TFcChar32
	Fpattern uintptr
}

type T_FcListBucket = TFcListBucket

type TFcListHashTable = struct {
	Fentries int32
	Fbuckets [4099]uintptr
}

type T_FcListHashTable = TFcListHashTable

func _FcListHashTableInit(tls *libc.TLS, table uintptr) {
	(*TFcListHashTable)(unsafe.Pointer(table)).Fentries = 0
	libc.X__builtin___memset_chk(tls, table+8, int32('\000'), uint64(32792), ^t__predefined_size_t(0))
}

func _FcListHashTableCleanup(tls *libc.TLS, table uintptr) {
	var bucket, next uintptr
	var i int32
	_, _, _ = bucket, i, next
	i = 0
	for {
		if !(i < int32(m_FC_LIST_HASH_SIZE)) {
			break
		}
		bucket = *(*uintptr)(unsafe.Pointer(table + 8 + uintptr(i)*8))
		for {
			if !(bucket != 0) {
				break
			}
			next = (*TFcListBucket)(unsafe.Pointer(bucket)).Fnext
			XFcPatternDestroy(tls, (*TFcListBucket)(unsafe.Pointer(bucket)).Fpattern)
			libc.Xfree(tls, bucket)
			goto _2
		_2:
			;
			bucket = next
		}
		*(*uintptr)(unsafe.Pointer(table + 8 + uintptr(i)*8)) = uintptr(0)
		goto _1
	_1:
		;
		i++
	}
	(*TFcListHashTable)(unsafe.Pointer(table)).Fentries = 0
}

func _FcGetDefaultObjectLangIndex(tls *libc.TLS, font uintptr, object TFcObject, lang uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var defidx, i, idx, v4, v5 int32
	var e, v2, v3 uintptr
	var res TFcLangResult
	var v TFcValueListPtr
	var _ /* value at bp+0 */ TFcValue
	_, _, _, _, _, _, _, _, _, _ = defidx, e, i, idx, res, v, v2, v3, v4, v5
	e = XFcPatternObjectFindElt(tls, font, object)
	idx = -int32(1)
	defidx = -int32(1)
	if e != 0 {
		if int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(1) != 0 {
			v2 = uintptr(int64(e) + int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues
		}
		v = v2
		i = libc.Int32FromInt32(0)
		for {
			if !(v != 0) {
				break
			}
			*(*TFcValue)(unsafe.Pointer(bp)) = XFcValueCanonicalize(tls, v+8)
			if (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 == int32(_FcTypeString) {
				res = XFcLangCompare(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), lang)
				if res == int32(_FcLangEqual) {
					return i
				}
				if res == int32(_FcLangDifferentCountry) && idx < 0 {
					idx = i
				}
				if defidx < 0 {
					/* workaround for fonts that has non-English value
					 * at the head of values.
					 */
					res = XFcLangCompare(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), __ccgo_ts+2752)
					if res == int32(_FcLangEqual) {
						defidx = i
					}
				}
			}
			goto _1
		_1:
			;
			if int64((*T_FcValueList)(unsafe.Pointer(v)).Fnext)&int64(1) != 0 {
				v3 = uintptr(int64(v) + int64((*T_FcValueList)(unsafe.Pointer(v)).Fnext)&int64(^libc.Int32FromInt32(1)))
			} else {
				v3 = (*T_FcValueList)(unsafe.Pointer(v)).Fnext
			}
			v = v3
			i++
		}
	}
	if idx > 0 {
		v4 = idx
	} else {
		if defidx > 0 {
			v5 = defidx
		} else {
			v5 = 0
		}
		v4 = v5
	}
	return v4
}

func _FcListAppend(tls *libc.TLS, table uintptr, font uintptr, os uintptr, lang uintptr) (r TFcBool) {
	var bucket, e, prev, v2, v5, v6 uintptr
	var defidx, familyidx, fullnameidx, idx, o, styleidx int32
	var hash TFcChar32
	var v TFcValueListPtr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = bucket, defidx, e, familyidx, fullnameidx, hash, idx, o, prev, styleidx, v, v2, v5, v6
	familyidx = -int32(1)
	fullnameidx = -int32(1)
	styleidx = -int32(1)
	defidx = 0
	hash = _FcListPatternHash(tls, font, os)
	prev = table + 8 + uintptr(hash%uint32(m_FC_LIST_HASH_SIZE))*8
	for {
		v2 = *(*uintptr)(unsafe.Pointer(prev))
		bucket = v2
		if !(v2 != 0) {
			break
		}
		if (*TFcListBucket)(unsafe.Pointer(bucket)).Fhash == hash && _FcListPatternEqual(tls, (*TFcListBucket)(unsafe.Pointer(bucket)).Fpattern, font, os) != 0 {
			return int32(m_FcTrue)
		}
		goto _1
	_1:
		;
		prev = bucket
	}
	bucket = libc.Xmalloc(tls, uint64(24))
	if !(bucket != 0) {
		goto bail0
	}
	(*TFcListBucket)(unsafe.Pointer(bucket)).Fnext = uintptr(0)
	(*TFcListBucket)(unsafe.Pointer(bucket)).Fhash = hash
	(*TFcListBucket)(unsafe.Pointer(bucket)).Fpattern = XFcPatternCreate(tls)
	if !((*TFcListBucket)(unsafe.Pointer(bucket)).Fpattern != 0) {
		goto bail1
	}
	o = 0
	for {
		if !(o < (*TFcObjectSet)(unsafe.Pointer(os)).Fnobject) {
			break
		}
		if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(o)*8)), __ccgo_ts+5977) != 0) || !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(o)*8)), __ccgo_ts+5984) != 0) {
			if familyidx < 0 {
				familyidx = _FcGetDefaultObjectLangIndex(tls, font, int32(_FC_FAMILYLANG_OBJECT), lang)
			}
			defidx = familyidx
		} else {
			if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(o)*8)), __ccgo_ts+5995) != 0) || !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(o)*8)), __ccgo_ts+6004) != 0) {
				if fullnameidx < 0 {
					fullnameidx = _FcGetDefaultObjectLangIndex(tls, font, int32(_FC_FULLNAMELANG_OBJECT), lang)
				}
				defidx = fullnameidx
			} else {
				if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(o)*8)), __ccgo_ts+4583) != 0) || !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(o)*8)), __ccgo_ts+6017) != 0) {
					if styleidx < 0 {
						styleidx = _FcGetDefaultObjectLangIndex(tls, font, int32(_FC_STYLELANG_OBJECT), lang)
					}
					defidx = styleidx
				} else {
					defidx = 0
				}
			}
		}
		e = XFcPatternObjectFindElt(tls, font, XFcObjectFromName(tls, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(o)*8))))
		if e != 0 {
			if int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(1) != 0 {
				v5 = uintptr(int64(e) + int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(^libc.Int32FromInt32(1)))
			} else {
				v5 = (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues
			}
			v = v5
			idx = libc.Int32FromInt32(0)
			for {
				if !(v != 0) {
					break
				}
				if !(XFcPatternAdd(tls, (*TFcListBucket)(unsafe.Pointer(bucket)).Fpattern, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(o)*8)), XFcValueCanonicalize(tls, v+8), libc.BoolInt32(defidx != idx)) != 0) {
					goto bail2
				}
				goto _4
			_4:
				;
				if int64((*T_FcValueList)(unsafe.Pointer(v)).Fnext)&int64(1) != 0 {
					v6 = uintptr(int64(v) + int64((*T_FcValueList)(unsafe.Pointer(v)).Fnext)&int64(^libc.Int32FromInt32(1)))
				} else {
					v6 = (*T_FcValueList)(unsafe.Pointer(v)).Fnext
				}
				v = v6
				idx++
			}
		}
		goto _3
	_3:
		;
		o++
	}
	*(*uintptr)(unsafe.Pointer(prev)) = bucket
	(*TFcListHashTable)(unsafe.Pointer(table)).Fentries++
	return int32(m_FcTrue)
	goto bail2
bail2:
	;
	XFcPatternDestroy(tls, (*TFcListBucket)(unsafe.Pointer(bucket)).Fpattern)
	goto bail1
bail1:
	;
	libc.Xfree(tls, bucket)
	goto bail0
bail0:
	;
	return m_FcFalse
	return r
}

func XFcFontSetList(tls *libc.TLS, config uintptr, sets uintptr, nsets int32, p uintptr, os uintptr) (r uintptr) {
	bp := tls.Alloc(32816)
	defer tls.Free(32816)
	var bucket, ret, s, v4 uintptr
	var destroy_os, f, i, set int32
	var _ /* lang at bp+32800 */ uintptr
	var _ /* table at bp+0 */ TFcListHashTable
	_, _, _, _, _, _, _, _ = bucket, destroy_os, f, i, ret, s, set, v4
	destroy_os = 0
	if !(config != 0) {
		if !(XFcInitBringUptoDate(tls) != 0) {
			goto bail0
		}
	}
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		goto bail0
	}
	_FcListHashTableInit(tls, bp)
	if !(os != 0) {
		os = XFcObjectGetSet(tls)
		destroy_os = int32(1)
	}
	/*
	 * Walk all available fonts adding those that
	 * match to the hash table
	 */
	set = 0
	for {
		if !(set < nsets) {
			break
		}
		s = *(*uintptr)(unsafe.Pointer(sets + uintptr(set)*8))
		if !(s != 0) {
			goto _1
		}
		f = 0
		for {
			if !(f < (*TFcFontSet)(unsafe.Pointer(s)).Fnfont) {
				break
			}
			if XFcListPatternMatchAny(tls, p, *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(s)).Ffonts + uintptr(f)*8))) != 0 { /* font */
				if XFcPatternObjectGetString(tls, p, int32(_FC_NAMELANG_OBJECT), 0, bp+32800) != int32(_FcResultMatch) {
					*(*uintptr)(unsafe.Pointer(bp + 32800)) = XFcGetDefaultLang(tls)
				}
				if !(_FcListAppend(tls, bp, *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(s)).Ffonts + uintptr(f)*8)), os, *(*uintptr)(unsafe.Pointer(bp + 32800))) != 0) {
					goto bail1
				}
			}
			goto _2
		_2:
			;
			f++
		}
		goto _1
	_1:
		;
		set++
	}
	/*
	 * Walk the hash table and build
	 * a font set
	 */
	ret = XFcFontSetCreate(tls)
	if !(ret != 0) {
		goto bail1
	}
	i = 0
	for {
		if !(i < int32(m_FC_LIST_HASH_SIZE)) {
			break
		}
		for {
			v4 = *(*uintptr)(unsafe.Pointer(bp + 8 + uintptr(i)*8))
			bucket = v4
			if !(v4 != 0) {
				break
			}
			if !(XFcFontSetAdd(tls, ret, (*TFcListBucket)(unsafe.Pointer(bucket)).Fpattern) != 0) {
				goto bail2
			}
			*(*uintptr)(unsafe.Pointer(bp + 8 + uintptr(i)*8)) = (*TFcListBucket)(unsafe.Pointer(bucket)).Fnext
			libc.Xfree(tls, bucket)
		}
		goto _3
	_3:
		;
		i++
	}
	if destroy_os != 0 {
		XFcObjectSetDestroy(tls, os)
	}
	XFcConfigDestroy(tls, config)
	return ret
	goto bail2
bail2:
	;
	XFcFontSetDestroy(tls, ret)
	goto bail1
bail1:
	;
	_FcListHashTableCleanup(tls, bp)
	XFcConfigDestroy(tls, config)
	goto bail0
bail0:
	;
	if destroy_os != 0 {
		XFcObjectSetDestroy(tls, os)
	}
	return uintptr(0)
}

func XFcFontList(tls *libc.TLS, config uintptr, p uintptr, os uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var nsets, v1, v2 int32
	var ret uintptr
	var _ /* sets at bp+0 */ [2]uintptr
	_, _, _, _ = nsets, ret, v1, v2
	if !(config != 0) {
		if !(XFcInitBringUptoDate(tls) != 0) {
			return uintptr(0)
		}
	}
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return libc.UintptrFromInt32(0)
	}
	nsets = 0
	if *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(_FcSetSystem)*8)) != 0 {
		v1 = nsets
		nsets++
		(*(*[2]uintptr)(unsafe.Pointer(bp)))[v1] = *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(_FcSetSystem)*8))
	}
	if *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(_FcSetApplication)*8)) != 0 {
		v2 = nsets
		nsets++
		(*(*[2]uintptr)(unsafe.Pointer(bp)))[v2] = *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(_FcSetApplication)*8))
	}
	ret = XFcFontSetList(tls, config, bp, nsets, p, os)
	XFcConfigDestroy(tls, config)
	return ret
}

func _FcCompareNumber(tls *libc.TLS, value1 uintptr, value2 uintptr, bestValue uintptr) (r float64) {
	var v, v1, v2 float64
	_, _, _ = v, v1, v2
	switch (*TFcValue)(unsafe.Pointer(value1)).Ftype1 {
	case int32(_FcTypeInteger):
		v1 = float64(*(*int32)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(value1)).Fu)))
	case int32(_FcTypeDouble):
		v1 = *(*float64)(unsafe.Pointer(value1 + 8))
	default:
		return -libc.Float64FromFloat64(1)
	}
	switch (*TFcValue)(unsafe.Pointer(value2)).Ftype1 {
	case int32(_FcTypeInteger):
		v2 = float64(*(*int32)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(value2)).Fu)))
	case int32(_FcTypeDouble):
		v2 = *(*float64)(unsafe.Pointer(value2 + 8))
	default:
		return -libc.Float64FromFloat64(1)
	}
	v = v2 - v1
	if v < libc.Float64FromInt32(0) {
		v = -v
	}
	*(*TFcValue)(unsafe.Pointer(bestValue)) = XFcValueCanonicalize(tls, value2)
	return v
}

func _FcCompareString(tls *libc.TLS, v1 uintptr, v2 uintptr, bestValue uintptr) (r float64) {
	var v11, v21 uintptr
	_, _ = v11, v21
	*(*TFcValue)(unsafe.Pointer(bestValue)) = XFcValueCanonicalize(tls, v2)
	if int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(1) != 0 {
		v11 = uintptr(int64(v1) + int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(^libc.Int32FromInt32(1)))
	} else {
		v11 = *(*uintptr)(unsafe.Pointer(v1 + 8))
	}
	if int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(1) != 0 {
		v21 = uintptr(int64(v2) + int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(^libc.Int32FromInt32(1)))
	} else {
		v21 = *(*uintptr)(unsafe.Pointer(v2 + 8))
	}
	return float64(libc.Bool32(float64(XFcStrCmpIgnoreCase(tls, v11, v21)) != libc.Float64FromInt32(0)))
}

func _FcCompareFamily(tls *libc.TLS, v1 uintptr, v2 uintptr, bestValue uintptr) (r float64) {
	var v1_string, v2_string, v11, v21 uintptr
	var v3, v4 int32
	_, _, _, _, _, _ = v1_string, v2_string, v11, v21, v3, v4
	if int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(1) != 0 {
		v11 = uintptr(int64(v1) + int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(^libc.Int32FromInt32(1)))
	} else {
		v11 = *(*uintptr)(unsafe.Pointer(v1 + 8))
	}
	/* rely on the guarantee in FcPatternObjectAddWithBinding that
	 * families are always FcTypeString. */
	v1_string = v11
	if int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(1) != 0 {
		v21 = uintptr(int64(v2) + int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(^libc.Int32FromInt32(1)))
	} else {
		v21 = *(*uintptr)(unsafe.Pointer(v2 + 8))
	}
	v2_string = v21
	*(*TFcValue)(unsafe.Pointer(bestValue)) = XFcValueCanonicalize(tls, v2)
	if int32(0101) <= libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v1_string))) && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v1_string))) <= int32(0132) {
		v3 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v1_string))) - int32(0101) + int32(0141)
	} else {
		v3 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v1_string)))
	}
	if int32(0101) <= libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v2_string))) && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v2_string))) <= int32(0132) {
		v4 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v2_string))) - int32(0101) + int32(0141)
	} else {
		v4 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v2_string)))
	}
	if v3 != v4 && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v1_string))) != int32(' ') && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v2_string))) != int32(' ') {
		return float64(1)
	}
	return float64(libc.Bool32(float64(XFcStrCmpIgnoreBlanksAndCase(tls, v1_string, v2_string)) != libc.Float64FromInt32(0)))
}

func _FcComparePostScript(tls *libc.TLS, v1 uintptr, v2 uintptr, bestValue uintptr) (r float64) {
	var len1, len2, mlen Tsize_t
	var n, v3, v4 int32
	var v1_string, v2_string, v11, v21 uintptr
	var v5 uint64
	_, _, _, _, _, _, _, _, _, _, _ = len1, len2, mlen, n, v1_string, v2_string, v11, v21, v3, v4, v5
	if int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(1) != 0 {
		v11 = uintptr(int64(v1) + int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(^libc.Int32FromInt32(1)))
	} else {
		v11 = *(*uintptr)(unsafe.Pointer(v1 + 8))
	}
	v1_string = v11
	if int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(1) != 0 {
		v21 = uintptr(int64(v2) + int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(^libc.Int32FromInt32(1)))
	} else {
		v21 = *(*uintptr)(unsafe.Pointer(v2 + 8))
	}
	v2_string = v21
	*(*TFcValue)(unsafe.Pointer(bestValue)) = XFcValueCanonicalize(tls, v2)
	if int32(0101) <= libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v1_string))) && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v1_string))) <= int32(0132) {
		v3 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v1_string))) - int32(0101) + int32(0141)
	} else {
		v3 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v1_string)))
	}
	if int32(0101) <= libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v2_string))) && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v2_string))) <= int32(0132) {
		v4 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v2_string))) - int32(0101) + int32(0141)
	} else {
		v4 = libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v2_string)))
	}
	if v3 != v4 && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v1_string))) != int32(' ') && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v2_string))) != int32(' ') {
		return float64(1)
	}
	n = XFcStrMatchIgnoreCaseAndDelims(tls, v1_string, v2_string, __ccgo_ts+6027)
	len1 = libc.Xstrlen(tls, v1_string)
	len2 = libc.Xstrlen(tls, v2_string)
	if len1 > len2 {
		v5 = len1
	} else {
		v5 = len2
	}
	mlen = v5
	return float64(mlen-libc.Uint64FromInt32(n)) / float64(mlen)
}

func _FcCompareLang(tls *libc.TLS, v1 uintptr, v2 uintptr, bestValue uintptr) (r float64) {
	var result TFcLangResult
	var v11, v21, v3, v4, v5, v6, v7, v8 uintptr
	_, _, _, _, _, _, _, _, _ = result, v11, v21, v3, v4, v5, v6, v7, v8
	switch (*TFcValue)(unsafe.Pointer(v1)).Ftype1 {
	case int32(_FcTypeLangSet):
		switch (*TFcValue)(unsafe.Pointer(v2)).Ftype1 {
		case int32(_FcTypeLangSet):
			if int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(1) != 0 {
				v11 = uintptr(int64(v1) + int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(^libc.Int32FromInt32(1)))
			} else {
				v11 = *(*uintptr)(unsafe.Pointer(v1 + 8))
			}
			if int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(1) != 0 {
				v21 = uintptr(int64(v2) + int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(^libc.Int32FromInt32(1)))
			} else {
				v21 = *(*uintptr)(unsafe.Pointer(v2 + 8))
			}
			result = XFcLangSetCompare(tls, v11, v21)
		case int32(_FcTypeString):
			if int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(1) != 0 {
				v3 = uintptr(int64(v1) + int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(^libc.Int32FromInt32(1)))
			} else {
				v3 = *(*uintptr)(unsafe.Pointer(v1 + 8))
			}
			if int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(1) != 0 {
				v4 = uintptr(int64(v2) + int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(^libc.Int32FromInt32(1)))
			} else {
				v4 = *(*uintptr)(unsafe.Pointer(v2 + 8))
			}
			result = XFcLangSetHasLang(tls, v3, v4)
		default:
			return -libc.Float64FromFloat64(1)
		}
	case int32(_FcTypeString):
		switch (*TFcValue)(unsafe.Pointer(v2)).Ftype1 {
		case int32(_FcTypeLangSet):
			if int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(1) != 0 {
				v5 = uintptr(int64(v2) + int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(^libc.Int32FromInt32(1)))
			} else {
				v5 = *(*uintptr)(unsafe.Pointer(v2 + 8))
			}
			if int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(1) != 0 {
				v6 = uintptr(int64(v1) + int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(^libc.Int32FromInt32(1)))
			} else {
				v6 = *(*uintptr)(unsafe.Pointer(v1 + 8))
			}
			result = XFcLangSetHasLang(tls, v5, v6)
		case int32(_FcTypeString):
			if int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(1) != 0 {
				v7 = uintptr(int64(v1) + int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(^libc.Int32FromInt32(1)))
			} else {
				v7 = *(*uintptr)(unsafe.Pointer(v1 + 8))
			}
			if int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(1) != 0 {
				v8 = uintptr(int64(v2) + int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(^libc.Int32FromInt32(1)))
			} else {
				v8 = *(*uintptr)(unsafe.Pointer(v2 + 8))
			}
			result = XFcLangCompare(tls, v7, v8)
		default:
			return -libc.Float64FromFloat64(1)
		}
	default:
		return -libc.Float64FromFloat64(1)
	}
	*(*TFcValue)(unsafe.Pointer(bestValue)) = XFcValueCanonicalize(tls, v2)
	switch result {
	case int32(_FcLangEqual):
		return libc.Float64FromInt32(0)
	case int32(_FcLangDifferentCountry):
		return libc.Float64FromInt32(1)
	case int32(_FcLangDifferentLang):
		fallthrough
	default:
		return libc.Float64FromInt32(2)
	}
	return r
}

func _FcCompareBool(tls *libc.TLS, v1 uintptr, v2 uintptr, bestValue uintptr) (r float64) {
	if (*TFcValue)(unsafe.Pointer(v2)).Ftype1 != int32(_FcTypeBool) || (*TFcValue)(unsafe.Pointer(v1)).Ftype1 != int32(_FcTypeBool) {
		return -libc.Float64FromFloat64(1)
	}
	(*TFcValue)(unsafe.Pointer(bestValue)).Ftype1 = int32(_FcTypeBool)
	if *(*TFcBool)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(v2)).Fu)) != int32(m_FcDontCare) {
		*(*TFcBool)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(bestValue)).Fu)) = *(*TFcBool)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(v2)).Fu))
	} else {
		*(*TFcBool)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(bestValue)).Fu)) = *(*TFcBool)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(v1)).Fu))
	}
	return float64(libc.Bool32(*(*TFcBool)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(v2)).Fu))^*(*TFcBool)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(v1)).Fu)) == libc.Int32FromInt32(1)))
}

func _FcCompareCharSet(tls *libc.TLS, v1 uintptr, v2 uintptr, bestValue uintptr) (r float64) {
	var v11, v21 uintptr
	_, _ = v11, v21
	*(*TFcValue)(unsafe.Pointer(bestValue)) = XFcValueCanonicalize(tls, v2) /* TODO Improve. */
	if int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(1) != 0 {
		v11 = uintptr(int64(v1) + int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(^libc.Int32FromInt32(1)))
	} else {
		v11 = *(*uintptr)(unsafe.Pointer(v1 + 8))
	}
	if int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(1) != 0 {
		v21 = uintptr(int64(v2) + int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(^libc.Int32FromInt32(1)))
	} else {
		v21 = *(*uintptr)(unsafe.Pointer(v2 + 8))
	}
	return float64(XFcCharSetSubtractCount(tls, v11, v21))
}

func _FcCompareRange(tls *libc.TLS, v1 uintptr, v2 uintptr, bestValue uintptr) (r float64) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var b1, b2, d, e1, e2, v11, v21, v3, v4, v5, v6, v7 float64
	var _ /* value1 at bp+0 */ TFcValue
	var _ /* value2 at bp+16 */ TFcValue
	_, _, _, _, _, _, _, _, _, _, _, _ = b1, b2, d, e1, e2, v11, v21, v3, v4, v5, v6, v7
	*(*TFcValue)(unsafe.Pointer(bp)) = TFcValue{}
	*(*T_FcValue)(unsafe.Pointer(bp)) = XFcValueCanonicalize(tls, v1)
	*(*TFcValue)(unsafe.Pointer(bp + 16)) = TFcValue{}
	*(*T_FcValue)(unsafe.Pointer(bp + 16)) = XFcValueCanonicalize(tls, v2)
	switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
	case int32(_FcTypeInteger):
		v11 = float64(*(*int32)(unsafe.Pointer(bp + 8)))
		e1 = v11
		b1 = v11
	case int32(_FcTypeDouble):
		v21 = *(*float64)(unsafe.Pointer(bp + 8))
		e1 = v21
		b1 = v21
	case int32(_FcTypeRange):
		b1 = (*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fbegin
		e1 = (*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fend
	default:
		return float64(-libc.Int32FromInt32(1))
	}
	switch (*(*TFcValue)(unsafe.Pointer(bp + 16))).Ftype1 {
	case int32(_FcTypeInteger):
		v3 = float64(*(*int32)(unsafe.Pointer(bp + 16 + 8)))
		e2 = v3
		b2 = v3
	case int32(_FcTypeDouble):
		v4 = *(*float64)(unsafe.Pointer(bp + 16 + 8))
		e2 = v4
		b2 = v4
	case int32(_FcTypeRange):
		b2 = (*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 + 8)))).Fbegin
		e2 = (*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 + 8)))).Fend
	default:
		return float64(-libc.Int32FromInt32(1))
	}
	if e1 < b2 {
		d = b2
	} else {
		if e2 < b1 {
			d = e2
		} else {
			if b1 > b2 {
				v5 = b1
			} else {
				v5 = b2
			}
			if e1 < e2 {
				v6 = e1
			} else {
				v6 = e2
			}
			d = float64((v5 + v6) * float64(0.5))
		}
	}
	(*TFcValue)(unsafe.Pointer(bestValue)).Ftype1 = int32(_FcTypeDouble)
	*(*float64)(unsafe.Pointer(bestValue + 8)) = d
	/* If the ranges overlap, it's a match, otherwise return closest distance. */
	if e1 < b2 || e2 < b1 {
		if libc.Xfabs(tls, b2-e1) < libc.Xfabs(tls, b1-e2) {
			v7 = libc.Xfabs(tls, b2-e1)
		} else {
			v7 = libc.Xfabs(tls, b1-e2)
		}
		return v7
	} else {
		return float64(0)
	}
	return r
}

func _FcCompareSize(tls *libc.TLS, v1 uintptr, v2 uintptr, bestValue uintptr) (r float64) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var b1, b2, e1, e2, v11, v21, v3, v4, v5 float64
	var _ /* value1 at bp+0 */ TFcValue
	var _ /* value2 at bp+16 */ TFcValue
	_, _, _, _, _, _, _, _, _ = b1, b2, e1, e2, v11, v21, v3, v4, v5
	*(*TFcValue)(unsafe.Pointer(bp)) = TFcValue{}
	*(*T_FcValue)(unsafe.Pointer(bp)) = XFcValueCanonicalize(tls, v1)
	*(*TFcValue)(unsafe.Pointer(bp + 16)) = TFcValue{}
	*(*T_FcValue)(unsafe.Pointer(bp + 16)) = XFcValueCanonicalize(tls, v2)
	switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
	case int32(_FcTypeInteger):
		v11 = float64(*(*int32)(unsafe.Pointer(bp + 8)))
		e1 = v11
		b1 = v11
	case int32(_FcTypeDouble):
		v21 = *(*float64)(unsafe.Pointer(bp + 8))
		e1 = v21
		b1 = v21
	case int32(_FcTypeRange):
		b1 = (*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fbegin
		e1 = (*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fend
	default:
		return float64(-libc.Int32FromInt32(1))
	}
	switch (*(*TFcValue)(unsafe.Pointer(bp + 16))).Ftype1 {
	case int32(_FcTypeInteger):
		v3 = float64(*(*int32)(unsafe.Pointer(bp + 16 + 8)))
		e2 = v3
		b2 = v3
	case int32(_FcTypeDouble):
		v4 = *(*float64)(unsafe.Pointer(bp + 16 + 8))
		e2 = v4
		b2 = v4
	case int32(_FcTypeRange):
		b2 = (*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 + 8)))).Fbegin
		e2 = (*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 + 8)))).Fend
	default:
		return float64(-libc.Int32FromInt32(1))
	}
	(*TFcValue)(unsafe.Pointer(bestValue)).Ftype1 = int32(_FcTypeDouble)
	*(*float64)(unsafe.Pointer(bestValue + 8)) = float64((b1 + e1) * float64(0.5))
	/* If the ranges overlap, it's a match, otherwise return closest distance. */
	if e1 < b2 || e2 < b1 {
		if libc.Xfabs(tls, b2-e1) < libc.Xfabs(tls, b1-e2) {
			v5 = libc.Xfabs(tls, b2-e1)
		} else {
			v5 = libc.Xfabs(tls, b1-e2)
		}
		return v5
	}
	if b2 != e2 && b1 == e2 { /* Semi-closed interval. */
		return float64(1e-15)
	} else {
		return float64(0)
	}
	return r
}

func _FcCompareFilename(tls *libc.TLS, v1 uintptr, v2 uintptr, bestValue uintptr) (r float64) {
	var s1, s2, v11, v21 uintptr
	_, _, _, _ = s1, s2, v11, v21
	if int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(1) != 0 {
		v11 = uintptr(int64(v1) + int64(*(*uintptr)(unsafe.Pointer(v1 + 8)))&int64(^libc.Int32FromInt32(1)))
	} else {
		v11 = *(*uintptr)(unsafe.Pointer(v1 + 8))
	}
	s1 = v11
	if int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(1) != 0 {
		v21 = uintptr(int64(v2) + int64(*(*uintptr)(unsafe.Pointer(v2 + 8)))&int64(^libc.Int32FromInt32(1)))
	} else {
		v21 = *(*uintptr)(unsafe.Pointer(v2 + 8))
	}
	s2 = v21
	*(*TFcValue)(unsafe.Pointer(bestValue)) = XFcValueCanonicalize(tls, v2)
	if XFcStrCmp(tls, s1, s2) == 0 {
		return float64(0)
	} else {
		if XFcStrCmpIgnoreCase(tls, s1, s2) == 0 {
			return float64(1)
		} else {
			if XFcStrGlobMatch(tls, s1, s2) != 0 {
				return float64(2)
			} else {
				return float64(3)
			}
		}
	}
	return r
}

/* Define priorities to -1 for objects that don't have a compare function. */

type TFcMatcherPriorityDummy = int32

/* Define priorities to -1 for objects that don't have a compare function. */

type __FcMatcherPriorityDummy = int32

const _PRI_FAMILYLANG_STRONG = -1
const _PRI_FAMILYLANG_WEAK = -1
const _PRI_STYLELANG_STRONG = -1
const _PRI_STYLELANG_WEAK = -1
const _PRI_FULLNAME_STRONG = -1
const _PRI_FULLNAME_WEAK = -1
const _PRI_FULLNAMELANG_STRONG = -1
const _PRI_FULLNAMELANG_WEAK = -1
const _PRI_ASPECT_STRONG = -1
const _PRI_ASPECT_WEAK = -1
const _PRI_HINT_STYLE_STRONG = -1
const _PRI_HINT_STYLE_WEAK = -1
const _PRI_HINTING_STRONG = -1
const _PRI_HINTING_WEAK = -1
const _PRI_VERTICAL_LAYOUT_STRONG = -1
const _PRI_VERTICAL_LAYOUT_WEAK = -1
const _PRI_AUTOHINT_STRONG = -1
const _PRI_AUTOHINT_WEAK = -1
const _PRI_GLOBAL_ADVANCE_STRONG = -1
const _PRI_GLOBAL_ADVANCE_WEAK = -1
const _PRI_INDEX_STRONG = -1
const _PRI_INDEX_WEAK = -1
const _PRI_DPI_STRONG = -1
const _PRI_DPI_WEAK = -1
const _PRI_RGBA_STRONG = -1
const _PRI_RGBA_WEAK = -1
const _PRI_SCALE_STRONG = -1
const _PRI_SCALE_WEAK = -1
const _PRI_MINSPACE_STRONG = -1
const _PRI_MINSPACE_WEAK = -1
const _PRI_CHARWIDTH_STRONG = -1
const _PRI_CHARWIDTH_WEAK = -1
const _PRI_CHAR_HEIGHT_STRONG = -1
const _PRI_CHAR_HEIGHT_WEAK = -1
const _PRI_MATRIX_STRONG = -1
const _PRI_MATRIX_WEAK = -1
const _PRI_CAPABILITY_STRONG = -1
const _PRI_CAPABILITY_WEAK = -1
const _PRI_EMBOLDEN_STRONG = -1
const _PRI_EMBOLDEN_WEAK = -1
const _PRI_EMBEDDED_BITMAP_STRONG = -1
const _PRI_EMBEDDED_BITMAP_WEAK = -1
const _PRI_LCD_FILTER_STRONG = -1
const _PRI_LCD_FILTER_WEAK = -1
const _PRI_NAMELANG_STRONG = -1
const _PRI_NAMELANG_WEAK = -1
const _PRI_FONT_FEATURES_STRONG = -1
const _PRI_FONT_FEATURES_WEAK = -1
const _PRI_PRGNAME_STRONG = -1
const _PRI_PRGNAME_WEAK = -1
const _PRI_HASH_STRONG = -1
const _PRI_HASH_WEAK = -1
const _PRI_FONT_VARIATIONS_STRONG = -1
const _PRI_FONT_VARIATIONS_WEAK = -1

/* Canonical match priority order. */

type TFcMatcherPriority = int32

/* Canonical match priority order. */

type __FcMatcherPriority = int32

const _PRI_FILE = 0
const _PRI_FILE_STRONG = 0
const _PRI_FILE_WEAK = 0
const _PRI_FONTFORMAT = 1
const _PRI_FONTFORMAT_STRONG = 1
const _PRI_FONTFORMAT_WEAK = 1
const _PRI_VARIABLE = 2
const _PRI_VARIABLE_STRONG = 2
const _PRI_VARIABLE_WEAK = 2
const _PRI_SCALABLE = 3
const _PRI_SCALABLE_STRONG = 3
const _PRI_SCALABLE_WEAK = 3
const _PRI_COLOR = 4
const _PRI_COLOR_STRONG = 4
const _PRI_COLOR_WEAK = 4
const _PRI_FOUNDRY = 5
const _PRI_FOUNDRY_STRONG = 5
const _PRI_FOUNDRY_WEAK = 5
const _PRI_CHARSET = 6
const _PRI_CHARSET_STRONG = 6
const _PRI_CHARSET_WEAK = 6
const _PRI_FAMILY_STRONG = 7
const _PRI_POSTSCRIPT_NAME_STRONG = 8
const _PRI_LANG = 9
const _PRI_LANG_STRONG = 9
const _PRI_LANG_WEAK = 9
const _PRI_FAMILY_WEAK = 10
const _PRI_POSTSCRIPT_NAME_WEAK = 11
const _PRI_SYMBOL = 12
const _PRI_SYMBOL_STRONG = 12
const _PRI_SYMBOL_WEAK = 12
const _PRI_SPACING = 13
const _PRI_SPACING_STRONG = 13
const _PRI_SPACING_WEAK = 13
const _PRI_SIZE = 14
const _PRI_SIZE_STRONG = 14
const _PRI_SIZE_WEAK = 14
const _PRI_PIXEL_SIZE = 15
const _PRI_PIXEL_SIZE_STRONG = 15
const _PRI_PIXEL_SIZE_WEAK = 15
const _PRI_STYLE = 16
const _PRI_STYLE_STRONG = 16
const _PRI_STYLE_WEAK = 16
const _PRI_SLANT = 17
const _PRI_SLANT_STRONG = 17
const _PRI_SLANT_WEAK = 17
const _PRI_WEIGHT = 18
const _PRI_WEIGHT_STRONG = 18
const _PRI_WEIGHT_WEAK = 18
const _PRI_WIDTH = 19
const _PRI_WIDTH_STRONG = 19
const _PRI_WIDTH_WEAK = 19
const _PRI_FONT_HAS_HINT = 20
const _PRI_FONT_HAS_HINT_STRONG = 20
const _PRI_FONT_HAS_HINT_WEAK = 20
const _PRI_DECORATIVE = 21
const _PRI_DECORATIVE_STRONG = 21
const _PRI_DECORATIVE_WEAK = 21
const _PRI_ANTIALIAS = 22
const _PRI_ANTIALIAS_STRONG = 22
const _PRI_ANTIALIAS_WEAK = 22
const _PRI_RASTERIZER = 23
const _PRI_RASTERIZER_STRONG = 23
const _PRI_RASTERIZER_WEAK = 23
const _PRI_OUTLINE = 24
const _PRI_OUTLINE_STRONG = 24
const _PRI_OUTLINE_WEAK = 24
const _PRI_ORDER = 25
const _PRI_ORDER_STRONG = 25
const _PRI_ORDER_WEAK = 25
const _PRI_FONTVERSION = 26
const _PRI_FONTVERSION_STRONG = 26
const _PRI_FONTVERSION_WEAK = 26
const _PRI_END = 27

type TFcMatcher = struct {
	Fobject  TFcObject
	Fcompare uintptr
	Fstrong  int32
	Fweak    int32
}

type T_FcMatcher = TFcMatcher

// C documentation
//
//	/*
//	 * Order is significant, it defines the precedence of
//	 * each value, earlier values are more significant than
//	 * later values
//	 */
var __FcMatchers = [53]TFcMatcher{
	0: {
		Fstrong: -int32(1),
		Fweak:   -int32(1),
	},
	1: {
		Fobject: int32(_FC_FAMILY_OBJECT),
		Fstrong: int32(_PRI_FAMILY_STRONG),
		Fweak:   int32(_PRI_FAMILY_WEAK),
	},
	2: {
		Fobject: int32(_FC_FAMILYLANG_OBJECT),
		Fstrong: int32(_PRI_FAMILYLANG_STRONG),
		Fweak:   int32(_PRI_FAMILYLANG_WEAK),
	},
	3: {
		Fobject: int32(_FC_STYLE_OBJECT),
		Fstrong: int32(_PRI_STYLE_STRONG),
		Fweak:   int32(_PRI_STYLE_WEAK),
	},
	4: {
		Fobject: int32(_FC_STYLELANG_OBJECT),
		Fstrong: int32(_PRI_STYLELANG_STRONG),
		Fweak:   int32(_PRI_STYLELANG_WEAK),
	},
	5: {
		Fobject: int32(_FC_FULLNAME_OBJECT),
		Fstrong: int32(_PRI_FULLNAME_STRONG),
		Fweak:   int32(_PRI_FULLNAME_WEAK),
	},
	6: {
		Fobject: int32(_FC_FULLNAMELANG_OBJECT),
		Fstrong: int32(_PRI_FULLNAMELANG_STRONG),
		Fweak:   int32(_PRI_FULLNAMELANG_WEAK),
	},
	7: {
		Fobject: int32(_FC_SLANT_OBJECT),
		Fstrong: int32(_PRI_SLANT_STRONG),
		Fweak:   int32(_PRI_SLANT_WEAK),
	},
	8: {
		Fobject: int32(_FC_WEIGHT_OBJECT),
		Fstrong: int32(_PRI_WEIGHT_STRONG),
		Fweak:   int32(_PRI_WEIGHT_WEAK),
	},
	9: {
		Fobject: int32(_FC_WIDTH_OBJECT),
		Fstrong: int32(_PRI_WIDTH_STRONG),
		Fweak:   int32(_PRI_WIDTH_WEAK),
	},
	10: {
		Fobject: int32(_FC_SIZE_OBJECT),
		Fstrong: int32(_PRI_SIZE_STRONG),
		Fweak:   int32(_PRI_SIZE_WEAK),
	},
	11: {
		Fobject: int32(_FC_ASPECT_OBJECT),
		Fstrong: int32(_PRI_ASPECT_STRONG),
		Fweak:   int32(_PRI_ASPECT_WEAK),
	},
	12: {
		Fobject: int32(_FC_PIXEL_SIZE_OBJECT),
		Fstrong: int32(_PRI_PIXEL_SIZE_STRONG),
		Fweak:   int32(_PRI_PIXEL_SIZE_WEAK),
	},
	13: {
		Fobject: int32(_FC_SPACING_OBJECT),
		Fstrong: int32(_PRI_SPACING_STRONG),
		Fweak:   int32(_PRI_SPACING_WEAK),
	},
	14: {
		Fobject: int32(_FC_FOUNDRY_OBJECT),
		Fstrong: int32(_PRI_FOUNDRY_STRONG),
		Fweak:   int32(_PRI_FOUNDRY_WEAK),
	},
	15: {
		Fobject: int32(_FC_ANTIALIAS_OBJECT),
		Fstrong: int32(_PRI_ANTIALIAS_STRONG),
		Fweak:   int32(_PRI_ANTIALIAS_WEAK),
	},
	16: {
		Fobject: int32(_FC_HINT_STYLE_OBJECT),
		Fstrong: int32(_PRI_HINT_STYLE_STRONG),
		Fweak:   int32(_PRI_HINT_STYLE_WEAK),
	},
	17: {
		Fobject: int32(_FC_HINTING_OBJECT),
		Fstrong: int32(_PRI_HINTING_STRONG),
		Fweak:   int32(_PRI_HINTING_WEAK),
	},
	18: {
		Fobject: int32(_FC_VERTICAL_LAYOUT_OBJECT),
		Fstrong: int32(_PRI_VERTICAL_LAYOUT_STRONG),
		Fweak:   int32(_PRI_VERTICAL_LAYOUT_WEAK),
	},
	19: {
		Fobject: int32(_FC_AUTOHINT_OBJECT),
		Fstrong: int32(_PRI_AUTOHINT_STRONG),
		Fweak:   int32(_PRI_AUTOHINT_WEAK),
	},
	20: {
		Fobject: int32(_FC_GLOBAL_ADVANCE_OBJECT),
		Fstrong: int32(_PRI_GLOBAL_ADVANCE_STRONG),
		Fweak:   int32(_PRI_GLOBAL_ADVANCE_WEAK),
	},
	21: {
		Fobject: int32(_FC_FILE_OBJECT),
	},
	22: {
		Fobject: int32(_FC_INDEX_OBJECT),
		Fstrong: int32(_PRI_INDEX_STRONG),
		Fweak:   int32(_PRI_INDEX_WEAK),
	},
	23: {
		Fobject: int32(_FC_RASTERIZER_OBJECT),
		Fstrong: int32(_PRI_RASTERIZER_STRONG),
		Fweak:   int32(_PRI_RASTERIZER_WEAK),
	},
	24: {
		Fobject: int32(_FC_OUTLINE_OBJECT),
		Fstrong: int32(_PRI_OUTLINE_STRONG),
		Fweak:   int32(_PRI_OUTLINE_WEAK),
	},
	25: {
		Fobject: int32(_FC_SCALABLE_OBJECT),
		Fstrong: int32(_PRI_SCALABLE_STRONG),
		Fweak:   int32(_PRI_SCALABLE_WEAK),
	},
	26: {
		Fobject: int32(_FC_DPI_OBJECT),
		Fstrong: int32(_PRI_DPI_STRONG),
		Fweak:   int32(_PRI_DPI_WEAK),
	},
	27: {
		Fobject: int32(_FC_RGBA_OBJECT),
		Fstrong: int32(_PRI_RGBA_STRONG),
		Fweak:   int32(_PRI_RGBA_WEAK),
	},
	28: {
		Fobject: int32(_FC_SCALE_OBJECT),
		Fstrong: int32(_PRI_SCALE_STRONG),
		Fweak:   int32(_PRI_SCALE_WEAK),
	},
	29: {
		Fobject: int32(_FC_MINSPACE_OBJECT),
		Fstrong: int32(_PRI_MINSPACE_STRONG),
		Fweak:   int32(_PRI_MINSPACE_WEAK),
	},
	30: {
		Fobject: int32(_FC_CHARWIDTH_OBJECT),
		Fstrong: int32(_PRI_CHARWIDTH_STRONG),
		Fweak:   int32(_PRI_CHARWIDTH_WEAK),
	},
	31: {
		Fobject: int32(_FC_CHAR_HEIGHT_OBJECT),
		Fstrong: int32(_PRI_CHAR_HEIGHT_STRONG),
		Fweak:   int32(_PRI_CHAR_HEIGHT_WEAK),
	},
	32: {
		Fobject: int32(_FC_MATRIX_OBJECT),
		Fstrong: int32(_PRI_MATRIX_STRONG),
		Fweak:   int32(_PRI_MATRIX_WEAK),
	},
	33: {
		Fobject: int32(_FC_CHARSET_OBJECT),
		Fstrong: int32(_PRI_CHARSET_STRONG),
		Fweak:   int32(_PRI_CHARSET_WEAK),
	},
	34: {
		Fobject: int32(_FC_LANG_OBJECT),
		Fstrong: int32(_PRI_LANG_STRONG),
		Fweak:   int32(_PRI_LANG_WEAK),
	},
	35: {
		Fobject: int32(_FC_FONTVERSION_OBJECT),
		Fstrong: int32(_PRI_FONTVERSION_STRONG),
		Fweak:   int32(_PRI_FONTVERSION_WEAK),
	},
	36: {
		Fobject: int32(_FC_CAPABILITY_OBJECT),
		Fstrong: int32(_PRI_CAPABILITY_STRONG),
		Fweak:   int32(_PRI_CAPABILITY_WEAK),
	},
	37: {
		Fobject: int32(_FC_FONTFORMAT_OBJECT),
		Fstrong: int32(_PRI_FONTFORMAT_STRONG),
		Fweak:   int32(_PRI_FONTFORMAT_WEAK),
	},
	38: {
		Fobject: int32(_FC_EMBOLDEN_OBJECT),
		Fstrong: int32(_PRI_EMBOLDEN_STRONG),
		Fweak:   int32(_PRI_EMBOLDEN_WEAK),
	},
	39: {
		Fobject: int32(_FC_EMBEDDED_BITMAP_OBJECT),
		Fstrong: int32(_PRI_EMBEDDED_BITMAP_STRONG),
		Fweak:   int32(_PRI_EMBEDDED_BITMAP_WEAK),
	},
	40: {
		Fobject: int32(_FC_DECORATIVE_OBJECT),
		Fstrong: int32(_PRI_DECORATIVE_STRONG),
		Fweak:   int32(_PRI_DECORATIVE_WEAK),
	},
	41: {
		Fobject: int32(_FC_LCD_FILTER_OBJECT),
		Fstrong: int32(_PRI_LCD_FILTER_STRONG),
		Fweak:   int32(_PRI_LCD_FILTER_WEAK),
	},
	42: {
		Fobject: int32(_FC_NAMELANG_OBJECT),
		Fstrong: int32(_PRI_NAMELANG_STRONG),
		Fweak:   int32(_PRI_NAMELANG_WEAK),
	},
	43: {
		Fobject: int32(_FC_FONT_FEATURES_OBJECT),
		Fstrong: int32(_PRI_FONT_FEATURES_STRONG),
		Fweak:   int32(_PRI_FONT_FEATURES_WEAK),
	},
	44: {
		Fobject: int32(_FC_PRGNAME_OBJECT),
		Fstrong: int32(_PRI_PRGNAME_STRONG),
		Fweak:   int32(_PRI_PRGNAME_WEAK),
	},
	45: {
		Fobject: int32(_FC_HASH_OBJECT),
		Fstrong: int32(_PRI_HASH_STRONG),
		Fweak:   int32(_PRI_HASH_WEAK),
	},
	46: {
		Fobject: int32(_FC_POSTSCRIPT_NAME_OBJECT),
		Fstrong: int32(_PRI_POSTSCRIPT_NAME_STRONG),
		Fweak:   int32(_PRI_POSTSCRIPT_NAME_WEAK),
	},
	47: {
		Fobject: int32(_FC_COLOR_OBJECT),
		Fstrong: int32(_PRI_COLOR_STRONG),
		Fweak:   int32(_PRI_COLOR_WEAK),
	},
	48: {
		Fobject: int32(_FC_SYMBOL_OBJECT),
		Fstrong: int32(_PRI_SYMBOL_STRONG),
		Fweak:   int32(_PRI_SYMBOL_WEAK),
	},
	49: {
		Fobject: int32(_FC_FONT_VARIATIONS_OBJECT),
		Fstrong: int32(_PRI_FONT_VARIATIONS_STRONG),
		Fweak:   int32(_PRI_FONT_VARIATIONS_WEAK),
	},
	50: {
		Fobject: int32(_FC_VARIABLE_OBJECT),
		Fstrong: int32(_PRI_VARIABLE_STRONG),
		Fweak:   int32(_PRI_VARIABLE_WEAK),
	},
	51: {
		Fobject: int32(_FC_FONT_HAS_HINT_OBJECT),
		Fstrong: int32(_PRI_FONT_HAS_HINT_STRONG),
		Fweak:   int32(_PRI_FONT_HAS_HINT_WEAK),
	},
	52: {
		Fobject: int32(_FC_ORDER_OBJECT),
		Fstrong: int32(_PRI_ORDER_STRONG),
		Fweak:   int32(_PRI_ORDER_WEAK),
	},
}

func init() {
	p := unsafe.Pointer(&__FcMatchers)
	*(*uintptr)(unsafe.Add(p, 32)) = __ccgo_fp(_FcCompareFamily)
	*(*uintptr)(unsafe.Add(p, 80)) = __ccgo_fp(_FcCompareString)
	*(*uintptr)(unsafe.Add(p, 176)) = __ccgo_fp(_FcCompareNumber)
	*(*uintptr)(unsafe.Add(p, 200)) = __ccgo_fp(_FcCompareRange)
	*(*uintptr)(unsafe.Add(p, 224)) = __ccgo_fp(_FcCompareRange)
	*(*uintptr)(unsafe.Add(p, 248)) = __ccgo_fp(_FcCompareSize)
	*(*uintptr)(unsafe.Add(p, 296)) = __ccgo_fp(_FcCompareNumber)
	*(*uintptr)(unsafe.Add(p, 320)) = __ccgo_fp(_FcCompareNumber)
	*(*uintptr)(unsafe.Add(p, 344)) = __ccgo_fp(_FcCompareString)
	*(*uintptr)(unsafe.Add(p, 368)) = __ccgo_fp(_FcCompareBool)
	*(*uintptr)(unsafe.Add(p, 512)) = __ccgo_fp(_FcCompareFilename)
	*(*uintptr)(unsafe.Add(p, 560)) = __ccgo_fp(_FcCompareString)
	*(*uintptr)(unsafe.Add(p, 584)) = __ccgo_fp(_FcCompareBool)
	*(*uintptr)(unsafe.Add(p, 608)) = __ccgo_fp(_FcCompareBool)
	*(*uintptr)(unsafe.Add(p, 800)) = __ccgo_fp(_FcCompareCharSet)
	*(*uintptr)(unsafe.Add(p, 824)) = __ccgo_fp(_FcCompareLang)
	*(*uintptr)(unsafe.Add(p, 848)) = __ccgo_fp(_FcCompareNumber)
	*(*uintptr)(unsafe.Add(p, 896)) = __ccgo_fp(_FcCompareString)
	*(*uintptr)(unsafe.Add(p, 968)) = __ccgo_fp(_FcCompareBool)
	*(*uintptr)(unsafe.Add(p, 1112)) = __ccgo_fp(_FcComparePostScript)
	*(*uintptr)(unsafe.Add(p, 1136)) = __ccgo_fp(_FcCompareBool)
	*(*uintptr)(unsafe.Add(p, 1160)) = __ccgo_fp(_FcCompareBool)
	*(*uintptr)(unsafe.Add(p, 1208)) = __ccgo_fp(_FcCompareBool)
	*(*uintptr)(unsafe.Add(p, 1232)) = __ccgo_fp(_FcCompareBool)
	*(*uintptr)(unsafe.Add(p, 1256)) = __ccgo_fp(_FcCompareNumber)
}

func _FcObjectToMatcher(tls *libc.TLS, object TFcObject, include_lang TFcBool) (r uintptr) {
	if include_lang != 0 {
		switch object {
		case int32(_FC_FAMILYLANG_OBJECT):
			fallthrough
		case int32(_FC_STYLELANG_OBJECT):
			fallthrough
		case int32(_FC_FULLNAMELANG_OBJECT):
			object = int32(_FC_LANG_OBJECT)
			break
		}
	}
	if object > int32(_FC_ONE_AFTER_MAX_BASE_OBJECT)-libc.Int32FromInt32(1) || !(__FcMatchers[object].Fcompare != 0) || __FcMatchers[object].Fstrong == -int32(1) || __FcMatchers[object].Fweak == -int32(1) {
		return libc.UintptrFromInt32(0)
	}
	return uintptr(unsafe.Pointer(&__FcMatchers)) + uintptr(object)*24
}

func _FcCompareValueList(tls *libc.TLS, object TFcObject, match uintptr, v1orig TFcValueListPtr, v2orig TFcValueListPtr, bestValue uintptr, value uintptr, n uintptr, result uintptr) (r TFcBool) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var best, bestStrong, bestWeak, v float64
	var j, k, pos, strong, weak, v3 int32
	var v1, v2 TFcValueListPtr
	var v4, v5 uintptr
	var _ /* matchValue at bp+0 */ TFcValue
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = best, bestStrong, bestWeak, j, k, pos, strong, v, v1, v2, weak, v3, v4, v5
	pos = 0
	if !(match != 0) {
		if bestValue != 0 {
			*(*TFcValue)(unsafe.Pointer(bestValue)) = XFcValueCanonicalize(tls, v2orig+8)
		}
		if n != 0 {
			*(*int32)(unsafe.Pointer(n)) = 0
		}
		return int32(m_FcTrue)
	}
	weak = (*TFcMatcher)(unsafe.Pointer(match)).Fweak
	strong = (*TFcMatcher)(unsafe.Pointer(match)).Fstrong
	best = float64(1e+99)
	bestStrong = float64(1e+99)
	bestWeak = float64(1e+99)
	v1 = v1orig
	j = libc.Int32FromInt32(0)
	for {
		if !(v1 != 0) {
			break
		}
		v2 = v2orig
		k = libc.Int32FromInt32(0)
		for {
			if !(v2 != 0) {
				break
			}
			v = (*(*func(*libc.TLS, uintptr, uintptr, uintptr) float64)(unsafe.Pointer(&struct{ uintptr }{(*TFcMatcher)(unsafe.Pointer(match)).Fcompare})))(tls, v1+8, v2+8, bp)
			if v < libc.Float64FromInt32(0) {
				*(*TFcResult)(unsafe.Pointer(result)) = int32(_FcResultTypeMismatch)
				return m_FcFalse
			}
			if (*T_FcValueList)(unsafe.Pointer(v2)).Fvalue.Ftype1 == int32(_FcTypeString) {
				v3 = int32(1)
			} else {
				v3 = 0
			}
			v = float64(v*libc.Float64FromInt32(1000)) + float64(j*int32(100)) + float64(k*v3)
			if v < best {
				if bestValue != 0 {
					*(*TFcValue)(unsafe.Pointer(bestValue)) = *(*TFcValue)(unsafe.Pointer(bp))
				}
				best = v
				pos = k
			}
			if weak == strong {
				/* found the best possible match */
				if best < libc.Float64FromInt32(1000) {
					goto done
				}
			} else {
				if (*T_FcValueList)(unsafe.Pointer(v1)).Fbinding == int32(_FcValueBindingStrong) {
					if v < bestStrong {
						bestStrong = v
					}
				} else {
					if v < bestWeak {
						bestWeak = v
					}
				}
			}
			goto _2
		_2:
			;
			if int64((*T_FcValueList)(unsafe.Pointer(v2)).Fnext)&int64(1) != 0 {
				v4 = uintptr(int64(v2) + int64((*T_FcValueList)(unsafe.Pointer(v2)).Fnext)&int64(^libc.Int32FromInt32(1)))
			} else {
				v4 = (*T_FcValueList)(unsafe.Pointer(v2)).Fnext
			}
			v2 = v4
			k++
		}
		goto _1
	_1:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(v1)).Fnext)&int64(1) != 0 {
			v5 = uintptr(int64(v1) + int64((*T_FcValueList)(unsafe.Pointer(v1)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v5 = (*T_FcValueList)(unsafe.Pointer(v1)).Fnext
		}
		v1 = v5
		j++
	}
	goto done
done:
	;
	if XFcDebugVal&int32(m_FC_DBG_MATCHV) != 0 {
		libc.Xprintf(tls, __ccgo_ts+6030, libc.VaList(bp+24, XFcObjectName(tls, object), best))
		XFcValueListPrint(tls, v1orig)
		libc.Xprintf(tls, __ccgo_ts+6039, 0)
		XFcValueListPrint(tls, v2orig)
		libc.Xprintf(tls, __ccgo_ts+1266, 0)
	}
	if value != 0 {
		if weak == strong {
			*(*float64)(unsafe.Pointer(value + uintptr(strong)*8)) += best
		} else {
			*(*float64)(unsafe.Pointer(value + uintptr(weak)*8)) += bestWeak
			*(*float64)(unsafe.Pointer(value + uintptr(strong)*8)) += bestStrong
		}
	}
	if n != 0 {
		*(*int32)(unsafe.Pointer(n)) = pos
	}
	return int32(m_FcTrue)
}

// C documentation
//
//	/* The bulk of the time in FcFontMatch and FcFontSort goes to
//	 * walking long lists of family names. We speed this up with a
//	 * hash table.
//	 */
type TFamilyEntry = struct {
	Fstrong_value float64
	Fweak_value   float64
}

type TFcCompareData = struct {
	Ffamily_hash uintptr
}

func _FcCompareDataClear(tls *libc.TLS, data uintptr) {
	XFcHashTableDestroy(tls, (*TFcCompareData)(unsafe.Pointer(data)).Ffamily_hash)
}

func _FcCompareDataInit(tls *libc.TLS, pat uintptr, data uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var elt, key, table, v2, v3, v4 uintptr
	var i int32
	var l TFcValueListPtr
	var _ /* e at bp+0 */ uintptr
	_, _, _, _, _, _, _, _ = elt, i, key, l, table, v2, v3, v4
	table = XFcHashTableCreate(tls, __ccgo_fp(XFcStrHashIgnoreBlanksAndCase), __ccgo_fp(XFcStrCmpIgnoreBlanksAndCase), libc.UintptrFromInt32(0), libc.UintptrFromInt32(0), libc.UintptrFromInt32(0), __ccgo_fp(libc.Xfree))
	elt = XFcPatternObjectFindElt(tls, pat, int32(_FC_FAMILY_OBJECT))
	if elt != 0 {
		if int64((*TFcPatternElt)(unsafe.Pointer(elt)).Fvalues)&int64(1) != 0 {
			v2 = uintptr(int64(elt) + int64((*TFcPatternElt)(unsafe.Pointer(elt)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*TFcPatternElt)(unsafe.Pointer(elt)).Fvalues
		}
		l = v2
		i = libc.Int32FromInt32(0)
		for {
			if !(l != 0) {
				break
			}
			if int64(*(*uintptr)(unsafe.Pointer(l + 8 + 8)))&int64(1) != 0 {
				v3 = uintptr(Tintptr_t(l+8) + int64(*(*uintptr)(unsafe.Pointer(l + 8 + 8)))&int64(^libc.Int32FromInt32(1)))
			} else {
				v3 = *(*uintptr)(unsafe.Pointer(l + 8 + 8))
			}
			key = v3
			if !(XFcHashTableFind(tls, table, key, bp) != 0) {
				*(*uintptr)(unsafe.Pointer(bp)) = libc.Xmalloc(tls, uint64(16))
				(*TFamilyEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fstrong_value = float64(1e+99)
				(*TFamilyEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fweak_value = float64(1e+99)
				XFcHashTableAdd(tls, table, key, *(*uintptr)(unsafe.Pointer(bp)))
			}
			if (*T_FcValueList)(unsafe.Pointer(l)).Fbinding == int32(_FcValueBindingWeak) {
				if float64(i) < (*TFamilyEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fweak_value {
					(*TFamilyEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fweak_value = float64(i)
				}
			} else {
				if float64(i) < (*TFamilyEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fstrong_value {
					(*TFamilyEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fstrong_value = float64(i)
				}
			}
			goto _1
		_1:
			;
			if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
				v4 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
			} else {
				v4 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
			}
			l = v4
			i++
		}
	}
	(*TFcCompareData)(unsafe.Pointer(data)).Ffamily_hash = table
}

func _FcCompareFamilies(tls *libc.TLS, pat uintptr, v1orig TFcValueListPtr, fnt uintptr, v2orig TFcValueListPtr, value uintptr, result uintptr, table uintptr) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var key, v21, v3 uintptr
	var strong_value, weak_value float64
	var v2 TFcValueListPtr
	var _ /* e at bp+0 */ uintptr
	_, _, _, _, _, _ = key, strong_value, v2, weak_value, v21, v3
	strong_value = float64(1e+99)
	weak_value = float64(1e+99)
	v2 = v2orig
	for {
		if !(v2 != 0) {
			break
		}
		if int64(*(*uintptr)(unsafe.Pointer(v2 + 8 + 8)))&int64(1) != 0 {
			v21 = uintptr(Tintptr_t(v2+8) + int64(*(*uintptr)(unsafe.Pointer(v2 + 8 + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v21 = *(*uintptr)(unsafe.Pointer(v2 + 8 + 8))
		}
		key = v21
		if XFcHashTableFind(tls, table, key, bp) != 0 {
			if (*TFamilyEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fstrong_value < strong_value {
				strong_value = (*TFamilyEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fstrong_value
			}
			if (*TFamilyEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fweak_value < weak_value {
				weak_value = (*TFamilyEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fweak_value
			}
		}
		goto _1
	_1:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(v2)).Fnext)&int64(1) != 0 {
			v3 = uintptr(int64(v2) + int64((*T_FcValueList)(unsafe.Pointer(v2)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v3 = (*T_FcValueList)(unsafe.Pointer(v2)).Fnext
		}
		v2 = v3
	}
	if XFcDebugVal&int32(m_FC_DBG_MATCHV) != 0 {
		libc.Xprintf(tls, __ccgo_ts+6042, libc.VaList(bp+16, XFcObjectName(tls, int32(_FC_FAMILY_OBJECT)), strong_value))
		XFcValueListPrint(tls, v1orig)
		libc.Xprintf(tls, __ccgo_ts+6039, 0)
		XFcValueListPrint(tls, v2orig)
		libc.Xprintf(tls, __ccgo_ts+1266, 0)
	}
	*(*float64)(unsafe.Pointer(value + uintptr(_PRI_FAMILY_STRONG)*8)) = strong_value
	*(*float64)(unsafe.Pointer(value + uintptr(_PRI_FAMILY_WEAK)*8)) = weak_value
	return int32(m_FcTrue)
}

/*
 * Return a value indicating the distance between the two lists of
 * values
 */

func _FcCompare(tls *libc.TLS, pat uintptr, fnt uintptr, value uintptr, result uintptr, data uintptr) (r TFcBool) {
	var elt_i1, elt_i2, match, v2, v3, v4, v5 uintptr
	var i, i1, i2 int32
	_, _, _, _, _, _, _, _, _, _ = elt_i1, elt_i2, i, i1, i2, match, v2, v3, v4, v5
	i = 0
	for {
		if !(i < int32(_PRI_END)) {
			break
		}
		*(*float64)(unsafe.Pointer(value + uintptr(i)*8)) = float64(0)
		goto _1
	_1:
		;
		i++
	}
	i1 = 0
	i2 = 0
	for i1 < (*TFcPattern)(unsafe.Pointer(pat)).Fnum && i2 < (*TFcPattern)(unsafe.Pointer(fnt)).Fnum {
		elt_i1 = uintptr(int64(pat)+(*TFcPattern)(unsafe.Pointer(pat)).Felts_offset) + uintptr(i1)*16
		elt_i2 = uintptr(int64(fnt)+(*TFcPattern)(unsafe.Pointer(fnt)).Felts_offset) + uintptr(i2)*16
		i = (*TFcPatternElt)(unsafe.Pointer(elt_i1)).Fobject - (*TFcPatternElt)(unsafe.Pointer(elt_i2)).Fobject
		if i > 0 {
			i2++
		} else {
			if i < 0 {
				i1++
			} else {
				if (*TFcPatternElt)(unsafe.Pointer(elt_i1)).Fobject == int32(_FC_FAMILY_OBJECT) && (*TFcCompareData)(unsafe.Pointer(data)).Ffamily_hash != 0 {
					if int64((*TFcPatternElt)(unsafe.Pointer(elt_i1)).Fvalues)&int64(1) != 0 {
						v2 = uintptr(int64(elt_i1) + int64((*TFcPatternElt)(unsafe.Pointer(elt_i1)).Fvalues)&int64(^libc.Int32FromInt32(1)))
					} else {
						v2 = (*TFcPatternElt)(unsafe.Pointer(elt_i1)).Fvalues
					}
					if int64((*TFcPatternElt)(unsafe.Pointer(elt_i2)).Fvalues)&int64(1) != 0 {
						v3 = uintptr(int64(elt_i2) + int64((*TFcPatternElt)(unsafe.Pointer(elt_i2)).Fvalues)&int64(^libc.Int32FromInt32(1)))
					} else {
						v3 = (*TFcPatternElt)(unsafe.Pointer(elt_i2)).Fvalues
					}
					if !(_FcCompareFamilies(tls, pat, v2, fnt, v3, value, result, (*TFcCompareData)(unsafe.Pointer(data)).Ffamily_hash) != 0) {
						return m_FcFalse
					}
					i1++
					i2++
				} else {
					match = _FcObjectToMatcher(tls, (*TFcPatternElt)(unsafe.Pointer(elt_i1)).Fobject, m_FcFalse)
					if int64((*TFcPatternElt)(unsafe.Pointer(elt_i1)).Fvalues)&int64(1) != 0 {
						v4 = uintptr(int64(elt_i1) + int64((*TFcPatternElt)(unsafe.Pointer(elt_i1)).Fvalues)&int64(^libc.Int32FromInt32(1)))
					} else {
						v4 = (*TFcPatternElt)(unsafe.Pointer(elt_i1)).Fvalues
					}
					if int64((*TFcPatternElt)(unsafe.Pointer(elt_i2)).Fvalues)&int64(1) != 0 {
						v5 = uintptr(int64(elt_i2) + int64((*TFcPatternElt)(unsafe.Pointer(elt_i2)).Fvalues)&int64(^libc.Int32FromInt32(1)))
					} else {
						v5 = (*TFcPatternElt)(unsafe.Pointer(elt_i2)).Fvalues
					}
					if !(_FcCompareValueList(tls, (*TFcPatternElt)(unsafe.Pointer(elt_i1)).Fobject, match, v4, v5, libc.UintptrFromInt32(0), value, libc.UintptrFromInt32(0), result) != 0) {
						return m_FcFalse
					}
					i1++
					i2++
				}
			}
		}
	}
	return int32(m_FcTrue)
}

func XFcFontRenderPrepare(tls *libc.TLS, config uintptr, pat uintptr, font uintptr) (r uintptr) {
	bp := tls.Alloc(352)
	defer tls.Free(352)
	var binding TFcValueBinding
	var fe, fel, func1, match, match1, new1, pe, pel, tag, v10, v11, v12, v13, v14, v15, v17, v19, v2, v3, v5, v6, v7, v8, v9 uintptr
	var i, j int32
	var l1, l11, l2, l21, ll, ln TFcValueListPtr
	var num float64
	var v16 bool
	var _ /* n at bp+176 */ int32
	var _ /* result at bp+16 */ TFcResult
	var _ /* temp at bp+180 */ [128]TFcChar8
	var _ /* v at bp+0 */ TFcValue
	var _ /* variable at bp+20 */ TFcBool
	var _ /* variations at bp+24 */ TFcStrBuf
	var _ /* vars at bp+312 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = binding, fe, fel, func1, i, j, l1, l11, l2, l21, ll, ln, match, match1, new1, num, pe, pel, tag, v10, v11, v12, v13, v14, v15, v16, v17, v19, v2, v3, v5, v6, v7, v8, v9
	*(*TFcBool)(unsafe.Pointer(bp + 20)) = m_FcFalse
	XFcPatternObjectGetBool(tls, font, int32(_FC_VARIABLE_OBJECT), 0, bp+20)
	if *(*TFcBool)(unsafe.Pointer(bp + 20)) != 0 {
		XFcStrBufInit(tls, bp+24, libc.UintptrFromInt32(0), 0)
	}
	new1 = XFcPatternCreate(tls)
	if !(new1 != 0) {
		return libc.UintptrFromInt32(0)
	}
	i = 0
	for {
		if !(i < (*TFcPattern)(unsafe.Pointer(font)).Fnum) {
			break
		}
		fe = uintptr(int64(font)+(*TFcPattern)(unsafe.Pointer(font)).Felts_offset) + uintptr(i)*16
		if (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject == int32(_FC_FAMILYLANG_OBJECT) || (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject == int32(_FC_STYLELANG_OBJECT) || (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject == int32(_FC_FULLNAMELANG_OBJECT) {
			/* ignore those objects. we need to deal with them
			 * another way */
			goto _1
		}
		if (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject == int32(_FC_FAMILY_OBJECT) || (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject == int32(_FC_STYLE_OBJECT) || (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject == int32(_FC_FULLNAME_OBJECT) {
			fel = XFcPatternObjectFindElt(tls, font, (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject+int32(1))
			pel = XFcPatternObjectFindElt(tls, pat, (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject+int32(1))
			if fel != 0 && pel != 0 {
				/* The font has name languages, and pattern asks for specific language(s).
				 * Match on language and and prefer that result.
				 * Note:  Currently the code only give priority to first matching language.
				 */
				*(*int32)(unsafe.Pointer(bp + 176)) = int32(1)
				ln = libc.UintptrFromInt32(0)
				ll = libc.UintptrFromInt32(0)
				match = _FcObjectToMatcher(tls, (*TFcPatternElt)(unsafe.Pointer(pel)).Fobject, int32(m_FcTrue))
				if int64((*TFcPatternElt)(unsafe.Pointer(pel)).Fvalues)&int64(1) != 0 {
					v2 = uintptr(int64(pel) + int64((*TFcPatternElt)(unsafe.Pointer(pel)).Fvalues)&int64(^libc.Int32FromInt32(1)))
				} else {
					v2 = (*TFcPatternElt)(unsafe.Pointer(pel)).Fvalues
				}
				if int64((*TFcPatternElt)(unsafe.Pointer(fel)).Fvalues)&int64(1) != 0 {
					v3 = uintptr(int64(fel) + int64((*TFcPatternElt)(unsafe.Pointer(fel)).Fvalues)&int64(^libc.Int32FromInt32(1)))
				} else {
					v3 = (*TFcPatternElt)(unsafe.Pointer(fel)).Fvalues
				}
				if !(_FcCompareValueList(tls, (*TFcPatternElt)(unsafe.Pointer(pel)).Fobject, match, v2, v3, libc.UintptrFromInt32(0), libc.UintptrFromInt32(0), bp+176, bp+16) != 0) {
					XFcPatternDestroy(tls, new1)
					return libc.UintptrFromInt32(0)
				}
				j = 0
				if int64((*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues)&int64(1) != 0 {
					v5 = uintptr(int64(fe) + int64((*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues)&int64(^libc.Int32FromInt32(1)))
				} else {
					v5 = (*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues
				}
				l1 = v5
				if int64((*TFcPatternElt)(unsafe.Pointer(fel)).Fvalues)&int64(1) != 0 {
					v6 = uintptr(int64(fel) + int64((*TFcPatternElt)(unsafe.Pointer(fel)).Fvalues)&int64(^libc.Int32FromInt32(1)))
				} else {
					v6 = (*TFcPatternElt)(unsafe.Pointer(fel)).Fvalues
				}
				l2 = v6
				for {
					if !(l1 != libc.UintptrFromInt32(0) || l2 != libc.UintptrFromInt32(0)) {
						break
					}
					binding = int32(_FcValueBindingEnd)
					if j == *(*int32)(unsafe.Pointer(bp + 176)) {
						binding = int32(_FcValueBindingStrong)
						func1 = __ccgo_fp(XFcValueListPrepend)
					} else {
						func1 = __ccgo_fp(XFcValueListAppend)
					}
					if l1 != 0 {
						ln = (*(*func(*libc.TLS, TFcValueListPtr, TFcValue, TFcValueBinding) TFcValueListPtr)(unsafe.Pointer(&struct{ uintptr }{func1})))(tls, ln, XFcValueCanonicalize(tls, l1+8), (*T_FcValueList)(unsafe.Pointer(l1)).Fbinding)
					}
					if l2 != 0 {
						if binding == int32(_FcValueBindingEnd) {
							binding = (*T_FcValueList)(unsafe.Pointer(l2)).Fbinding
						}
						ll = (*(*func(*libc.TLS, TFcValueListPtr, TFcValue, TFcValueBinding) TFcValueListPtr)(unsafe.Pointer(&struct{ uintptr }{func1})))(tls, ll, XFcValueCanonicalize(tls, l2+8), binding)
					}
					goto _4
				_4:
					;
					j++
					if l1 != 0 {
						if int64((*T_FcValueList)(unsafe.Pointer(l1)).Fnext)&int64(1) != 0 {
							v8 = uintptr(int64(l1) + int64((*T_FcValueList)(unsafe.Pointer(l1)).Fnext)&int64(^libc.Int32FromInt32(1)))
						} else {
							v8 = (*T_FcValueList)(unsafe.Pointer(l1)).Fnext
						}
						v7 = v8
					} else {
						v7 = libc.UintptrFromInt32(0)
					}
					l1 = v7
					if l2 != 0 {
						if int64((*T_FcValueList)(unsafe.Pointer(l2)).Fnext)&int64(1) != 0 {
							v10 = uintptr(int64(l2) + int64((*T_FcValueList)(unsafe.Pointer(l2)).Fnext)&int64(^libc.Int32FromInt32(1)))
						} else {
							v10 = (*T_FcValueList)(unsafe.Pointer(l2)).Fnext
						}
						v9 = v10
					} else {
						v9 = libc.UintptrFromInt32(0)
					}
					l2 = v9
				}
				XFcPatternObjectListAdd(tls, new1, (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject, ln, m_FcFalse)
				XFcPatternObjectListAdd(tls, new1, (*TFcPatternElt)(unsafe.Pointer(fel)).Fobject, ll, m_FcFalse)
				goto _1
			} else {
				if fel != 0 {
					if int64((*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues)&int64(1) != 0 {
						v11 = uintptr(int64(fe) + int64((*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues)&int64(^libc.Int32FromInt32(1)))
					} else {
						v11 = (*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues
					}
					l11 = XFcValueListDuplicate(tls, v11)
					if int64((*TFcPatternElt)(unsafe.Pointer(fel)).Fvalues)&int64(1) != 0 {
						v12 = uintptr(int64(fel) + int64((*TFcPatternElt)(unsafe.Pointer(fel)).Fvalues)&int64(^libc.Int32FromInt32(1)))
					} else {
						v12 = (*TFcPatternElt)(unsafe.Pointer(fel)).Fvalues
					}
					l21 = XFcValueListDuplicate(tls, v12)
					XFcPatternObjectListAdd(tls, new1, (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject, l11, m_FcFalse)
					XFcPatternObjectListAdd(tls, new1, (*TFcPatternElt)(unsafe.Pointer(fel)).Fobject, l21, m_FcFalse)
					goto _1
				}
			}
		}
		pe = XFcPatternObjectFindElt(tls, pat, (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject)
		if pe != 0 {
			match1 = _FcObjectToMatcher(tls, (*TFcPatternElt)(unsafe.Pointer(pe)).Fobject, m_FcFalse)
			if int64((*TFcPatternElt)(unsafe.Pointer(pe)).Fvalues)&int64(1) != 0 {
				v13 = uintptr(int64(pe) + int64((*TFcPatternElt)(unsafe.Pointer(pe)).Fvalues)&int64(^libc.Int32FromInt32(1)))
			} else {
				v13 = (*TFcPatternElt)(unsafe.Pointer(pe)).Fvalues
			}
			if int64((*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues)&int64(1) != 0 {
				v14 = uintptr(int64(fe) + int64((*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues)&int64(^libc.Int32FromInt32(1)))
			} else {
				v14 = (*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues
			}
			if !(_FcCompareValueList(tls, (*TFcPatternElt)(unsafe.Pointer(pe)).Fobject, match1, v13, v14, bp, libc.UintptrFromInt32(0), libc.UintptrFromInt32(0), bp+16) != 0) {
				XFcPatternDestroy(tls, new1)
				return libc.UintptrFromInt32(0)
			}
			XFcPatternObjectAdd(tls, new1, (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject, *(*TFcValue)(unsafe.Pointer(bp)), m_FcFalse)
			/* Set font-variations settings for standard axes in variable fonts. */
			if v16 = *(*TFcBool)(unsafe.Pointer(bp + 20)) != 0; v16 {
				if int64((*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues)&int64(1) != 0 {
					v15 = uintptr(int64(fe) + int64((*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues)&int64(^libc.Int32FromInt32(1)))
				} else {
					v15 = (*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues
				}
			}
			if v16 && (*TFcValueList)(unsafe.Pointer(v15)).Fvalue.Ftype1 == int32(_FcTypeRange) && ((*TFcPatternElt)(unsafe.Pointer(fe)).Fobject == int32(_FC_WEIGHT_OBJECT) || (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject == int32(_FC_WIDTH_OBJECT) || (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject == int32(_FC_SIZE_OBJECT)) {
				tag = __ccgo_ts + 6050
				num = *(*float64)(unsafe.Pointer(bp + 8))
				if (*(*TFcStrBuf)(unsafe.Pointer(bp + 24))).Flen1 != 0 {
					XFcStrBufChar(tls, bp+24, uint8(','))
				}
				switch (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject {
				case int32(_FC_WEIGHT_OBJECT):
					tag = __ccgo_ts + 6055
					num = float64(XFcWeightToOpenType(tls, int32(num)))
				case int32(_FC_WIDTH_OBJECT):
					tag = __ccgo_ts + 6060
				case int32(_FC_SIZE_OBJECT):
					tag = __ccgo_ts + 6065
					break
				}
				libc.X__builtin___sprintf_chk(tls, bp+180, 0, ^t__predefined_size_t(0), __ccgo_ts+6070, libc.VaList(bp+328, tag, num))
				XFcStrBufString(tls, bp+24, bp+180)
			}
		} else {
			if int64((*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues)&int64(1) != 0 {
				v17 = uintptr(int64(fe) + int64((*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues)&int64(^libc.Int32FromInt32(1)))
			} else {
				v17 = (*TFcPatternElt)(unsafe.Pointer(fe)).Fvalues
			}
			XFcPatternObjectListAdd(tls, new1, (*TFcPatternElt)(unsafe.Pointer(fe)).Fobject, XFcValueListDuplicate(tls, v17), int32(m_FcTrue))
		}
		goto _1
	_1:
		;
		i++
	}
	i = 0
	for {
		if !(i < (*TFcPattern)(unsafe.Pointer(pat)).Fnum) {
			break
		}
		pe = uintptr(int64(pat)+(*TFcPattern)(unsafe.Pointer(pat)).Felts_offset) + uintptr(i)*16
		fe = XFcPatternObjectFindElt(tls, font, (*TFcPatternElt)(unsafe.Pointer(pe)).Fobject)
		if !(fe != 0) && (*TFcPatternElt)(unsafe.Pointer(pe)).Fobject != int32(_FC_FAMILYLANG_OBJECT) && (*TFcPatternElt)(unsafe.Pointer(pe)).Fobject != int32(_FC_STYLELANG_OBJECT) && (*TFcPatternElt)(unsafe.Pointer(pe)).Fobject != int32(_FC_FULLNAMELANG_OBJECT) {
			if int64((*TFcPatternElt)(unsafe.Pointer(pe)).Fvalues)&int64(1) != 0 {
				v19 = uintptr(int64(pe) + int64((*TFcPatternElt)(unsafe.Pointer(pe)).Fvalues)&int64(^libc.Int32FromInt32(1)))
			} else {
				v19 = (*TFcPatternElt)(unsafe.Pointer(pe)).Fvalues
			}
			XFcPatternObjectListAdd(tls, new1, (*TFcPatternElt)(unsafe.Pointer(pe)).Fobject, XFcValueListDuplicate(tls, v19), m_FcFalse)
		}
		goto _18
	_18:
		;
		i++
	}
	if *(*TFcBool)(unsafe.Pointer(bp + 20)) != 0 && (*(*TFcStrBuf)(unsafe.Pointer(bp + 24))).Flen1 != 0 {
		*(*uintptr)(unsafe.Pointer(bp + 312)) = libc.UintptrFromInt32(0)
		if XFcPatternObjectGetString(tls, new1, int32(_FC_FONT_VARIATIONS_OBJECT), 0, bp+312) == int32(_FcResultMatch) {
			XFcStrBufChar(tls, bp+24, uint8(','))
			XFcStrBufString(tls, bp+24, *(*uintptr)(unsafe.Pointer(bp + 312)))
			XFcPatternObjectDel(tls, new1, int32(_FC_FONT_VARIATIONS_OBJECT))
		}
		XFcPatternObjectAddString(tls, new1, int32(_FC_FONT_VARIATIONS_OBJECT), XFcStrBufDoneStatic(tls, bp+24))
		XFcStrBufDestroy(tls, bp+24)
	}
	XFcConfigSubstituteWithPat(tls, config, new1, pat, int32(_FcMatchFont))
	return new1
}

func _FcFontSetMatchInternal(tls *libc.TLS, sets uintptr, nsets int32, p uintptr, result uintptr) (r uintptr) {
	bp := tls.Alloc(240)
	defer tls.Free(240)
	var best, elt, env, match, os, p1, pat, s, s1, ss, x, v11, v12, v14, v15, v8 uintptr
	var bestscore [27]float64
	var binding TFcValueBinding
	var f, i, set int32
	var f1 TFcBool
	var l, ll, new1, t, v10 TFcValueListPtr
	var len1 Tsize_t
	var v TFcValue
	var _ /* data at bp+216 */ TFcCompareData
	var _ /* score at bp+0 */ [27]float64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = best, bestscore, binding, elt, env, f, f1, i, l, len1, ll, match, new1, os, p1, pat, s, s1, set, ss, t, v, x, v10, v11, v12, v14, v15, v8
	pat = libc.UintptrFromInt32(0)
	i = 0
	for {
		if !(i < int32(_PRI_END)) {
			break
		}
		bestscore[i] = libc.Float64FromInt32(0)
		goto _1
	_1:
		;
		i++
	}
	best = uintptr(0)
	if XFcDebugVal&int32(m_FC_DBG_MATCH) != 0 {
		libc.Xprintf(tls, __ccgo_ts+6077, 0)
		XFcPatternPrint(tls, p)
	}
	_FcCompareDataInit(tls, p, bp+216)
	set = 0
	for {
		if !(set < nsets) {
			break
		}
		s = *(*uintptr)(unsafe.Pointer(sets + uintptr(set)*8))
		if !(s != 0) {
			goto _2
		}
		f = 0
		for {
			if !(f < (*TFcFontSet)(unsafe.Pointer(s)).Fnfont) {
				break
			}
			if XFcDebugVal&int32(m_FC_DBG_MATCHV) != 0 {
				libc.Xprintf(tls, __ccgo_ts+2692, libc.VaList(bp+232, f))
				XFcPatternPrint(tls, *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(s)).Ffonts + uintptr(f)*8)))
			}
			if !(_FcCompare(tls, p, *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(s)).Ffonts + uintptr(f)*8)), bp, result, bp+216) != 0) {
				_FcCompareDataClear(tls, bp+216)
				return uintptr(0)
			}
			if XFcDebugVal&int32(m_FC_DBG_MATCHV) != 0 {
				libc.Xprintf(tls, __ccgo_ts+6084, 0)
				i = 0
				for {
					if !(i < int32(_PRI_END)) {
						break
					}
					libc.Xprintf(tls, __ccgo_ts+6090, libc.VaList(bp+232, (*(*[27]float64)(unsafe.Pointer(bp)))[i]))
					goto _4
				_4:
					;
					i++
				}
				libc.Xprintf(tls, __ccgo_ts+1266, 0)
			}
			i = 0
			for {
				if !(i < int32(_PRI_END)) {
					break
				}
				if best != 0 && bestscore[i] < (*(*[27]float64)(unsafe.Pointer(bp)))[i] {
					break
				}
				if !(best != 0) || (*(*[27]float64)(unsafe.Pointer(bp)))[i] < bestscore[i] {
					i = 0
					for {
						if !(i < int32(_PRI_END)) {
							break
						}
						bestscore[i] = (*(*[27]float64)(unsafe.Pointer(bp)))[i]
						goto _6
					_6:
						;
						i++
					}
					best = *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(s)).Ffonts + uintptr(f)*8))
					break
				}
				goto _5
			_5:
				;
				i++
			}
			goto _3
		_3:
			;
			f++
		}
		goto _2
	_2:
		;
		set++
	}
	_FcCompareDataClear(tls, bp+216)
	/* Update the binding according to the score to indicate how exactly values matches on. */
	if best != 0 {
		pat = XFcPatternCreate(tls)
		elt = uintptr(int64(best) + (*TFcPattern)(unsafe.Pointer(best)).Felts_offset)
		i = 0
		for {
			if !(i < XFcPatternObjectCount(tls, best)) {
				break
			}
			match = _FcObjectToMatcher(tls, (*(*TFcPatternElt)(unsafe.Pointer(elt + uintptr(i)*16))).Fobject, m_FcFalse)
			if int64((*TFcPatternElt)(unsafe.Pointer(elt+uintptr(i)*16)).Fvalues)&int64(1) != 0 {
				v8 = uintptr(Tintptr_t(elt+uintptr(i)*16) + int64((*TFcPatternElt)(unsafe.Pointer(elt+uintptr(i)*16)).Fvalues)&int64(^libc.Int32FromInt32(1)))
			} else {
				v8 = (*TFcPatternElt)(unsafe.Pointer(elt + uintptr(i)*16)).Fvalues
			}
			l = v8
			if !(match != 0) {
				XFcPatternObjectListAdd(tls, pat, (*(*TFcPatternElt)(unsafe.Pointer(elt + uintptr(i)*16))).Fobject, XFcValueListDuplicate(tls, l), int32(m_FcTrue))
			} else {
				binding = int32(_FcValueBindingWeak)
				new1 = libc.UintptrFromInt32(0)
				t = libc.UintptrFromInt32(0)
				/* If the value was matched exactly, update the binding to Strong. */
				if bestscore[(*TFcMatcher)(unsafe.Pointer(match)).Fstrong] < libc.Float64FromInt32(1000) {
					binding = int32(_FcValueBindingStrong)
				}
				ll = l
				for {
					if !(ll != libc.UintptrFromInt32(0)) {
						break
					}
					if !(new1 != 0) {
						v10 = XFcValueListCreate(tls)
						new1 = v10
						t = v10
					} else {
						(*T_FcValueList)(unsafe.Pointer(t)).Fnext = XFcValueListCreate(tls)
						if int64((*T_FcValueList)(unsafe.Pointer(t)).Fnext)&int64(1) != 0 {
							v11 = uintptr(int64(t) + int64((*T_FcValueList)(unsafe.Pointer(t)).Fnext)&int64(^libc.Int32FromInt32(1)))
						} else {
							v11 = (*T_FcValueList)(unsafe.Pointer(t)).Fnext
						}
						t = v11
					}
					v = XFcValueCanonicalize(tls, ll+8)
					(*T_FcValueList)(unsafe.Pointer(t)).Fvalue = XFcValueSave(tls, v)
					(*T_FcValueList)(unsafe.Pointer(t)).Fbinding = binding
					(*T_FcValueList)(unsafe.Pointer(t)).Fnext = libc.UintptrFromInt32(0)
					goto _9
				_9:
					;
					if int64((*T_FcValueList)(unsafe.Pointer(ll)).Fnext)&int64(1) != 0 {
						v12 = uintptr(int64(ll) + int64((*T_FcValueList)(unsafe.Pointer(ll)).Fnext)&int64(^libc.Int32FromInt32(1)))
					} else {
						v12 = (*T_FcValueList)(unsafe.Pointer(ll)).Fnext
					}
					ll = v12
				}
				XFcPatternObjectListAdd(tls, pat, (*(*TFcPatternElt)(unsafe.Pointer(elt + uintptr(i)*16))).Fobject, new1, int32(m_FcTrue))
			}
			goto _7
		_7:
			;
			i++
		}
	}
	if XFcDebugVal&int32(m_FC_DBG_MATCH) != 0 {
		libc.Xprintf(tls, __ccgo_ts+6094, 0)
		i = 0
		for {
			if !(i < int32(_PRI_END)) {
				break
			}
			libc.Xprintf(tls, __ccgo_ts+6090, libc.VaList(bp+232, bestscore[i]))
			goto _13
		_13:
			;
			i++
		}
		libc.Xprintf(tls, __ccgo_ts+1266, 0)
		XFcPatternPrint(tls, pat)
	}
	if XFcDebugVal&int32(m_FC_DBG_MATCH2) != 0 {
		env = libc.Xgetenv(tls, __ccgo_ts+6105)
		os = libc.UintptrFromInt32(0)
		if env != 0 {
			f1 = int32(m_FcTrue)
			v14 = libc.Xstrdup(tls, env)
			s1 = v14
			ss = v14
			os = XFcObjectSetCreate(tls)
			for f1 != 0 {
				v15 = libc.Xstrchr(tls, s1, int32(','))
				p1 = v15
				if !(v15 != 0) {
					f1 = m_FcFalse
					len1 = libc.Xstrlen(tls, s1)
				} else {
					len1 = libc.Uint64FromInt64(int64(p1) - int64(s1))
				}
				x = libc.Xmalloc(tls, uint64(1)*(len1+uint64(1)))
				if x != 0 {
					libc.X__builtin___strcpy_chk(tls, x, s1, ^t__predefined_size_t(0))
					if XFcObjectFromName(tls, x) > 0 {
						XFcObjectSetAdd(tls, os, x)
					}
					s1 = p1 + uintptr(1)
					libc.Xfree(tls, x)
				}
			}
			libc.Xfree(tls, ss)
		}
		XFcPatternPrint2(tls, p, pat, os)
		if os != 0 {
			XFcObjectSetDestroy(tls, os)
		}
	}
	/* assuming that 'result' is initialized with FcResultNoMatch
	 * outside this function */
	if pat != 0 {
		*(*TFcResult)(unsafe.Pointer(result)) = int32(_FcResultMatch)
	}
	return pat
}

func XFcFontSetMatch(tls *libc.TLS, config uintptr, sets uintptr, nsets int32, p uintptr, result uintptr) (r uintptr) {
	var best, ret uintptr
	_, _ = best, ret
	ret = libc.UintptrFromInt32(0)
	*(*TFcResult)(unsafe.Pointer(result)) = int32(_FcResultNoMatch)
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return libc.UintptrFromInt32(0)
	}
	best = _FcFontSetMatchInternal(tls, sets, nsets, p, result)
	if best != 0 {
		ret = XFcFontRenderPrepare(tls, config, p, best)
		XFcPatternDestroy(tls, best)
	}
	XFcConfigDestroy(tls, config)
	return ret
}

func XFcFontMatch(tls *libc.TLS, config uintptr, p uintptr, result uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var best, ret uintptr
	var nsets, v1, v2 int32
	var _ /* sets at bp+0 */ [2]uintptr
	_, _, _, _, _ = best, nsets, ret, v1, v2
	ret = libc.UintptrFromInt32(0)
	*(*TFcResult)(unsafe.Pointer(result)) = int32(_FcResultNoMatch)
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return libc.UintptrFromInt32(0)
	}
	nsets = 0
	if *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(_FcSetSystem)*8)) != 0 {
		v1 = nsets
		nsets++
		(*(*[2]uintptr)(unsafe.Pointer(bp)))[v1] = *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(_FcSetSystem)*8))
	}
	if *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(_FcSetApplication)*8)) != 0 {
		v2 = nsets
		nsets++
		(*(*[2]uintptr)(unsafe.Pointer(bp)))[v2] = *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(_FcSetApplication)*8))
	}
	best = _FcFontSetMatchInternal(tls, bp, nsets, p, result)
	if best != 0 {
		ret = XFcFontRenderPrepare(tls, config, p, best)
		XFcPatternDestroy(tls, best)
	}
	XFcConfigDestroy(tls, config)
	return ret
}

type TFcSortNode = struct {
	Fpattern uintptr
	Fscore   [27]float64
}

type T_FcSortNode = TFcSortNode

func _FcSortCompare(tls *libc.TLS, aa uintptr, ab uintptr) (r int32) {
	var a, as, b, bs, v3, v5 uintptr
	var ad, bd, v2, v4 float64
	var i, v1, v7, v8 int32
	var v6 bool
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = a, ad, as, b, bd, bs, i, v1, v2, v3, v4, v5, v6, v7, v8
	a = *(*uintptr)(unsafe.Pointer(aa))
	b = *(*uintptr)(unsafe.Pointer(ab))
	as = a + 8
	bs = b + 8
	ad = libc.Float64FromInt32(0)
	bd = libc.Float64FromInt32(0)
	i = int32(_PRI_END)
	for {
		v1 = i
		i--
		if v6 = v1 != 0; v6 {
			v3 = as
			as += 8
			v2 = *(*float64)(unsafe.Pointer(v3))
			ad = v2
			v5 = bs
			bs += 8
			v4 = *(*float64)(unsafe.Pointer(v5))
			bd = v4
		}
		if !(v6 && v2 == v4) {
			break
		}
	}
	if ad < bd {
		v7 = -int32(1)
	} else {
		if ad > bd {
			v8 = int32(1)
		} else {
			v8 = 0
		}
		v7 = v8
	}
	return v7
}

func _FcSortWalk(tls *libc.TLS, n uintptr, nnode int32, fs uintptr, csp uintptr, trim TFcBool) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var cs, node, v2 uintptr
	var i int32
	var ret TFcBool
	var _ /* adds_chars at bp+0 */ TFcBool
	var _ /* ncs at bp+8 */ uintptr
	_, _, _, _, _ = cs, i, node, ret, v2
	ret = m_FcFalse
	cs = uintptr(0)
	if trim != 0 || csp != 0 {
		cs = XFcCharSetCreate(tls)
		if cs == libc.UintptrFromInt32(0) {
			goto bail
		}
	}
	i = 0
	for {
		if !(i < nnode) {
			break
		}
		v2 = n
		n += 8
		node = *(*uintptr)(unsafe.Pointer(v2))
		*(*TFcBool)(unsafe.Pointer(bp)) = m_FcFalse
		/*
		 * Only fetch node charset if we'd need it
		 */
		if cs != 0 {
			if XFcPatternGetCharSet(tls, (*TFcSortNode)(unsafe.Pointer(node)).Fpattern, __ccgo_ts+6125, 0, bp+8) != int32(_FcResultMatch) {
				goto _1
			}
			if !(XFcCharSetMerge(tls, cs, *(*uintptr)(unsafe.Pointer(bp + 8)), bp) != 0) {
				goto bail
			}
		}
		/*
		 * If this font isn't a subset of the previous fonts,
		 * add it to the list
		 */
		if !(i != 0) || !(trim != 0) || *(*TFcBool)(unsafe.Pointer(bp)) != 0 {
			XFcPatternReference(tls, (*TFcSortNode)(unsafe.Pointer(node)).Fpattern)
			if XFcDebugVal&int32(m_FC_DBG_MATCHV) != 0 {
				libc.Xprintf(tls, __ccgo_ts+6133, 0)
				XFcPatternPrint(tls, (*TFcSortNode)(unsafe.Pointer(node)).Fpattern)
			}
			if !(XFcFontSetAdd(tls, fs, (*TFcSortNode)(unsafe.Pointer(node)).Fpattern) != 0) {
				XFcPatternDestroy(tls, (*TFcSortNode)(unsafe.Pointer(node)).Fpattern)
				goto bail
			}
		}
		goto _1
	_1:
		;
		i++
	}
	if csp != 0 {
		*(*uintptr)(unsafe.Pointer(csp)) = cs
		cs = uintptr(0)
	}
	ret = int32(m_FcTrue)
	goto bail
bail:
	;
	if cs != 0 {
		XFcCharSetDestroy(tls, cs)
	}
	return ret
}

func XFcFontSetSortDestroy(tls *libc.TLS, fs uintptr) {
	XFcFontSetDestroy(tls, fs)
}

func XFcFontSetSort(tls *libc.TLS, config uintptr, sets uintptr, nsets int32, p uintptr, trim TFcBool, csp uintptr, result uintptr) (r uintptr) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var compare float64
	var f, i, nPatternLang, nnodes, set int32
	var new1, nodep, nodeps, nodes, patternLangSat, ret, s uintptr
	var satisfies TFcBool
	var _ /* data at bp+16 */ TFcCompareData
	var _ /* family at bp+56 */ uintptr
	var _ /* matchValue at bp+40 */ TFcValue
	var _ /* nodeLang at bp+24 */ TFcValue
	var _ /* patternLang at bp+0 */ TFcValue
	var _ /* style at bp+64 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = compare, f, i, nPatternLang, new1, nnodes, nodep, nodeps, nodes, patternLangSat, ret, s, satisfies, set
	/* There are some implementation that relying on the result of
	 * "result" to check if the return value of FcFontSetSort
	 * is valid or not.
	 * So we should initialize it to the conservative way since
	 * this function doesn't return NULL anymore.
	 */
	if result != 0 {
		*(*TFcResult)(unsafe.Pointer(result)) = int32(_FcResultNoMatch)
	}
	if XFcDebugVal&int32(m_FC_DBG_MATCH) != 0 {
		libc.Xprintf(tls, __ccgo_ts+6138, 0)
		XFcPatternPrint(tls, p)
	}
	nnodes = 0
	set = 0
	for {
		if !(set < nsets) {
			break
		}
		s = *(*uintptr)(unsafe.Pointer(sets + uintptr(set)*8))
		if !(s != 0) {
			goto _1
		}
		nnodes += (*TFcFontSet)(unsafe.Pointer(s)).Fnfont
		goto _1
	_1:
		;
		set++
	}
	if !(nnodes != 0) {
		return XFcFontSetCreate(tls)
	}
	nPatternLang = 0
	for {
		if !(XFcPatternGet(tls, p, __ccgo_ts+6144, nPatternLang, bp) == int32(_FcResultMatch)) {
			break
		}
		goto _2
	_2:
		;
		nPatternLang++
	}
	/* freed below */
	nodes = libc.Xmalloc(tls, libc.Uint64FromInt32(nnodes)*uint64(224)+libc.Uint64FromInt32(nnodes)*uint64(8)+libc.Uint64FromInt32(nPatternLang)*uint64(4))
	if !(nodes != 0) {
		goto bail0
	}
	nodeps = nodes + uintptr(nnodes)*224
	patternLangSat = nodeps + uintptr(nnodes)*8
	_FcCompareDataInit(tls, p, bp+16)
	new1 = nodes
	nodep = nodeps
	set = 0
	for {
		if !(set < nsets) {
			break
		}
		s = *(*uintptr)(unsafe.Pointer(sets + uintptr(set)*8))
		if !(s != 0) {
			goto _3
		}
		f = 0
		for {
			if !(f < (*TFcFontSet)(unsafe.Pointer(s)).Fnfont) {
				break
			}
			if XFcDebugVal&int32(m_FC_DBG_MATCHV) != 0 {
				libc.Xprintf(tls, __ccgo_ts+2692, libc.VaList(bp+80, f))
				XFcPatternPrint(tls, *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(s)).Ffonts + uintptr(f)*8)))
			}
			(*TFcSortNode)(unsafe.Pointer(new1)).Fpattern = *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(s)).Ffonts + uintptr(f)*8))
			if !(_FcCompare(tls, p, (*TFcSortNode)(unsafe.Pointer(new1)).Fpattern, new1+8, result, bp+16) != 0) {
				goto bail1
			}
			if XFcDebugVal&int32(m_FC_DBG_MATCHV) != 0 {
				libc.Xprintf(tls, __ccgo_ts+6084, 0)
				i = 0
				for {
					if !(i < int32(_PRI_END)) {
						break
					}
					libc.Xprintf(tls, __ccgo_ts+6090, libc.VaList(bp+80, *(*float64)(unsafe.Pointer(new1 + 8 + uintptr(i)*8))))
					goto _5
				_5:
					;
					i++
				}
				libc.Xprintf(tls, __ccgo_ts+1266, 0)
			}
			*(*uintptr)(unsafe.Pointer(nodep)) = new1
			new1 += 224
			nodep += 8
			goto _4
		_4:
			;
			f++
		}
		goto _3
	_3:
		;
		set++
	}
	_FcCompareDataClear(tls, bp+16)
	nnodes = int32((int64(new1) - int64(nodes)) / 224)
	libc.Xqsort(tls, nodeps, libc.Uint64FromInt32(nnodes), uint64(8), __ccgo_fp(_FcSortCompare))
	i = 0
	for {
		if !(i < nPatternLang) {
			break
		}
		*(*TFcBool)(unsafe.Pointer(patternLangSat + uintptr(i)*4)) = m_FcFalse
		goto _6
	_6:
		;
		i++
	}
	f = 0
	for {
		if !(f < nnodes) {
			break
		}
		satisfies = m_FcFalse
		/*
		 * If this node matches any language, go check
		 * which ones and satisfy those entries
		 */
		if *(*float64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(nodeps + uintptr(f)*8)) + 8 + uintptr(_PRI_LANG)*8)) < libc.Float64FromInt32(2000) {
			i = 0
			for {
				if !(i < nPatternLang) {
					break
				}
				if !(*(*TFcBool)(unsafe.Pointer(patternLangSat + uintptr(i)*4)) != 0) && XFcPatternGet(tls, p, __ccgo_ts+6144, i, bp) == int32(_FcResultMatch) && XFcPatternGet(tls, (*TFcSortNode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(nodeps + uintptr(f)*8)))).Fpattern, __ccgo_ts+6144, 0, bp+24) == int32(_FcResultMatch) {
					compare = _FcCompareLang(tls, bp, bp+24, bp+40)
					if compare >= libc.Float64FromInt32(0) && compare < libc.Float64FromInt32(2) {
						if XFcDebugVal&int32(m_FC_DBG_MATCHV) != 0 {
							if XFcPatternGetString(tls, (*TFcSortNode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(nodeps + uintptr(f)*8)))).Fpattern, __ccgo_ts+5977, 0, bp+56) == int32(_FcResultMatch) && XFcPatternGetString(tls, (*TFcSortNode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(nodeps + uintptr(f)*8)))).Fpattern, __ccgo_ts+4583, 0, bp+64) == int32(_FcResultMatch) {
								libc.Xprintf(tls, __ccgo_ts+6149, libc.VaList(bp+80, *(*uintptr)(unsafe.Pointer(bp + 56)), *(*uintptr)(unsafe.Pointer(bp + 64)), i))
							}
						}
						*(*TFcBool)(unsafe.Pointer(patternLangSat + uintptr(i)*4)) = int32(m_FcTrue)
						satisfies = int32(m_FcTrue)
						break
					}
				}
				goto _8
			_8:
				;
				i++
			}
		}
		if !(satisfies != 0) {
			*(*float64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(nodeps + uintptr(f)*8)) + 8 + uintptr(_PRI_LANG)*8)) = float64(10000)
		}
		goto _7
	_7:
		;
		f++
	}
	/*
	 * Re-sort once the language issues have been settled
	 */
	libc.Xqsort(tls, nodeps, libc.Uint64FromInt32(nnodes), uint64(8), __ccgo_fp(_FcSortCompare))
	ret = XFcFontSetCreate(tls)
	if !(ret != 0) {
		goto bail1
	}
	if !(_FcSortWalk(tls, nodeps, nnodes, ret, csp, trim) != 0) {
		goto bail2
	}
	libc.Xfree(tls, nodes)
	if XFcDebugVal&int32(m_FC_DBG_MATCH) != 0 {
		libc.Xprintf(tls, __ccgo_ts+6181, 0)
		XFcPatternPrint(tls, *(*uintptr)(unsafe.Pointer((*TFcFontSet)(unsafe.Pointer(ret)).Ffonts)))
	}
	if (*TFcFontSet)(unsafe.Pointer(ret)).Fnfont > 0 {
		*(*TFcResult)(unsafe.Pointer(result)) = int32(_FcResultMatch)
	}
	return ret
	goto bail2
bail2:
	;
	XFcFontSetDestroy(tls, ret)
	goto bail1
bail1:
	;
	libc.Xfree(tls, nodes)
	goto bail0
bail0:
	;
	return uintptr(0)
	return r
}

func XFcFontSort(tls *libc.TLS, config uintptr, p uintptr, trim TFcBool, csp uintptr, result uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var nsets, v1, v2 int32
	var ret uintptr
	var _ /* sets at bp+0 */ [2]uintptr
	_, _, _, _ = nsets, ret, v1, v2
	*(*TFcResult)(unsafe.Pointer(result)) = int32(_FcResultNoMatch)
	config = XFcConfigReference(tls, config)
	if !(config != 0) {
		return libc.UintptrFromInt32(0)
	}
	nsets = 0
	if *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(_FcSetSystem)*8)) != 0 {
		v1 = nsets
		nsets++
		(*(*[2]uintptr)(unsafe.Pointer(bp)))[v1] = *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(_FcSetSystem)*8))
	}
	if *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(_FcSetApplication)*8)) != 0 {
		v2 = nsets
		nsets++
		(*(*[2]uintptr)(unsafe.Pointer(bp)))[v2] = *(*uintptr)(unsafe.Pointer(config + 104 + uintptr(_FcSetApplication)*8))
	}
	ret = XFcFontSetSort(tls, config, bp, nsets, p, trim, csp, result)
	XFcConfigDestroy(tls, config)
	return ret
}

func XFcMatrixCopy(tls *libc.TLS, mat uintptr) (r1 uintptr) {
	var r uintptr
	_ = r
	if !(mat != 0) {
		return uintptr(0)
	}
	r = libc.Xmalloc(tls, uint64(32))
	if !(r != 0) {
		return uintptr(0)
	}
	*(*TFcMatrix)(unsafe.Pointer(r)) = *(*TFcMatrix)(unsafe.Pointer(mat))
	return r
}

func XFcMatrixFree(tls *libc.TLS, mat uintptr) {
	if mat != uintptr(unsafe.Pointer(&XFcIdentityMatrix)) {
		libc.Xfree(tls, mat)
	}
}

func XFcMatrixEqual(tls *libc.TLS, mat1 uintptr, mat2 uintptr) (r TFcBool) {
	if mat1 == mat2 {
		return int32(m_FcTrue)
	}
	if mat1 == uintptr(0) || mat2 == uintptr(0) {
		return m_FcFalse
	}
	return libc.BoolInt32((*TFcMatrix)(unsafe.Pointer(mat1)).Fxx == (*TFcMatrix)(unsafe.Pointer(mat2)).Fxx && (*TFcMatrix)(unsafe.Pointer(mat1)).Fxy == (*TFcMatrix)(unsafe.Pointer(mat2)).Fxy && (*TFcMatrix)(unsafe.Pointer(mat1)).Fyx == (*TFcMatrix)(unsafe.Pointer(mat2)).Fyx && (*TFcMatrix)(unsafe.Pointer(mat1)).Fyy == (*TFcMatrix)(unsafe.Pointer(mat2)).Fyy)
}

func XFcMatrixMultiply(tls *libc.TLS, result uintptr, a uintptr, b uintptr) {
	var r TFcMatrix
	_ = r
	r.Fxx = float64((*TFcMatrix)(unsafe.Pointer(a)).Fxx*(*TFcMatrix)(unsafe.Pointer(b)).Fxx) + float64((*TFcMatrix)(unsafe.Pointer(a)).Fxy*(*TFcMatrix)(unsafe.Pointer(b)).Fyx)
	r.Fxy = float64((*TFcMatrix)(unsafe.Pointer(a)).Fxx*(*TFcMatrix)(unsafe.Pointer(b)).Fxy) + float64((*TFcMatrix)(unsafe.Pointer(a)).Fxy*(*TFcMatrix)(unsafe.Pointer(b)).Fyy)
	r.Fyx = float64((*TFcMatrix)(unsafe.Pointer(a)).Fyx*(*TFcMatrix)(unsafe.Pointer(b)).Fxx) + float64((*TFcMatrix)(unsafe.Pointer(a)).Fyy*(*TFcMatrix)(unsafe.Pointer(b)).Fyx)
	r.Fyy = float64((*TFcMatrix)(unsafe.Pointer(a)).Fyx*(*TFcMatrix)(unsafe.Pointer(b)).Fxy) + float64((*TFcMatrix)(unsafe.Pointer(a)).Fyy*(*TFcMatrix)(unsafe.Pointer(b)).Fyy)
	*(*TFcMatrix)(unsafe.Pointer(result)) = r
}

func XFcMatrixRotate(tls *libc.TLS, m uintptr, c float64, s float64) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* r at bp+0 */ TFcMatrix
	/*
	 * X Coordinate system is upside down, swap to make
	 * rotations counterclockwise
	 */
	(*(*TFcMatrix)(unsafe.Pointer(bp))).Fxx = c
	(*(*TFcMatrix)(unsafe.Pointer(bp))).Fxy = -s
	(*(*TFcMatrix)(unsafe.Pointer(bp))).Fyx = s
	(*(*TFcMatrix)(unsafe.Pointer(bp))).Fyy = c
	XFcMatrixMultiply(tls, m, bp, m)
}

func XFcMatrixScale(tls *libc.TLS, m uintptr, sx float64, sy float64) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* r at bp+0 */ TFcMatrix
	(*(*TFcMatrix)(unsafe.Pointer(bp))).Fxx = sx
	(*(*TFcMatrix)(unsafe.Pointer(bp))).Fxy = libc.Float64FromInt32(0)
	(*(*TFcMatrix)(unsafe.Pointer(bp))).Fyx = libc.Float64FromInt32(0)
	(*(*TFcMatrix)(unsafe.Pointer(bp))).Fyy = sy
	XFcMatrixMultiply(tls, m, bp, m)
}

func XFcMatrixShear(tls *libc.TLS, m uintptr, sh float64, sv float64) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* r at bp+0 */ TFcMatrix
	(*(*TFcMatrix)(unsafe.Pointer(bp))).Fxx = libc.Float64FromInt32(1)
	(*(*TFcMatrix)(unsafe.Pointer(bp))).Fxy = sh
	(*(*TFcMatrix)(unsafe.Pointer(bp))).Fyx = sv
	(*(*TFcMatrix)(unsafe.Pointer(bp))).Fyy = libc.Float64FromInt32(1)
	XFcMatrixMultiply(tls, m, bp, m)
}

const m_FC_ESCAPE_FIXED = "\\-:,"
const m_FC_ESCAPE_VARIABLE = "\\=_:,"

/*
 * Copyright (c) 2000, 2005, 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * This code is derived from software contributed to Berkeley by
 * Paul Borman at Krystal Technologies.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ctype.h	8.4 (Berkeley) 1/21/94
 */

/*
 * Copyright (c) 2000, 2005, 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * This code is derived from software contributed to Berkeley by
 * Paul Borman at Krystal Technologies.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ctype.h	8.4 (Berkeley) 1/21/94
 */

/*
 * Copyright (c) 2000, 2002 - 2008, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2000, 2007, 2010, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

/*
 * Copyright (c) 2000, 2005, 2007, 2009, 2010, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdio.h	8.5 (Berkeley) 4/29/95
 */

/*
 * Copyright (c) 2000, 2005, 2007, 2009, 2010, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdio.h	8.5 (Berkeley) 4/29/95
 */

/*
 * Common header for stdio.h and xlocale/_stdio.h
 */

var _FcObjects = [52]TFcObjectType{
	0: {
		Fobject: __ccgo_ts + 5977,
		Ftype1:  int32(_FcTypeString),
	},
	1: {
		Fobject: __ccgo_ts + 5984,
		Ftype1:  int32(_FcTypeString),
	},
	2: {
		Fobject: __ccgo_ts + 4583,
		Ftype1:  int32(_FcTypeString),
	},
	3: {
		Fobject: __ccgo_ts + 6017,
		Ftype1:  int32(_FcTypeString),
	},
	4: {
		Fobject: __ccgo_ts + 5995,
		Ftype1:  int32(_FcTypeString),
	},
	5: {
		Fobject: __ccgo_ts + 6004,
		Ftype1:  int32(_FcTypeString),
	},
	6: {
		Fobject: __ccgo_ts + 6193,
		Ftype1:  int32(_FcTypeInteger),
	},
	7: {
		Fobject: __ccgo_ts + 6199,
		Ftype1:  int32(_FcTypeRange),
	},
	8: {
		Fobject: __ccgo_ts + 6206,
		Ftype1:  int32(_FcTypeRange),
	},
	9: {
		Fobject: __ccgo_ts + 6212,
		Ftype1:  int32(_FcTypeRange),
	},
	10: {
		Fobject: __ccgo_ts + 6217,
		Ftype1:  int32(_FcTypeDouble),
	},
	11: {
		Fobject: __ccgo_ts + 6224,
		Ftype1:  int32(_FcTypeDouble),
	},
	12: {
		Fobject: __ccgo_ts + 6234,
		Ftype1:  int32(_FcTypeInteger),
	},
	13: {
		Fobject: __ccgo_ts + 6242,
		Ftype1:  int32(_FcTypeString),
	},
	14: {
		Fobject: __ccgo_ts + 6250,
		Ftype1:  int32(_FcTypeBool),
	},
	15: {
		Fobject: __ccgo_ts + 6260,
		Ftype1:  int32(_FcTypeInteger),
	},
	16: {
		Fobject: __ccgo_ts + 6270,
		Ftype1:  int32(_FcTypeBool),
	},
	17: {
		Fobject: __ccgo_ts + 6278,
		Ftype1:  int32(_FcTypeBool),
	},
	18: {
		Fobject: __ccgo_ts + 6293,
		Ftype1:  int32(_FcTypeBool),
	},
	19: {
		Fobject: __ccgo_ts + 6302,
		Ftype1:  int32(_FcTypeBool),
	},
	20: {
		Fobject: __ccgo_ts + 6316,
		Ftype1:  int32(_FcTypeString),
	},
	21: {
		Fobject: __ccgo_ts + 6321,
		Ftype1:  int32(_FcTypeInteger),
	},
	22: {
		Fobject: __ccgo_ts + 6327,
		Ftype1:  int32(_FcTypeString),
	},
	23: {
		Fobject: __ccgo_ts + 6338,
		Ftype1:  int32(_FcTypeBool),
	},
	24: {
		Fobject: __ccgo_ts + 6346,
		Ftype1:  int32(_FcTypeBool),
	},
	25: {
		Fobject: __ccgo_ts + 6355,
		Ftype1:  int32(_FcTypeDouble),
	},
	26: {
		Fobject: __ccgo_ts + 6359,
		Ftype1:  int32(_FcTypeInteger),
	},
	27: {
		Fobject: __ccgo_ts + 6364,
		Ftype1:  int32(_FcTypeDouble),
	},
	28: {
		Fobject: __ccgo_ts + 6370,
		Ftype1:  int32(_FcTypeBool),
	},
	29: {
		Fobject: __ccgo_ts + 6379,
		Ftype1:  int32(_FcTypeInteger),
	},
	30: {
		Fobject: __ccgo_ts + 6389,
		Ftype1:  int32(_FcTypeInteger),
	},
	31: {
		Fobject: __ccgo_ts + 6400,
		Ftype1:  int32(_FcTypeMatrix),
	},
	32: {
		Fobject: __ccgo_ts + 6125,
		Ftype1:  int32(_FcTypeCharSet),
	},
	33: {
		Fobject: __ccgo_ts + 6144,
		Ftype1:  int32(_FcTypeLangSet),
	},
	34: {
		Fobject: __ccgo_ts + 6407,
		Ftype1:  int32(_FcTypeInteger),
	},
	35: {
		Fobject: __ccgo_ts + 6419,
		Ftype1:  int32(_FcTypeString),
	},
	36: {
		Fobject: __ccgo_ts + 6430,
		Ftype1:  int32(_FcTypeString),
	},
	37: {
		Fobject: __ccgo_ts + 6441,
		Ftype1:  int32(_FcTypeBool),
	},
	38: {
		Fobject: __ccgo_ts + 6450,
		Ftype1:  int32(_FcTypeBool),
	},
	39: {
		Fobject: __ccgo_ts + 6465,
		Ftype1:  int32(_FcTypeBool),
	},
	40: {
		Fobject: __ccgo_ts + 6476,
		Ftype1:  int32(_FcTypeInteger),
	},
	41: {
		Fobject: __ccgo_ts + 6486,
		Ftype1:  int32(_FcTypeString),
	},
	42: {
		Fobject: __ccgo_ts + 6495,
		Ftype1:  int32(_FcTypeString),
	},
	43: {
		Fobject: __ccgo_ts + 6508,
		Ftype1:  int32(_FcTypeString),
	},
	44: {
		Fobject: __ccgo_ts + 6516,
		Ftype1:  int32(_FcTypeString),
	},
	45: {
		Fobject: __ccgo_ts + 6521,
		Ftype1:  int32(_FcTypeString),
	},
	46: {
		Fobject: __ccgo_ts + 6536,
		Ftype1:  int32(_FcTypeBool),
	},
	47: {
		Fobject: __ccgo_ts + 6542,
		Ftype1:  int32(_FcTypeBool),
	},
	48: {
		Fobject: __ccgo_ts + 6549,
		Ftype1:  int32(_FcTypeString),
	},
	49: {
		Fobject: __ccgo_ts + 6564,
		Ftype1:  int32(_FcTypeBool),
	},
	50: {
		Fobject: __ccgo_ts + 6573,
		Ftype1:  int32(_FcTypeBool),
	},
	51: {
		Fobject: __ccgo_ts + 6585,
		Ftype1:  int32(_FcTypeInteger),
	},
}

func _FcObjectFindById(tls *libc.TLS, object TFcObject) (r uintptr) {
	if int32(1) <= object && object <= libc.Int32FromUint64(libc.Uint64FromInt64(832)/libc.Uint64FromInt64(16)) {
		return uintptr(unsafe.Pointer(&_FcObjects)) + uintptr(object-int32(1))*16
	}
	return XFcObjectLookupOtherTypeById(tls, object)
}

func XFcNameRegisterObjectTypes(tls *libc.TLS, types uintptr, ntypes int32) (r TFcBool) {
	/* Deprecated. */
	return m_FcFalse
}

func XFcNameUnregisterObjectTypes(tls *libc.TLS, types uintptr, ntypes int32) (r TFcBool) {
	/* Deprecated. */
	return m_FcFalse
}

func XFcNameGetObjectType(tls *libc.TLS, object uintptr) (r uintptr) {
	var id int32
	_ = id
	id = XFcObjectLookupBuiltinIdByName(tls, object)
	if !(id != 0) {
		return XFcObjectLookupOtherTypeByName(tls, object)
	}
	return uintptr(unsafe.Pointer(&_FcObjects)) + uintptr(id-int32(1))*16
}

func XFcObjectValidType(tls *libc.TLS, object TFcObject, type1 TFcType) (r TFcBool) {
	var t uintptr
	_ = t
	t = _FcObjectFindById(tls, object)
	if t != 0 {
		switch (*TFcObjectType)(unsafe.Pointer(t)).Ftype1 {
		case int32(_FcTypeUnknown):
			return int32(m_FcTrue)
		case int32(_FcTypeDouble):
			fallthrough
		case int32(_FcTypeInteger):
			if type1 == int32(_FcTypeDouble) || type1 == int32(_FcTypeInteger) {
				return int32(m_FcTrue)
			}
		case int32(_FcTypeLangSet):
			if type1 == int32(_FcTypeLangSet) || type1 == int32(_FcTypeString) {
				return int32(m_FcTrue)
			}
		case int32(_FcTypeRange):
			if type1 == int32(_FcTypeRange) || type1 == int32(_FcTypeDouble) || type1 == int32(_FcTypeInteger) {
				return int32(m_FcTrue)
			}
		default:
			if type1 == (*TFcObjectType)(unsafe.Pointer(t)).Ftype1 {
				return int32(m_FcTrue)
			}
			break
		}
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

func XFcObjectFromName(tls *libc.TLS, name uintptr) (r TFcObject) {
	return XFcObjectLookupIdByName(tls, name)
}

func XFcObjectGetSet(tls *libc.TLS) (r uintptr) {
	var i int32
	var os uintptr
	_, _ = i, os
	os = libc.UintptrFromInt32(0)
	os = XFcObjectSetCreate(tls)
	i = 0
	for {
		if !(i < libc.Int32FromUint64(libc.Uint64FromInt64(832)/libc.Uint64FromInt64(16))) {
			break
		}
		XFcObjectSetAdd(tls, os, _FcObjects[i].Fobject)
		goto _1
	_1:
		;
		i++
	}
	return os
}

func XFcObjectName(tls *libc.TLS, object TFcObject) (r uintptr) {
	var o uintptr
	_ = o
	o = _FcObjectFindById(tls, object)
	if o != 0 {
		return (*TFcObjectType)(unsafe.Pointer(o)).Fobject
	}
	return XFcObjectLookupOtherNameById(tls, object)
}

var __FcBaseConstants = [57]TFcConstant{
	0: {
		Fname:   __ccgo_ts + 3851,
		Fobject: __ccgo_ts + 6199,
	},
	1: {
		Fname:   __ccgo_ts + 3856,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_EXTRALIGHT),
	},
	2: {
		Fname:   __ccgo_ts + 3867,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_EXTRALIGHT),
	},
	3: {
		Fname:   __ccgo_ts + 3878,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_DEMILIGHT),
	},
	4: {
		Fname:   __ccgo_ts + 3888,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_DEMILIGHT),
	},
	5: {
		Fname:   __ccgo_ts + 3898,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_LIGHT),
	},
	6: {
		Fname:   __ccgo_ts + 3904,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_BOOK),
	},
	7: {
		Fname:   __ccgo_ts + 3909,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_REGULAR),
	},
	8: {
		Fname:   __ccgo_ts + 3924,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_MEDIUM),
	},
	9: {
		Fname:   __ccgo_ts + 3931,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_DEMIBOLD),
	},
	10: {
		Fname:   __ccgo_ts + 3945,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_DEMIBOLD),
	},
	11: {
		Fname:   __ccgo_ts + 3984,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_BOLD),
	},
	12: {
		Fname:   __ccgo_ts + 3954,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_EXTRABOLD),
	},
	13: {
		Fname:   __ccgo_ts + 3974,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_EXTRABOLD),
	},
	14: {
		Fname:   __ccgo_ts + 4029,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_BLACK),
	},
	15: {
		Fname:   __ccgo_ts + 4035,
		Fobject: __ccgo_ts + 6199,
		Fvalue:  int32(m_FC_WEIGHT_BLACK),
	},
	16: {
		Fname:   __ccgo_ts + 6591,
		Fobject: __ccgo_ts + 6193,
	},
	17: {
		Fname:   __ccgo_ts + 4154,
		Fobject: __ccgo_ts + 6193,
		Fvalue:  int32(m_FC_SLANT_ITALIC),
	},
	18: {
		Fname:   __ccgo_ts + 4168,
		Fobject: __ccgo_ts + 6193,
		Fvalue:  int32(m_FC_SLANT_OBLIQUE),
	},
	19: {
		Fname:   __ccgo_ts + 4041,
		Fobject: __ccgo_ts + 6206,
		Fvalue:  int32(m_FC_WIDTH_ULTRACONDENSED),
	},
	20: {
		Fname:   __ccgo_ts + 4056,
		Fobject: __ccgo_ts + 6206,
		Fvalue:  int32(m_FC_WIDTH_EXTRACONDENSED),
	},
	21: {
		Fname:   __ccgo_ts + 4085,
		Fobject: __ccgo_ts + 6206,
		Fvalue:  int32(m_FC_WIDTH_CONDENSED),
	},
	22: {
		Fname:   __ccgo_ts + 4071,
		Fobject: __ccgo_ts + 6206,
		Fvalue:  int32(m_FC_WIDTH_SEMICONDENSED),
	},
	23: {
		Fname:   __ccgo_ts + 3917,
		Fobject: __ccgo_ts + 6206,
		Fvalue:  int32(m_FC_WIDTH_NORMAL),
	},
	24: {
		Fname:   __ccgo_ts + 4095,
		Fobject: __ccgo_ts + 6206,
		Fvalue:  int32(m_FC_WIDTH_SEMIEXPANDED),
	},
	25: {
		Fname:   __ccgo_ts + 4136,
		Fobject: __ccgo_ts + 6206,
		Fvalue:  int32(m_FC_WIDTH_EXPANDED),
	},
	26: {
		Fname:   __ccgo_ts + 4108,
		Fobject: __ccgo_ts + 6206,
		Fvalue:  int32(m_FC_WIDTH_EXTRAEXPANDED),
	},
	27: {
		Fname:   __ccgo_ts + 4122,
		Fobject: __ccgo_ts + 6206,
		Fvalue:  int32(m_FC_WIDTH_ULTRAEXPANDED),
	},
	28: {
		Fname:   __ccgo_ts + 6597,
		Fobject: __ccgo_ts + 6234,
	},
	29: {
		Fname:   __ccgo_ts + 6610,
		Fobject: __ccgo_ts + 6234,
		Fvalue:  int32(m_FC_DUAL),
	},
	30: {
		Fname:   __ccgo_ts + 6615,
		Fobject: __ccgo_ts + 6234,
		Fvalue:  int32(m_FC_MONO),
	},
	31: {
		Fname:   __ccgo_ts + 6620,
		Fobject: __ccgo_ts + 6234,
		Fvalue:  int32(m_FC_CHARCELL),
	},
	32: {
		Fname:   __ccgo_ts + 4707,
		Fobject: __ccgo_ts + 6359,
	},
	33: {
		Fname:   __ccgo_ts + 6629,
		Fobject: __ccgo_ts + 6359,
		Fvalue:  int32(m_FC_RGBA_RGB),
	},
	34: {
		Fname:   __ccgo_ts + 6633,
		Fobject: __ccgo_ts + 6359,
		Fvalue:  int32(m_FC_RGBA_BGR),
	},
	35: {
		Fname:   __ccgo_ts + 6637,
		Fobject: __ccgo_ts + 6359,
		Fvalue:  int32(m_FC_RGBA_VRGB),
	},
	36: {
		Fname:   __ccgo_ts + 6642,
		Fobject: __ccgo_ts + 6359,
		Fvalue:  int32(m_FC_RGBA_VBGR),
	},
	37: {
		Fname:   __ccgo_ts + 2465,
		Fobject: __ccgo_ts + 6359,
		Fvalue:  int32(m_FC_RGBA_NONE),
	},
	38: {
		Fname:   __ccgo_ts + 6647,
		Fobject: __ccgo_ts + 6260,
	},
	39: {
		Fname:   __ccgo_ts + 6656,
		Fobject: __ccgo_ts + 6260,
		Fvalue:  int32(m_FC_HINT_SLIGHT),
	},
	40: {
		Fname:   __ccgo_ts + 6667,
		Fobject: __ccgo_ts + 6260,
		Fvalue:  int32(m_FC_HINT_MEDIUM),
	},
	41: {
		Fname:   __ccgo_ts + 6678,
		Fobject: __ccgo_ts + 6260,
		Fvalue:  int32(m_FC_HINT_FULL),
	},
	42: {
		Fname:   __ccgo_ts + 6250,
		Fobject: __ccgo_ts + 6250,
		Fvalue:  int32(m_FcTrue),
	},
	43: {
		Fname:   __ccgo_ts + 6270,
		Fobject: __ccgo_ts + 6270,
		Fvalue:  int32(m_FcTrue),
	},
	44: {
		Fname:   __ccgo_ts + 6278,
		Fobject: __ccgo_ts + 6278,
		Fvalue:  int32(m_FcTrue),
	},
	45: {
		Fname:   __ccgo_ts + 6293,
		Fobject: __ccgo_ts + 6293,
		Fvalue:  int32(m_FcTrue),
	},
	46: {
		Fname:   __ccgo_ts + 6302,
		Fobject: __ccgo_ts + 6302,
		Fvalue:  int32(m_FcTrue),
	},
	47: {
		Fname:   __ccgo_ts + 6338,
		Fobject: __ccgo_ts + 6338,
		Fvalue:  int32(m_FcTrue),
	},
	48: {
		Fname:   __ccgo_ts + 6346,
		Fobject: __ccgo_ts + 6346,
		Fvalue:  int32(m_FcTrue),
	},
	49: {
		Fname:   __ccgo_ts + 6370,
		Fobject: __ccgo_ts + 6370,
		Fvalue:  int32(m_FcTrue),
	},
	50: {
		Fname:   __ccgo_ts + 6441,
		Fobject: __ccgo_ts + 6441,
		Fvalue:  int32(m_FcTrue),
	},
	51: {
		Fname:   __ccgo_ts + 6450,
		Fobject: __ccgo_ts + 6450,
		Fvalue:  int32(m_FcTrue),
	},
	52: {
		Fname:   __ccgo_ts + 6465,
		Fobject: __ccgo_ts + 6465,
		Fvalue:  int32(m_FcTrue),
	},
	53: {
		Fname:   __ccgo_ts + 6687,
		Fobject: __ccgo_ts + 6476,
	},
	54: {
		Fname:   __ccgo_ts + 6695,
		Fobject: __ccgo_ts + 6476,
		Fvalue:  int32(m_FC_LCD_DEFAULT),
	},
	55: {
		Fname:   __ccgo_ts + 6706,
		Fobject: __ccgo_ts + 6476,
		Fvalue:  int32(m_FC_LCD_LIGHT),
	},
	56: {
		Fname:   __ccgo_ts + 6715,
		Fobject: __ccgo_ts + 6476,
		Fvalue:  int32(m_FC_LCD_LEGACY),
	},
}

func XFcNameRegisterConstants(tls *libc.TLS, consts uintptr, nconsts int32) (r TFcBool) {
	/* Deprecated. */
	return m_FcFalse
}

func XFcNameUnregisterConstants(tls *libc.TLS, consts uintptr, nconsts int32) (r TFcBool) {
	/* Deprecated. */
	return m_FcFalse
}

func XFcNameGetConstant(tls *libc.TLS, string1 uintptr) (r uintptr) {
	var i uint32
	_ = i
	i = uint32(0)
	for {
		if !(uint64(i) < libc.Uint64FromInt64(1368)/libc.Uint64FromInt64(24)) {
			break
		}
		if !(XFcStrCmpIgnoreCase(tls, string1, __FcBaseConstants[i].Fname) != 0) {
			return uintptr(unsafe.Pointer(&__FcBaseConstants)) + uintptr(i)*24
		}
		goto _1
	_1:
		;
		i++
	}
	return uintptr(0)
}

func XFcNameConstant(tls *libc.TLS, string1 uintptr, result uintptr) (r TFcBool) {
	var c, v1 uintptr
	_, _ = c, v1
	v1 = XFcNameGetConstant(tls, string1)
	c = v1
	if v1 != 0 {
		*(*int32)(unsafe.Pointer(result)) = (*TFcConstant)(unsafe.Pointer(c)).Fvalue
		return int32(m_FcTrue)
	}
	return m_FcFalse
}

func XFcNameConstantWithObjectCheck(tls *libc.TLS, string1 uintptr, object uintptr, result uintptr) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var c, v1 uintptr
	_, _ = c, v1
	v1 = XFcNameGetConstant(tls, string1)
	c = v1
	if v1 != 0 {
		if libc.Xstrcmp(tls, (*TFcConstant)(unsafe.Pointer(c)).Fobject, object) != 0 {
			libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+6725, libc.VaList(bp+8, string1, object, (*TFcConstant)(unsafe.Pointer(c)).Fobject))
			return m_FcFalse
		}
		*(*int32)(unsafe.Pointer(result)) = (*TFcConstant)(unsafe.Pointer(c)).Fvalue
		return int32(m_FcTrue)
	}
	return m_FcFalse
}

func XFcNameBool(tls *libc.TLS, v uintptr, result uintptr) (r TFcBool) {
	var c0, c1 int8
	var v1, v2 int32
	_, _, _, _ = c0, c1, v1, v2
	c0 = libc.Int8FromUint8(*(*TFcChar8)(unsafe.Pointer(v)))
	if int32(0101) <= int32(c0) && int32(c0) <= int32(0132) {
		v1 = int32(c0) - int32(0101) + int32(0141)
	} else {
		v1 = int32(c0)
	}
	c0 = int8(v1)
	if int32(c0) == int32('t') || int32(c0) == int32('y') || int32(c0) == int32('1') {
		*(*TFcBool)(unsafe.Pointer(result)) = int32(m_FcTrue)
		return int32(m_FcTrue)
	}
	if int32(c0) == int32('f') || int32(c0) == int32('n') || int32(c0) == int32('0') {
		*(*TFcBool)(unsafe.Pointer(result)) = m_FcFalse
		return int32(m_FcTrue)
	}
	if int32(c0) == int32('d') || int32(c0) == int32('x') || int32(c0) == int32('2') {
		*(*TFcBool)(unsafe.Pointer(result)) = int32(m_FcDontCare)
		return int32(m_FcTrue)
	}
	if int32(c0) == int32('o') {
		c1 = libc.Int8FromUint8(*(*TFcChar8)(unsafe.Pointer(v + 1)))
		if int32(0101) <= int32(c1) && int32(c1) <= int32(0132) {
			v2 = int32(c1) - int32(0101) + int32(0141)
		} else {
			v2 = int32(c1)
		}
		c1 = int8(v2)
		if int32(c1) == int32('n') {
			*(*TFcBool)(unsafe.Pointer(result)) = int32(m_FcTrue)
			return int32(m_FcTrue)
		}
		if int32(c1) == int32('f') {
			*(*TFcBool)(unsafe.Pointer(result)) = m_FcFalse
			return int32(m_FcTrue)
		}
		if int32(c1) == int32('r') {
			*(*TFcBool)(unsafe.Pointer(result)) = int32(m_FcDontCare)
			return int32(m_FcTrue)
		}
	}
	return m_FcFalse
}

func _FcNameConvert(tls *libc.TLS, type1 TFcType, object uintptr, string1 uintptr) (r TFcValue) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var ec, sc uintptr
	var len1 Tsize_t
	var v11, v12 float64
	var _ /* b at bp+48 */ float64
	var _ /* e at bp+56 */ float64
	var _ /* ei at bp+76 */ int32
	var _ /* m at bp+16 */ TFcMatrix
	var _ /* p at bp+64 */ uintptr
	var _ /* si at bp+72 */ int32
	var _ /* v at bp+0 */ TFcValue
	_, _, _, _, _ = ec, len1, sc, v11, v12
	(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = type1
	switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
	case int32(_FcTypeInteger):
		goto _1
	case int32(_FcTypeString):
		goto _2
	case int32(_FcTypeBool):
		goto _3
	case int32(_FcTypeDouble):
		goto _4
	case int32(_FcTypeMatrix):
		goto _5
	case int32(_FcTypeCharSet):
		goto _6
	case int32(_FcTypeLangSet):
		goto _7
	case int32(_FcTypeRange):
		goto _8
	default:
		goto _9
	}
	goto _10
_1:
	;
	if !(XFcNameConstantWithObjectCheck(tls, string1, object, bp+8) != 0) {
		*(*int32)(unsafe.Pointer(bp + 8)) = libc.Xatoi(tls, string1)
	}
	goto _10
_2:
	;
	*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.Xstrdup(tls, string1)
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) != 0) {
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
	}
	goto _10
_3:
	;
	if !(XFcNameBool(tls, string1, bp+8) != 0) {
		*(*TFcBool)(unsafe.Pointer(bp + 8)) = m_FcFalse
	}
	goto _10
_4:
	;
	*(*float64)(unsafe.Pointer(bp + 8)) = libc.Xstrtod(tls, string1, uintptr(0))
	goto _10
_5:
	;
	v11 = libc.Float64FromInt32(1)
	(*TFcMatrix)(unsafe.Pointer(bp + 16)).Fyy = v11
	(*TFcMatrix)(unsafe.Pointer(bp + 16)).Fxx = v11
	v12 = libc.Float64FromInt32(0)
	(*TFcMatrix)(unsafe.Pointer(bp + 16)).Fyx = v12
	(*TFcMatrix)(unsafe.Pointer(bp + 16)).Fxy = v12
	libc.Xsscanf(tls, string1, __ccgo_ts+6811, libc.VaList(bp+88, bp+16, bp+16+8, bp+16+16, bp+16+24))
	*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcMatrixCopy(tls, bp+16)
	goto _10
_6:
	;
	*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcNameParseCharSet(tls, string1)
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) != 0) {
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
	}
	goto _10
_7:
	;
	*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcNameParseLangSet(tls, string1)
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) != 0) {
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
	}
	goto _10
_8:
	;
	if libc.Xsscanf(tls, string1, __ccgo_ts+6827, libc.VaList(bp+88, bp+48, bp+56)) != int32(2) {
		len1 = libc.Xstrlen(tls, string1)
		sc = libc.Xmalloc(tls, len1+uint64(1))
		ec = libc.Xmalloc(tls, len1+uint64(1))
		if !(sc != 0 && ec != 0 && libc.Xsscanf(tls, string1, __ccgo_ts+6837, libc.VaList(bp+88, sc, ec)) == int32(2)) {
			goto _13
		}
		if XFcNameConstantWithObjectCheck(tls, sc, object, bp+72) != 0 && XFcNameConstantWithObjectCheck(tls, ec, object, bp+76) != 0 {
			*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcRangeCreateDouble(tls, float64(*(*int32)(unsafe.Pointer(bp + 72))), float64(*(*int32)(unsafe.Pointer(bp + 76))))
		} else {
			goto bail1
		}
		goto _14
	_13:
		;
		goto bail1
	bail1:
		;
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeDouble)
		if XFcNameConstantWithObjectCheck(tls, string1, object, bp+72) != 0 {
			*(*float64)(unsafe.Pointer(bp + 8)) = float64(*(*int32)(unsafe.Pointer(bp + 72)))
		} else {
			*(*float64)(unsafe.Pointer(bp + 8)) = libc.Xstrtod(tls, string1, bp+64)
			if *(*uintptr)(unsafe.Pointer(bp + 64)) != libc.UintptrFromInt32(0) && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 64))))) != 0 {
				(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
			}
		}
	_14:
		;
		if sc != 0 {
			libc.Xfree(tls, sc)
		}
		if ec != 0 {
			libc.Xfree(tls, ec)
		}
	} else {
		*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcRangeCreateDouble(tls, *(*float64)(unsafe.Pointer(bp + 48)), *(*float64)(unsafe.Pointer(bp + 56)))
	}
	goto _10
_9:
	;
	goto _10
_10:
	;
	return *(*TFcValue)(unsafe.Pointer(bp))
}

func _FcNameFindNext(tls *libc.TLS, cur uintptr, delim uintptr, save uintptr, last uintptr) (r uintptr) {
	var c, v1, v11, v12 TFcChar8
	var v13 uintptr
	var v2, v6, v8, v9 int32
	var v4 t__darwin_ct_rune_t
	var v5 uint64
	_, _, _, _, _, _, _, _, _, _, _ = c, v1, v11, v12, v13, v2, v4, v5, v6, v8, v9
	for {
		v1 = *(*TFcChar8)(unsafe.Pointer(cur))
		c = v1
		if !(v1 != 0) {
			break
		}
		v4 = libc.Int32FromUint8(c)
		v5 = uint64(0x00004000)
		v9 = libc.BoolInt32(v4 & ^libc.Int32FromInt32(0x7F) == 0)
		goto _10
	_10:
		if v9 != 0 {
			v8 = libc.BoolInt32(!!(uint64(*(*t__uint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&libc.X_DefaultRuneLocale)) + 60 + uintptr(v4)*4)))&v5 != 0))
		} else {
			v8 = libc.BoolInt32(!!(libc.X__maskrune(tls, v4, v5) != 0))
		}
		v6 = v8
		goto _7
	_7:
		v2 = v6
		goto _3
	_3:
		if !(v2 != 0) {
			break
		}
		cur++
	}
	for {
		v11 = *(*TFcChar8)(unsafe.Pointer(cur))
		c = v11
		if !(v11 != 0) {
			break
		}
		if libc.Int32FromUint8(c) == int32('\\') {
			cur++
			v12 = *(*TFcChar8)(unsafe.Pointer(cur))
			c = v12
			if !(v12 != 0) {
				break
			}
		} else {
			if libc.Xstrchr(tls, delim, libc.Int32FromUint8(c)) != 0 {
				break
			}
		}
		cur++
		v13 = save
		save++
		*(*TFcChar8)(unsafe.Pointer(v13)) = c
	}
	*(*TFcChar8)(unsafe.Pointer(save)) = uint8(0)
	*(*TFcChar8)(unsafe.Pointer(last)) = *(*TFcChar8)(unsafe.Pointer(cur))
	if *(*TFcChar8)(unsafe.Pointer(cur)) != 0 {
		cur++
	}
	return cur
}

func XFcNameParse(tls *libc.TLS, name uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, pat, save, t, v4 uintptr
	var d float64
	var v TFcValue
	var _ /* delim at bp+8 */ TFcChar8
	var _ /* e at bp+0 */ uintptr
	_, _, _, _, _, _, _ = c, d, pat, save, t, v, v4
	/* freed below */
	save = libc.Xmalloc(tls, libc.Xstrlen(tls, name)+uint64(1))
	if !(save != 0) {
		goto bail0
	}
	pat = XFcPatternCreate(tls)
	if !(pat != 0) {
		goto bail1
	}
	for {
		name = _FcNameFindNext(tls, name, __ccgo_ts+6848, save, bp+8)
		if *(*TFcChar8)(unsafe.Pointer(save)) != 0 {
			if !(XFcPatternObjectAddString(tls, pat, int32(_FC_FAMILY_OBJECT), save) != 0) {
				goto bail2
			}
		}
		if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(bp + 8))) != int32(',') {
			break
		}
		goto _1
	_1:
	}
	if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(bp + 8))) == int32('-') {
		for {
			name = _FcNameFindNext(tls, name, __ccgo_ts+6848, save, bp+8)
			d = libc.Xstrtod(tls, save, bp)
			if *(*uintptr)(unsafe.Pointer(bp)) != save {
				if !(XFcPatternObjectAddDouble(tls, pat, int32(_FC_SIZE_OBJECT), d) != 0) {
					goto bail2
				}
			}
			if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(bp + 8))) != int32(',') {
				break
			}
			goto _2
		_2:
		}
	}
	for libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(bp + 8))) == int32(':') {
		name = _FcNameFindNext(tls, name, __ccgo_ts+6852, save, bp+8)
		if *(*TFcChar8)(unsafe.Pointer(save)) != 0 {
			if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(bp + 8))) == int32('=') || libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(bp + 8))) == int32('_') {
				t = XFcNameGetObjectType(tls, save)
				for {
					name = _FcNameFindNext(tls, name, __ccgo_ts+6856, save, bp+8)
					if t != 0 {
						v = _FcNameConvert(tls, (*TFcObjectType)(unsafe.Pointer(t)).Ftype1, (*TFcObjectType)(unsafe.Pointer(t)).Fobject, save)
						if !(XFcPatternAdd(tls, pat, (*TFcObjectType)(unsafe.Pointer(t)).Fobject, v, int32(m_FcTrue)) != 0) {
							XFcValueDestroy(tls, v)
							goto bail2
						}
						XFcValueDestroy(tls, v)
					}
					if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(bp + 8))) != int32(',') {
						break
					}
					goto _3
				_3:
				}
			} else {
				v4 = XFcNameGetConstant(tls, save)
				c = v4
				if v4 != 0 {
					t = XFcNameGetObjectType(tls, (*TFcConstant)(unsafe.Pointer(c)).Fobject)
					if t == libc.UintptrFromInt32(0) {
						goto bail2
					}
					switch (*TFcObjectType)(unsafe.Pointer(t)).Ftype1 {
					case int32(_FcTypeInteger):
						fallthrough
					case int32(_FcTypeDouble):
						if !(XFcPatternAddInteger(tls, pat, (*TFcConstant)(unsafe.Pointer(c)).Fobject, (*TFcConstant)(unsafe.Pointer(c)).Fvalue) != 0) {
							goto bail2
						}
					case int32(_FcTypeBool):
						if !(XFcPatternAddBool(tls, pat, (*TFcConstant)(unsafe.Pointer(c)).Fobject, (*TFcConstant)(unsafe.Pointer(c)).Fvalue) != 0) {
							goto bail2
						}
					case int32(_FcTypeRange):
						if !(XFcPatternAddInteger(tls, pat, (*TFcConstant)(unsafe.Pointer(c)).Fobject, (*TFcConstant)(unsafe.Pointer(c)).Fvalue) != 0) {
							goto bail2
						}
					default:
						break
					}
				}
			}
		}
	}
	libc.Xfree(tls, save)
	return pat
	goto bail2
bail2:
	;
	XFcPatternDestroy(tls, pat)
	goto bail1
bail1:
	;
	libc.Xfree(tls, save)
	goto bail0
bail0:
	;
	return uintptr(0)
	return r
}

func _FcNameUnparseString(tls *libc.TLS, buf uintptr, string1 uintptr, escape uintptr) (r TFcBool) {
	var c, v1 TFcChar8
	var v2 uintptr
	_, _, _ = c, v1, v2
	for {
		v2 = string1
		string1++
		v1 = *(*TFcChar8)(unsafe.Pointer(v2))
		c = v1
		if !(v1 != 0) {
			break
		}
		if escape != 0 && libc.Xstrchr(tls, escape, int32(libc.Int8FromUint8(c))) != 0 {
			if !(XFcStrBufChar(tls, buf, *(*TFcChar8)(unsafe.Pointer(escape))) != 0) {
				return m_FcFalse
			}
		}
		if !(XFcStrBufChar(tls, buf, c) != 0) {
			return m_FcFalse
		}
	}
	return int32(m_FcTrue)
}

func XFcNameUnparseValue(tls *libc.TLS, buf uintptr, v0 uintptr, escape uintptr) (r TFcBool) {
	bp := tls.Alloc(1088)
	defer tls.Free(1088)
	var v1, v2 uintptr
	var _ /* temp at bp+0 */ [1024]TFcChar8
	var _ /* v at bp+1024 */ TFcValue
	_, _ = v1, v2
	*(*TFcValue)(unsafe.Pointer(bp + 1024)) = TFcValue{}
	*(*T_FcValue)(unsafe.Pointer(bp + 1024)) = XFcValueCanonicalize(tls, v0)
	switch (*(*TFcValue)(unsafe.Pointer(bp + 1024))).Ftype1 {
	case int32(_FcTypeUnknown):
		fallthrough
	case int32(_FcTypeVoid):
		return int32(m_FcTrue)
	case int32(_FcTypeInteger):
		libc.X__builtin___sprintf_chk(tls, bp, 0, ^t__predefined_size_t(0), __ccgo_ts+2470, libc.VaList(bp+1048, *(*int32)(unsafe.Pointer(bp + 1024 + 8))))
		return _FcNameUnparseString(tls, buf, bp, uintptr(0))
	case int32(_FcTypeDouble):
		libc.X__builtin___sprintf_chk(tls, bp, 0, ^t__predefined_size_t(0), __ccgo_ts+2473, libc.VaList(bp+1048, *(*float64)(unsafe.Pointer(bp + 1024 + 8))))
		return _FcNameUnparseString(tls, buf, bp, uintptr(0))
	case int32(_FcTypeString):
		return _FcNameUnparseString(tls, buf, *(*uintptr)(unsafe.Pointer(bp + 1024 + 8)), escape)
	case int32(_FcTypeBool):
		if *(*TFcBool)(unsafe.Pointer(bp + 1024 + 8)) == int32(m_FcTrue) {
			v1 = __ccgo_ts + 1904
		} else {
			if *(*TFcBool)(unsafe.Pointer(bp + 1024 + 8)) == m_FcFalse {
				v2 = __ccgo_ts + 1909
			} else {
				v2 = __ccgo_ts + 1915
			}
			v1 = v2
		}
		return _FcNameUnparseString(tls, buf, v1, uintptr(0))
	case int32(_FcTypeMatrix):
		libc.X__builtin___sprintf_chk(tls, bp, 0, ^t__predefined_size_t(0), __ccgo_ts+6859, libc.VaList(bp+1048, (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 1024 + 8)))).Fxx, (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 1024 + 8)))).Fxy, (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 1024 + 8)))).Fyx, (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 1024 + 8)))).Fyy))
		return _FcNameUnparseString(tls, buf, bp, uintptr(0))
	case int32(_FcTypeCharSet):
		return XFcNameUnparseCharSet(tls, buf, *(*uintptr)(unsafe.Pointer(bp + 1024 + 8)))
	case int32(_FcTypeLangSet):
		return XFcNameUnparseLangSet(tls, buf, *(*uintptr)(unsafe.Pointer(bp + 1024 + 8)))
	case int32(_FcTypeFTFace):
		return int32(m_FcTrue)
	case int32(_FcTypeRange):
		libc.X__builtin___sprintf_chk(tls, bp, 0, ^t__predefined_size_t(0), __ccgo_ts+1944, libc.VaList(bp+1048, (*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 1024 + 8)))).Fbegin, (*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 1024 + 8)))).Fend))
		return _FcNameUnparseString(tls, buf, bp, uintptr(0))
	}
	return m_FcFalse
}

func XFcNameUnparseValueList(tls *libc.TLS, buf uintptr, v TFcValueListPtr, escape uintptr) (r TFcBool) {
	var v1 TFcValueListPtr
	var v2 uintptr
	_, _ = v1, v2
	for v != 0 {
		if !(XFcNameUnparseValue(tls, buf, v+8, escape) != 0) {
			return m_FcFalse
		}
		if int64((*T_FcValueList)(unsafe.Pointer(v)).Fnext)&int64(1) != 0 {
			v2 = uintptr(int64(v) + int64((*T_FcValueList)(unsafe.Pointer(v)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*T_FcValueList)(unsafe.Pointer(v)).Fnext
		}
		v1 = v2
		v = v1
		if v1 != libc.UintptrFromInt32(0) {
			if !(_FcNameUnparseString(tls, buf, __ccgo_ts+6871, uintptr(0)) != 0) {
				return m_FcFalse
			}
		}
	}
	return int32(m_FcTrue)
}

func XFcNameUnparse(tls *libc.TLS, pat uintptr) (r uintptr) {
	return XFcNameUnparseEscaped(tls, pat, int32(m_FcTrue))
}

func XFcNameUnparseEscaped(tls *libc.TLS, pat uintptr, escape TFcBool) (r uintptr) {
	bp := tls.Alloc(8752)
	defer tls.Free(8752)
	var e, o, p, v1, v2, v3, v4, v6, v7, v8 uintptr
	var i int32
	var id TFcObject
	var _ /* buf at bp+0 */ TFcStrBuf
	var _ /* buf2 at bp+152 */ TFcStrBuf
	var _ /* buf2_static at bp+8496 */ [256]TFcChar8
	var _ /* buf_static at bp+304 */ [8192]TFcChar8
	_, _, _, _, _, _, _, _, _, _, _, _ = e, i, id, o, p, v1, v2, v3, v4, v6, v7, v8
	XFcStrBufInit(tls, bp, bp+304, int32(8192))
	XFcStrBufInit(tls, bp+152, bp+8496, int32(256))
	e = XFcPatternObjectFindElt(tls, pat, int32(_FC_FAMILY_OBJECT))
	if e != 0 {
		if int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(1) != 0 {
			v1 = uintptr(int64(e) + int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v1 = (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues
		}
		if escape != 0 {
			v2 = __ccgo_ts + 6873
		} else {
			v2 = uintptr(0)
		}
		if !(XFcNameUnparseValueList(tls, bp, v1, v2) != 0) {
			goto bail0
		}
	}
	e = XFcPatternObjectFindElt(tls, pat, int32(_FC_SIZE_OBJECT))
	if e != 0 {
		if !(_FcNameUnparseString(tls, bp+152, __ccgo_ts+6878, uintptr(0)) != 0) {
			goto bail0
		}
		if int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(1) != 0 {
			v3 = uintptr(int64(e) + int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v3 = (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues
		}
		if escape != 0 {
			v4 = __ccgo_ts + 6873
		} else {
			v4 = uintptr(0)
		}
		if !(XFcNameUnparseValueList(tls, bp+152, v3, v4) != 0) {
			goto bail0
		}
		p = XFcStrBufDoneStatic(tls, bp+152)
		XFcStrBufDestroy(tls, bp+152)
		if libc.Xstrlen(tls, p) > uint64(1) {
			if !(XFcStrBufString(tls, bp, p) != 0) {
				goto bail0
			}
		}
	}
	i = 0
	for {
		if !(i < libc.Int32FromUint64(libc.Uint64FromInt64(832)/libc.Uint64FromInt64(16))) {
			break
		}
		id = i + int32(1)
		o = uintptr(unsafe.Pointer(&_FcObjects)) + uintptr(i)*16
		if !(libc.Xstrcmp(tls, (*TFcObjectType)(unsafe.Pointer(o)).Fobject, __ccgo_ts+5977) != 0) || !(libc.Xstrcmp(tls, (*TFcObjectType)(unsafe.Pointer(o)).Fobject, __ccgo_ts+6212) != 0) {
			goto _5
		}
		e = XFcPatternObjectFindElt(tls, pat, id)
		if e != 0 {
			if !(_FcNameUnparseString(tls, bp, __ccgo_ts+6880, uintptr(0)) != 0) {
				goto bail0
			}
			if escape != 0 {
				v6 = __ccgo_ts + 6882
			} else {
				v6 = uintptr(0)
			}
			if !(_FcNameUnparseString(tls, bp, (*TFcObjectType)(unsafe.Pointer(o)).Fobject, v6) != 0) {
				goto bail0
			}
			if !(_FcNameUnparseString(tls, bp, __ccgo_ts+6888, uintptr(0)) != 0) {
				goto bail0
			}
			if int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(1) != 0 {
				v7 = uintptr(int64(e) + int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(^libc.Int32FromInt32(1)))
			} else {
				v7 = (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues
			}
			if escape != 0 {
				v8 = __ccgo_ts + 6882
			} else {
				v8 = uintptr(0)
			}
			if !(XFcNameUnparseValueList(tls, bp, v7, v8) != 0) {
				goto bail0
			}
		}
		goto _5
	_5:
		;
		i++
	}
	return XFcStrBufDone(tls, bp)
	goto bail0
bail0:
	;
	XFcStrBufDestroy(tls, bp)
	return uintptr(0)
}

/* ANSI-C code produced by gperf version 3.0.3 */
/* Command-line: /Library/Developer/CommandLineTools/usr/bin/gperf --pic -m 100 fcobjshash.gperf  */
/* Computed positions: -k'3,5' */

type TFcObjectTypeInfo = struct {
	Fname int32
	Fid   int32
}

/*
 * Copyright (c) 2000, 2007, 2010, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*
 * This header is designed to be included multiple times. If any of the __need_
 * macros are defined, then only that subset of interfaces are provided. This
 * can be useful for POSIX headers that need to not expose all of stddef.h, but
 * need to use some of its interfaces. Otherwise this header provides all of
 * the expected interfaces.
 *
 * When clang modules are enabled, this header is a textual header to support
 * the multiple include behavior. As such, it doesn't directly declare anything
 * so that it doesn't add duplicate declarations to all of its includers'
 * modules.
 */

/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
/* wint_t is provided by <wchar.h> and not <stddef.h>. It's here
 * for compatibility, but must be explicitly requested. Therefore
 * __need_wint_t is intentionally not defined here. */
/*===---- __stddef_header_macro.h ------------------------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*===---- __stddef_ptrdiff_t.h - Definition of ptrdiff_t -------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*
 * When -fbuiltin-headers-in-system-modules is set this is a non-modular header
 * and needs to behave as if it was textual.
 */

/*===---- __stddef_size_t.h - Definition of size_t -------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*
 * When -fbuiltin-headers-in-system-modules is set this is a non-modular header
 * and needs to behave as if it was textual.
 */

/*===---- __stddef_rsize_t.h - Definition of rsize_t -----------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*
 * When -fbuiltin-headers-in-system-modules is set this is a non-modular header
 * and needs to behave as if it was textual.
 */

/*===---- __stddef_wchar.h - Definition of wchar_t -------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*
 * When -fbuiltin-headers-in-system-modules is set this is a non-modular header
 * and needs to behave as if it was textual.
 */

/*===---- __stddef_max_align_t.h - Definition of max_align_t ---------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*===---- __stddef_offsetof.h - Definition of offsetof ---------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

/*
 * When -fbuiltin-headers-in-system-modules is set this is a non-modular header
 * and needs to behave as if it was textual.
 */

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */

/* maximum key range = 59, duplicates = 0 */

func _FcObjectTypeHash(tls *libc.TLS, str uintptr, len1 uint32) (r uint32) {
	var hval uint32
	_ = hval
	hval = len1
	switch hval {
	default:
		hval += uint32(_asso_values[libc.Uint8FromInt8(*(*int8)(unsafe.Pointer(str + 4)))])
		/*FALLTHROUGH*/
		fallthrough
	case uint32(4):
		fallthrough
	case uint32(3):
		hval += uint32(_asso_values[libc.Uint8FromInt8(*(*int8)(unsafe.Pointer(str + 2)))])
		break
	}
	return hval
}

var _asso_values = [256]uint8{
	0:   uint8(66),
	1:   uint8(66),
	2:   uint8(66),
	3:   uint8(66),
	4:   uint8(66),
	5:   uint8(66),
	6:   uint8(66),
	7:   uint8(66),
	8:   uint8(66),
	9:   uint8(66),
	10:  uint8(66),
	11:  uint8(66),
	12:  uint8(66),
	13:  uint8(66),
	14:  uint8(66),
	15:  uint8(66),
	16:  uint8(66),
	17:  uint8(66),
	18:  uint8(66),
	19:  uint8(66),
	20:  uint8(66),
	21:  uint8(66),
	22:  uint8(66),
	23:  uint8(66),
	24:  uint8(66),
	25:  uint8(66),
	26:  uint8(66),
	27:  uint8(66),
	28:  uint8(66),
	29:  uint8(66),
	30:  uint8(66),
	31:  uint8(66),
	32:  uint8(66),
	33:  uint8(66),
	34:  uint8(66),
	35:  uint8(66),
	36:  uint8(66),
	37:  uint8(66),
	38:  uint8(66),
	39:  uint8(66),
	40:  uint8(66),
	41:  uint8(66),
	42:  uint8(66),
	43:  uint8(66),
	44:  uint8(66),
	45:  uint8(66),
	46:  uint8(66),
	47:  uint8(66),
	48:  uint8(66),
	49:  uint8(66),
	50:  uint8(66),
	51:  uint8(66),
	52:  uint8(66),
	53:  uint8(66),
	54:  uint8(66),
	55:  uint8(66),
	56:  uint8(66),
	57:  uint8(66),
	58:  uint8(66),
	59:  uint8(66),
	60:  uint8(66),
	61:  uint8(66),
	62:  uint8(66),
	63:  uint8(66),
	64:  uint8(66),
	65:  uint8(66),
	66:  uint8(66),
	67:  uint8(66),
	68:  uint8(66),
	69:  uint8(66),
	70:  uint8(66),
	71:  uint8(66),
	72:  uint8(66),
	73:  uint8(66),
	74:  uint8(66),
	75:  uint8(66),
	76:  uint8(66),
	77:  uint8(66),
	78:  uint8(66),
	79:  uint8(66),
	80:  uint8(66),
	81:  uint8(66),
	82:  uint8(66),
	83:  uint8(66),
	84:  uint8(66),
	85:  uint8(66),
	86:  uint8(66),
	87:  uint8(66),
	88:  uint8(66),
	89:  uint8(66),
	90:  uint8(66),
	91:  uint8(66),
	92:  uint8(66),
	93:  uint8(66),
	94:  uint8(66),
	95:  uint8(66),
	96:  uint8(66),
	97:  uint8(4),
	98:  uint8(10),
	99:  uint8(32),
	100: uint8(21),
	101: uint8(29),
	102: uint8(28),
	103: uint8(49),
	104: uint8(14),
	105: uint8(4),
	106: uint8(66),
	107: uint8(66),
	108: uint8(5),
	109: uint8(31),
	110: uint8(18),
	111: uint8(22),
	112: uint8(27),
	113: uint8(66),
	114: uint8(15),
	115: uint8(9),
	116: uint8(8),
	117: uint8(23),
	118: uint8(23),
	119: uint8(13),
	120: uint8(23),
	121: uint8(16),
	122: uint8(4),
	123: uint8(66),
	124: uint8(66),
	125: uint8(66),
	126: uint8(66),
	127: uint8(66),
	128: uint8(66),
	129: uint8(66),
	130: uint8(66),
	131: uint8(66),
	132: uint8(66),
	133: uint8(66),
	134: uint8(66),
	135: uint8(66),
	136: uint8(66),
	137: uint8(66),
	138: uint8(66),
	139: uint8(66),
	140: uint8(66),
	141: uint8(66),
	142: uint8(66),
	143: uint8(66),
	144: uint8(66),
	145: uint8(66),
	146: uint8(66),
	147: uint8(66),
	148: uint8(66),
	149: uint8(66),
	150: uint8(66),
	151: uint8(66),
	152: uint8(66),
	153: uint8(66),
	154: uint8(66),
	155: uint8(66),
	156: uint8(66),
	157: uint8(66),
	158: uint8(66),
	159: uint8(66),
	160: uint8(66),
	161: uint8(66),
	162: uint8(66),
	163: uint8(66),
	164: uint8(66),
	165: uint8(66),
	166: uint8(66),
	167: uint8(66),
	168: uint8(66),
	169: uint8(66),
	170: uint8(66),
	171: uint8(66),
	172: uint8(66),
	173: uint8(66),
	174: uint8(66),
	175: uint8(66),
	176: uint8(66),
	177: uint8(66),
	178: uint8(66),
	179: uint8(66),
	180: uint8(66),
	181: uint8(66),
	182: uint8(66),
	183: uint8(66),
	184: uint8(66),
	185: uint8(66),
	186: uint8(66),
	187: uint8(66),
	188: uint8(66),
	189: uint8(66),
	190: uint8(66),
	191: uint8(66),
	192: uint8(66),
	193: uint8(66),
	194: uint8(66),
	195: uint8(66),
	196: uint8(66),
	197: uint8(66),
	198: uint8(66),
	199: uint8(66),
	200: uint8(66),
	201: uint8(66),
	202: uint8(66),
	203: uint8(66),
	204: uint8(66),
	205: uint8(66),
	206: uint8(66),
	207: uint8(66),
	208: uint8(66),
	209: uint8(66),
	210: uint8(66),
	211: uint8(66),
	212: uint8(66),
	213: uint8(66),
	214: uint8(66),
	215: uint8(66),
	216: uint8(66),
	217: uint8(66),
	218: uint8(66),
	219: uint8(66),
	220: uint8(66),
	221: uint8(66),
	222: uint8(66),
	223: uint8(66),
	224: uint8(66),
	225: uint8(66),
	226: uint8(66),
	227: uint8(66),
	228: uint8(66),
	229: uint8(66),
	230: uint8(66),
	231: uint8(66),
	232: uint8(66),
	233: uint8(66),
	234: uint8(66),
	235: uint8(66),
	236: uint8(66),
	237: uint8(66),
	238: uint8(66),
	239: uint8(66),
	240: uint8(66),
	241: uint8(66),
	242: uint8(66),
	243: uint8(66),
	244: uint8(66),
	245: uint8(66),
	246: uint8(66),
	247: uint8(66),
	248: uint8(66),
	249: uint8(66),
	250: uint8(66),
	251: uint8(66),
	252: uint8(66),
	253: uint8(66),
	254: uint8(66),
	255: uint8(66),
}

type TFcObjectTypeNamePool_t = struct {
	FFcObjectTypeNamePool_str7  [4]int8
	FFcObjectTypeNamePool_str8  [5]int8
	FFcObjectTypeNamePool_str9  [5]int8
	FFcObjectTypeNamePool_str13 [5]int8
	FFcObjectTypeNamePool_str14 [5]int8
	FFcObjectTypeNamePool_str15 [8]int8
	FFcObjectTypeNamePool_str16 [9]int8
	FFcObjectTypeNamePool_str17 [6]int8
	FFcObjectTypeNamePool_str18 [7]int8
	FFcObjectTypeNamePool_str19 [8]int8
	FFcObjectTypeNamePool_str20 [8]int8
	FFcObjectTypeNamePool_str21 [10]int8
	FFcObjectTypeNamePool_str22 [5]int8
	FFcObjectTypeNamePool_str23 [9]int8
	FFcObjectTypeNamePool_str24 [7]int8
	FFcObjectTypeNamePool_str25 [6]int8
	FFcObjectTypeNamePool_str26 [10]int8
	FFcObjectTypeNamePool_str27 [9]int8
	FFcObjectTypeNamePool_str28 [11]int8
	FFcObjectTypeNamePool_str29 [8]int8
	FFcObjectTypeNamePool_str30 [9]int8
	FFcObjectTypeNamePool_str31 [9]int8
	FFcObjectTypeNamePool_str32 [15]int8
	FFcObjectTypeNamePool_str33 [15]int8
	FFcObjectTypeNamePool_str34 [10]int8
	FFcObjectTypeNamePool_str35 [13]int8
	FFcObjectTypeNamePool_str36 [10]int8
	FFcObjectTypeNamePool_str37 [10]int8
	FFcObjectTypeNamePool_str38 [6]int8
	FFcObjectTypeNamePool_str39 [14]int8
	FFcObjectTypeNamePool_str40 [6]int8
	FFcObjectTypeNamePool_str41 [6]int8
	FFcObjectTypeNamePool_str42 [7]int8
	FFcObjectTypeNamePool_str43 [12]int8
	FFcObjectTypeNamePool_str44 [9]int8
	FFcObjectTypeNamePool_str45 [15]int8
	FFcObjectTypeNamePool_str46 [11]int8
	FFcObjectTypeNamePool_str47 [11]int8
	FFcObjectTypeNamePool_str48 [11]int8
	FFcObjectTypeNamePool_str49 [6]int8
	FFcObjectTypeNamePool_str50 [6]int8
	FFcObjectTypeNamePool_str51 [8]int8
	FFcObjectTypeNamePool_str52 [12]int8
	FFcObjectTypeNamePool_str53 [9]int8
	FFcObjectTypeNamePool_str54 [10]int8
	FFcObjectTypeNamePool_str55 [15]int8
	FFcObjectTypeNamePool_str56 [11]int8
	FFcObjectTypeNamePool_str57 [11]int8
	FFcObjectTypeNamePool_str58 [13]int8
	FFcObjectTypeNamePool_str59 [7]int8
	FFcObjectTypeNamePool_str60 [8]int8
	FFcObjectTypeNamePool_str65 [7]int8
}

var _FcObjectTypeNamePool_contents = TFcObjectTypeNamePool_t{
	FFcObjectTypeNamePool_str7:  [4]int8{'d', 'p', 'i'},
	FFcObjectTypeNamePool_str8:  [5]int8{'s', 'i', 'z', 'e'},
	FFcObjectTypeNamePool_str9:  [5]int8{'f', 'i', 'l', 'e'},
	FFcObjectTypeNamePool_str13: [5]int8{'h', 'a', 's', 'h'},
	FFcObjectTypeNamePool_str14: [5]int8{'r', 'g', 'b', 'a'},
	FFcObjectTypeNamePool_str15: [8]int8{'s', 'p', 'a', 'c', 'i', 'n', 'g'},
	FFcObjectTypeNamePool_str16: [9]int8{'s', 'c', 'a', 'l', 'a', 'b', 'l', 'e'},
	FFcObjectTypeNamePool_str17: [6]int8{'s', 'l', 'a', 'n', 't'},
	FFcObjectTypeNamePool_str18: [7]int8{'m', 'a', 't', 'r', 'i', 'x'},
	FFcObjectTypeNamePool_str19: [8]int8{'o', 'u', 't', 'l', 'i', 'n', 'e'},
	FFcObjectTypeNamePool_str20: [8]int8{'c', 'h', 'a', 'r', 's', 'e', 't'},
	FFcObjectTypeNamePool_str21: [10]int8{'a', 'n', 't', 'i', 'a', 'l', 'i', 'a', 's'},
	FFcObjectTypeNamePool_str22: [5]int8{'l', 'a', 'n', 'g'},
	FFcObjectTypeNamePool_str23: [9]int8{'e', 'm', 'b', 'o', 'l', 'd', 'e', 'n'},
	FFcObjectTypeNamePool_str24: [7]int8{'w', 'e', 'i', 'g', 'h', 't'},
	FFcObjectTypeNamePool_str25: [6]int8{'c', 'o', 'l', 'o', 'r'},
	FFcObjectTypeNamePool_str26: [10]int8{'c', 'h', 'a', 'r', 'w', 'i', 'd', 't', 'h'},
	FFcObjectTypeNamePool_str27: [9]int8{'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e'},
	FFcObjectTypeNamePool_str28: [11]int8{'c', 'h', 'a', 'r', 'h', 'e', 'i', 'g', 'h', 't'},
	FFcObjectTypeNamePool_str29: [8]int8{'h', 'i', 'n', 't', 'i', 'n', 'g'},
	FFcObjectTypeNamePool_str30: [9]int8{'a', 'u', 't', 'o', 'h', 'i', 'n', 't'},
	FFcObjectTypeNamePool_str31: [9]int8{'f', 'u', 'l', 'l', 'n', 'a', 'm', 'e'},
	FFcObjectTypeNamePool_str32: [15]int8{'p', 'o', 's', 't', 's', 'c', 'r', 'i', 'p', 't', 'n', 'a', 'm', 'e'},
	FFcObjectTypeNamePool_str33: [15]int8{'v', 'e', 'r', 't', 'i', 'c', 'a', 'l', 'l', 'a', 'y', 'o', 'u', 't'},
	FFcObjectTypeNamePool_str34: [10]int8{'l', 'c', 'd', 'f', 'i', 'l', 't', 'e', 'r'},
	FFcObjectTypeNamePool_str35: [13]int8{'f', 'u', 'l', 'l', 'n', 'a', 'm', 'e', 'l', 'a', 'n', 'g'},
	FFcObjectTypeNamePool_str36: [10]int8{'h', 'i', 'n', 't', 's', 't', 'y', 'l', 'e'},
	FFcObjectTypeNamePool_str37: [10]int8{'p', 'i', 'x', 'e', 'l', 's', 'i', 'z', 'e'},
	FFcObjectTypeNamePool_str38: [6]int8{'s', 'c', 'a', 'l', 'e'},
	FFcObjectTypeNamePool_str39: [14]int8{'g', 'l', 'o', 'b', 'a', 'l', 'a', 'd', 'v', 'a', 'n', 'c', 'e'},
	FFcObjectTypeNamePool_str40: [6]int8{'w', 'i', 'd', 't', 'h'},
	FFcObjectTypeNamePool_str41: [6]int8{'o', 'r', 'd', 'e', 'r'},
	FFcObjectTypeNamePool_str42: [7]int8{'f', 'a', 'm', 'i', 'l', 'y'},
	FFcObjectTypeNamePool_str43: [12]int8{'f', 'o', 'n', 't', 'h', 'a', 's', 'h', 'i', 'n', 't'},
	FFcObjectTypeNamePool_str44: [9]int8{'n', 'a', 'm', 'e', 'l', 'a', 'n', 'g'},
	FFcObjectTypeNamePool_str45: [15]int8{'e', 'm', 'b', 'e', 'd', 'd', 'e', 'd', 'b', 'i', 't', 'm', 'a', 'p'},
	FFcObjectTypeNamePool_str46: [11]int8{'f', 'a', 'm', 'i', 'l', 'y', 'l', 'a', 'n', 'g'},
	FFcObjectTypeNamePool_str47: [11]int8{'c', 'a', 'p', 'a', 'b', 'i', 'l', 'i', 't', 'y'},
	FFcObjectTypeNamePool_str48: [11]int8{'r', 'a', 's', 't', 'e', 'r', 'i', 'z', 'e', 'r'},
	FFcObjectTypeNamePool_str49: [6]int8{'i', 'n', 'd', 'e', 'x'},
	FFcObjectTypeNamePool_str50: [6]int8{'s', 't', 'y', 'l', 'e'},
	FFcObjectTypeNamePool_str51: [8]int8{'f', 'o', 'u', 'n', 'd', 'r', 'y'},
	FFcObjectTypeNamePool_str52: [12]int8{'f', 'o', 'n', 't', 'v', 'e', 'r', 's', 'i', 'o', 'n'},
	FFcObjectTypeNamePool_str53: [9]int8{'m', 'i', 'n', 's', 'p', 'a', 'c', 'e'},
	FFcObjectTypeNamePool_str54: [10]int8{'s', 't', 'y', 'l', 'e', 'l', 'a', 'n', 'g'},
	FFcObjectTypeNamePool_str55: [15]int8{'f', 'o', 'n', 't', 'v', 'a', 'r', 'i', 'a', 't', 'i', 'o', 'n', 's'},
	FFcObjectTypeNamePool_str56: [11]int8{'f', 'o', 'n', 't', 'f', 'o', 'r', 'm', 'a', 't'},
	FFcObjectTypeNamePool_str57: [11]int8{'d', 'e', 'c', 'o', 'r', 'a', 't', 'i', 'v', 'e'},
	FFcObjectTypeNamePool_str58: [13]int8{'f', 'o', 'n', 't', 'f', 'e', 'a', 't', 'u', 'r', 'e', 's'},
	FFcObjectTypeNamePool_str59: [7]int8{'s', 'y', 'm', 'b', 'o', 'l'},
	FFcObjectTypeNamePool_str60: [8]int8{'p', 'r', 'g', 'n', 'a', 'm', 'e'},
	FFcObjectTypeNamePool_str65: [7]int8{'a', 's', 'p', 'e', 'c', 't'},
}

func _FcObjectTypeLookup(tls *libc.TLS, str uintptr, len1 uint32) (r uintptr) {
	var key uint32
	var o int32
	var s uintptr
	_, _, _ = key, o, s
	if len1 <= libc.Uint32FromInt32(14) && len1 >= libc.Uint32FromInt32(3) {
		key = _FcObjectTypeHash(tls, str, len1)
		if key <= libc.Uint32FromInt32(65) {
			o = _wordlist[key].Fname
			if o >= 0 {
				s = uintptr(o) + uintptr(unsafe.Pointer(&_FcObjectTypeNamePool_contents))
				if int32(*(*int8)(unsafe.Pointer(str))) == int32(*(*int8)(unsafe.Pointer(s))) && !(libc.Xstrcmp(tls, str+uintptr(1), s+uintptr(1)) != 0) {
					return uintptr(unsafe.Pointer(&_wordlist)) + uintptr(key)*8
				}
			}
		}
	}
	return uintptr(0)
}

var _wordlist = [66]TFcObjectTypeInfo{
	0: {
		Fname: -int32(1),
	},
	1: {
		Fname: -int32(1),
	},
	2: {
		Fname: -int32(1),
	},
	3: {
		Fname: -int32(1),
	},
	4: {
		Fname: -int32(1),
	},
	5: {
		Fname: -int32(1),
	},
	6: {
		Fname: -int32(1),
	},
	7: {
		Fid: int32(_FC_DPI_OBJECT),
	},
	8: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 4)),
		Fid:   int32(_FC_SIZE_OBJECT),
	},
	9: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 9)),
		Fid:   int32(_FC_FILE_OBJECT),
	},
	10: {
		Fname: -int32(1),
	},
	11: {
		Fname: -int32(1),
	},
	12: {
		Fname: -int32(1),
	},
	13: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 14)),
		Fid:   int32(_FC_HASH_OBJECT),
	},
	14: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 19)),
		Fid:   int32(_FC_RGBA_OBJECT),
	},
	15: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 24)),
		Fid:   int32(_FC_SPACING_OBJECT),
	},
	16: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 32)),
		Fid:   int32(_FC_SCALABLE_OBJECT),
	},
	17: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 41)),
		Fid:   int32(_FC_SLANT_OBJECT),
	},
	18: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 47)),
		Fid:   int32(_FC_MATRIX_OBJECT),
	},
	19: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 54)),
		Fid:   int32(_FC_OUTLINE_OBJECT),
	},
	20: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 62)),
		Fid:   int32(_FC_CHARSET_OBJECT),
	},
	21: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 70)),
		Fid:   int32(_FC_ANTIALIAS_OBJECT),
	},
	22: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 80)),
		Fid:   int32(_FC_LANG_OBJECT),
	},
	23: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 85)),
		Fid:   int32(_FC_EMBOLDEN_OBJECT),
	},
	24: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 94)),
		Fid:   int32(_FC_WEIGHT_OBJECT),
	},
	25: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 101)),
		Fid:   int32(_FC_COLOR_OBJECT),
	},
	26: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 107)),
		Fid:   int32(_FC_CHARWIDTH_OBJECT),
	},
	27: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 117)),
		Fid:   int32(_FC_VARIABLE_OBJECT),
	},
	28: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 126)),
		Fid:   int32(_FC_CHAR_HEIGHT_OBJECT),
	},
	29: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 137)),
		Fid:   int32(_FC_HINTING_OBJECT),
	},
	30: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 145)),
		Fid:   int32(_FC_AUTOHINT_OBJECT),
	},
	31: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 154)),
		Fid:   int32(_FC_FULLNAME_OBJECT),
	},
	32: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 163)),
		Fid:   int32(_FC_POSTSCRIPT_NAME_OBJECT),
	},
	33: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 178)),
		Fid:   int32(_FC_VERTICAL_LAYOUT_OBJECT),
	},
	34: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 193)),
		Fid:   int32(_FC_LCD_FILTER_OBJECT),
	},
	35: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 203)),
		Fid:   int32(_FC_FULLNAMELANG_OBJECT),
	},
	36: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 216)),
		Fid:   int32(_FC_HINT_STYLE_OBJECT),
	},
	37: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 226)),
		Fid:   int32(_FC_PIXEL_SIZE_OBJECT),
	},
	38: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 236)),
		Fid:   int32(_FC_SCALE_OBJECT),
	},
	39: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 242)),
		Fid:   int32(_FC_GLOBAL_ADVANCE_OBJECT),
	},
	40: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 256)),
		Fid:   int32(_FC_WIDTH_OBJECT),
	},
	41: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 262)),
		Fid:   int32(_FC_ORDER_OBJECT),
	},
	42: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 268)),
		Fid:   int32(_FC_FAMILY_OBJECT),
	},
	43: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 275)),
		Fid:   int32(_FC_FONT_HAS_HINT_OBJECT),
	},
	44: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 287)),
		Fid:   int32(_FC_NAMELANG_OBJECT),
	},
	45: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 296)),
		Fid:   int32(_FC_EMBEDDED_BITMAP_OBJECT),
	},
	46: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 311)),
		Fid:   int32(_FC_FAMILYLANG_OBJECT),
	},
	47: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 322)),
		Fid:   int32(_FC_CAPABILITY_OBJECT),
	},
	48: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 333)),
		Fid:   int32(_FC_RASTERIZER_OBJECT),
	},
	49: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 344)),
		Fid:   int32(_FC_INDEX_OBJECT),
	},
	50: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 350)),
		Fid:   int32(_FC_STYLE_OBJECT),
	},
	51: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 356)),
		Fid:   int32(_FC_FOUNDRY_OBJECT),
	},
	52: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 364)),
		Fid:   int32(_FC_FONTVERSION_OBJECT),
	},
	53: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 376)),
		Fid:   int32(_FC_MINSPACE_OBJECT),
	},
	54: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 385)),
		Fid:   int32(_FC_STYLELANG_OBJECT),
	},
	55: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 395)),
		Fid:   int32(_FC_FONT_VARIATIONS_OBJECT),
	},
	56: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 410)),
		Fid:   int32(_FC_FONTFORMAT_OBJECT),
	},
	57: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 421)),
		Fid:   int32(_FC_DECORATIVE_OBJECT),
	},
	58: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 432)),
		Fid:   int32(_FC_FONT_FEATURES_OBJECT),
	},
	59: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 445)),
		Fid:   int32(_FC_SYMBOL_OBJECT),
	},
	60: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 452)),
		Fid:   int32(_FC_PRGNAME_OBJECT),
	},
	61: {
		Fname: -int32(1),
	},
	62: {
		Fname: -int32(1),
	},
	63: {
		Fname: -int32(1),
	},
	64: {
		Fname: -int32(1),
	},
	65: {
		Fname: libc.Int32FromUint64(uint64(libc.UintptrFromInt32(0) + 460)),
		Fid:   int32(_FC_ASPECT_OBJECT),
	},
}

/*
 * Copyright (c) 2000, 2007, 2010, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

// C documentation
//
//	/* The 1000 is to leave some room for future added internal objects, such
//	 * that caches from newer fontconfig can still be used with older fontconfig
//	 * without getting confused. */
var _next_id = int32(_FC_ONE_AFTER_MAX_BASE_OBJECT) - libc.Int32FromInt32(1) + libc.Int32FromInt32(m_FC_EXT_OBJ_INDEX)

type TFcObjectOtherTypeInfo = struct {
	Fnext   uintptr
	Fobject TFcObjectType
	Fid     TFcObject
}

func XFcObjectFini(tls *libc.TLS) {
	var ot, ots uintptr
	var v1 int32
	_, _, _ = ot, ots, v1
	goto retry
retry:
	;
	ots = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&Xother_types))))
	if !(ots != 0) {
		return
	}
	if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&Xother_types)))) == ots {
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&Xother_types)))) = libc.UintptrFromInt32(0)
		v1 = libc.Int32FromInt32(m_FcTrue)
	} else {
		v1 = m_FcFalse
	}
	if !(v1 != 0) {
		goto retry
	}
	for ots != 0 {
		ot = (*TFcObjectOtherTypeInfo)(unsafe.Pointer(ots)).Fnext
		if (*TFcObjectOtherTypeInfo)(unsafe.Pointer(ots)).Fobject.Fobject != 0 {
			libc.Xfree(tls, (*TFcObjectOtherTypeInfo)(unsafe.Pointer(ots)).Fobject.Fobject)
		}
		libc.Xfree(tls, ots)
		ots = ot
	}
}

func __FcObjectLookupOtherTypeByName(tls *libc.TLS, str uintptr, id uintptr) (r uintptr) {
	var ot, ots uintptr
	var v2 int32
	_, _, _ = ot, ots, v2
	goto retry
retry:
	;
	ots = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&Xother_types))))
	ot = ots
	for {
		if !(ot != 0) {
			break
		}
		if 0 == libc.Xstrcmp(tls, (*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fobject.Fobject, str) {
			break
		}
		goto _1
	_1:
		;
		ot = (*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fnext
	}
	if !(ot != 0) {
		ot = libc.Xmalloc(tls, uint64(32))
		if !(ot != 0) {
			return libc.UintptrFromInt32(0)
		}
		(*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fobject.Fobject = libc.Xstrdup(tls, str)
		(*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fobject.Ftype1 = int32(_FcTypeUnknown)
		_next_id += +libc.Int32FromInt32(1)
		(*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fid = _next_id - +libc.Int32FromInt32(1)
		if (*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fid < int32(_FC_ONE_AFTER_MAX_BASE_OBJECT)-libc.Int32FromInt32(1)+libc.Int32FromInt32(m_FC_EXT_OBJ_INDEX) {
			libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+6890, 0)
			libc.Xabort(tls)
		}
		(*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fnext = ots
		if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&Xother_types)))) == ots {
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&Xother_types)))) = ot
			v2 = libc.Int32FromInt32(m_FcTrue)
		} else {
			v2 = m_FcFalse
		}
		if !(v2 != 0) {
			if (*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fobject.Fobject != 0 {
				libc.Xfree(tls, (*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fobject.Fobject)
			}
			libc.Xfree(tls, ot)
			goto retry
		}
	}
	if id != 0 {
		*(*TFcObject)(unsafe.Pointer(id)) = (*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fid
	}
	return ot + 8
}

func XFcObjectLookupBuiltinIdByName(tls *libc.TLS, str uintptr) (r TFcObject) {
	var o uintptr
	_ = o
	o = _FcObjectTypeLookup(tls, str, uint32(libc.Xstrlen(tls, str)))
	if o != 0 {
		return (*TFcObjectTypeInfo)(unsafe.Pointer(o)).Fid
	}
	return 0
}

func XFcObjectLookupIdByName(tls *libc.TLS, str uintptr) (r TFcObject) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var o uintptr
	var _ /* id at bp+0 */ TFcObject
	_ = o
	o = _FcObjectTypeLookup(tls, str, uint32(libc.Xstrlen(tls, str)))
	if o != 0 {
		return (*TFcObjectTypeInfo)(unsafe.Pointer(o)).Fid
	}
	if __FcObjectLookupOtherTypeByName(tls, str, bp) != 0 {
		return *(*TFcObject)(unsafe.Pointer(bp))
	}
	return 0
}

func XFcObjectLookupOtherNameById(tls *libc.TLS, id TFcObject) (r uintptr) {
	var ot uintptr
	_ = ot
	ot = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&Xother_types))))
	for {
		if !(ot != 0) {
			break
		}
		if (*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fid == id {
			return (*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fobject.Fobject
		}
		goto _1
	_1:
		;
		ot = (*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fnext
	}
	return libc.UintptrFromInt32(0)
}

func XFcObjectLookupOtherTypeByName(tls *libc.TLS, str uintptr) (r uintptr) {
	return __FcObjectLookupOtherTypeByName(tls, str, libc.UintptrFromInt32(0))
}

func XFcObjectLookupOtherTypeById(tls *libc.TLS, id TFcObject) (r uintptr) {
	var ot uintptr
	_ = ot
	ot = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&Xother_types))))
	for {
		if !(ot != 0) {
			break
		}
		if (*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fid == id {
			return ot + 8
		}
		goto _1
	_1:
		;
		ot = (*TFcObjectOtherTypeInfo)(unsafe.Pointer(ot)).Fnext
	}
	return libc.UintptrFromInt32(0)
}

/* Objects MT-safe for readonly access. */

func XFcPatternCreate(tls *libc.TLS) (r uintptr) {
	var p uintptr
	_ = p
	p = libc.Xmalloc(tls, uint64(24))
	if !(p != 0) {
		return uintptr(0)
	}
	libc.X__builtin___memset_chk(tls, p, 0, uint64(24), ^t__predefined_size_t(0))
	(*TFcPattern)(unsafe.Pointer(p)).Fnum = 0
	(*TFcPattern)(unsafe.Pointer(p)).Fsize = 0
	(*TFcPattern)(unsafe.Pointer(p)).Felts_offset = int64(libc.UintptrFromInt32(0)) - int64(p)
	(*TFcRef)(unsafe.Pointer(p + 16)).Fcount = int32(1)
	return p
}

func XFcValueDestroy(tls *libc.TLS, _v TFcValue) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*TFcValue)(unsafe.Pointer(bp)) = _v
	switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
	case int32(_FcTypeString):
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	case int32(_FcTypeMatrix):
		XFcMatrixFree(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	case int32(_FcTypeCharSet):
		XFcCharSetDestroy(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	case int32(_FcTypeLangSet):
		XFcLangSetDestroy(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	case int32(_FcTypeRange):
		XFcRangeDestroy(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	default:
		break
	}
}

func XFcValueCanonicalize(tls *libc.TLS, v uintptr) (r TFcValue) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1, v2, v3, v4 uintptr
	var _ /* new at bp+0 */ TFcValue
	_, _, _, _ = v1, v2, v3, v4
	switch (*TFcValue)(unsafe.Pointer(v)).Ftype1 {
	case int32(_FcTypeString):
		if int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(1) != 0 {
			v1 = uintptr(int64(v) + int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v1 = *(*uintptr)(unsafe.Pointer(v + 8))
		}
		*(*uintptr)(unsafe.Pointer(bp + 8)) = v1
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeString)
	case int32(_FcTypeCharSet):
		if int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(1) != 0 {
			v2 = uintptr(int64(v) + int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = *(*uintptr)(unsafe.Pointer(v + 8))
		}
		*(*uintptr)(unsafe.Pointer(bp + 8)) = v2
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeCharSet)
	case int32(_FcTypeLangSet):
		if int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(1) != 0 {
			v3 = uintptr(int64(v) + int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v3 = *(*uintptr)(unsafe.Pointer(v + 8))
		}
		*(*uintptr)(unsafe.Pointer(bp + 8)) = v3
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeLangSet)
	case int32(_FcTypeRange):
		if int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(1) != 0 {
			v4 = uintptr(int64(v) + int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v4 = *(*uintptr)(unsafe.Pointer(v + 8))
		}
		*(*uintptr)(unsafe.Pointer(bp + 8)) = v4
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeRange)
	default:
		*(*TFcValue)(unsafe.Pointer(bp)) = *(*TFcValue)(unsafe.Pointer(v))
		break
	}
	return *(*TFcValue)(unsafe.Pointer(bp))
}

func XFcValueSave(tls *libc.TLS, _v TFcValue) (r TFcValue) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*TFcValue)(unsafe.Pointer(bp)) = _v
	switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
	case int32(_FcTypeString):
		*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.Xstrdup(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
		if !(*(*uintptr)(unsafe.Pointer(bp + 8)) != 0) {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
		}
	case int32(_FcTypeMatrix):
		*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcMatrixCopy(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
		if !(*(*uintptr)(unsafe.Pointer(bp + 8)) != 0) {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
		}
	case int32(_FcTypeCharSet):
		*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcCharSetCopy(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
		if !(*(*uintptr)(unsafe.Pointer(bp + 8)) != 0) {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
		}
	case int32(_FcTypeLangSet):
		*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcLangSetCopy(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
		if !(*(*uintptr)(unsafe.Pointer(bp + 8)) != 0) {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
		}
	case int32(_FcTypeRange):
		*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcRangeCopy(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
		if !(*(*uintptr)(unsafe.Pointer(bp + 8)) != 0) {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
		}
	default:
		break
	}
	return *(*TFcValue)(unsafe.Pointer(bp))
}

func XFcValueListCreate(tls *libc.TLS) (r TFcValueListPtr) {
	return libc.Xcalloc(tls, uint64(1), uint64(32))
}

func XFcValueListDestroy(tls *libc.TLS, l TFcValueListPtr) {
	var next TFcValueListPtr
	var v2 uintptr
	_, _ = next, v2
	for {
		if !(l != 0) {
			break
		}
		XFcValueDestroy(tls, (*T_FcValueList)(unsafe.Pointer(l)).Fvalue)
		if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
			v2 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
		}
		next = v2
		libc.Xfree(tls, l)
		goto _1
	_1:
		;
		l = next
	}
}

func XFcValueListPrepend(tls *libc.TLS, vallist TFcValueListPtr, value TFcValue, binding TFcValueBinding) (r TFcValueListPtr) {
	var new1 TFcValueListPtr
	_ = new1
	if value.Ftype1 == int32(_FcTypeVoid) {
		return vallist
	}
	new1 = XFcValueListCreate(tls)
	if !(new1 != 0) {
		return vallist
	}
	(*T_FcValueList)(unsafe.Pointer(new1)).Fvalue = XFcValueSave(tls, value)
	(*T_FcValueList)(unsafe.Pointer(new1)).Fbinding = binding
	(*T_FcValueList)(unsafe.Pointer(new1)).Fnext = vallist
	return new1
}

func XFcValueListAppend(tls *libc.TLS, vallist TFcValueListPtr, value TFcValue, binding TFcValueBinding) (r TFcValueListPtr) {
	var last, new1 TFcValueListPtr
	var v2, v3 uintptr
	_, _, _, _ = last, new1, v2, v3
	if value.Ftype1 == int32(_FcTypeVoid) {
		return vallist
	}
	new1 = XFcValueListCreate(tls)
	if !(new1 != 0) {
		return vallist
	}
	(*T_FcValueList)(unsafe.Pointer(new1)).Fvalue = XFcValueSave(tls, value)
	(*T_FcValueList)(unsafe.Pointer(new1)).Fbinding = binding
	(*T_FcValueList)(unsafe.Pointer(new1)).Fnext = libc.UintptrFromInt32(0)
	if vallist != 0 {
		last = vallist
		for {
			if int64((*T_FcValueList)(unsafe.Pointer(last)).Fnext)&int64(1) != 0 {
				v2 = uintptr(int64(last) + int64((*T_FcValueList)(unsafe.Pointer(last)).Fnext)&int64(^libc.Int32FromInt32(1)))
			} else {
				v2 = (*T_FcValueList)(unsafe.Pointer(last)).Fnext
			}
			if !(v2 != 0) {
				break
			}
			goto _1
		_1:
			;
			if int64((*T_FcValueList)(unsafe.Pointer(last)).Fnext)&int64(1) != 0 {
				v3 = uintptr(int64(last) + int64((*T_FcValueList)(unsafe.Pointer(last)).Fnext)&int64(^libc.Int32FromInt32(1)))
			} else {
				v3 = (*T_FcValueList)(unsafe.Pointer(last)).Fnext
			}
			last = v3
		}
		(*T_FcValueList)(unsafe.Pointer(last)).Fnext = new1
	} else {
		vallist = new1
	}
	return vallist
}

func XFcValueListDuplicate(tls *libc.TLS, orig TFcValueListPtr) (r TFcValueListPtr) {
	var l, new1, t, v2 TFcValueListPtr
	var v TFcValue
	var v3, v4 uintptr
	_, _, _, _, _, _, _ = l, new1, t, v, v2, v3, v4
	new1 = libc.UintptrFromInt32(0)
	t = libc.UintptrFromInt32(0)
	l = orig
	for {
		if !(l != libc.UintptrFromInt32(0)) {
			break
		}
		if !(new1 != 0) {
			v2 = XFcValueListCreate(tls)
			new1 = v2
			t = v2
		} else {
			(*T_FcValueList)(unsafe.Pointer(t)).Fnext = XFcValueListCreate(tls)
			if int64((*T_FcValueList)(unsafe.Pointer(t)).Fnext)&int64(1) != 0 {
				v3 = uintptr(int64(t) + int64((*T_FcValueList)(unsafe.Pointer(t)).Fnext)&int64(^libc.Int32FromInt32(1)))
			} else {
				v3 = (*T_FcValueList)(unsafe.Pointer(t)).Fnext
			}
			t = v3
		}
		v = XFcValueCanonicalize(tls, l+8)
		(*T_FcValueList)(unsafe.Pointer(t)).Fvalue = XFcValueSave(tls, v)
		(*T_FcValueList)(unsafe.Pointer(t)).Fbinding = (*T_FcValueList)(unsafe.Pointer(l)).Fbinding
		(*T_FcValueList)(unsafe.Pointer(t)).Fnext = libc.UintptrFromInt32(0)
		goto _1
	_1:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
			v4 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v4 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
		}
		l = v4
	}
	return new1
}

func XFcValueEqual(tls *libc.TLS, _va TFcValue, _vb TFcValue) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*TFcValue)(unsafe.Pointer(bp)) = _va
	*(*TFcValue)(unsafe.Pointer(bp + 16)) = _vb
	if (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 != (*(*TFcValue)(unsafe.Pointer(bp + 16))).Ftype1 {
		if (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 == int32(_FcTypeInteger) {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeDouble)
			*(*float64)(unsafe.Pointer(bp + 8)) = float64(*(*int32)(unsafe.Pointer(bp + 8)))
		}
		if (*(*TFcValue)(unsafe.Pointer(bp + 16))).Ftype1 == int32(_FcTypeInteger) {
			(*(*TFcValue)(unsafe.Pointer(bp + 16))).Ftype1 = int32(_FcTypeDouble)
			*(*float64)(unsafe.Pointer(bp + 16 + 8)) = float64(*(*int32)(unsafe.Pointer(bp + 16 + 8)))
		}
		if (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 != (*(*TFcValue)(unsafe.Pointer(bp + 16))).Ftype1 {
			return m_FcFalse
		}
	}
	switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
	case int32(_FcTypeUnknown):
		return m_FcFalse /* don't know how to compare this object */
	case int32(_FcTypeVoid):
		return int32(m_FcTrue)
	case int32(_FcTypeInteger):
		return libc.BoolInt32(*(*int32)(unsafe.Pointer(bp + 8)) == *(*int32)(unsafe.Pointer(bp + 16 + 8)))
	case int32(_FcTypeDouble):
		return libc.BoolInt32(*(*float64)(unsafe.Pointer(bp + 8)) == *(*float64)(unsafe.Pointer(bp + 16 + 8)))
	case int32(_FcTypeString):
		return libc.BoolInt32(XFcStrCmpIgnoreCase(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), *(*uintptr)(unsafe.Pointer(bp + 16 + 8))) == 0)
	case int32(_FcTypeBool):
		return libc.BoolInt32(*(*TFcBool)(unsafe.Pointer(bp + 8)) == *(*TFcBool)(unsafe.Pointer(bp + 16 + 8)))
	case int32(_FcTypeMatrix):
		return XFcMatrixEqual(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), *(*uintptr)(unsafe.Pointer(bp + 16 + 8)))
	case int32(_FcTypeCharSet):
		return XFcCharSetEqual(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), *(*uintptr)(unsafe.Pointer(bp + 16 + 8)))
	case int32(_FcTypeFTFace):
		return libc.BoolInt32(*(*uintptr)(unsafe.Pointer(bp + 8)) == *(*uintptr)(unsafe.Pointer(bp + 16 + 8)))
	case int32(_FcTypeLangSet):
		return XFcLangSetEqual(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), *(*uintptr)(unsafe.Pointer(bp + 16 + 8)))
	case int32(_FcTypeRange):
		return XFcRangeIsInRange(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), *(*uintptr)(unsafe.Pointer(bp + 16 + 8)))
	}
	return m_FcFalse
}

func _FcDoubleHash(tls *libc.TLS, d float64) (r TFcChar32) {
	if d < libc.Float64FromInt32(0) {
		d = -d
	}
	if d > libc.Float64FromUint32(0xffffffff) {
		d = libc.Float64FromUint32(0xffffffff)
	}
	return uint32(d)
}

func XFcStringHash(tls *libc.TLS, s uintptr) (r TFcChar32) {
	var c, v1 TFcChar8
	var h TFcChar32
	var v2 uintptr
	_, _, _, _ = c, h, v1, v2
	h = uint32(0)
	if s != 0 {
		for {
			v2 = s
			s++
			v1 = *(*TFcChar8)(unsafe.Pointer(v2))
			c = v1
			if !(v1 != 0) {
				break
			}
			h = h<<libc.Int32FromInt32(1) | h>>libc.Int32FromInt32(31) ^ uint32(c)
		}
	}
	return h
}

func _FcValueHash(tls *libc.TLS, v uintptr) (r TFcChar32) {
	var v1, v2, v3, v4 uintptr
	_, _, _, _ = v1, v2, v3, v4
	switch (*TFcValue)(unsafe.Pointer(v)).Ftype1 {
	case int32(_FcTypeUnknown):
		fallthrough
	case int32(_FcTypeVoid):
		return uint32(0)
	case int32(_FcTypeInteger):
		return libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(v)).Fu)))
	case int32(_FcTypeDouble):
		return _FcDoubleHash(tls, *(*float64)(unsafe.Pointer(v + 8)))
	case int32(_FcTypeString):
		if int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(1) != 0 {
			v1 = uintptr(int64(v) + int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v1 = *(*uintptr)(unsafe.Pointer(v + 8))
		}
		return XFcStringHash(tls, v1)
	case int32(_FcTypeBool):
		return libc.Uint32FromInt32(*(*TFcBool)(unsafe.Pointer(&(*TFcValue)(unsafe.Pointer(v)).Fu)))
	case int32(_FcTypeMatrix):
		return _FcDoubleHash(tls, (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(v + 8)))).Fxx) ^ _FcDoubleHash(tls, (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(v + 8)))).Fxy) ^ _FcDoubleHash(tls, (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(v + 8)))).Fyx) ^ _FcDoubleHash(tls, (*TFcMatrix)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(v + 8)))).Fyy)
	case int32(_FcTypeCharSet):
		if int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(1) != 0 {
			v2 = uintptr(int64(v) + int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = *(*uintptr)(unsafe.Pointer(v + 8))
		}
		return libc.Uint32FromInt32((*TFcCharSet)(unsafe.Pointer(v2)).Fnum)
	case int32(_FcTypeFTFace):
		return XFcStringHash(tls, (*TFT_FaceRec_)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(v + 8)))).Ffamily_name) ^ XFcStringHash(tls, (*TFT_FaceRec_)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(v + 8)))).Fstyle_name)
	case int32(_FcTypeLangSet):
		if int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(1) != 0 {
			v3 = uintptr(int64(v) + int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v3 = *(*uintptr)(unsafe.Pointer(v + 8))
		}
		return XFcLangSetHash(tls, v3)
	case int32(_FcTypeRange):
		if int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(1) != 0 {
			v4 = uintptr(int64(v) + int64(*(*uintptr)(unsafe.Pointer(v + 8)))&int64(^libc.Int32FromInt32(1)))
		} else {
			v4 = *(*uintptr)(unsafe.Pointer(v + 8))
		}
		return XFcRangeHash(tls, v4)
	}
	return uint32(0)
}

func _FcValueListEqual(tls *libc.TLS, la TFcValueListPtr, lb TFcValueListPtr) (r TFcBool) {
	var v1, v2 uintptr
	_, _ = v1, v2
	if la == lb {
		return int32(m_FcTrue)
	}
	for la != 0 && lb != 0 {
		if !(XFcValueEqual(tls, (*T_FcValueList)(unsafe.Pointer(la)).Fvalue, (*T_FcValueList)(unsafe.Pointer(lb)).Fvalue) != 0) {
			return m_FcFalse
		}
		if int64((*T_FcValueList)(unsafe.Pointer(la)).Fnext)&int64(1) != 0 {
			v1 = uintptr(int64(la) + int64((*T_FcValueList)(unsafe.Pointer(la)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v1 = (*T_FcValueList)(unsafe.Pointer(la)).Fnext
		}
		la = v1
		if int64((*T_FcValueList)(unsafe.Pointer(lb)).Fnext)&int64(1) != 0 {
			v2 = uintptr(int64(lb) + int64((*T_FcValueList)(unsafe.Pointer(lb)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*T_FcValueList)(unsafe.Pointer(lb)).Fnext
		}
		lb = v2
	}
	if la != 0 || lb != 0 {
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

func _FcValueListHash(tls *libc.TLS, l TFcValueListPtr) (r TFcChar32) {
	var hash TFcChar32
	var v2 uintptr
	_, _ = hash, v2
	hash = uint32(0)
	for {
		if !(l != 0) {
			break
		}
		hash = hash<<libc.Int32FromInt32(1) | hash>>libc.Int32FromInt32(31) ^ _FcValueHash(tls, l+8)
		goto _1
	_1:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
			v2 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
		}
		l = v2
	}
	return hash
}

func _FcPatternGetCacheObject(tls *libc.TLS, p uintptr) (r uintptr) {
	var v1 uintptr
	_ = v1
	/* We use a value to find the cache, instead of the FcPattern object
	 * because the pattern itself may be a cache allocation if we rewrote the path,
	 * so the p may not be in the cached region. */
	if int64((*TFcPatternElt)(unsafe.Pointer(uintptr(int64(p)+(*TFcPattern)(unsafe.Pointer(p)).Felts_offset))).Fvalues)&int64(1) != 0 {
		v1 = uintptr(Tintptr_t(uintptr(int64(p)+(*TFcPattern)(unsafe.Pointer(p)).Felts_offset)) + int64((*TFcPatternElt)(unsafe.Pointer(uintptr(int64(p)+(*TFcPattern)(unsafe.Pointer(p)).Felts_offset))).Fvalues)&int64(^libc.Int32FromInt32(1)))
	} else {
		v1 = (*TFcPatternElt)(unsafe.Pointer(uintptr(int64(p) + (*TFcPattern)(unsafe.Pointer(p)).Felts_offset))).Fvalues
	}
	return v1
}

func XFcPatternCacheRewriteFile(tls *libc.TLS, p uintptr, cache uintptr, relocated_font_file uintptr) (r uintptr) {
	var data, elt, elts, new_elts, new_p, new_path, new_value_list, v3 uintptr
	var i, j, new_path_len, v2, v4 Tsize_t
	_, _, _, _, _, _, _, _, _, _, _, _, _ = data, elt, elts, i, j, new_elts, new_p, new_path, new_path_len, new_value_list, v2, v3, v4
	elts = uintptr(int64(p) + (*TFcPattern)(unsafe.Pointer(p)).Felts_offset)
	new_path_len = libc.Xstrlen(tls, relocated_font_file)
	/* Allocate space for the patter, the PatternElt headers and
	 * the FC_FILE FcValueList and path that will be freed with the
	 * cache */
	data = XFcCacheAllocate(tls, cache, uint64(24)+libc.Uint64FromInt32((*TFcPattern)(unsafe.Pointer(p)).Fnum)*uint64(16)+uint64(32)+new_path_len+uint64(1))
	new_p = data
	data += uintptr(24)
	new_elts = data
	data += uintptr(libc.Uint64FromInt32((*TFcPattern)(unsafe.Pointer(p)).Fnum) * uint64(16))
	new_value_list = data
	data += uintptr(32)
	new_path = data
	*(*TFcPattern)(unsafe.Pointer(new_p)) = *(*TFcPattern)(unsafe.Pointer(p))
	(*TFcPattern)(unsafe.Pointer(new_p)).Felts_offset = int64(new_elts) - int64(new_p)
	/* Copy all but the FILE values from the cache */
	i = uint64(0)
	j = libc.Uint64FromInt32(0)
	for {
		if !(i < libc.Uint64FromInt32((*TFcPattern)(unsafe.Pointer(p)).Fnum)) {
			break
		}
		elt = elts + uintptr(i)*16
		(*(*TFcPatternElt)(unsafe.Pointer(new_elts + uintptr(j)*16))).Fobject = (*TFcPatternElt)(unsafe.Pointer(elt)).Fobject
		if (*TFcPatternElt)(unsafe.Pointer(elt)).Fobject != int32(_FC_FILE_OBJECT) {
			v2 = j
			j++
			if int64((*TFcPatternElt)(unsafe.Pointer(elt)).Fvalues)&int64(1) != 0 {
				v3 = uintptr(int64(elt) + int64((*TFcPatternElt)(unsafe.Pointer(elt)).Fvalues)&int64(^libc.Int32FromInt32(1)))
			} else {
				v3 = (*TFcPatternElt)(unsafe.Pointer(elt)).Fvalues
			}
			(*(*TFcPatternElt)(unsafe.Pointer(new_elts + uintptr(v2)*16))).Fvalues = v3
		} else {
			v4 = j
			j++
			(*(*TFcPatternElt)(unsafe.Pointer(new_elts + uintptr(v4)*16))).Fvalues = new_value_list
		}
		goto _1
	_1:
		;
		i++
	}
	(*TFcValueList)(unsafe.Pointer(new_value_list)).Fnext = libc.UintptrFromInt32(0)
	(*TFcValueList)(unsafe.Pointer(new_value_list)).Fvalue.Ftype1 = int32(_FcTypeString)
	*(*uintptr)(unsafe.Pointer(new_value_list + 8 + 8)) = new_path
	(*TFcValueList)(unsafe.Pointer(new_value_list)).Fbinding = int32(_FcValueBindingWeak)
	/* Add rewritten path at the end */
	libc.X__builtin___strcpy_chk(tls, new_path, relocated_font_file, ^t__predefined_size_t(0))
	return new_p
}

func XFcPatternDestroy(tls *libc.TLS, p uintptr) {
	var elts, v7, p5 uintptr
	var i, v3 int32
	var v1 TFcBool
	_, _, _, _, _, _ = elts, i, v1, v3, v7, p5
	if !(p != 0) {
		return
	}
	v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(p+16)).Fcount == -libc.Int32FromInt32(1))
	goto _2
_2:
	if v1 != 0 {
		XFcCacheObjectDereference(tls, _FcPatternGetCacheObject(tls, p))
		return
	}
	p5 = p + 16
	*(*Tfc_atomic_int_t)(unsafe.Pointer(p5)) += -int32(1)
	v3 = *(*Tfc_atomic_int_t)(unsafe.Pointer(p5)) - -int32(1)
	goto _4
_4:
	if v3 != int32(1) {
		return
	}
	elts = uintptr(int64(p) + (*TFcPattern)(unsafe.Pointer(p)).Felts_offset)
	i = 0
	for {
		if !(i < XFcPatternObjectCount(tls, p)) {
			break
		}
		if int64((*TFcPatternElt)(unsafe.Pointer(elts+uintptr(i)*16)).Fvalues)&int64(1) != 0 {
			v7 = uintptr(Tintptr_t(elts+uintptr(i)*16) + int64((*TFcPatternElt)(unsafe.Pointer(elts+uintptr(i)*16)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v7 = (*TFcPatternElt)(unsafe.Pointer(elts + uintptr(i)*16)).Fvalues
		}
		XFcValueListDestroy(tls, v7)
		goto _6
	_6:
		;
		i++
	}
	libc.Xfree(tls, elts)
	libc.Xfree(tls, p)
}

func XFcPatternObjectCount(tls *libc.TLS, pat uintptr) (r int32) {
	if pat != 0 {
		return (*TFcPattern)(unsafe.Pointer(pat)).Fnum
	}
	return 0
}

func _FcPatternObjectPosition(tls *libc.TLS, p uintptr, object TFcObject) (r int32) {
	var c, high, low, mid int32
	var elts uintptr
	_, _, _, _, _ = c, elts, high, low, mid
	elts = uintptr(int64(p) + (*TFcPattern)(unsafe.Pointer(p)).Felts_offset)
	low = 0
	high = XFcPatternObjectCount(tls, p) - int32(1)
	c = int32(1)
	mid = 0
	for low <= high {
		mid = (low + high) >> int32(1)
		c = (*(*TFcPatternElt)(unsafe.Pointer(elts + uintptr(mid)*16))).Fobject - object
		if c == 0 {
			return mid
		}
		if c < 0 {
			low = mid + int32(1)
		} else {
			high = mid - int32(1)
		}
	}
	if c < 0 {
		mid++
	}
	return -(mid + int32(1))
}

func XFcPatternPosition(tls *libc.TLS, p uintptr, object uintptr) (r int32) {
	return _FcPatternObjectPosition(tls, p, XFcObjectFromName(tls, object))
}

func XFcPatternObjectFindElt(tls *libc.TLS, p uintptr, object TFcObject) (r uintptr) {
	var i int32
	_ = i
	i = _FcPatternObjectPosition(tls, p, object)
	if i < 0 {
		return uintptr(0)
	}
	return uintptr(int64(p)+(*TFcPattern)(unsafe.Pointer(p)).Felts_offset) + uintptr(i)*16
}

func XFcPatternObjectInsertElt(tls *libc.TLS, p uintptr, object TFcObject) (r uintptr) {
	var e, e0 uintptr
	var i, s int32
	_, _, _, _ = e, e0, i, s
	i = _FcPatternObjectPosition(tls, p, object)
	if i < 0 {
		i = -i - int32(1)
		/* reallocate array */
		if XFcPatternObjectCount(tls, p)+int32(1) >= (*TFcPattern)(unsafe.Pointer(p)).Fsize {
			s = (*TFcPattern)(unsafe.Pointer(p)).Fsize + int32(16)
			if (*TFcPattern)(unsafe.Pointer(p)).Fsize != 0 {
				e0 = uintptr(int64(p) + (*TFcPattern)(unsafe.Pointer(p)).Felts_offset)
				e = libc.Xrealloc(tls, e0, libc.Uint64FromInt32(s)*uint64(16))
				if !(e != 0) { /* maybe it was mmapped */
					e = libc.Xmalloc(tls, libc.Uint64FromInt32(s)*uint64(16))
					if e != 0 {
						libc.X__builtin___memcpy_chk(tls, e, e0, libc.Uint64FromInt32(XFcPatternObjectCount(tls, p))*uint64(16), ^t__predefined_size_t(0))
					}
				}
			} else {
				e = libc.Xmalloc(tls, libc.Uint64FromInt32(s)*uint64(16))
			}
			if !(e != 0) {
				return uintptr(m_FcFalse)
			}
			(*TFcPattern)(unsafe.Pointer(p)).Felts_offset = int64(e) - int64(p)
			for (*TFcPattern)(unsafe.Pointer(p)).Fsize < s {
				(*(*TFcPatternElt)(unsafe.Pointer(e + uintptr((*TFcPattern)(unsafe.Pointer(p)).Fsize)*16))).Fobject = 0
				(*(*TFcPatternElt)(unsafe.Pointer(e + uintptr((*TFcPattern)(unsafe.Pointer(p)).Fsize)*16))).Fvalues = libc.UintptrFromInt32(0)
				(*TFcPattern)(unsafe.Pointer(p)).Fsize++
			}
		}
		e = uintptr(int64(p) + (*TFcPattern)(unsafe.Pointer(p)).Felts_offset)
		/* move elts up */
		libc.X__builtin___memmove_chk(tls, e+uintptr(i)*16+uintptr(1)*16, e+uintptr(i)*16, uint64(16)*libc.Uint64FromInt32(XFcPatternObjectCount(tls, p)-i), ^t__predefined_size_t(0))
		/* bump count */
		(*TFcPattern)(unsafe.Pointer(p)).Fnum++
		(*(*TFcPatternElt)(unsafe.Pointer(e + uintptr(i)*16))).Fobject = object
		(*(*TFcPatternElt)(unsafe.Pointer(e + uintptr(i)*16))).Fvalues = libc.UintptrFromInt32(0)
	}
	return uintptr(int64(p)+(*TFcPattern)(unsafe.Pointer(p)).Felts_offset) + uintptr(i)*16
}

func XFcPatternEqual(tls *libc.TLS, pa uintptr, pb uintptr) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var ra, rb TFcBool
	var _ /* ia at bp+0 */ TFcPatternIter
	var _ /* ib at bp+16 */ TFcPatternIter
	_, _ = ra, rb
	if pa == pb {
		return int32(m_FcTrue)
	}
	if XFcPatternObjectCount(tls, pa) != XFcPatternObjectCount(tls, pb) {
		return m_FcFalse
	}
	XFcPatternIterStart(tls, pa, bp)
	XFcPatternIterStart(tls, pb, bp+16)
	for cond := true; cond; cond = int32(1) != 0 {
		if !(XFcPatternIterEqual(tls, pa, bp, pb, bp+16) != 0) {
			return m_FcFalse
		}
		ra = XFcPatternIterNext(tls, pa, bp)
		rb = XFcPatternIterNext(tls, pb, bp+16)
		if !(ra != 0) && !(rb != 0) {
			break
		}
	}
	return int32(m_FcTrue)
}

func XFcPatternHash(tls *libc.TLS, p uintptr) (r TFcChar32) {
	var h TFcChar32
	var i int32
	var pe, v2 uintptr
	_, _, _, _ = h, i, pe, v2
	h = uint32(0)
	pe = uintptr(int64(p) + (*TFcPattern)(unsafe.Pointer(p)).Felts_offset)
	i = 0
	for {
		if !(i < XFcPatternObjectCount(tls, p)) {
			break
		}
		if int64((*TFcPatternElt)(unsafe.Pointer(pe+uintptr(i)*16)).Fvalues)&int64(1) != 0 {
			v2 = uintptr(Tintptr_t(pe+uintptr(i)*16) + int64((*TFcPatternElt)(unsafe.Pointer(pe+uintptr(i)*16)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*TFcPatternElt)(unsafe.Pointer(pe + uintptr(i)*16)).Fvalues
		}
		h = h<<libc.Int32FromInt32(1) | h>>libc.Int32FromInt32(31) ^ libc.Uint32FromInt32((*(*TFcPatternElt)(unsafe.Pointer(pe + uintptr(i)*16))).Fobject) ^ _FcValueListHash(tls, v2)
		goto _1
	_1:
		;
		i++
	}
	return h
}

func XFcPatternEqualSubset(tls *libc.TLS, pai uintptr, pbi uintptr, os uintptr) (r TFcBool) {
	var ea, eb, v2, v3 uintptr
	var i int32
	var object TFcObject
	_, _, _, _, _, _ = ea, eb, i, object, v2, v3
	i = 0
	for {
		if !(i < (*TFcObjectSet)(unsafe.Pointer(os)).Fnobject) {
			break
		}
		object = XFcObjectFromName(tls, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(i)*8)))
		ea = XFcPatternObjectFindElt(tls, pai, object)
		eb = XFcPatternObjectFindElt(tls, pbi, object)
		if ea != 0 {
			if !(eb != 0) {
				return m_FcFalse
			}
			if int64((*TFcPatternElt)(unsafe.Pointer(ea)).Fvalues)&int64(1) != 0 {
				v2 = uintptr(int64(ea) + int64((*TFcPatternElt)(unsafe.Pointer(ea)).Fvalues)&int64(^libc.Int32FromInt32(1)))
			} else {
				v2 = (*TFcPatternElt)(unsafe.Pointer(ea)).Fvalues
			}
			if int64((*TFcPatternElt)(unsafe.Pointer(eb)).Fvalues)&int64(1) != 0 {
				v3 = uintptr(int64(eb) + int64((*TFcPatternElt)(unsafe.Pointer(eb)).Fvalues)&int64(^libc.Int32FromInt32(1)))
			} else {
				v3 = (*TFcPatternElt)(unsafe.Pointer(eb)).Fvalues
			}
			if !(_FcValueListEqual(tls, v2, v3) != 0) {
				return m_FcFalse
			}
		} else {
			if eb != 0 {
				return m_FcFalse
			}
		}
		goto _1
	_1:
		;
		i++
	}
	return int32(m_FcTrue)
}

func XFcPatternObjectListAdd(tls *libc.TLS, p uintptr, object TFcObject, _list TFcValueListPtr, append1 TFcBool) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*TFcValueListPtr)(unsafe.Pointer(bp)) = _list
	var e, prev, v4 uintptr
	var l TFcValueListPtr
	var v1 TFcBool
	_, _, _, _, _ = e, l, prev, v1, v4
	v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(p+16)).Fcount == -libc.Int32FromInt32(1))
	goto _2
_2:
	if v1 != 0 {
		goto bail0
	}
	/*
	 * Make sure the stored type is valid for built-in objects
	 */
	l = *(*TFcValueListPtr)(unsafe.Pointer(bp))
	for {
		if !(l != libc.UintptrFromInt32(0)) {
			break
		}
		if !(XFcObjectValidType(tls, object, (*T_FcValueList)(unsafe.Pointer(l)).Fvalue.Ftype1) != 0) {
			libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+1204, libc.VaList(bp+16, XFcObjectName(tls, object)))
			XFcValuePrintFile(tls, libc.X__stderrp, (*T_FcValueList)(unsafe.Pointer(l)).Fvalue)
			libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+1266, 0)
			goto bail0
		}
		goto _3
	_3:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
			v4 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v4 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
		}
		l = v4
	}
	e = XFcPatternObjectInsertElt(tls, p, object)
	if !(e != 0) {
		goto bail0
	}
	if append1 != 0 {
		prev = e + 8
		for {
			if !(*(*TFcValueListPtr)(unsafe.Pointer(prev)) != 0) {
				break
			}
			goto _5
		_5:
			;
			prev = *(*TFcValueListPtr)(unsafe.Pointer(prev))
		}
		*(*TFcValueListPtr)(unsafe.Pointer(prev)) = *(*TFcValueListPtr)(unsafe.Pointer(bp))
	} else {
		prev = bp
		for {
			if !(*(*TFcValueListPtr)(unsafe.Pointer(prev)) != 0) {
				break
			}
			goto _6
		_6:
			;
			prev = *(*TFcValueListPtr)(unsafe.Pointer(prev))
		}
		*(*TFcValueListPtr)(unsafe.Pointer(prev)) = (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues
		(*TFcPatternElt)(unsafe.Pointer(e)).Fvalues = *(*TFcValueListPtr)(unsafe.Pointer(bp))
	}
	return int32(m_FcTrue)
	goto bail0
bail0:
	;
	return m_FcFalse
	return r
}

func XFcPatternObjectAddWithBinding(tls *libc.TLS, p uintptr, object TFcObject, value TFcValue, binding TFcValueBinding, append1 TFcBool) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e, prev uintptr
	var new1 TFcValueListPtr
	var v1 TFcBool
	_, _, _, _ = e, new1, prev, v1
	v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(p+16)).Fcount == -libc.Int32FromInt32(1))
	goto _2
_2:
	if v1 != 0 {
		goto bail0
	}
	new1 = XFcValueListCreate(tls)
	if !(new1 != 0) {
		goto bail0
	}
	(*T_FcValueList)(unsafe.Pointer(new1)).Fvalue = XFcValueSave(tls, value)
	(*T_FcValueList)(unsafe.Pointer(new1)).Fbinding = binding
	(*T_FcValueList)(unsafe.Pointer(new1)).Fnext = libc.UintptrFromInt32(0)
	if (*T_FcValueList)(unsafe.Pointer(new1)).Fvalue.Ftype1 == int32(_FcTypeVoid) {
		goto bail1
	}
	/*
	 * Make sure the stored type is valid for built-in objects
	 */
	if !(XFcObjectValidType(tls, object, (*T_FcValueList)(unsafe.Pointer(new1)).Fvalue.Ftype1) != 0) {
		libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+1204, libc.VaList(bp+8, XFcObjectName(tls, object)))
		XFcValuePrintFile(tls, libc.X__stderrp, (*T_FcValueList)(unsafe.Pointer(new1)).Fvalue)
		libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+1266, 0)
		goto bail1
	}
	e = XFcPatternObjectInsertElt(tls, p, object)
	if !(e != 0) {
		goto bail1
	}
	if append1 != 0 {
		prev = e + 8
		for {
			if !(*(*TFcValueListPtr)(unsafe.Pointer(prev)) != 0) {
				break
			}
			goto _3
		_3:
			;
			prev = *(*TFcValueListPtr)(unsafe.Pointer(prev))
		}
		*(*TFcValueListPtr)(unsafe.Pointer(prev)) = new1
	} else {
		(*T_FcValueList)(unsafe.Pointer(new1)).Fnext = (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues
		(*TFcPatternElt)(unsafe.Pointer(e)).Fvalues = new1
	}
	return int32(m_FcTrue)
	goto bail1
bail1:
	;
	XFcValueListDestroy(tls, new1)
	goto bail0
bail0:
	;
	return m_FcFalse
	return r
}

func XFcPatternObjectAdd(tls *libc.TLS, p uintptr, object TFcObject, value TFcValue, append1 TFcBool) (r TFcBool) {
	return XFcPatternObjectAddWithBinding(tls, p, object, value, int32(_FcValueBindingStrong), append1)
}

func XFcPatternAdd(tls *libc.TLS, p uintptr, object uintptr, value TFcValue, append1 TFcBool) (r TFcBool) {
	return XFcPatternObjectAddWithBinding(tls, p, XFcObjectFromName(tls, object), value, int32(_FcValueBindingStrong), append1)
}

func XFcPatternAddWeak(tls *libc.TLS, p uintptr, object uintptr, value TFcValue, append1 TFcBool) (r TFcBool) {
	return XFcPatternObjectAddWithBinding(tls, p, XFcObjectFromName(tls, object), value, int32(_FcValueBindingWeak), append1)
}

func XFcPatternObjectDel(tls *libc.TLS, p uintptr, object TFcObject) (r TFcBool) {
	var e uintptr
	_ = e
	e = XFcPatternObjectFindElt(tls, p, object)
	if !(e != 0) {
		return m_FcFalse
	}
	/* destroy value */
	XFcValueListDestroy(tls, (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)
	/* shuffle existing ones down */
	libc.X__builtin___memmove_chk(tls, e, e+uintptr(1)*16, libc.Uint64FromInt64((int64(uintptr(int64(p)+(*TFcPattern)(unsafe.Pointer(p)).Felts_offset)+uintptr(XFcPatternObjectCount(tls, p))*16)-int64(e+libc.UintptrFromInt32(1)*16))/16)*uint64(16), ^t__predefined_size_t(0))
	(*TFcPattern)(unsafe.Pointer(p)).Fnum--
	e = uintptr(int64(p)+(*TFcPattern)(unsafe.Pointer(p)).Felts_offset) + uintptr(XFcPatternObjectCount(tls, p))*16
	(*TFcPatternElt)(unsafe.Pointer(e)).Fobject = 0
	(*TFcPatternElt)(unsafe.Pointer(e)).Fvalues = libc.UintptrFromInt32(0)
	return int32(m_FcTrue)
}

func XFcPatternDel(tls *libc.TLS, p uintptr, object uintptr) (r TFcBool) {
	return XFcPatternObjectDel(tls, p, XFcObjectFromName(tls, object))
}

func XFcPatternRemove(tls *libc.TLS, p uintptr, object uintptr, id int32) (r TFcBool) {
	var e, prev uintptr
	var l, v2 TFcValueListPtr
	_, _, _, _ = e, l, prev, v2
	e = XFcPatternObjectFindElt(tls, p, XFcObjectFromName(tls, object))
	if !(e != 0) {
		return m_FcFalse
	}
	prev = e + 8
	for {
		v2 = *(*TFcValueListPtr)(unsafe.Pointer(prev))
		l = v2
		if !(v2 != 0) {
			break
		}
		if !(id != 0) {
			*(*TFcValueListPtr)(unsafe.Pointer(prev)) = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
			(*T_FcValueList)(unsafe.Pointer(l)).Fnext = libc.UintptrFromInt32(0)
			XFcValueListDestroy(tls, l)
			if !((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues != 0) {
				XFcPatternDel(tls, p, object)
			}
			return int32(m_FcTrue)
		}
		id--
		goto _1
	_1:
		;
		prev = l
	}
	return m_FcFalse
}

func XFcPatternObjectAddInteger(tls *libc.TLS, p uintptr, object TFcObject, i int32) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* v at bp+0 */ TFcValue
	(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeInteger)
	*(*int32)(unsafe.Pointer(bp + 8)) = i
	return XFcPatternObjectAdd(tls, p, object, *(*TFcValue)(unsafe.Pointer(bp)), int32(m_FcTrue))
}

func XFcPatternAddInteger(tls *libc.TLS, p uintptr, object uintptr, i int32) (r TFcBool) {
	return XFcPatternObjectAddInteger(tls, p, XFcObjectFromName(tls, object), i)
}

func XFcPatternObjectAddDouble(tls *libc.TLS, p uintptr, object TFcObject, d float64) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* v at bp+0 */ TFcValue
	(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeDouble)
	*(*float64)(unsafe.Pointer(bp + 8)) = d
	return XFcPatternObjectAdd(tls, p, object, *(*TFcValue)(unsafe.Pointer(bp)), int32(m_FcTrue))
}

func XFcPatternAddDouble(tls *libc.TLS, p uintptr, object uintptr, d float64) (r TFcBool) {
	return XFcPatternObjectAddDouble(tls, p, XFcObjectFromName(tls, object), d)
}

func XFcPatternObjectAddString(tls *libc.TLS, p uintptr, object TFcObject, s uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* v at bp+0 */ TFcValue
	if !(s != 0) {
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
		*(*uintptr)(unsafe.Pointer(bp + 8)) = uintptr(0)
		return XFcPatternObjectAdd(tls, p, object, *(*TFcValue)(unsafe.Pointer(bp)), int32(m_FcTrue))
	}
	(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeString)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = s
	return XFcPatternObjectAdd(tls, p, object, *(*TFcValue)(unsafe.Pointer(bp)), int32(m_FcTrue))
}

func XFcPatternAddString(tls *libc.TLS, p uintptr, object uintptr, s uintptr) (r TFcBool) {
	return XFcPatternObjectAddString(tls, p, XFcObjectFromName(tls, object), s)
}

func XFcPatternAddMatrix(tls *libc.TLS, p uintptr, object uintptr, s uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* v at bp+0 */ TFcValue
	(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeMatrix)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = s
	return XFcPatternAdd(tls, p, object, *(*TFcValue)(unsafe.Pointer(bp)), int32(m_FcTrue))
}

func XFcPatternObjectAddBool(tls *libc.TLS, p uintptr, object TFcObject, b TFcBool) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* v at bp+0 */ TFcValue
	(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeBool)
	*(*TFcBool)(unsafe.Pointer(bp + 8)) = b
	return XFcPatternObjectAdd(tls, p, object, *(*TFcValue)(unsafe.Pointer(bp)), int32(m_FcTrue))
}

func XFcPatternAddBool(tls *libc.TLS, p uintptr, object uintptr, b TFcBool) (r TFcBool) {
	return XFcPatternObjectAddBool(tls, p, XFcObjectFromName(tls, object), b)
}

func XFcPatternObjectAddCharSet(tls *libc.TLS, p uintptr, object TFcObject, c uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* v at bp+0 */ TFcValue
	(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeCharSet)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = c
	return XFcPatternObjectAdd(tls, p, object, *(*TFcValue)(unsafe.Pointer(bp)), int32(m_FcTrue))
}

func XFcPatternAddCharSet(tls *libc.TLS, p uintptr, object uintptr, c uintptr) (r TFcBool) {
	return XFcPatternObjectAddCharSet(tls, p, XFcObjectFromName(tls, object), c)
}

func XFcPatternAddFTFace(tls *libc.TLS, p uintptr, object uintptr, f TFT_Face) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* v at bp+0 */ TFcValue
	(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeFTFace)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = f
	return XFcPatternAdd(tls, p, object, *(*TFcValue)(unsafe.Pointer(bp)), int32(m_FcTrue))
}

func XFcPatternObjectAddLangSet(tls *libc.TLS, p uintptr, object TFcObject, ls uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* v at bp+0 */ TFcValue
	(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeLangSet)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = ls
	return XFcPatternObjectAdd(tls, p, object, *(*TFcValue)(unsafe.Pointer(bp)), int32(m_FcTrue))
}

func XFcPatternAddLangSet(tls *libc.TLS, p uintptr, object uintptr, ls uintptr) (r TFcBool) {
	return XFcPatternObjectAddLangSet(tls, p, XFcObjectFromName(tls, object), ls)
}

func XFcPatternObjectAddRange(tls *libc.TLS, p uintptr, object TFcObject, r uintptr) (r1 TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* v at bp+0 */ TFcValue
	(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeRange)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = r
	return XFcPatternObjectAdd(tls, p, object, *(*TFcValue)(unsafe.Pointer(bp)), int32(m_FcTrue))
}

func XFcPatternAddRange(tls *libc.TLS, p uintptr, object uintptr, r uintptr) (r1 TFcBool) {
	return XFcPatternObjectAddRange(tls, p, XFcObjectFromName(tls, object), r)
}

func XFcPatternObjectGetWithBinding(tls *libc.TLS, p uintptr, object TFcObject, id int32, v uintptr, b uintptr) (r TFcResult) {
	var e, v2, v3 uintptr
	var l TFcValueListPtr
	_, _, _, _ = e, l, v2, v3
	if !(p != 0) {
		return int32(_FcResultNoMatch)
	}
	e = XFcPatternObjectFindElt(tls, p, object)
	if !(e != 0) {
		return int32(_FcResultNoMatch)
	}
	if int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(1) != 0 {
		v2 = uintptr(int64(e) + int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(^libc.Int32FromInt32(1)))
	} else {
		v2 = (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues
	}
	l = v2
	for {
		if !(l != 0) {
			break
		}
		if !(id != 0) {
			*(*TFcValue)(unsafe.Pointer(v)) = XFcValueCanonicalize(tls, l+8)
			if b != 0 {
				*(*TFcValueBinding)(unsafe.Pointer(b)) = (*T_FcValueList)(unsafe.Pointer(l)).Fbinding
			}
			return int32(_FcResultMatch)
		}
		id--
		goto _1
	_1:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
			v3 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v3 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
		}
		l = v3
	}
	return int32(_FcResultNoId)
}

func XFcPatternObjectGet(tls *libc.TLS, p uintptr, object TFcObject, id int32, v uintptr) (r TFcResult) {
	return XFcPatternObjectGetWithBinding(tls, p, object, id, v, libc.UintptrFromInt32(0))
}

func XFcPatternGetWithBinding(tls *libc.TLS, p uintptr, object uintptr, id int32, v uintptr, b uintptr) (r TFcResult) {
	return XFcPatternObjectGetWithBinding(tls, p, XFcObjectFromName(tls, object), id, v, b)
}

func XFcPatternGet(tls *libc.TLS, p uintptr, object uintptr, id int32, v uintptr) (r TFcResult) {
	return XFcPatternObjectGetWithBinding(tls, p, XFcObjectFromName(tls, object), id, v, libc.UintptrFromInt32(0))
}

func XFcPatternObjectGetInteger(tls *libc.TLS, p uintptr, object TFcObject, id int32, i uintptr) (r1 TFcResult) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r TFcResult
	var _ /* v at bp+0 */ TFcValue
	_ = r
	r = XFcPatternObjectGet(tls, p, object, id, bp)
	if r != int32(_FcResultMatch) {
		return r
	}
	switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
	case int32(_FcTypeDouble):
		*(*int32)(unsafe.Pointer(i)) = int32(*(*float64)(unsafe.Pointer(bp + 8)))
	case int32(_FcTypeInteger):
		*(*int32)(unsafe.Pointer(i)) = *(*int32)(unsafe.Pointer(bp + 8))
	default:
		return int32(_FcResultTypeMismatch)
	}
	return int32(_FcResultMatch)
}

func XFcPatternGetInteger(tls *libc.TLS, p uintptr, object uintptr, id int32, i uintptr) (r TFcResult) {
	return XFcPatternObjectGetInteger(tls, p, XFcObjectFromName(tls, object), id, i)
}

func XFcPatternObjectGetDouble(tls *libc.TLS, p uintptr, object TFcObject, id int32, d uintptr) (r1 TFcResult) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r TFcResult
	var _ /* v at bp+0 */ TFcValue
	_ = r
	r = XFcPatternObjectGet(tls, p, object, id, bp)
	if r != int32(_FcResultMatch) {
		return r
	}
	switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
	case int32(_FcTypeDouble):
		*(*float64)(unsafe.Pointer(d)) = *(*float64)(unsafe.Pointer(bp + 8))
	case int32(_FcTypeInteger):
		*(*float64)(unsafe.Pointer(d)) = float64(*(*int32)(unsafe.Pointer(bp + 8)))
	default:
		return int32(_FcResultTypeMismatch)
	}
	return int32(_FcResultMatch)
}

func XFcPatternGetDouble(tls *libc.TLS, p uintptr, object uintptr, id int32, d uintptr) (r TFcResult) {
	return XFcPatternObjectGetDouble(tls, p, XFcObjectFromName(tls, object), id, d)
}

func XFcPatternObjectGetString(tls *libc.TLS, p uintptr, object TFcObject, id int32, s uintptr) (r1 TFcResult) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r TFcResult
	var _ /* v at bp+0 */ TFcValue
	_ = r
	r = XFcPatternObjectGet(tls, p, object, id, bp)
	if r != int32(_FcResultMatch) {
		return r
	}
	if (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 != int32(_FcTypeString) {
		return int32(_FcResultTypeMismatch)
	}
	*(*uintptr)(unsafe.Pointer(s)) = *(*uintptr)(unsafe.Pointer(bp + 8))
	return int32(_FcResultMatch)
}

func XFcPatternGetString(tls *libc.TLS, p uintptr, object uintptr, id int32, s uintptr) (r TFcResult) {
	return XFcPatternObjectGetString(tls, p, XFcObjectFromName(tls, object), id, s)
}

func XFcPatternGetMatrix(tls *libc.TLS, p uintptr, object uintptr, id int32, m uintptr) (r1 TFcResult) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r TFcResult
	var _ /* v at bp+0 */ TFcValue
	_ = r
	r = XFcPatternGet(tls, p, object, id, bp)
	if r != int32(_FcResultMatch) {
		return r
	}
	if (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 != int32(_FcTypeMatrix) {
		return int32(_FcResultTypeMismatch)
	}
	*(*uintptr)(unsafe.Pointer(m)) = *(*uintptr)(unsafe.Pointer(bp + 8))
	return int32(_FcResultMatch)
}

func XFcPatternObjectGetBool(tls *libc.TLS, p uintptr, object TFcObject, id int32, b uintptr) (r1 TFcResult) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r TFcResult
	var _ /* v at bp+0 */ TFcValue
	_ = r
	r = XFcPatternObjectGet(tls, p, object, id, bp)
	if r != int32(_FcResultMatch) {
		return r
	}
	if (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 != int32(_FcTypeBool) {
		return int32(_FcResultTypeMismatch)
	}
	*(*TFcBool)(unsafe.Pointer(b)) = *(*TFcBool)(unsafe.Pointer(bp + 8))
	return int32(_FcResultMatch)
}

func XFcPatternGetBool(tls *libc.TLS, p uintptr, object uintptr, id int32, b uintptr) (r TFcResult) {
	return XFcPatternObjectGetBool(tls, p, XFcObjectFromName(tls, object), id, b)
}

func XFcPatternGetCharSet(tls *libc.TLS, p uintptr, object uintptr, id int32, c uintptr) (r1 TFcResult) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r TFcResult
	var _ /* v at bp+0 */ TFcValue
	_ = r
	r = XFcPatternGet(tls, p, object, id, bp)
	if r != int32(_FcResultMatch) {
		return r
	}
	if (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 != int32(_FcTypeCharSet) {
		return int32(_FcResultTypeMismatch)
	}
	*(*uintptr)(unsafe.Pointer(c)) = *(*uintptr)(unsafe.Pointer(bp + 8))
	return int32(_FcResultMatch)
}

func XFcPatternGetFTFace(tls *libc.TLS, p uintptr, object uintptr, id int32, f uintptr) (r1 TFcResult) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r TFcResult
	var _ /* v at bp+0 */ TFcValue
	_ = r
	r = XFcPatternGet(tls, p, object, id, bp)
	if r != int32(_FcResultMatch) {
		return r
	}
	if (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 != int32(_FcTypeFTFace) {
		return int32(_FcResultTypeMismatch)
	}
	*(*TFT_Face)(unsafe.Pointer(f)) = *(*uintptr)(unsafe.Pointer(bp + 8))
	return int32(_FcResultMatch)
}

func XFcPatternGetLangSet(tls *libc.TLS, p uintptr, object uintptr, id int32, ls uintptr) (r1 TFcResult) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r TFcResult
	var _ /* v at bp+0 */ TFcValue
	_ = r
	r = XFcPatternGet(tls, p, object, id, bp)
	if r != int32(_FcResultMatch) {
		return r
	}
	if (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 != int32(_FcTypeLangSet) {
		return int32(_FcResultTypeMismatch)
	}
	*(*uintptr)(unsafe.Pointer(ls)) = *(*uintptr)(unsafe.Pointer(bp + 8))
	return int32(_FcResultMatch)
}

func XFcPatternObjectGetRange(tls *libc.TLS, p uintptr, object TFcObject, id int32, r uintptr) (r1 TFcResult) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var res TFcResult
	var _ /* v at bp+0 */ TFcValue
	_ = res
	res = XFcPatternObjectGet(tls, p, object, id, bp)
	if res != int32(_FcResultMatch) {
		return res
	}
	switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
	case int32(_FcTypeRange):
		*(*uintptr)(unsafe.Pointer(r)) = *(*uintptr)(unsafe.Pointer(bp + 8))
	default:
		return int32(_FcResultTypeMismatch)
	}
	return int32(_FcResultMatch)
}

func XFcPatternGetRange(tls *libc.TLS, p uintptr, object uintptr, id int32, r uintptr) (r1 TFcResult) {
	return XFcPatternObjectGetRange(tls, p, XFcObjectFromName(tls, object), id, r)
}

func XFcPatternDuplicate(tls *libc.TLS, orig uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var l TFcValueListPtr
	var new1, v2 uintptr
	var _ /* iter at bp+0 */ TFcPatternIter
	_, _, _ = l, new1, v2
	if !(orig != 0) {
		return libc.UintptrFromInt32(0)
	}
	new1 = XFcPatternCreate(tls)
	if !(new1 != 0) {
		goto bail0
	}
	XFcPatternIterStart(tls, orig, bp)
	for cond := true; cond; cond = XFcPatternIterNext(tls, orig, bp) != 0 {
		l = XFcPatternIterGetValues(tls, orig, bp)
		for {
			if !(l != 0) {
				break
			}
			if !(XFcPatternObjectAddWithBinding(tls, new1, XFcPatternIterGetObjectId(tls, orig, bp), XFcValueCanonicalize(tls, l+8), (*T_FcValueList)(unsafe.Pointer(l)).Fbinding, int32(m_FcTrue)) != 0) {
				goto bail1
			}
			goto _1
		_1:
			;
			if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
				v2 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
			} else {
				v2 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
			}
			l = v2
		}
	}
	return new1
	goto bail1
bail1:
	;
	XFcPatternDestroy(tls, new1)
	goto bail0
bail0:
	;
	return uintptr(0)
	return r
}

func XFcPatternReference(tls *libc.TLS, p uintptr) {
	var v1 TFcBool
	var p4 uintptr
	_, _ = v1, p4
	v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(p+16)).Fcount == -libc.Int32FromInt32(1))
	goto _2
_2:
	if !(v1 != 0) {
		p4 = p + 16
		*(*Tfc_atomic_int_t)(unsafe.Pointer(p4)) += +libc.Int32FromInt32(1)
		_ = *(*Tfc_atomic_int_t)(unsafe.Pointer(p4)) - +libc.Int32FromInt32(1)
		goto _3
	_3:
	} else {
		XFcCacheObjectReference(tls, _FcPatternGetCacheObject(tls, p))
	}
}

func XFcPatternVaBuild(tls *libc.TLS, p uintptr, va Tva_list) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var __o__, __p__, ret uintptr
	var _ /* __v__ at bp+0 */ TFcValue
	_, _, _ = __o__, __p__, ret
	__p__ = p
	if !(__p__ != 0) {
		__p__ = XFcPatternCreate(tls)
		if !(__p__ != 0) {
			goto _FcPatternVapBuild_bail0
		}
	}
	for {
		__o__ = libc.VaUintptr(&va)
		if !(__o__ != 0) {
			break
		}
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = libc.VaInt32(&va)
		switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
		case int32(_FcTypeUnknown):
			fallthrough
		case int32(_FcTypeVoid):
			goto _FcPatternVapBuild_bail1
		case int32(_FcTypeInteger):
			*(*int32)(unsafe.Pointer(bp + 8)) = libc.VaInt32(&va)
		case int32(_FcTypeDouble):
			*(*float64)(unsafe.Pointer(bp + 8)) = libc.VaFloat64(&va)
		case int32(_FcTypeString):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeBool):
			*(*TFcBool)(unsafe.Pointer(bp + 8)) = libc.VaInt32(&va)
		case int32(_FcTypeMatrix):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeCharSet):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeFTFace):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeLangSet):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeRange):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
			break
		}
		if !(XFcPatternAdd(tls, __p__, __o__, *(*TFcValue)(unsafe.Pointer(bp)), int32(m_FcTrue)) != 0) {
			goto _FcPatternVapBuild_bail1
		}
		goto _1
	_1:
	}
	ret = __p__
	goto _FcPatternVapBuild_return
	goto _FcPatternVapBuild_bail1
_FcPatternVapBuild_bail1:
	;
	if !(p != 0) {
		XFcPatternDestroy(tls, __p__)
	}
	goto _FcPatternVapBuild_bail0
_FcPatternVapBuild_bail0:
	;
	ret = libc.UintptrFromInt32(0)
	goto _FcPatternVapBuild_return
_FcPatternVapBuild_return:
	;
	return ret
}

func XFcPatternBuild(tls *libc.TLS, p uintptr, va1 uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var __o__, __p__ uintptr
	var va Tva_list
	var _ /* __v__ at bp+0 */ TFcValue
	_, _, _ = __o__, __p__, va
	va = va1
	__p__ = p
	if !(__p__ != 0) {
		__p__ = XFcPatternCreate(tls)
		if !(__p__ != 0) {
			goto _FcPatternVapBuild_bail0
		}
	}
	for {
		__o__ = libc.VaUintptr(&va)
		if !(__o__ != 0) {
			break
		}
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = libc.VaInt32(&va)
		switch (*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 {
		case int32(_FcTypeUnknown):
			fallthrough
		case int32(_FcTypeVoid):
			goto _FcPatternVapBuild_bail1
		case int32(_FcTypeInteger):
			*(*int32)(unsafe.Pointer(bp + 8)) = libc.VaInt32(&va)
		case int32(_FcTypeDouble):
			*(*float64)(unsafe.Pointer(bp + 8)) = libc.VaFloat64(&va)
		case int32(_FcTypeString):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeBool):
			*(*TFcBool)(unsafe.Pointer(bp + 8)) = libc.VaInt32(&va)
		case int32(_FcTypeMatrix):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeCharSet):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeFTFace):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeLangSet):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
		case int32(_FcTypeRange):
			*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.VaUintptr(&va)
			break
		}
		if !(XFcPatternAdd(tls, __p__, __o__, *(*TFcValue)(unsafe.Pointer(bp)), int32(m_FcTrue)) != 0) {
			goto _FcPatternVapBuild_bail1
		}
		goto _1
	_1:
	}
	p = __p__
	goto _FcPatternVapBuild_return
	goto _FcPatternVapBuild_bail1
_FcPatternVapBuild_bail1:
	;
	if !(p != 0) {
		XFcPatternDestroy(tls, __p__)
	}
	goto _FcPatternVapBuild_bail0
_FcPatternVapBuild_bail0:
	;
	p = libc.UintptrFromInt32(0)
	goto _FcPatternVapBuild_return
_FcPatternVapBuild_return:
	;
	_ = va
	return p
}

// C documentation
//
//	/*
//	 * Add all of the elements in 's' to 'p'
//	 */
func XFcPatternAppend(tls *libc.TLS, p uintptr, s uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v TFcValueListPtr
	var v2 uintptr
	var _ /* iter at bp+0 */ TFcPatternIter
	_, _ = v, v2
	XFcPatternIterStart(tls, s, bp)
	for cond := true; cond; cond = XFcPatternIterNext(tls, s, bp) != 0 {
		v = XFcPatternIterGetValues(tls, s, bp)
		for {
			if !(v != 0) {
				break
			}
			if !(XFcPatternObjectAddWithBinding(tls, p, XFcPatternIterGetObjectId(tls, s, bp), XFcValueCanonicalize(tls, v+8), (*T_FcValueList)(unsafe.Pointer(v)).Fbinding, int32(m_FcTrue)) != 0) {
				return m_FcFalse
			}
			goto _1
		_1:
			;
			if int64((*T_FcValueList)(unsafe.Pointer(v)).Fnext)&int64(1) != 0 {
				v2 = uintptr(int64(v) + int64((*T_FcValueList)(unsafe.Pointer(v)).Fnext)&int64(^libc.Int32FromInt32(1)))
			} else {
				v2 = (*T_FcValueList)(unsafe.Pointer(v)).Fnext
			}
			v = v2
		}
	}
	return int32(m_FcTrue)
}

func XFcPatternFilter(tls *libc.TLS, p uintptr, os uintptr) (r uintptr) {
	var e, ret, v3, v4 uintptr
	var i int32
	var object TFcObject
	var v TFcValueListPtr
	_, _, _, _, _, _, _ = e, i, object, ret, v, v3, v4
	if !(os != 0) {
		return XFcPatternDuplicate(tls, p)
	}
	ret = XFcPatternCreate(tls)
	if !(ret != 0) {
		return libc.UintptrFromInt32(0)
	}
	i = 0
	for {
		if !(i < (*TFcObjectSet)(unsafe.Pointer(os)).Fnobject) {
			break
		}
		object = XFcObjectFromName(tls, *(*uintptr)(unsafe.Pointer((*TFcObjectSet)(unsafe.Pointer(os)).Fobjects + uintptr(i)*8)))
		e = XFcPatternObjectFindElt(tls, p, object)
		if e != 0 {
			if int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(1) != 0 {
				v3 = uintptr(int64(e) + int64((*TFcPatternElt)(unsafe.Pointer(e)).Fvalues)&int64(^libc.Int32FromInt32(1)))
			} else {
				v3 = (*TFcPatternElt)(unsafe.Pointer(e)).Fvalues
			}
			v = v3
			for {
				if !(v != 0) {
					break
				}
				if !(XFcPatternObjectAddWithBinding(tls, ret, (*TFcPatternElt)(unsafe.Pointer(e)).Fobject, XFcValueCanonicalize(tls, v+8), (*T_FcValueList)(unsafe.Pointer(v)).Fbinding, int32(m_FcTrue)) != 0) {
					goto bail0
				}
				goto _2
			_2:
				;
				if int64((*T_FcValueList)(unsafe.Pointer(v)).Fnext)&int64(1) != 0 {
					v4 = uintptr(int64(v) + int64((*T_FcValueList)(unsafe.Pointer(v)).Fnext)&int64(^libc.Int32FromInt32(1)))
				} else {
					v4 = (*T_FcValueList)(unsafe.Pointer(v)).Fnext
				}
				v = v4
			}
		}
		goto _1
	_1:
		;
		i++
	}
	return ret
	goto bail0
bail0:
	;
	XFcPatternDestroy(tls, ret)
	return libc.UintptrFromInt32(0)
}

type TFcPatternPrivateIter = struct {
	Felt uintptr
	Fpos int32
}

type T_FcPatternPrivateIter = TFcPatternPrivateIter

func _FcPatternIterSet(tls *libc.TLS, pat uintptr, iter uintptr) {
	var v1 uintptr
	_ = v1
	if XFcPatternObjectCount(tls, pat) > 0 && (*TFcPatternPrivateIter)(unsafe.Pointer(iter)).Fpos < XFcPatternObjectCount(tls, pat) {
		v1 = uintptr(int64(pat)+(*TFcPattern)(unsafe.Pointer(pat)).Felts_offset) + uintptr((*TFcPatternPrivateIter)(unsafe.Pointer(iter)).Fpos)*16
	} else {
		v1 = libc.UintptrFromInt32(0)
	}
	(*TFcPatternPrivateIter)(unsafe.Pointer(iter)).Felt = v1
}

func XFcPatternIterStart(tls *libc.TLS, pat uintptr, iter uintptr) {
	var priv uintptr
	_ = priv
	priv = iter
	(*TFcPatternPrivateIter)(unsafe.Pointer(priv)).Fpos = 0
	_FcPatternIterSet(tls, pat, priv)
}

func XFcPatternIterNext(tls *libc.TLS, pat uintptr, iter uintptr) (r TFcBool) {
	var priv uintptr
	_ = priv
	priv = iter
	(*TFcPatternPrivateIter)(unsafe.Pointer(priv)).Fpos++
	if (*TFcPatternPrivateIter)(unsafe.Pointer(priv)).Fpos >= XFcPatternObjectCount(tls, pat) {
		return m_FcFalse
	}
	_FcPatternIterSet(tls, pat, priv)
	return int32(m_FcTrue)
}

func XFcPatternIterEqual(tls *libc.TLS, p1 uintptr, i1 uintptr, p2 uintptr, i2 uintptr) (r TFcBool) {
	var b1, b2 TFcBool
	_, _ = b1, b2
	b1 = XFcPatternIterIsValid(tls, p1, i1)
	b2 = XFcPatternIterIsValid(tls, p2, i2)
	if !(i1 != 0) && !(i2 != 0) {
		return int32(m_FcTrue)
	}
	if !(b1 != 0) || !(b2 != 0) {
		return m_FcFalse
	}
	if XFcPatternIterGetObjectId(tls, p1, i1) != XFcPatternIterGetObjectId(tls, p2, i2) {
		return m_FcFalse
	}
	return _FcValueListEqual(tls, XFcPatternIterGetValues(tls, p1, i1), XFcPatternIterGetValues(tls, p2, i2))
}

func XFcPatternFindObjectIter(tls *libc.TLS, pat uintptr, iter uintptr, object TFcObject) (r TFcBool) {
	var i int32
	var priv uintptr
	_, _ = i, priv
	priv = iter
	i = _FcPatternObjectPosition(tls, pat, object)
	(*TFcPatternPrivateIter)(unsafe.Pointer(priv)).Felt = libc.UintptrFromInt32(0)
	if i < 0 {
		return m_FcFalse
	}
	(*TFcPatternPrivateIter)(unsafe.Pointer(priv)).Fpos = i
	_FcPatternIterSet(tls, pat, priv)
	return int32(m_FcTrue)
}

func XFcPatternFindIter(tls *libc.TLS, pat uintptr, iter uintptr, object uintptr) (r TFcBool) {
	return XFcPatternFindObjectIter(tls, pat, iter, XFcObjectFromName(tls, object))
}

func XFcPatternIterIsValid(tls *libc.TLS, pat uintptr, iter uintptr) (r TFcBool) {
	var priv uintptr
	_ = priv
	priv = iter
	if priv != 0 && (*TFcPatternPrivateIter)(unsafe.Pointer(priv)).Felt != 0 {
		return int32(m_FcTrue)
	}
	return m_FcFalse
}

func XFcPatternIterGetObjectId(tls *libc.TLS, pat uintptr, iter uintptr) (r TFcObject) {
	var priv uintptr
	_ = priv
	priv = iter
	if priv != 0 && (*TFcPatternPrivateIter)(unsafe.Pointer(priv)).Felt != 0 {
		return (*TFcPatternElt)(unsafe.Pointer((*TFcPatternPrivateIter)(unsafe.Pointer(priv)).Felt)).Fobject
	}
	return 0
}

func XFcPatternIterGetObject(tls *libc.TLS, pat uintptr, iter uintptr) (r uintptr) {
	return XFcObjectName(tls, XFcPatternIterGetObjectId(tls, pat, iter))
}

func XFcPatternIterGetValues(tls *libc.TLS, pat uintptr, iter uintptr) (r TFcValueListPtr) {
	var priv, v1 uintptr
	_, _ = priv, v1
	priv = iter
	if priv != 0 && (*TFcPatternPrivateIter)(unsafe.Pointer(priv)).Felt != 0 {
		if int64((*TFcPatternElt)(unsafe.Pointer((*TFcPatternPrivateIter)(unsafe.Pointer(priv)).Felt)).Fvalues)&int64(1) != 0 {
			v1 = uintptr(int64((*TFcPatternPrivateIter)(unsafe.Pointer(priv)).Felt) + int64((*TFcPatternElt)(unsafe.Pointer((*TFcPatternPrivateIter)(unsafe.Pointer(priv)).Felt)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v1 = (*TFcPatternElt)(unsafe.Pointer((*TFcPatternPrivateIter)(unsafe.Pointer(priv)).Felt)).Fvalues
		}
		return v1
	}
	return libc.UintptrFromInt32(0)
}

func XFcPatternIterValueCount(tls *libc.TLS, pat uintptr, iter uintptr) (r int32) {
	var count int32
	var l TFcValueListPtr
	var v2 uintptr
	_, _, _ = count, l, v2
	count = 0
	l = XFcPatternIterGetValues(tls, pat, iter)
	for {
		if !(l != 0) {
			break
		}
		count++
		goto _1
	_1:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
			v2 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
		}
		l = v2
	}
	return count
}

func XFcPatternIterGetValue(tls *libc.TLS, pat uintptr, iter uintptr, id int32, v uintptr, b uintptr) (r TFcResult) {
	var l TFcValueListPtr
	var v2 uintptr
	_, _ = l, v2
	l = XFcPatternIterGetValues(tls, pat, iter)
	for {
		if !(l != 0) {
			break
		}
		if id == 0 {
			*(*TFcValue)(unsafe.Pointer(v)) = XFcValueCanonicalize(tls, l+8)
			if b != 0 {
				*(*TFcValueBinding)(unsafe.Pointer(b)) = (*T_FcValueList)(unsafe.Pointer(l)).Fbinding
			}
			return int32(_FcResultMatch)
		}
		id--
		goto _1
	_1:
		;
		if int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(1) != 0 {
			v2 = uintptr(int64(l) + int64((*T_FcValueList)(unsafe.Pointer(l)).Fnext)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*T_FcValueList)(unsafe.Pointer(l)).Fnext
		}
		l = v2
	}
	return int32(_FcResultNoId)
}

func XFcPatternSerializeAlloc(tls *libc.TLS, serialize uintptr, pat uintptr) (r TFcBool) {
	var elts, v2 uintptr
	var i int32
	_, _, _ = elts, i, v2
	elts = uintptr(int64(pat) + (*TFcPattern)(unsafe.Pointer(pat)).Felts_offset)
	if !(XFcSerializeAlloc(tls, serialize, pat, int32(24)) != 0) {
		return m_FcFalse
	}
	if !(XFcSerializeAlloc(tls, serialize, elts, libc.Int32FromUint64(libc.Uint64FromInt32(XFcPatternObjectCount(tls, pat))*uint64(16))) != 0) {
		return m_FcFalse
	}
	i = 0
	for {
		if !(i < XFcPatternObjectCount(tls, pat)) {
			break
		}
		if int64((*TFcPatternElt)(unsafe.Pointer(elts+uintptr(i)*16)).Fvalues)&int64(1) != 0 {
			v2 = uintptr(int64(elts+uintptr(i)*16) + int64((*TFcPatternElt)(unsafe.Pointer(elts+uintptr(i)*16)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*TFcPatternElt)(unsafe.Pointer(elts + uintptr(i)*16)).Fvalues
		}
		if !(XFcValueListSerializeAlloc(tls, serialize, v2) != 0) {
			return m_FcFalse
		}
		goto _1
	_1:
		;
		i++
	}
	return int32(m_FcTrue)
}

func XFcPatternSerialize(tls *libc.TLS, serialize uintptr, pat uintptr) (r uintptr) {
	var elts, elts_serialized, pat_serialized, values_serialized, v2 uintptr
	var i int32
	_, _, _, _, _, _ = elts, elts_serialized, i, pat_serialized, values_serialized, v2
	elts = uintptr(int64(pat) + (*TFcPattern)(unsafe.Pointer(pat)).Felts_offset)
	pat_serialized = XFcSerializePtr(tls, serialize, pat)
	if !(pat_serialized != 0) {
		return libc.UintptrFromInt32(0)
	}
	*(*TFcPattern)(unsafe.Pointer(pat_serialized)) = *(*TFcPattern)(unsafe.Pointer(pat))
	(*TFcPattern)(unsafe.Pointer(pat_serialized)).Fsize = XFcPatternObjectCount(tls, pat)
	(*TFcRef)(unsafe.Pointer(pat_serialized + 16)).Fcount = -libc.Int32FromInt32(1)
	elts_serialized = XFcSerializePtr(tls, serialize, elts)
	if !(elts_serialized != 0) {
		return libc.UintptrFromInt32(0)
	}
	(*TFcPattern)(unsafe.Pointer(pat_serialized)).Felts_offset = int64(elts_serialized) - int64(pat_serialized)
	i = 0
	for {
		if !(i < XFcPatternObjectCount(tls, pat)) {
			break
		}
		if int64((*TFcPatternElt)(unsafe.Pointer(elts+uintptr(i)*16)).Fvalues)&int64(1) != 0 {
			v2 = uintptr(int64(elts+uintptr(i)*16) + int64((*TFcPatternElt)(unsafe.Pointer(elts+uintptr(i)*16)).Fvalues)&int64(^libc.Int32FromInt32(1)))
		} else {
			v2 = (*TFcPatternElt)(unsafe.Pointer(elts + uintptr(i)*16)).Fvalues
		}
		values_serialized = XFcValueListSerialize(tls, serialize, v2)
		if !(values_serialized != 0) {
			return libc.UintptrFromInt32(0)
		}
		(*(*TFcPatternElt)(unsafe.Pointer(elts_serialized + uintptr(i)*16))).Fobject = (*(*TFcPatternElt)(unsafe.Pointer(elts + uintptr(i)*16))).Fobject
		(*(*TFcPatternElt)(unsafe.Pointer(elts_serialized + uintptr(i)*16))).Fvalues = uintptr(int64(values_serialized) - Tintptr_t(elts_serialized+uintptr(i)*16) | libc.Int64FromInt32(1))
		goto _1
	_1:
		;
		i++
	}
	if XFcDebugVal&int32(m_FC_DBG_CACHEV) != 0 {
		libc.Xprintf(tls, __ccgo_ts+6932, 0)
		XFcPatternPrint(tls, pat)
		libc.Xprintf(tls, __ccgo_ts+6946, 0)
		XFcPatternPrint(tls, pat_serialized)
		libc.Xprintf(tls, __ccgo_ts+1266, 0)
	}
	return pat_serialized
}

func XFcValueListSerializeAlloc(tls *libc.TLS, serialize uintptr, vl uintptr) (r TFcBool) {
	for vl != 0 {
		if !(XFcSerializeAlloc(tls, serialize, vl, int32(32)) != 0) {
			return m_FcFalse
		}
		switch (*TFcValueList)(unsafe.Pointer(vl)).Fvalue.Ftype1 {
		case int32(_FcTypeString):
			if !(XFcStrSerializeAlloc(tls, serialize, *(*uintptr)(unsafe.Pointer(vl + 8 + 8))) != 0) {
				return m_FcFalse
			}
		case int32(_FcTypeCharSet):
			if !(XFcCharSetSerializeAlloc(tls, serialize, *(*uintptr)(unsafe.Pointer(vl + 8 + 8))) != 0) {
				return m_FcFalse
			}
		case int32(_FcTypeLangSet):
			if !(XFcLangSetSerializeAlloc(tls, serialize, *(*uintptr)(unsafe.Pointer(vl + 8 + 8))) != 0) {
				return m_FcFalse
			}
		case int32(_FcTypeRange):
			if !(XFcRangeSerializeAlloc(tls, serialize, *(*uintptr)(unsafe.Pointer(vl + 8 + 8))) != 0) {
				return m_FcFalse
			}
		default:
			break
		}
		vl = (*TFcValueList)(unsafe.Pointer(vl)).Fnext
	}
	return int32(m_FcTrue)
}

func XFcValueListSerialize(tls *libc.TLS, serialize uintptr, vl uintptr) (r uintptr) {
	var c_serialized, head_serialized, l_serialized, prev_serialized, r_serialized, s_serialized, vl_serialized uintptr
	_, _, _, _, _, _, _ = c_serialized, head_serialized, l_serialized, prev_serialized, r_serialized, s_serialized, vl_serialized
	head_serialized = libc.UintptrFromInt32(0)
	prev_serialized = libc.UintptrFromInt32(0)
	for vl != 0 {
		vl_serialized = XFcSerializePtr(tls, serialize, vl)
		if !(vl_serialized != 0) {
			return libc.UintptrFromInt32(0)
		}
		if prev_serialized != 0 {
			(*TFcValueList)(unsafe.Pointer(prev_serialized)).Fnext = uintptr(int64(vl_serialized) - int64(prev_serialized) | libc.Int64FromInt32(1))
		} else {
			head_serialized = vl_serialized
		}
		(*TFcValueList)(unsafe.Pointer(vl_serialized)).Fnext = libc.UintptrFromInt32(0)
		(*TFcValueList)(unsafe.Pointer(vl_serialized)).Fvalue.Ftype1 = (*TFcValueList)(unsafe.Pointer(vl)).Fvalue.Ftype1
		switch (*TFcValueList)(unsafe.Pointer(vl)).Fvalue.Ftype1 {
		case int32(_FcTypeInteger):
			*(*int32)(unsafe.Pointer(vl_serialized + 8 + 8)) = *(*int32)(unsafe.Pointer(vl + 8 + 8))
		case int32(_FcTypeDouble):
			*(*float64)(unsafe.Pointer(vl_serialized + 8 + 8)) = *(*float64)(unsafe.Pointer(vl + 8 + 8))
		case int32(_FcTypeString):
			s_serialized = XFcStrSerialize(tls, serialize, *(*uintptr)(unsafe.Pointer(vl + 8 + 8)))
			if !(s_serialized != 0) {
				return libc.UintptrFromInt32(0)
			}
			*(*uintptr)(unsafe.Pointer(vl_serialized + 8 + 8)) = uintptr(int64(s_serialized) - Tintptr_t(vl_serialized+8) | libc.Int64FromInt32(1))
		case int32(_FcTypeBool):
			*(*TFcBool)(unsafe.Pointer(vl_serialized + 8 + 8)) = *(*TFcBool)(unsafe.Pointer(vl + 8 + 8))
		case int32(_FcTypeMatrix):
			/* can't happen */
		case int32(_FcTypeCharSet):
			c_serialized = XFcCharSetSerialize(tls, serialize, *(*uintptr)(unsafe.Pointer(vl + 8 + 8)))
			if !(c_serialized != 0) {
				return libc.UintptrFromInt32(0)
			}
			*(*uintptr)(unsafe.Pointer(vl_serialized + 8 + 8)) = uintptr(int64(c_serialized) - Tintptr_t(vl_serialized+8) | libc.Int64FromInt32(1))
		case int32(_FcTypeFTFace):
			/* can't happen */
		case int32(_FcTypeLangSet):
			l_serialized = XFcLangSetSerialize(tls, serialize, *(*uintptr)(unsafe.Pointer(vl + 8 + 8)))
			if !(l_serialized != 0) {
				return libc.UintptrFromInt32(0)
			}
			*(*uintptr)(unsafe.Pointer(vl_serialized + 8 + 8)) = uintptr(int64(l_serialized) - Tintptr_t(vl_serialized+8) | libc.Int64FromInt32(1))
		case int32(_FcTypeRange):
			r_serialized = XFcRangeSerialize(tls, serialize, *(*uintptr)(unsafe.Pointer(vl + 8 + 8)))
			if !(r_serialized != 0) {
				return libc.UintptrFromInt32(0)
			}
			*(*uintptr)(unsafe.Pointer(vl_serialized + 8 + 8)) = uintptr(int64(r_serialized) - Tintptr_t(vl_serialized+8) | libc.Int64FromInt32(1))
		default:
			break
		}
		prev_serialized = vl_serialized
		vl = (*TFcValueList)(unsafe.Pointer(vl)).Fnext
	}
	return head_serialized
}

func XFcRangeCreateDouble(tls *libc.TLS, begin float64, end float64) (r uintptr) {
	var ret uintptr
	_ = ret
	ret = libc.Xmalloc(tls, uint64(16))
	if ret != 0 {
		(*TFcRange)(unsafe.Pointer(ret)).Fbegin = begin
		(*TFcRange)(unsafe.Pointer(ret)).Fend = end
	}
	return ret
}

func XFcRangeCreateInteger(tls *libc.TLS, begin TFcChar32, end TFcChar32) (r uintptr) {
	var ret uintptr
	_ = ret
	ret = libc.Xmalloc(tls, uint64(16))
	if ret != 0 {
		(*TFcRange)(unsafe.Pointer(ret)).Fbegin = float64(begin)
		(*TFcRange)(unsafe.Pointer(ret)).Fend = float64(end)
	}
	return ret
}

func XFcRangeDestroy(tls *libc.TLS, range1 uintptr) {
	libc.Xfree(tls, range1)
}

func XFcRangeCopy(tls *libc.TLS, range1 uintptr) (r uintptr) {
	return XFcRangeCreateDouble(tls, (*TFcRange)(unsafe.Pointer(range1)).Fbegin, (*TFcRange)(unsafe.Pointer(range1)).Fend)
}

func XFcRangeGetDouble(tls *libc.TLS, range1 uintptr, begin uintptr, end uintptr) (r TFcBool) {
	if !(range1 != 0) {
		return m_FcFalse
	}
	if begin != 0 {
		*(*float64)(unsafe.Pointer(begin)) = (*TFcRange)(unsafe.Pointer(range1)).Fbegin
	}
	if end != 0 {
		*(*float64)(unsafe.Pointer(end)) = (*TFcRange)(unsafe.Pointer(range1)).Fend
	}
	return int32(m_FcTrue)
}

func XFcRangePromote(tls *libc.TLS, v float64, vbuf uintptr) (r uintptr) {
	var buf uintptr
	_ = buf
	buf = vbuf
	(*struct {
		Fr TFcRange
	})(unsafe.Pointer(buf)).Fr.Fbegin = v
	(*struct {
		Fr TFcRange
	})(unsafe.Pointer(buf)).Fr.Fend = v
	return buf
}

func XFcRangeIsInRange(tls *libc.TLS, a uintptr, b uintptr) (r TFcBool) {
	return libc.BoolInt32((*TFcRange)(unsafe.Pointer(a)).Fbegin >= (*TFcRange)(unsafe.Pointer(b)).Fbegin && (*TFcRange)(unsafe.Pointer(a)).Fend <= (*TFcRange)(unsafe.Pointer(b)).Fend)
}

func XFcRangeCompare(tls *libc.TLS, op TFcOp, a uintptr, b uintptr) (r TFcBool) {
	switch op {
	case int32(_FcOpEqual):
		return libc.BoolInt32((*TFcRange)(unsafe.Pointer(a)).Fbegin == (*TFcRange)(unsafe.Pointer(b)).Fbegin && (*TFcRange)(unsafe.Pointer(a)).Fend == (*TFcRange)(unsafe.Pointer(b)).Fend)
	case int32(_FcOpContains):
		fallthrough
	case int32(_FcOpListing):
		return XFcRangeIsInRange(tls, a, b)
	case int32(_FcOpNotEqual):
		return libc.BoolInt32((*TFcRange)(unsafe.Pointer(a)).Fbegin != (*TFcRange)(unsafe.Pointer(b)).Fbegin || (*TFcRange)(unsafe.Pointer(a)).Fend != (*TFcRange)(unsafe.Pointer(b)).Fend)
	case int32(_FcOpNotContains):
		return libc.BoolInt32(!(XFcRangeIsInRange(tls, a, b) != 0))
	case int32(_FcOpLess):
		return libc.BoolInt32((*TFcRange)(unsafe.Pointer(a)).Fend < (*TFcRange)(unsafe.Pointer(b)).Fbegin)
	case int32(_FcOpLessEqual):
		return libc.BoolInt32((*TFcRange)(unsafe.Pointer(a)).Fend <= (*TFcRange)(unsafe.Pointer(b)).Fbegin)
	case int32(_FcOpMore):
		return libc.BoolInt32((*TFcRange)(unsafe.Pointer(a)).Fbegin > (*TFcRange)(unsafe.Pointer(b)).Fend)
	case int32(_FcOpMoreEqual):
		return libc.BoolInt32((*TFcRange)(unsafe.Pointer(a)).Fbegin >= (*TFcRange)(unsafe.Pointer(b)).Fend)
	default:
		break
	}
	return m_FcFalse
}

func XFcRangeHash(tls *libc.TLS, r uintptr) (r1 TFcChar32) {
	var b, e int32
	_, _ = b, e
	b = int32(float64((*TFcRange)(unsafe.Pointer(r)).Fbegin * libc.Float64FromInt32(100)))
	e = int32(float64((*TFcRange)(unsafe.Pointer(r)).Fend * libc.Float64FromInt32(100)))
	return libc.Uint32FromInt32(b ^ b<<int32(1) ^ e<<int32(9))
}

func XFcRangeSerializeAlloc(tls *libc.TLS, serialize uintptr, r uintptr) (r1 TFcBool) {
	if !(XFcSerializeAlloc(tls, serialize, r, int32(16)) != 0) {
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

func XFcRangeSerialize(tls *libc.TLS, serialize uintptr, r uintptr) (r1 uintptr) {
	var r_serialize uintptr
	_ = r_serialize
	r_serialize = XFcSerializePtr(tls, serialize, r)
	if !(r_serialize != 0) {
		return libc.UintptrFromInt32(0)
	}
	libc.X__builtin___memcpy_chk(tls, r_serialize, r, uint64(16), ^t__predefined_size_t(0))
	return r_serialize
}

func XFcAlignSize(tls *libc.TLS, size Tintptr_t) (r Tintptr_t) {
	var rem Tintptr_t
	_ = rem
	rem = libc.Int64FromUint64(libc.Uint64FromInt64(size) % uint64(8))
	if rem != 0 {
		size = Tintptr_t(uint64(size) + (libc.Uint64FromInt64(8) - libc.Uint64FromInt64(rem)))
	}
	return size
}

/*
 * Serialization helper object -- allocate space in the
 * yet-to-be-created linear array for a serialized font set
 */

func XFcSerializeCreate(tls *libc.TLS) (r uintptr) {
	var serialize uintptr
	_ = serialize
	serialize = libc.Xmalloc(tls, uint64(56))
	if !(serialize != 0) {
		return libc.UintptrFromInt32(0)
	}
	(*TFcSerialize)(unsafe.Pointer(serialize)).Fsize = 0
	(*TFcSerialize)(unsafe.Pointer(serialize)).Flinear = libc.UintptrFromInt32(0)
	(*TFcSerialize)(unsafe.Pointer(serialize)).Fcs_freezer = libc.UintptrFromInt32(0)
	(*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets = libc.UintptrFromInt32(0)
	(*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_count = uint64(0)
	(*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_used = uint64(0)
	(*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_used_max = uint64(0)
	return serialize
}

func XFcSerializeDestroy(tls *libc.TLS, serialize uintptr) {
	libc.Xfree(tls, (*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets)
	if (*TFcSerialize)(unsafe.Pointer(serialize)).Fcs_freezer != 0 {
		XFcCharSetFreezerDestroy(tls, (*TFcSerialize)(unsafe.Pointer(serialize)).Fcs_freezer)
	}
	libc.Xfree(tls, serialize)
}

func _FcSerializeNextBucketIndex(tls *libc.TLS, serialize uintptr, index Tsize_t) (r Tsize_t) {
	if index == uint64(0) {
		index = (*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_count
	}
	index--
	return index
}

// C documentation
//
//	/*
//	 * Based on splittable64/splitmix64 from Mix13
//	 * https://zimbry.blogspot.com/2011/09/better-bit-mixing-improving-on.html
//	 * https://prng.di.unimi.it/splitmix64.c
//	 */
func _FcSerializeHashPtr(tls *libc.TLS, object uintptr) (r Tuintptr_t) {
	var x Tuintptr_t
	var v1 uint64
	_, _ = x, v1
	x = uint64(object)
	x ^= x >> int32(30)
	x *= uint64(0xbf58476d1ce4e5b9)
	x ^= x >> int32(27)
	x *= uint64(0x94d049bb133111eb)
	x ^= x >> int32(31)
	if x != 0 {
		v1 = x
	} else {
		v1 = uint64(1)
	}
	return v1 /* 0 reserved to mark empty, x starts out 0 */
}

func _FcSerializeFind(tls *libc.TLS, serialize uintptr, object uintptr) (r uintptr) {
	var bucket uintptr
	var buckets_count, index, n Tsize_t
	var hash Tuintptr_t
	_, _, _, _, _ = bucket, buckets_count, hash, index, n
	hash = _FcSerializeHashPtr(tls, object)
	buckets_count = (*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_count
	index = hash & (buckets_count - uint64(1))
	n = uint64(0)
	for {
		if !(n < buckets_count) {
			break
		}
		bucket = (*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets + uintptr(index)*24
		if (*TFcSerializeBucket)(unsafe.Pointer(bucket)).Fhash == uint64(0) {
			return libc.UintptrFromInt32(0)
		}
		if object == (*TFcSerializeBucket)(unsafe.Pointer(bucket)).Fobject {
			return bucket
		}
		index = _FcSerializeNextBucketIndex(tls, serialize, index)
		goto _1
	_1:
		;
		n++
	}
	return libc.UintptrFromInt32(0)
}

func _FcSerializeUncheckedSet(tls *libc.TLS, serialize uintptr, insert uintptr) (r uintptr) {
	var bucket, object uintptr
	var buckets_count, index, n Tsize_t
	_, _, _, _, _ = bucket, buckets_count, index, n, object
	object = (*TFcSerializeBucket)(unsafe.Pointer(insert)).Fobject
	buckets_count = (*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_count
	index = (*TFcSerializeBucket)(unsafe.Pointer(insert)).Fhash & (buckets_count - uint64(1))
	n = uint64(0)
	for {
		if !(n < buckets_count) {
			break
		}
		bucket = (*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets + uintptr(index)*24
		if (*TFcSerializeBucket)(unsafe.Pointer(bucket)).Fhash == uint64(0) {
			*(*TFcSerializeBucket)(unsafe.Pointer(bucket)) = *(*TFcSerializeBucket)(unsafe.Pointer(insert))
			(*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_used++
			return bucket
		}
		if object == (*TFcSerializeBucket)(unsafe.Pointer(bucket)).Fobject {
			/* FcSerializeAlloc should not allow this to happen. */
			*(*TFcSerializeBucket)(unsafe.Pointer(bucket)) = *(*TFcSerializeBucket)(unsafe.Pointer(insert))
			return bucket
		}
		index = _FcSerializeNextBucketIndex(tls, serialize, index)
		goto _1
	_1:
		;
		n++
	}
	return libc.UintptrFromInt32(0)
}

func _FcSerializeResize(tls *libc.TLS, serialize uintptr, new_count Tsize_t) (r TFcBool) {
	var b, b1, new_buckets, new_buckets_end, old_buckets, old_buckets_end uintptr
	var old_count, old_used Tsize_t
	_, _, _, _, _, _, _, _ = b, b1, new_buckets, new_buckets_end, old_buckets, old_buckets_end, old_count, old_used
	old_used = (*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_used
	old_count = (*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_count
	old_buckets = (*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets
	old_buckets_end = old_buckets + uintptr(old_count)*24
	new_buckets = libc.Xmalloc(tls, new_count*uint64(24))
	if !(new_buckets != 0) {
		return m_FcFalse
	}
	new_buckets_end = new_buckets + uintptr(new_count)*24
	b = new_buckets
	for {
		if !(b < new_buckets_end) {
			break
		}
		(*TFcSerializeBucket)(unsafe.Pointer(b)).Fhash = uint64(0)
		goto _1
	_1:
		;
		b += 24
	}
	(*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets = new_buckets
	(*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_count = new_count
	(*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_used = uint64(0)
	b1 = old_buckets
	for {
		if !(b1 < old_buckets_end) {
			break
		}
		if (*TFcSerializeBucket)(unsafe.Pointer(b1)).Fhash != uint64(0) && !(_FcSerializeUncheckedSet(tls, serialize, b1) != 0) {
			(*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets = old_buckets
			(*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_count = old_count
			(*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_used = old_used
			libc.Xfree(tls, new_buckets)
			return m_FcFalse
		}
		goto _2
	_2:
		;
		b1 += 24
	}
	libc.Xfree(tls, old_buckets)
	return int32(m_FcTrue)
}

func _FcSerializeSet(tls *libc.TLS, serialize uintptr, object uintptr, offset Tintptr_t) (r uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var capacity Tsize_t
	var _ /* bucket at bp+0 */ TFcSerializeBucket
	_ = capacity
	if (*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_used >= (*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_used_max {
		capacity = (*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_count
		if capacity == uint64(0) {
			capacity = uint64(4)
		} else {
			if capacity > libc.Uint64FromUint64(18446744073709551615)/libc.Uint64FromUint32(2) {
				return libc.UintptrFromInt32(0)
			} else {
				capacity *= uint64(2)
			}
		}
		if !(_FcSerializeResize(tls, serialize, capacity) != 0) {
			return libc.UintptrFromInt32(0)
		}
		(*TFcSerialize)(unsafe.Pointer(serialize)).Fbuckets_used_max = capacity / uint64(4) * uint64(3)
	}
	(*(*TFcSerializeBucket)(unsafe.Pointer(bp))).Fobject = object
	(*(*TFcSerializeBucket)(unsafe.Pointer(bp))).Foffset = offset
	(*(*TFcSerializeBucket)(unsafe.Pointer(bp))).Fhash = _FcSerializeHashPtr(tls, object)
	return _FcSerializeUncheckedSet(tls, serialize, bp)
}

// C documentation
//
//	/*
//	 * Allocate space for an object in the serialized array. Keep track
//	 * of where the object is placed and only allocate one copy of each object
//	 */
func XFcSerializeAlloc(tls *libc.TLS, serialize uintptr, object uintptr, size int32) (r TFcBool) {
	var bucket uintptr
	_ = bucket
	bucket = _FcSerializeFind(tls, serialize, object)
	if bucket != 0 {
		return int32(m_FcTrue)
	}
	if !(_FcSerializeSet(tls, serialize, object, (*TFcSerialize)(unsafe.Pointer(serialize)).Fsize) != 0) {
		return m_FcFalse
	}
	*(*Tintptr_t)(unsafe.Pointer(serialize)) += XFcAlignSize(tls, int64(size))
	return int32(m_FcTrue)
}

// C documentation
//
//	/*
//	 * Reserve space in the serialization array
//	 */
func XFcSerializeReserve(tls *libc.TLS, serialize uintptr, size int32) (r Tintptr_t) {
	var offset Tintptr_t
	_ = offset
	offset = (*TFcSerialize)(unsafe.Pointer(serialize)).Fsize
	*(*Tintptr_t)(unsafe.Pointer(serialize)) += XFcAlignSize(tls, int64(size))
	return offset
}

// C documentation
//
//	/*
//	 * Given an object, return the offset in the serialized array where
//	 * the serialized copy of the object is stored
//	 */
func XFcSerializeOffset(tls *libc.TLS, serialize uintptr, object uintptr) (r Tintptr_t) {
	var bucket uintptr
	var v1 int64
	_, _ = bucket, v1
	bucket = _FcSerializeFind(tls, serialize, object)
	if bucket != 0 {
		v1 = (*TFcSerializeBucket)(unsafe.Pointer(bucket)).Foffset
	} else {
		v1 = 0
	}
	return v1
}

// C documentation
//
//	/*
//	 * Given a cache and an object, return a pointer to where
//	 * the serialized copy of the object is stored
//	 */
func XFcSerializePtr(tls *libc.TLS, serialize uintptr, object uintptr) (r uintptr) {
	var offset Tintptr_t
	_ = offset
	offset = XFcSerializeOffset(tls, serialize, object)
	if !(offset != 0) {
		return libc.UintptrFromInt32(0)
	}
	return (*TFcSerialize)(unsafe.Pointer(serialize)).Flinear + uintptr(offset)
}

func XFcStrSerializeAlloc(tls *libc.TLS, serialize uintptr, str uintptr) (r TFcBool) {
	return XFcSerializeAlloc(tls, serialize, str, libc.Int32FromUint64(libc.Xstrlen(tls, str)+uint64(1)))
}

func XFcStrSerialize(tls *libc.TLS, serialize uintptr, str uintptr) (r uintptr) {
	var str_serialize uintptr
	_ = str_serialize
	str_serialize = XFcSerializePtr(tls, serialize, str)
	if !(str_serialize != 0) {
		return libc.UintptrFromInt32(0)
	}
	libc.X__builtin___strcpy_chk(tls, str_serialize, str, ^t__predefined_size_t(0))
	return str_serialize
}

const m_ALIGNBYTES = "__DARWIN_ALIGNBYTES"
const m_AQ_BUFSZ = "MAXAUDITDATA"
const m_AQ_HIWATER = 100
const m_AQ_LOWATER = 10
const m_AQ_MAXBUFSZ = 1048576
const m_AQ_MAXHIGH = 10000
const m_ATTR_BIT_MAP_COUNT = 5
const m_ATTR_CMNEXT_ATTRIBUTION_TAG = 0x00000800
const m_ATTR_CMNEXT_CLONEID = 0x00000100
const m_ATTR_CMNEXT_CLONE_REFCNT = 0x00001000
const m_ATTR_CMNEXT_EXT_FLAGS = 0x00000200
const m_ATTR_CMNEXT_LINKID = 0x00000010
const m_ATTR_CMNEXT_NOFIRMLINKPATH = 0x00000020
const m_ATTR_CMNEXT_PRIVATESIZE = 0x00000008
const m_ATTR_CMNEXT_REALDEVID = 0x00000040
const m_ATTR_CMNEXT_REALFSID = 0x00000080
const m_ATTR_CMNEXT_RECURSIVE_GENCOUNT = 0x00000400
const m_ATTR_CMNEXT_RELPATH = 0x00000004
const m_ATTR_CMNEXT_SETMASK = 0x00000000
const m_ATTR_CMNEXT_VALIDMASK = 0x00001ffc
const m_ATTR_CMN_ACCESSMASK = 0x00020000
const m_ATTR_CMN_ACCTIME = 0x00001000
const m_ATTR_CMN_ADDEDTIME = 0x10000000
const m_ATTR_CMN_BKUPTIME = 0x00002000
const m_ATTR_CMN_CHGTIME = 0x00000800
const m_ATTR_CMN_CRTIME = 0x00000200
const m_ATTR_CMN_DATA_PROTECT_FLAGS = 0x40000000
const m_ATTR_CMN_DEVID = 0x00000002
const m_ATTR_CMN_DOCUMENT_ID = 0x00100000
const m_ATTR_CMN_ERROR = 0x20000000
const m_ATTR_CMN_EXTENDED_SECURITY = 0x00400000
const m_ATTR_CMN_FILEID = 0x02000000
const m_ATTR_CMN_FLAGS = 0x00040000
const m_ATTR_CMN_FNDRINFO = 0x00004000
const m_ATTR_CMN_FSID = 0x00000004
const m_ATTR_CMN_FULLPATH = 0x08000000
const m_ATTR_CMN_GEN_COUNT = 0x00080000
const m_ATTR_CMN_GRPID = 0x00010000
const m_ATTR_CMN_GRPUUID = 0x01000000
const m_ATTR_CMN_MODTIME = 0x00000400
const m_ATTR_CMN_NAME = 0x00000001
const m_ATTR_CMN_NAMEDATTRCOUNT = 0x00080000
const m_ATTR_CMN_NAMEDATTRLIST = 0x00100000
const m_ATTR_CMN_OBJID = 0x00000020
const m_ATTR_CMN_OBJPERMANENTID = 0x00000040
const m_ATTR_CMN_OBJTAG = 0x00000010
const m_ATTR_CMN_OBJTYPE = 0x00000008
const m_ATTR_CMN_OWNERID = 0x00008000
const m_ATTR_CMN_PARENTID = 0x04000000
const m_ATTR_CMN_PAROBJID = 0x00000080
const m_ATTR_CMN_RETURNED_ATTRS = 0x80000000
const m_ATTR_CMN_SCRIPT = 0x00000100
const m_ATTR_CMN_SETMASK = 0x51C7FF00
const m_ATTR_CMN_USERACCESS = 0x00200000
const m_ATTR_CMN_UUID = 0x00800000
const m_ATTR_CMN_VALIDMASK = 0xFFFFFFFF
const m_ATTR_CMN_VOLSETMASK = 0x00006700
const m_ATTR_DIR_ALLOCSIZE = 0x00000008
const m_ATTR_DIR_DATALENGTH = 0x00000020
const m_ATTR_DIR_ENTRYCOUNT = 0x00000002
const m_ATTR_DIR_IOBLOCKSIZE = 0x00000010
const m_ATTR_DIR_LINKCOUNT = 0x00000001
const m_ATTR_DIR_MOUNTSTATUS = 0x00000004
const m_ATTR_DIR_SETMASK = 0x00000000
const m_ATTR_DIR_VALIDMASK = 0x0000003f
const m_ATTR_FILE_ALLOCSIZE = 0x00000004
const m_ATTR_FILE_CLUMPSIZE = 0x00000010
const m_ATTR_FILE_DATAALLOCSIZE = 0x00000400
const m_ATTR_FILE_DATAEXTENTS = 0x00000800
const m_ATTR_FILE_DATALENGTH = 0x00000200
const m_ATTR_FILE_DEVTYPE = 0x00000020
const m_ATTR_FILE_FILETYPE = 0x00000040
const m_ATTR_FILE_FORKCOUNT = 0x00000080
const m_ATTR_FILE_FORKLIST = 0x00000100
const m_ATTR_FILE_IOBLOCKSIZE = 0x00000008
const m_ATTR_FILE_LINKCOUNT = 0x00000001
const m_ATTR_FILE_RSRCALLOCSIZE = 0x00002000
const m_ATTR_FILE_RSRCEXTENTS = 0x00004000
const m_ATTR_FILE_RSRCLENGTH = 0x00001000
const m_ATTR_FILE_SETMASK = 0x00000020
const m_ATTR_FILE_TOTALSIZE = 0x00000002
const m_ATTR_FILE_VALIDMASK = 0x000037FF
const m_ATTR_FORK_ALLOCSIZE = 0x00000002
const m_ATTR_FORK_RESERVED = 0xffffffff
const m_ATTR_FORK_SETMASK = 0x00000000
const m_ATTR_FORK_TOTALSIZE = 0x00000001
const m_ATTR_FORK_VALIDMASK = 0x00000003
const m_ATTR_MAX_BUFFER = 8192
const m_ATTR_VOL_ALLOCATIONCLUMP = 0x00000040
const m_ATTR_VOL_ATTRIBUTES = 0x40000000
const m_ATTR_VOL_CAPABILITIES = 0x00020000
const m_ATTR_VOL_DIRCOUNT = 0x00000400
const m_ATTR_VOL_ENCODINGSUSED = 0x00010000
const m_ATTR_VOL_FILECOUNT = 0x00000200
const m_ATTR_VOL_FSSUBTYPE = 0x00200000
const m_ATTR_VOL_FSTYPE = 0x00000001
const m_ATTR_VOL_FSTYPENAME = 0x00100000
const m_ATTR_VOL_INFO = 0x80000000
const m_ATTR_VOL_IOBLOCKSIZE = 0x00000080
const m_ATTR_VOL_MAXOBJCOUNT = 0x00000800
const m_ATTR_VOL_MINALLOCATION = 0x00000020
const m_ATTR_VOL_MOUNTEDDEVICE = 0x00008000
const m_ATTR_VOL_MOUNTEXTFLAGS = 0x00080000
const m_ATTR_VOL_MOUNTFLAGS = 0x00004000
const m_ATTR_VOL_MOUNTPOINT = 0x00001000
const m_ATTR_VOL_NAME = 0x00002000
const m_ATTR_VOL_OBJCOUNT = 0x00000100
const m_ATTR_VOL_OWNER = 0x00400000
const m_ATTR_VOL_QUOTA_SIZE = 0x10000000
const m_ATTR_VOL_RESERVED_SIZE = 0x20000000
const m_ATTR_VOL_SETMASK = 0x80002000
const m_ATTR_VOL_SIGNATURE = 0x00000002
const m_ATTR_VOL_SIZE = 0x00000004
const m_ATTR_VOL_SPACEAVAIL = 0x00000010
const m_ATTR_VOL_SPACEFREE = 0x00000008
const m_ATTR_VOL_SPACEUSED = 0x00800000
const m_ATTR_VOL_UUID = 0x00040000
const m_ATTR_VOL_VALIDMASK = 0xF0FFFFFF
const m_AUC_AUDITING = 1
const m_AUC_NOAUDIT = 2
const m_AUC_UNSET = 0
const m_AUDITDEV_FILENAME = "audit"
const m_AUDIT_AHLT = 0x0002
const m_AUDIT_ARGE = 0x0008
const m_AUDIT_ARGV = 0x0004
const m_AUDIT_CNT = 0x0001
const m_AUDIT_GROUP = 0x0080
const m_AUDIT_HARD_LIMIT_FREE_BLOCKS = 4
const m_AUDIT_PATH = 0x0200
const m_AUDIT_PERZONE = 0x2000
const m_AUDIT_PUBLIC = 0x0800
const m_AUDIT_RECORD_MAGIC = 0x828a0f1b
const m_AUDIT_SCNT = 0x0400
const m_AUDIT_SEQ = 0x0010
const m_AUDIT_TRAIL = 0x0100
const m_AUDIT_TRIGGER_CLOSE_AND_DIE = 4
const m_AUDIT_TRIGGER_EXPIRE_TRAILS = 8
const m_AUDIT_TRIGGER_INITIALIZE = 7
const m_AUDIT_TRIGGER_LOW_SPACE = 1
const m_AUDIT_TRIGGER_MAX = 8
const m_AUDIT_TRIGGER_MIN = 1
const m_AUDIT_TRIGGER_NO_SPACE = 5
const m_AUDIT_TRIGGER_READ_FILE = 3
const m_AUDIT_TRIGGER_ROTATE_KERNEL = 2
const m_AUDIT_TRIGGER_ROTATE_USER = 6
const m_AUDIT_USER = 0x0040
const m_AUDIT_WINDATA = 0x0020
const m_AUDIT_ZONENAME = 0x1000
const m_AU_CLASS_MASK_RESERVED = 0x10000000
const m_AU_DEFAUDITSID = 0
const m_AU_FS_MINFREE = 20
const m_AU_IPv4 = 4
const m_AU_IPv6 = 16
const m_A_GETCAR = 9
const m_A_GETCLASS = 22
const m_A_GETCOND = 37
const m_A_GETCTLMODE = 41
const m_A_GETCWD = 8
const m_A_GETEXPAFTER = 43
const m_A_GETFSIZE = 27
const m_A_GETKAUDIT = 29
const m_A_GETKMASK = 4
const m_A_GETPINFO = 24
const m_A_GETPINFO_ADDR = 28
const m_A_GETPOLICY = 33
const m_A_GETQCTRL = 35
const m_A_GETSFLAGS = 39
const m_A_GETSINFO_ADDR = 32
const m_A_GETSTAT = 12
const m_A_OLDGETCOND = 20
const m_A_OLDGETPOLICY = 2
const m_A_OLDGETQCTRL = 6
const m_A_OLDSETCOND = 21
const m_A_OLDSETPOLICY = 3
const m_A_OLDSETQCTRL = 7
const m_A_SENDTRIGGER = 31
const m_A_SETCLASS = 23
const m_A_SETCOND = 38
const m_A_SETCTLMODE = 42
const m_A_SETEXPAFTER = 44
const m_A_SETFSIZE = 26
const m_A_SETKAUDIT = 30
const m_A_SETKMASK = 5
const m_A_SETPMASK = 25
const m_A_SETPOLICY = 34
const m_A_SETQCTRL = 36
const m_A_SETSFLAGS = 40
const m_A_SETSMASK = 15
const m_A_SETSTAT = 13
const m_A_SETUMASK = 14
const m_BLKDEV_IOSIZE = 2048
const m_BSD = 199506
const m_BSD4_3 = 1
const m_BSD4_4 = 1
const m_CBLOCK = 64
const m_CLOFF = "CLOFSET"
const m_CLSIZE = 1
const m_CLSIZELOG2 = 0
const m_CMASK = 022
const m_CRF_MAC_ENFORCE = 0x00000002
const m_CRF_NOMEMBERD = 0x00000001
const m_CRYPTEX_AUTH_STRUCT_VERSION = 2
const m_DEV_BSHIFT = 9
const m_DEV_BSIZE = 512
const m_DIR_MNTSTATUS_MNTPOINT = 0x00000001
const m_DIR_MNTSTATUS_TRIGGER = 0x00000002
const m_FALSE = 0
const m_FC_ARCH_ENDIAN1 = "le"
const m_FC_DIR_SEPARATOR3 = 47
const m_FSHIFT = 11
const m_FSOPT_ATTR_CMN_EXTENDED = 0x00000020
const m_FSOPT_NOFOLLOW = 0x00000001
const m_FSOPT_NOFOLLOW_ANY = 0x00000800
const m_FSOPT_NOINMEMUPDATE = 0x00000002
const m_FSOPT_PACK_INVAL_ATTRS = 0x00000008
const m_FSOPT_REPORT_FULLSIZE = 0x00000004
const m_FSOPT_RETURN_REALDEV = 0x00000200
const m_GRAFTDMG_SECURE_BOOT_CRYPTEX_ARGS_VERSION = 1
const m_GUARD_TYPE_MACH_PORT = 0x1
const m_M16KCLSHIFT = 14
const m_MACH_MSG_TYPE_INTEGER_T = "MACH_MSG_TYPE_INTEGER_32"
const m_MACH_PORT_DENAP_RECEIVER = 6
const m_MACH_PORT_DNREQUESTS_SIZE = 3
const m_MACH_PORT_DNREQUESTS_SIZE_COUNT = 1
const m_MACH_PORT_GUARD_INFO = 8
const m_MACH_PORT_IMPORTANCE_RECEIVER = 5
const m_MACH_PORT_INFO_EXT = 7
const m_MACH_PORT_LIMITS_INFO = 1
const m_MACH_PORT_NULL = 0
const m_MACH_PORT_QLIMIT_BASIC = 5
const m_MACH_PORT_QLIMIT_DEFAULT = "MACH_PORT_QLIMIT_BASIC"
const m_MACH_PORT_QLIMIT_KERNEL = 65534
const m_MACH_PORT_QLIMIT_LARGE = 1024
const m_MACH_PORT_QLIMIT_MAX = "MACH_PORT_QLIMIT_LARGE"
const m_MACH_PORT_QLIMIT_MIN = "MACH_PORT_QLIMIT_ZERO"
const m_MACH_PORT_QLIMIT_SMALL = 16
const m_MACH_PORT_QLIMIT_ZERO = 0
const m_MACH_PORT_RECEIVE_STATUS = 2
const m_MACH_PORT_SERVICE_THROTTLED = 9
const m_MACH_PORT_SERVICE_THROTTLED_COUNT = 1
const m_MACH_PORT_SRIGHTS_NONE = 0
const m_MACH_PORT_SRIGHTS_PRESENT = 1
const m_MACH_PORT_STATUS_FLAG_GUARDED = 0x02
const m_MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE = 0x40
const m_MACH_PORT_STATUS_FLAG_IMP_DONATION = 0x08
const m_MACH_PORT_STATUS_FLAG_NO_GRANT = 0x80
const m_MACH_PORT_STATUS_FLAG_REVIVE = 0x10
const m_MACH_PORT_STATUS_FLAG_STRICT_GUARD = 0x04
const m_MACH_PORT_STATUS_FLAG_TASKPTR = 0x20
const m_MACH_PORT_STATUS_FLAG_TEMPOWNER = 0x01
const m_MACH_PORT_TEMPOWNER = 4
const m_MACH_PORT_TYPE_DNREQUEST = 0x80000000
const m_MACH_PORT_TYPE_SPREQUEST = 0x40000000
const m_MACH_PORT_TYPE_SPREQUEST_DELAYED = 0x20000000
const m_MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN = 255
const m_MAXCOMLEN = 16
const m_MAXDOMNAMELEN = 256
const m_MAXFRAG = 8
const m_MAXHOSTNAMELEN = 256
const m_MAXINTERP = 64
const m_MAXLOGNAME = 255
const m_MAXPATHLEN = "PATH_MAX"
const m_MAXPHYSIO = "MAXPHYS"
const m_MAXPRI = 127
const m_MAXSYMLINKS = 32
const m_MAXUPRC = "CHILD_MAX"
const m_MAX_AUDIT_RECORDS = 20
const m_MAX_AUDIT_RECORD_SIZE = "MAXAUDITDATA"
const m_MAX_FATAL_kGUARD_EXC_CODE = "kGUARD_EXC_MSG_FILTERED"
const m_MAX_GRAFT_ARGS_SIZE = 512
const m_MAX_OPTIONAL_kGUARD_EXC_CODE = "kGUARD_EXC_RCV_INVALID_NAME"
const m_MBIGCLSHIFT = 12
const m_MCLSHIFT = 11
const m_MFSNAMELEN = 15
const m_MFSTYPENAMELEN = 16
const m_MNAMELEN = "MAXPATHLEN"
const m_MNT_ASYNC = 0x00000040
const m_MNT_AUTOMOUNTED = 0x00400000
const m_MNT_CPROTECT = 0x00000080
const m_MNT_DEFWRITE = 0x02000000
const m_MNT_DONTBROWSE = 0x00100000
const m_MNT_DOVOLFS = 0x00008000
const m_MNT_DWAIT = 4
const m_MNT_EXPORTED = 0x00000100
const m_MNT_EXT_FSKIT = 0x00000002
const m_MNT_EXT_ROOT_DATA_VOL = 0x00000001
const m_MNT_FORCE = 0x00080000
const m_MNT_IGNORE_OWNERSHIP = 0x00200000
const m_MNT_JOURNALED = 0x00800000
const m_MNT_LOCAL = 4096
const m_MNT_MULTILABEL = 0x04000000
const m_MNT_NOATIME = 0x10000000
const m_MNT_NOBLOCK = 0x00020000
const m_MNT_NODEV = 0x00000010
const m_MNT_NOEXEC = 0x00000004
const m_MNT_NOFOLLOW = 0x08000000
const m_MNT_NOSUID = 0x00000008
const m_MNT_NOUSERXATTR = 0x01000000
const m_MNT_NOWAIT = 2
const m_MNT_QUARANTINE = 0x00000400
const m_MNT_QUOTA = 0x00002000
const m_MNT_RDONLY = 0x00000001
const m_MNT_RELOAD = 0x00040000
const m_MNT_REMOVABLE = 0x00000200
const m_MNT_ROOTFS = 0x00004000
const m_MNT_SNAPSHOT = 0x40000000
const m_MNT_STRICTATIME = 0x80000000
const m_MNT_SYNCHRONOUS = 0x00000002
const m_MNT_UNION = 0x00000020
const m_MNT_UNKNOWNPERMISSIONS = "MNT_IGNORE_OWNERSHIP"
const m_MNT_UPDATE = 0x00010000
const m_MNT_WAIT = 1
const m_MPG_FLAGS_NONE = "0x00ull"
const m_MPG_IMMOVABLE_RECEIVE = 0x02
const m_MPG_STRICT = 0x01
const m_MPO_CONNECTION_PORT = 0x800
const m_MPO_CONTEXT_AS_GUARD = 0x01
const m_MPO_DENAP_RECEIVER = 0x40
const m_MPO_ENFORCE_REPLY_PORT_SEMANTICS = 0x2000
const m_MPO_EXCEPTION_PORT = 0x8000
const m_MPO_FILTER_MSG = 0x100
const m_MPO_IMMOVABLE_RECEIVE = 0x80
const m_MPO_IMPORTANCE_RECEIVER = 0x08
const m_MPO_INSERT_SEND_RIGHT = 0x10
const m_MPO_PROVISIONAL_REPLY_PORT = 0x4000
const m_MPO_QLIMIT = 0x02
const m_MPO_REPLY_PORT = 0x1000
const m_MPO_SERVICE_PORT = 0x400
const m_MPO_STRICT = 0x20
const m_MPO_TEMPOWNER = 0x04
const m_MPO_TG_BLOCK_TRACKING = 0x200
const m_MSIZESHIFT = 8
const m_NBPG = 4096
const m_NCARGS = "ARG_MAX"
const m_NFSV2_MAX_FH_SIZE = 32
const m_NFSV3_MAX_FH_SIZE = 64
const m_NFSV4_MAX_FH_SIZE = 128
const m_NFS_MAX_FH_SIZE = "NFSV4_MAX_FH_SIZE"
const m_NGROUPS = "NGROUPS_MAX"
const m_NOFILE = 256
const m_NOGROUP = 65535
const m_NeXTBSD = 1995064
const m_NeXTBSD4_0 = 0
const m_OS_ASSUME_PTR_ABI_SINGLE_BEGIN = "__ASSUME_PTR_ABI_SINGLE_BEGIN"
const m_OS_ASSUME_PTR_ABI_SINGLE_END = "__ASSUME_PTR_ABI_SINGLE_END"
const m_OS_HEADER_INDEXABLE = "__header_indexable"
const m_OS_UNSAFE_INDEXABLE = "__unsafe_indexable"
const m_O_CLOEXEC2 = 0x01000000
const m_O_CREAT1 = 0x00000200
const m_O_RDONLY2 = 0
const m_PCATCH = 0x100
const m_PDROP = 0x400
const m_PGSHIFT = 12
const m_PINOD = 8
const m_PLOCK = 36
const m_PPAUSE = 40
const m_PRIBIO = 16
const m_PRIMASK = 0x0ff
const m_PSOCK = 24
const m_PSPIN = 0x800
const m_PSWP = 0
const m_PTTYBLOCK = 0x200
const m_PUSER = 50
const m_PVFS = 20
const m_PVM = 4
const m_PWAIT = 32
const m_PZERO = 22
const m_SBC_ALTERNATE_SHARED_REGION = 0x0002
const m_SBC_PANIC_ON_AUTHFAIL = 0x0008
const m_SBC_PRESERVE_GRAFT = 0x0020
const m_SBC_PRESERVE_MOUNT = 0x0001
const m_SBC_STRICT_AUTH = 0x0010
const m_SBC_SYSTEM_CONTENT = 0x0004
const m_SEARCHFS_MAX_SEARCHPARMS = 4096
const m_SRCHFS_MATCHDIRS = 0x00000004
const m_SRCHFS_MATCHFILES = 0x00000008
const m_SRCHFS_MATCHPARTIALNAMES = 0x00000002
const m_SRCHFS_NEGATEPARAMS = 0x80000000
const m_SRCHFS_SKIPINAPPROPRIATE = 0x00000080
const m_SRCHFS_SKIPINVISIBLE = 0x00000020
const m_SRCHFS_SKIPLINKS = 0x00000010
const m_SRCHFS_SKIPPACKAGES = 0x00000040
const m_SRCHFS_START = 0x00000001
const m_SRCHFS_VALIDOPTIONSMASK = 0x800000FF
const m_ST_NOSUID = 0x00000002
const m_ST_RDONLY = 0x00000001
const m_S_IFDIR3 = 16384
const m_S_IFMT5 = 61440
const m_TRUE = 1
const m_VFS_CONF = 2
const m_VFS_CTL_DISC = 0x00010008
const m_VFS_CTL_NEWADDR = 0x00010004
const m_VFS_CTL_NOLOCKS = 0x00010006
const m_VFS_CTL_NSTATUS = 0x0001000A
const m_VFS_CTL_OSTATFS = 0x00010001
const m_VFS_CTL_QUERY = 0x00010003
const m_VFS_CTL_SADDR = 0x00010007
const m_VFS_CTL_SERVERINFO = 0x00010009
const m_VFS_CTL_STATFS = "VFS_CTL_STATFS64"
const m_VFS_CTL_STATFS64 = 0x0001000B
const m_VFS_CTL_TIMEO = 0x00010005
const m_VFS_CTL_UMOUNT = 0x00010002
const m_VFS_CTL_VERS1 = 0x01
const m_VFS_GENERIC = 0
const m_VFS_MAXTYPENUM = 1
const m_VFS_NUMMNTOPS = 1
const m_VOL_CAPABILITIES_FORMAT = 0
const m_VOL_CAPABILITIES_INTERFACES = 1
const m_VOL_CAPABILITIES_RESERVED1 = 2
const m_VOL_CAPABILITIES_RESERVED2 = 3
const m_VOL_CAP_FMT_2TB_FILESIZE = 0x00000800
const m_VOL_CAP_FMT_64BIT_OBJECT_IDS = 0x00020000
const m_VOL_CAP_FMT_CASE_PRESERVING = 0x00000200
const m_VOL_CAP_FMT_CASE_SENSITIVE = 0x00000100
const m_VOL_CAP_FMT_CLONE_MAPPING = 0x04000000
const m_VOL_CAP_FMT_DECMPFS_COMPRESSION = 0x00010000
const m_VOL_CAP_FMT_DIR_HARDLINKS = 0x00040000
const m_VOL_CAP_FMT_DOCUMENT_ID = 0x00080000
const m_VOL_CAP_FMT_FAST_STATFS = 0x00000400
const m_VOL_CAP_FMT_HARDLINKS = 0x00000004
const m_VOL_CAP_FMT_HIDDEN_FILES = 0x00002000
const m_VOL_CAP_FMT_JOURNAL = 0x00000008
const m_VOL_CAP_FMT_JOURNAL_ACTIVE = 0x00000010
const m_VOL_CAP_FMT_NO_IMMUTABLE_FILES = 0x00200000
const m_VOL_CAP_FMT_NO_PERMISSIONS = 0x00400000
const m_VOL_CAP_FMT_NO_ROOT_TIMES = 0x00000020
const m_VOL_CAP_FMT_NO_VOLUME_SIZES = 0x00008000
const m_VOL_CAP_FMT_OPENDENYMODES = 0x00001000
const m_VOL_CAP_FMT_PATH_FROM_ID = 0x00004000
const m_VOL_CAP_FMT_PERSISTENTOBJECTIDS = 0x00000001
const m_VOL_CAP_FMT_SEALED = 0x02000000
const m_VOL_CAP_FMT_SHARED_SPACE = 0x00800000
const m_VOL_CAP_FMT_SPARSE_FILES = 0x00000040
const m_VOL_CAP_FMT_SYMBOLICLINKS = 0x00000002
const m_VOL_CAP_FMT_VOL_GROUPS = 0x01000000
const m_VOL_CAP_FMT_WRITE_GENERATION_COUNT = 0x00100000
const m_VOL_CAP_FMT_ZERO_RUNS = 0x00000080
const m_VOL_CAP_INT_ADVLOCK = 0x00000100
const m_VOL_CAP_INT_ALLOCATE = 0x00000040
const m_VOL_CAP_INT_ATTRIBUTION_TAG = 0x00400000
const m_VOL_CAP_INT_ATTRLIST = 0x00000002
const m_VOL_CAP_INT_CLONE = 0x00010000
const m_VOL_CAP_INT_COPYFILE = 0x00000020
const m_VOL_CAP_INT_EXCHANGEDATA = 0x00000010
const m_VOL_CAP_INT_EXTENDED_ATTR = 0x00004000
const m_VOL_CAP_INT_EXTENDED_SECURITY = 0x00000400
const m_VOL_CAP_INT_FLOCK = 0x00000200
const m_VOL_CAP_INT_MANLOCK = 0x00001000
const m_VOL_CAP_INT_NAMEDSTREAMS = 0x00002000
const m_VOL_CAP_INT_NFSEXPORT = 0x00000004
const m_VOL_CAP_INT_PUNCHHOLE = 0x00800000
const m_VOL_CAP_INT_READDIRATTR = 0x00000008
const m_VOL_CAP_INT_RENAME_EXCL = 0x00080000
const m_VOL_CAP_INT_RENAME_OPENFAIL = 0x00100000
const m_VOL_CAP_INT_RENAME_SECLUDE = 0x00200000
const m_VOL_CAP_INT_RENAME_SWAP = 0x00040000
const m_VOL_CAP_INT_SEARCHFS = 0x00000001
const m_VOL_CAP_INT_SNAPSHOT = 0x00020000
const m_VOL_CAP_INT_USERACCESS = 0x00000800
const m_VOL_CAP_INT_VOL_RENAME = 0x00000080
const m_VQ_ASSIST = 0x0040
const m_VQ_DEAD = 0x0020
const m_VQ_DESIRED_DISK = 0x4000
const m_VQ_FLAG20000 = 0x20000
const m_VQ_FREE_SPACE_CHANGE = 0x8000
const m_VQ_LOWDISK = 0x0004
const m_VQ_MOUNT = 0x0008
const m_VQ_NEARLOWDISK = 0x2000
const m_VQ_NEEDAUTH = 0x0002
const m_VQ_NOTRESP = 0x0001
const m_VQ_NOTRESPLOCK = 0x0080
const m_VQ_PURGEABLE_SPACE_CHANGE = 0x10000
const m_VQ_QUOTA = 0x1000
const m_VQ_SERVEREVENT = 0x0800
const m_VQ_SYNCEVENT = 0x0400
const m_VQ_UNMOUNT = 0x0010
const m_VQ_UPDATE = 0x0100
const m_VQ_VERYLOWDISK = 0x0200
const m_XUCRED_VERSION = 0

type Tfssearchblock = struct {
	Freturnattrs         uintptr
	Freturnbuffer        uintptr
	Freturnbuffersize    Tsize_t
	Fmaxmatches          Tu_long
	Ftimelimit           Ttimeval
	Fsearchparams1       uintptr
	Fsizeofsearchparams1 Tsize_t
	Fsearchparams2       uintptr
	Fsizeofsearchparams2 Tsize_t
	Fsearchattrs         Tattrlist
}

type Tsearchstate = struct {
	Fss_union_flags Tuint32_t
	Fss_union_layer Tuint32_t
	Fss_fsstate     [548]Tu_char
}

type Tstatvfs = struct {
	Ff_bsize   uint64
	Ff_frsize  uint64
	Ff_blocks  Tfsblkcnt_t
	Ff_bfree   Tfsblkcnt_t
	Ff_bavail  Tfsblkcnt_t
	Ff_files   Tfsfilcnt_t
	Ff_ffree   Tfsfilcnt_t
	Ff_favail  Tfsfilcnt_t
	Ff_fsid    uint64
	Ff_flag    uint64
	Ff_namemax uint64
}

type Tau_id_t = uint32

type Tau_asid_t = int32

type Tau_event_t = uint16

type Tau_emod_t = uint16

type Tau_class_t = uint32

type Tau_asflgs_t = uint64

type Tau_ctlmode_t = uint8

type Tau_tid = struct {
	Fport    Tdev_t
	Fmachine Tu_int32_t
}

type Tau_tid_t = struct {
	Fport    Tdev_t
	Fmachine Tu_int32_t
}

type Tau_tid_addr = struct {
	Fat_port Tdev_t
	Fat_type Tu_int32_t
	Fat_addr [4]Tu_int32_t
}

type Tau_tid_addr_t = struct {
	Fat_port Tdev_t
	Fat_type Tu_int32_t
	Fat_addr [4]Tu_int32_t
}

type Tau_mask = struct {
	Fam_success uint32
	Fam_failure uint32
}

type Tau_mask_t = struct {
	Fam_success uint32
	Fam_failure uint32
}

type Tauditinfo = struct {
	Fai_auid   Tau_id_t
	Fai_mask   Tau_mask_t
	Fai_termid Tau_tid_t
	Fai_asid   Tau_asid_t
}

type Tauditinfo_t = struct {
	Fai_auid   Tau_id_t
	Fai_mask   Tau_mask_t
	Fai_termid Tau_tid_t
	Fai_asid   Tau_asid_t
}

type Tauditinfo_addr = struct {
	Fai_auid   Tau_id_t
	Fai_mask   Tau_mask_t
	Fai_termid Tau_tid_addr_t
	Fai_asid   Tau_asid_t
	Fai_flags  Tau_asflgs_t
}

type Tauditinfo_addr_t = struct {
	Fai_auid   Tau_id_t
	Fai_mask   Tau_mask_t
	Fai_termid Tau_tid_addr_t
	Fai_asid   Tau_asid_t
	Fai_flags  Tau_asflgs_t
}

type Tauditpinfo = struct {
	Fap_pid    Tpid_t
	Fap_auid   Tau_id_t
	Fap_mask   Tau_mask_t
	Fap_termid Tau_tid_t
	Fap_asid   Tau_asid_t
}

type Tauditpinfo_t = struct {
	Fap_pid    Tpid_t
	Fap_auid   Tau_id_t
	Fap_mask   Tau_mask_t
	Fap_termid Tau_tid_t
	Fap_asid   Tau_asid_t
}

type Tauditpinfo_addr = struct {
	Fap_pid    Tpid_t
	Fap_auid   Tau_id_t
	Fap_mask   Tau_mask_t
	Fap_termid Tau_tid_addr_t
	Fap_asid   Tau_asid_t
	Fap_flags  Tau_asflgs_t
}

type Tauditpinfo_addr_t = struct {
	Fap_pid    Tpid_t
	Fap_auid   Tau_id_t
	Fap_mask   Tau_mask_t
	Fap_termid Tau_tid_addr_t
	Fap_asid   Tau_asid_t
	Fap_flags  Tau_asflgs_t
}

type Tau_session = struct {
	Fas_aia_p uintptr
	Fas_mask  Tau_mask_t
}

type Tau_session_t = struct {
	Fas_aia_p uintptr
	Fas_mask  Tau_mask_t
}

type Tau_expire_after = struct {
	Fage     Ttime_t
	Fsize    Tsize_t
	Fop_type uint8
}

type Tau_expire_after_t = struct {
	Fage     Ttime_t
	Fsize    Tsize_t
	Fop_type uint8
}

type Tau_qctrl = struct {
	Faq_hiwater int32
	Faq_lowater int32
	Faq_bufsz   int32
	Faq_delay   int32
	Faq_minfree int32
}

type Tau_qctrl_t = struct {
	Faq_hiwater int32
	Faq_lowater int32
	Faq_bufsz   int32
	Faq_delay   int32
	Faq_minfree int32
}

type Taudit_stat = struct {
	Fas_version   uint32
	Fas_numevent  uint32
	Fas_generated int32
	Fas_nonattrib int32
	Fas_kernel    int32
	Fas_audit     int32
	Fas_auditctl  int32
	Fas_enqueue   int32
	Fas_written   int32
	Fas_wblocked  int32
	Fas_rblocked  int32
	Fas_dropped   int32
	Fas_totalsize int32
	Fas_memused   uint32
}

type Tau_stat_t = struct {
	Fas_version   uint32
	Fas_numevent  uint32
	Fas_generated int32
	Fas_nonattrib int32
	Fas_kernel    int32
	Fas_audit     int32
	Fas_auditctl  int32
	Fas_enqueue   int32
	Fas_written   int32
	Fas_wblocked  int32
	Fas_rblocked  int32
	Fas_dropped   int32
	Fas_totalsize int32
	Fas_memused   uint32
}

type Taudit_fstat = struct {
	Faf_filesz Tu_int64_t
	Faf_currsz Tu_int64_t
}

type Tau_fstat_t = struct {
	Faf_filesz Tu_int64_t
	Faf_currsz Tu_int64_t
}

type Tau_evclass_map = struct {
	Fec_number Tau_event_t
	Fec_class  Tau_class_t
}

type Tau_evclass_map_t = struct {
	Fec_number Tau_event_t
	Fec_class  Tau_class_t
}

type _audit_session_flags = int32

const _AU_SESSION_FLAG_IS_INITIAL = 1
const _AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS = 16
const _AU_SESSION_FLAG_HAS_TTY = 32
const _AU_SESSION_FLAG_IS_REMOTE = 4096
const _AU_SESSION_FLAG_HAS_CONSOLE_ACCESS = 8192
const _AU_SESSION_FLAG_HAS_AUTHENTICATED = 16384

type Tboolean_t = uint32

type Tnatural_t = uint32

type Tinteger_t = int32

type Tvm_offset_t = uint64

type Tvm_size_t = uint64

type Tmach_vm_address_t = uint64

type Tmach_vm_offset_t = uint64

type Tmach_vm_size_t = uint64

type Tvm_map_offset_t = uint64

type Tvm_map_address_t = uint64

type Tvm_map_size_t = uint64

type Tmach_port_context_t = uint64

type Tmach_port_name_t = uint32

type Tmach_port_name_array_t = uintptr

type Tmach_port_t = uint32

type Tmach_port_array_t = uintptr

type Tmach_port_right_t = uint32

type Tmach_port_type_t = uint32

type Tmach_port_type_array_t = uintptr

type Tmach_port_urefs_t = uint32

type Tmach_port_delta_t = int32

type Tmach_port_seqno_t = uint32

type Tmach_port_mscount_t = uint32

type Tmach_port_msgcount_t = uint32

type Tmach_port_rights_t = uint32

type Tmach_port_srights_t = uint32

type Tmach_port_status_t = struct {
	Fmps_pset      Tmach_port_rights_t
	Fmps_seqno     Tmach_port_seqno_t
	Fmps_mscount   Tmach_port_mscount_t
	Fmps_qlimit    Tmach_port_msgcount_t
	Fmps_msgcount  Tmach_port_msgcount_t
	Fmps_sorights  Tmach_port_rights_t
	Fmps_srights   Tboolean_t
	Fmps_pdrequest Tboolean_t
	Fmps_nsrequest Tboolean_t
	Fmps_flags     Tnatural_t
}

type Tmach_port_status = Tmach_port_status_t

type Tmach_port_limits_t = struct {
	Fmpl_qlimit Tmach_port_msgcount_t
}

type Tmach_port_limits = Tmach_port_limits_t

type Tmach_port_info_ext_t = struct {
	Fmpie_status    Tmach_port_status_t
	Fmpie_boost_cnt Tmach_port_msgcount_t
	Freserved       [6]Tuint32_t
}

type Tmach_port_info_ext = Tmach_port_info_ext_t

type Tmach_port_guard_info_t = struct {
	Fmpgi_guard Tuint64_t
}

type Tmach_port_guard_info = Tmach_port_guard_info_t

type Tmach_port_info_t = uintptr

type Tmach_port_flavor_t = int32

type Tmach_port_qos_t = struct {
	F__ccgo0 uint32
	Flen1    Tnatural_t
}

type Tmach_port_qos = Tmach_port_qos_t

type Tmach_service_port_info_data_t = struct {
	Fmspi_string_name [255]int8
	Fmspi_domain_type Tuint8_t
}

type Tmach_service_port_info = Tmach_service_port_info_data_t

type Tmach_service_port_info_t = uintptr

type Tmach_port_options_t = struct {
	Fflags     Tuint32_t
	Fmpl       Tmach_port_limits_t
	F__ccgo2_8 struct {
		Fwork_interval_port [0]Tmach_port_name_t
		Fservice_port_info  [0]Tmach_service_port_info_t
		Fservice_port_name  [0]Tmach_port_name_t
		Freserved           [2]Tuint64_t
	}
}

type Tmach_port_options = Tmach_port_options_t

type Tmach_port_options_ptr_t = uintptr

type _mach_port_guard_exception_codes = int32

const _kGUARD_EXC_DESTROY = 1
const _kGUARD_EXC_MOD_REFS = 2
const _kGUARD_EXC_INVALID_OPTIONS = 3
const _kGUARD_EXC_SET_CONTEXT = 4
const _kGUARD_EXC_THREAD_SET_STATE = 5
const _kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE = 6
const _kGUARD_EXC_SERVICE_PORT_VIOLATION_FATAL = 7
const _kGUARD_EXC_UNGUARDED = 8
const _kGUARD_EXC_INCORRECT_GUARD = 16
const _kGUARD_EXC_IMMOVABLE = 32
const _kGUARD_EXC_STRICT_REPLY = 64
const _kGUARD_EXC_MSG_FILTERED = 128
const _kGUARD_EXC_INVALID_RIGHT = 256
const _kGUARD_EXC_INVALID_NAME = 512
const _kGUARD_EXC_INVALID_VALUE = 1024
const _kGUARD_EXC_INVALID_ARGUMENT = 2048
const _kGUARD_EXC_RIGHT_EXISTS = 4096
const _kGUARD_EXC_KERN_NO_SPACE = 8192
const _kGUARD_EXC_KERN_FAILURE = 16384
const _kGUARD_EXC_KERN_RESOURCE = 32768
const _kGUARD_EXC_SEND_INVALID_REPLY = 65536
const _kGUARD_EXC_SEND_INVALID_VOUCHER = 131072
const _kGUARD_EXC_SEND_INVALID_RIGHT = 262144
const _kGUARD_EXC_RCV_INVALID_NAME = 524288
const _kGUARD_EXC_RCV_GUARDED_DESC = 1048576
const _kGUARD_EXC_SERVICE_PORT_VIOLATION_NON_FATAL = 1048577
const _kGUARD_EXC_PROVISIONAL_REPLY_PORT = 1048578
const _kGUARD_EXC_MOD_REFS_NON_FATAL = 2097152
const _kGUARD_EXC_IMMOVABLE_NON_FATAL = 4194304
const _kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS = 8388608

type Tkauth_cred_t = uintptr

type Tposix_cred_t = uintptr

type Txucred = struct {
	Fcr_version Tu_int
	Fcr_uid     Tuid_t
	Fcr_ngroups int16
	Fcr_groups  [16]Tgid_t
}

type Ttext_encoding_t = uint32

type Tfsobj_type_t = uint32

type Tfsobj_tag_t = uint32

type Tfsfile_type_t = uint32

type Tfsvolid_t = uint32

type Tfsobj_id_t = struct {
	Ffid_objno      Tu_int32_t
	Ffid_generation Tu_int32_t
}

type Tfsobj_id = Tfsobj_id_t

type Tattrgroup_t = uint32

type Tattrlist = struct {
	Fbitmapcount Tu_short
	Freserved    Tu_int16_t
	Fcommonattr  Tattrgroup_t
	Fvolattr     Tattrgroup_t
	Fdirattr     Tattrgroup_t
	Ffileattr    Tattrgroup_t
	Fforkattr    Tattrgroup_t
}

type Tattribute_set_t = struct {
	Fcommonattr Tattrgroup_t
	Fvolattr    Tattrgroup_t
	Fdirattr    Tattrgroup_t
	Ffileattr   Tattrgroup_t
	Fforkattr   Tattrgroup_t
}

type Tattribute_set = Tattribute_set_t

type Tattrreference_t = struct {
	Fattr_dataoffset Tint32_t
	Fattr_length     Tu_int32_t
}

type Tattrreference = Tattrreference_t

type Tdiskextent = struct {
	Fstartblock Tu_int32_t
	Fblockcount Tu_int32_t
}

type Textentrecord = [8]Tdiskextent

type Tvol_capabilities_set_t = [4]Tu_int32_t

type Tvol_capabilities_attr_t = struct {
	Fcapabilities Tvol_capabilities_set_t
	Fvalid        Tvol_capabilities_set_t
}

type Tvol_capabilities_attr = Tvol_capabilities_attr_t

type Tvol_attributes_attr_t = struct {
	Fvalidattr  Tattribute_set_t
	Fnativeattr Tattribute_set_t
}

type Tvol_attributes_attr = Tvol_attributes_attr_t

type Tos_function_t = uintptr

type Tos_block_t = uintptr

type Tfsid_t = struct {
	Fval [2]Tint32_t
}

type Tfsid = Tfsid_t

type Tsecure_boot_cryptex_args_t = struct {
	Fsbc_version               Tu_int32_t
	Fsbc_4cc                   Tu_int32_t
	Fsbc_authentic_manifest_fd int32
	Fsbc_user_manifest_fd      int32
	Fsbc_payload_fd            int32
	Fsbc_flags                 Tu_int64_t
}

type Tsecure_boot_cryptex_args = Tsecure_boot_cryptex_args_t

type Tgraftdmg_args_un = struct {
	Fsbc_args [0]Tsecure_boot_cryptex_args_t
	Fmax_size [512]Tu_int8_t
}

type Tgraft_args = Tgraftdmg_args_un

type Tmount_t = uintptr

type Tvnode_t = uintptr

type Tstatfs64 = struct {
	Ff_bsize       Tuint32_t
	Ff_iosize      Tint32_t
	Ff_blocks      Tuint64_t
	Ff_bfree       Tuint64_t
	Ff_bavail      Tuint64_t
	Ff_files       Tuint64_t
	Ff_ffree       Tuint64_t
	Ff_fsid        Tfsid_t
	Ff_owner       Tuid_t
	Ff_type        Tuint32_t
	Ff_flags       Tuint32_t
	Ff_fssubtype   Tuint32_t
	Ff_fstypename  [16]int8
	Ff_mntonname   [1024]int8
	Ff_mntfromname [1024]int8
	Ff_flags_ext   Tuint32_t
	Ff_reserved    [7]Tuint32_t
}

type Tstatfs = struct {
	Ff_bsize       Tuint32_t
	Ff_iosize      Tint32_t
	Ff_blocks      Tuint64_t
	Ff_bfree       Tuint64_t
	Ff_bavail      Tuint64_t
	Ff_files       Tuint64_t
	Ff_ffree       Tuint64_t
	Ff_fsid        Tfsid_t
	Ff_owner       Tuid_t
	Ff_type        Tuint32_t
	Ff_flags       Tuint32_t
	Ff_fssubtype   Tuint32_t
	Ff_fstypename  [16]int8
	Ff_mntonname   [1024]int8
	Ff_mntfromname [1024]int8
	Ff_flags_ext   Tuint32_t
	Ff_reserved    [7]Tuint32_t
}

type Tvfsstatfs = struct {
	Ff_bsize       Tuint32_t
	Ff_iosize      Tsize_t
	Ff_blocks      Tuint64_t
	Ff_bfree       Tuint64_t
	Ff_bavail      Tuint64_t
	Ff_bused       Tuint64_t
	Ff_files       Tuint64_t
	Ff_ffree       Tuint64_t
	Ff_fsid        Tfsid_t
	Ff_owner       Tuid_t
	Ff_flags       Tuint64_t
	Ff_fstypename  [16]int8
	Ff_mntonname   [1024]int8
	Ff_mntfromname [1024]int8
	Ff_fssubtype   Tuint32_t
	Ff_reserved    [2]uintptr
}

type Tvfsconf = struct {
	Fvfc_reserved1 Tuint32_t
	Fvfc_name      [15]int8
	Fvfc_typenum   int32
	Fvfc_refcount  int32
	Fvfc_flags     int32
	Fvfc_reserved2 Tuint32_t
	Fvfc_reserved3 Tuint32_t
}

type Tvfsidctl = struct {
	Fvc_vers  int32
	Fvc_fsid  Tfsid_t
	Fvc_ptr   uintptr
	Fvc_len   Tsize_t
	Fvc_spare [12]Tu_int32_t
}

type Tvfsquery = struct {
	Fvq_flags Tu_int32_t
	Fvq_spare [31]Tu_int32_t
}

type Tvfs_server = struct {
	Fvs_minutes     Tint32_t
	Fvs_server_name [768]Tu_int8_t
}

type Tnetfs_status = struct {
	F__ccgo_align   [0]uint64
	Fns_status      Tu_int32_t
	Fns_mountopts   [512]int8
	Fns_waittime    Tuint32_t
	Fns_threadcount Tuint32_t
}

type Tfhandle = struct {
	Ffh_len  uint32
	Ffh_data [128]uint8
}

type Tfhandle_t = struct {
	Ffh_len  uint32
	Ffh_data [128]uint8
}

type Tgraftdmg_type_t = uint32

const _GRAFTDMG_CRYPTEX_BOOT = 1
const _GRAFTDMG_CRYPTEX_PREBOOT = 2
const _GRAFTDMG_CRYPTEX_DOWNLEVEL = 3
const _GRAFTDMG_CRYPTEX_PDI_NONCE = 6
const _GRAFTDMG_CRYPTEX_EFFECTIVE_AP = 7
const _GRAFTDMG_CRYPTEX_MOBILE_ASSET = 8
const _GRAFTDMG_CRYPTEX_MAX = 8

type Tcryptex_auth_type_t = uint32

const _CRYPTEX1_AUTH_ENV_GENERIC = 4
const _CRYPTEX1_AUTH_ENV_GENERIC_SUPPLEMENTAL = 5
const _CRYPTEX_AUTH_PDI_NONCE = 6
const _CRYPTEX_AUTH_MOBILE_ASSET = 8
const _CRYPTEX_AUTH_MAX = 8

/*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 2000-2012 Apple, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)errno.h	8.5 (Berkeley) 1/21/94
 */

func XFcStat(tls *libc.TLS, file uintptr, statb uintptr) (r int32) {
	return libc.Xstat(tls, file, statb)
}

/* Adler-32 checksum implementation */
type TAdler32 = struct {
	Fa int32
	Fb int32
}

func _Adler32Init(tls *libc.TLS, ctx uintptr) {
	(*TAdler32)(unsafe.Pointer(ctx)).Fa = int32(1)
	(*TAdler32)(unsafe.Pointer(ctx)).Fb = 0
}

func _Adler32Update(tls *libc.TLS, ctx uintptr, data uintptr, data_len int32) {
	var v1 int32
	var v2 uintptr
	_, _ = v1, v2
	for {
		v1 = data_len
		data_len--
		if !(v1 != 0) {
			break
		}
		v2 = data
		data++
		(*TAdler32)(unsafe.Pointer(ctx)).Fa = ((*TAdler32)(unsafe.Pointer(ctx)).Fa + int32(*(*int8)(unsafe.Pointer(v2)))) % int32(65521)
		(*TAdler32)(unsafe.Pointer(ctx)).Fb = ((*TAdler32)(unsafe.Pointer(ctx)).Fb + (*TAdler32)(unsafe.Pointer(ctx)).Fa) % int32(65521)
	}
}

func _Adler32Finish(tls *libc.TLS, ctx uintptr) (r int32) {
	return (*TAdler32)(unsafe.Pointer(ctx)).Fa + (*TAdler32)(unsafe.Pointer(ctx)).Fb<<int32(16)
}

// C documentation
//
//	/* dirent.d_type can be relied upon on FAT filesystem */
func _FcDirChecksumScandirFilter(tls *libc.TLS, entry uintptr) (r TFcBool) {
	return libc.BoolInt32(libc.Int32FromUint8((*Tdirent)(unsafe.Pointer(entry)).Fd_type) != int32(m_DT_DIR))
}

func _FcDirChecksumScandirSorter(tls *libc.TLS, lhs uintptr, rhs uintptr) (r int32) {
	return libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(lhs))+21, *(*uintptr)(unsafe.Pointer(rhs))+21)
}

func _free_dirent(tls *libc.TLS, p uintptr) {
	var x uintptr
	_ = x
	x = p
	for {
		if !(*(*uintptr)(unsafe.Pointer(x)) != libc.UintptrFromInt32(0)) {
			break
		}
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(x)))
		goto _1
	_1:
		;
		x += 8
	}
	libc.Xfree(tls, p)
}

type t__ccgo_fp__XFcScandir_2 = func(*libc.TLS, uintptr) int32

type t__ccgo_fp__XFcScandir_3 = func(*libc.TLS, uintptr, uintptr) int32

func XFcScandir(tls *libc.TLS, dirp uintptr, namelist uintptr, __ccgo_fp_filter uintptr, __ccgo_fp_compar uintptr) (r int32) {
	var d, dent, dlist, dlp, p, v1 uintptr
	var dentlen, lsize, n, v2 Tsize_t
	_, _, _, _, _, _, _, _, _, _ = d, dent, dentlen, dlist, dlp, lsize, n, p, v1, v2
	lsize = uint64(128)
	n = uint64(0)
	d = libc.Xopendir(tls, dirp)
	if !(d != 0) {
		return -int32(1)
	}
	dlist = libc.Xmalloc(tls, uint64(8)*lsize)
	if !(dlist != 0) {
		libc.Xclosedir(tls, d)
		*(*int32)(unsafe.Pointer(libc.X__error(tls))) = int32(m_ENOMEM)
		return -int32(1)
	}
	*(*uintptr)(unsafe.Pointer(dlist)) = libc.UintptrFromInt32(0)
	for {
		v1 = libc.Xreaddir(tls, d)
		dent = v1
		if !(v1 != 0) {
			break
		}
		if !(__ccgo_fp_filter != 0) || (*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_filter})))(tls, dent) != 0 {
			dentlen = libc.Uint64FromInt64(Tintptr_t(dent+21)-int64(dent)) + libc.Xstrlen(tls, dent+21) + uint64(1)
			dentlen = (dentlen + libc.Uint64FromInt32(m_ALIGNOF_VOID_P) - libc.Uint64FromInt32(1)) & libc.Uint64FromInt32(^(libc.Int32FromInt32(m_ALIGNOF_VOID_P) - libc.Int32FromInt32(1)))
			p = libc.Xmalloc(tls, dentlen)
			if !(p != 0) {
				_free_dirent(tls, dlist)
				libc.Xclosedir(tls, d)
				*(*int32)(unsafe.Pointer(libc.X__error(tls))) = int32(m_ENOMEM)
				return -int32(1)
			}
			libc.X__builtin___memcpy_chk(tls, p, dent, dentlen, ^t__predefined_size_t(0))
			if n+uint64(1) >= lsize {
				lsize += uint64(128)
				dlp = libc.Xrealloc(tls, dlist, uint64(8)*lsize)
				if !(dlp != 0) {
					libc.Xfree(tls, p)
					_free_dirent(tls, dlist)
					libc.Xclosedir(tls, d)
					*(*int32)(unsafe.Pointer(libc.X__error(tls))) = int32(m_ENOMEM)
					return -int32(1)
				}
				dlist = dlp
			}
			v2 = n
			n++
			*(*uintptr)(unsafe.Pointer(dlist + uintptr(v2)*8)) = p
			*(*uintptr)(unsafe.Pointer(dlist + uintptr(n)*8)) = libc.UintptrFromInt32(0)
		}
	}
	libc.Xclosedir(tls, d)
	libc.Xqsort(tls, dlist, n, uint64(8), __ccgo_fp_compar)
	*(*uintptr)(unsafe.Pointer(namelist)) = dlist
	return libc.Int32FromUint64(n)
}

func _FcDirChecksum1(tls *libc.TLS, dir uintptr, checksum uintptr) (r int32) {
	bp := tls.Alloc(176)
	defer tls.Free(176)
	var dlen, len1 Tsize_t
	var f uintptr
	var n, ret, v1 int32
	var _ /* ctx at bp+0 */ TAdler32
	var _ /* dtype at bp+16 */ int32
	var _ /* files at bp+8 */ uintptr
	var _ /* statb at bp+24 */ Tstat
	_, _, _, _, _, _ = dlen, f, len1, n, ret, v1
	ret = 0
	len1 = libc.Xstrlen(tls, dir)
	_Adler32Init(tls, bp)
	n = XFcScandir(tls, dir, bp+8, __ccgo_fp(_FcDirChecksumScandirFilter), __ccgo_fp(_FcDirChecksumScandirSorter))
	if n == -int32(1) {
		return -int32(1)
	}
	for {
		v1 = n
		n--
		if !(v1 != 0) {
			break
		}
		dlen = libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(n)*8))+21)
		*(*int32)(unsafe.Pointer(bp + 16)) = libc.Int32FromUint8((*Tdirent)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(n)*8)))).Fd_type)
		if *(*int32)(unsafe.Pointer(bp + 16)) == m_DT_UNKNOWN {
			f = libc.Xmalloc(tls, len1+uint64(1)+dlen+uint64(1))
			if !(f != 0) {
				ret = -int32(1)
				goto bail
			}
			libc.X__builtin___memcpy_chk(tls, f, dir, len1, ^t__predefined_size_t(0))
			*(*int8)(unsafe.Pointer(f + uintptr(len1))) = int8('/')
			libc.X__builtin___memcpy_chk(tls, f+uintptr(len1+uint64(1)), *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(n)*8))+21, dlen, ^t__predefined_size_t(0))
			*(*int8)(unsafe.Pointer(f + uintptr(len1+uint64(1)+dlen))) = 0
			if libc.Xlstat(tls, f, bp+24) < 0 {
				ret = -int32(1)
				libc.Xfree(tls, f)
				goto bail
			}
			if libc.Int32FromUint16((*(*Tstat)(unsafe.Pointer(bp + 24))).Fst_mode)&int32(m_S_IFMT5) == int32(m_S_IFDIR3) {
				libc.Xfree(tls, f)
				goto bail
			}
			libc.Xfree(tls, f)
			*(*int32)(unsafe.Pointer(bp + 16)) = libc.Int32FromUint16((*(*Tstat)(unsafe.Pointer(bp + 24))).Fst_mode)
		}
		_Adler32Update(tls, bp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(n)*8))+21, libc.Int32FromUint64(dlen+uint64(1)))
		_Adler32Update(tls, bp, bp+16, int32(4))
		goto bail
	bail:
		;
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(n)*8)))
	}
	libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	if ret == -int32(1) {
		return -int32(1)
	}
	*(*Ttime_t)(unsafe.Pointer(checksum)) = int64(_Adler32Finish(tls, bp))
	return 0
}

func XFcStatChecksum(tls *libc.TLS, file uintptr, statb uintptr) (r int32) {
	if XFcStat(tls, file, statb) == -int32(1) {
		return -int32(1)
	}
	/* We have a workaround of the broken stat() in FcStat() for Win32.
	 * No need to do something further more.
	 */
	if XFcIsFsMtimeBroken(tls, file) != 0 {
		if _FcDirChecksum1(tls, file, statb+48) == -int32(1) {
			return -int32(1)
		}
	}
	return 0
}

func _FcFStatFs(tls *libc.TLS, fd int32, statb uintptr) (r int32) {
	bp := tls.Alloc(2176)
	defer tls.Free(2176)
	var flag TFcBool
	var p uintptr
	var ret, v1 int32
	var _ /* buf at bp+0 */ Tstatfs
	_, _, _, _ = flag, p, ret, v1
	p = libc.UintptrFromInt32(0)
	ret = -int32(1)
	flag = m_FcFalse
	libc.X__builtin___memset_chk(tls, statb, 0, uint64(8), ^t__predefined_size_t(0))
	v1 = libc.Xfstatfs(tls, fd, bp)
	ret = v1
	if v1 == 0 {
		(*TFcStatFS)(unsafe.Pointer(statb)).Fis_remote_fs = libc.BoolInt32(!((*(*Tstatfs)(unsafe.Pointer(bp))).Ff_flags&libc.Uint32FromInt32(m_MNT_LOCAL) != 0))
		flag = int32(m_FcTrue)
		p = bp + 72
	}
	if p != 0 {
		if !(flag != 0) && libc.Xstrcmp(tls, p, __ccgo_ts+6967) == 0 {
			(*TFcStatFS)(unsafe.Pointer(statb)).Fis_remote_fs = int32(m_FcTrue)
		}
		if libc.Xstrcmp(tls, p, __ccgo_ts+6971) == 0 || libc.Xstrcmp(tls, p, __ccgo_ts+6979) == 0 {
			(*TFcStatFS)(unsafe.Pointer(statb)).Fis_mtime_broken = int32(m_FcTrue)
		}
	}
	return ret
}

func XFcIsFsMmapSafe(tls *libc.TLS, fd int32) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* statb at bp+0 */ TFcStatFS
	if _FcFStatFs(tls, fd, bp) < 0 {
		return int32(m_FcTrue)
	}
	return libc.BoolInt32(!((*(*TFcStatFS)(unsafe.Pointer(bp))).Fis_remote_fs != 0))
}

func XFcIsFsMtimeBroken(tls *libc.TLS, dir uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var fd, ret int32
	var _ /* statb at bp+0 */ TFcStatFS
	_, _ = fd, ret
	fd = XFcOpen(tls, dir, m_O_RDONLY2, 0)
	if fd != -int32(1) {
		ret = _FcFStatFs(tls, fd, bp)
		libc.Xclose(tls, fd)
		if ret < 0 {
			return m_FcFalse
		}
		return (*(*TFcStatFS)(unsafe.Pointer(bp))).Fis_mtime_broken
	}
	return m_FcFalse
}

const m_FC_MAX_CASE_FOLD_CHARS = 6
const m_FC_MAX_CASE_FOLD_EXPAND = 4
const m_FC_MAX_FOLD_CHAR = 125217
const m_FC_MIN_FOLD_CHAR = 65
const m_FC_NUM_CASE_FOLD = 302
const m_FC_NUM_CASE_FOLD_CHARS = 471
const m_S_IFDIR4 = 0040000
const m_S_IFMT6 = 0170000

/*
 * Copyright (c) 2000, 2002 - 2008, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2000, 2005, 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * This code is derived from software contributed to Berkeley by
 * Paul Borman at Krystal Technologies.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ctype.h	8.4 (Berkeley) 1/21/94
 */

/*
 * Copyright (c) 2000, 2005, 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * This code is derived from software contributed to Berkeley by
 * Paul Borman at Krystal Technologies.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ctype.h	8.4 (Berkeley) 1/21/94
 */

/*
 * Copyright (c) 2000, 2007, 2010, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

/* Objects MT-safe for readonly access. */

func XFcStrCopy(tls *libc.TLS, s uintptr) (r uintptr) {
	return libc.Xstrdup(tls, s)
}

func _FcStrMakeTriple(tls *libc.TLS, s1 uintptr, s2 uintptr, s3 uintptr) (r uintptr) {
	var l, s1l, s2l, s3l int32
	var s uintptr
	var v1, v2, v3 uint64
	_, _, _, _, _, _, _, _ = l, s, s1l, s2l, s3l, v1, v2, v3
	if s1 != 0 {
		v1 = libc.Xstrlen(tls, s1)
	} else {
		v1 = uint64(0)
	}
	s1l = libc.Int32FromUint64(v1)
	if s2 != 0 {
		v2 = libc.Xstrlen(tls, s2)
	} else {
		v2 = uint64(0)
	}
	s2l = libc.Int32FromUint64(v2)
	if s3 != 0 {
		v3 = libc.Xstrlen(tls, s3)
	} else {
		v3 = uint64(0)
	}
	s3l = libc.Int32FromUint64(v3)
	l = s1l + int32(1) + s2l + int32(1) + s3l + int32(1)
	s = libc.Xmalloc(tls, libc.Uint64FromInt32(l))
	if !(s != 0) {
		return uintptr(0)
	}
	if s1 != 0 {
		libc.X__builtin___memcpy_chk(tls, s, s1, libc.Uint64FromInt32(s1l+int32(1)), ^t__predefined_size_t(0))
	} else {
		*(*TFcChar8)(unsafe.Pointer(s)) = uint8('\000')
	}
	if s2 != 0 {
		libc.X__builtin___memcpy_chk(tls, s+uintptr(s1l)+uintptr(1), s2, libc.Uint64FromInt32(s2l+int32(1)), ^t__predefined_size_t(0))
	} else {
		*(*TFcChar8)(unsafe.Pointer(s + uintptr(s1l+int32(1)))) = uint8('\000')
	}
	if s3 != 0 {
		libc.X__builtin___memcpy_chk(tls, s+uintptr(s1l)+uintptr(1)+uintptr(s2l)+uintptr(1), s3, libc.Uint64FromInt32(s3l+int32(1)), ^t__predefined_size_t(0))
	} else {
		*(*TFcChar8)(unsafe.Pointer(s + uintptr(s1l+int32(1)+s2l+int32(1)))) = uint8('\000')
	}
	return s
}

func XFcStrPlus(tls *libc.TLS, s1 uintptr, s2 uintptr) (r uintptr) {
	var l, s1l, s2l int32
	var s uintptr
	_, _, _, _ = l, s, s1l, s2l
	s1l = libc.Int32FromUint64(libc.Xstrlen(tls, s1))
	s2l = libc.Int32FromUint64(libc.Xstrlen(tls, s2))
	l = s1l + s2l + int32(1)
	s = libc.Xmalloc(tls, libc.Uint64FromInt32(l))
	if !(s != 0) {
		return uintptr(0)
	}
	libc.X__builtin___memcpy_chk(tls, s, s1, libc.Uint64FromInt32(s1l), ^t__predefined_size_t(0))
	libc.X__builtin___memcpy_chk(tls, s+uintptr(s1l), s2, libc.Uint64FromInt32(s2l+int32(1)), ^t__predefined_size_t(0))
	return s
}

func XFcStrFree(tls *libc.TLS, s uintptr) {
	libc.Xfree(tls, s)
}

var _fcCaseFold = [302]TFcCaseFold{
	0: {
		Fupper:   uint32(0x00000041),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x001a)&0x3fff<<2,
		Foffset:  int16(32),
	},
	1: {
		Fupper:   uint32(0x000000b5),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(775),
	},
	2: {
		Fupper:   uint32(0x000000c0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0017)&0x3fff<<2,
		Foffset:  int16(32),
	},
	3: {
		Fupper:   uint32(0x000000d8),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0007)&0x3fff<<2,
		Foffset:  int16(32),
	},
	4: {
		Fupper:   uint32(0x000000df),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
	},
	5: {
		Fupper:   uint32(0x00000100),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x002f)&0x3fff<<2,
		Foffset:  int16(1),
	},
	6: {
		Fupper:   uint32(0x00000130),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(2),
	},
	7: {
		Fupper:   uint32(0x00000132),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(1),
	},
	8: {
		Fupper:   uint32(0x00000139),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x000f)&0x3fff<<2,
		Foffset:  int16(1),
	},
	9: {
		Fupper:   uint32(0x00000149),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(5),
	},
	10: {
		Fupper:   uint32(0x0000014a),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x002d)&0x3fff<<2,
		Foffset:  int16(1),
	},
	11: {
		Fupper:   uint32(0x00000178),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(121)),
	},
	12: {
		Fupper:   uint32(0x00000179),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(1),
	},
	13: {
		Fupper:   uint32(0x0000017f),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(268)),
	},
	14: {
		Fupper:   uint32(0x00000181),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(210),
	},
	15: {
		Fupper:   uint32(0x00000182),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(1),
	},
	16: {
		Fupper:   uint32(0x00000186),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(206),
	},
	17: {
		Fupper:   uint32(0x00000187),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	18: {
		Fupper:   uint32(0x00000189),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(205),
	},
	19: {
		Fupper:   uint32(0x0000018b),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	20: {
		Fupper:   uint32(0x0000018e),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(79),
	},
	21: {
		Fupper:   uint32(0x0000018f),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(202),
	},
	22: {
		Fupper:   uint32(0x00000190),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(203),
	},
	23: {
		Fupper:   uint32(0x00000191),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	24: {
		Fupper:   uint32(0x00000193),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(205),
	},
	25: {
		Fupper:   uint32(0x00000194),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(207),
	},
	26: {
		Fupper:   uint32(0x00000196),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(211),
	},
	27: {
		Fupper:   uint32(0x00000197),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(209),
	},
	28: {
		Fupper:   uint32(0x00000198),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	29: {
		Fupper:   uint32(0x0000019c),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(211),
	},
	30: {
		Fupper:   uint32(0x0000019d),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(213),
	},
	31: {
		Fupper:   uint32(0x0000019f),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(214),
	},
	32: {
		Fupper:   uint32(0x000001a0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(1),
	},
	33: {
		Fupper:   uint32(0x000001a6),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(218),
	},
	34: {
		Fupper:   uint32(0x000001a7),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	35: {
		Fupper:   uint32(0x000001a9),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(218),
	},
	36: {
		Fupper:   uint32(0x000001ac),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	37: {
		Fupper:   uint32(0x000001ae),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(218),
	},
	38: {
		Fupper:   uint32(0x000001af),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	39: {
		Fupper:   uint32(0x000001b1),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(217),
	},
	40: {
		Fupper:   uint32(0x000001b3),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(1),
	},
	41: {
		Fupper:   uint32(0x000001b7),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(219),
	},
	42: {
		Fupper:   uint32(0x000001b8),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	43: {
		Fupper:   uint32(0x000001bc),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	44: {
		Fupper:   uint32(0x000001c4),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(2),
	},
	45: {
		Fupper:   uint32(0x000001c5),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	46: {
		Fupper:   uint32(0x000001c7),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(2),
	},
	47: {
		Fupper:   uint32(0x000001c8),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	48: {
		Fupper:   uint32(0x000001ca),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(2),
	},
	49: {
		Fupper:   uint32(0x000001cb),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0011)&0x3fff<<2,
		Foffset:  int16(1),
	},
	50: {
		Fupper:   uint32(0x000001de),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0011)&0x3fff<<2,
		Foffset:  int16(1),
	},
	51: {
		Fupper:   uint32(0x000001f0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(8),
	},
	52: {
		Fupper:   uint32(0x000001f1),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(2),
	},
	53: {
		Fupper:   uint32(0x000001f2),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(1),
	},
	54: {
		Fupper:   uint32(0x000001f6),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(97)),
	},
	55: {
		Fupper:   uint32(0x000001f7),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(56)),
	},
	56: {
		Fupper:   uint32(0x000001f8),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0027)&0x3fff<<2,
		Foffset:  int16(1),
	},
	57: {
		Fupper:   uint32(0x00000220),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(130)),
	},
	58: {
		Fupper:   uint32(0x00000222),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0011)&0x3fff<<2,
		Foffset:  int16(1),
	},
	59: {
		Fupper:   uint32(0x0000023a),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(10795),
	},
	60: {
		Fupper:   uint32(0x0000023b),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	61: {
		Fupper:   uint32(0x0000023d),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(163)),
	},
	62: {
		Fupper:   uint32(0x0000023e),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(10792),
	},
	63: {
		Fupper:   uint32(0x00000241),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	64: {
		Fupper:   uint32(0x00000243),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(195)),
	},
	65: {
		Fupper:   uint32(0x00000244),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(69),
	},
	66: {
		Fupper:   uint32(0x00000245),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(71),
	},
	67: {
		Fupper:   uint32(0x00000246),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0009)&0x3fff<<2,
		Foffset:  int16(1),
	},
	68: {
		Fupper:   uint32(0x00000345),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(116),
	},
	69: {
		Fupper:   uint32(0x00000370),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(1),
	},
	70: {
		Fupper:   uint32(0x00000376),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	71: {
		Fupper:   uint32(0x0000037f),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(116),
	},
	72: {
		Fupper:   uint32(0x00000386),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(38),
	},
	73: {
		Fupper:   uint32(0x00000388),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(37),
	},
	74: {
		Fupper:   uint32(0x0000038c),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(64),
	},
	75: {
		Fupper:   uint32(0x0000038e),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(63),
	},
	76: {
		Fupper:   uint32(0x00000390),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(11),
	},
	77: {
		Fupper:   uint32(0x00000391),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0011)&0x3fff<<2,
		Foffset:  int16(32),
	},
	78: {
		Fupper:   uint32(0x000003a3),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0009)&0x3fff<<2,
		Foffset:  int16(32),
	},
	79: {
		Fupper:   uint32(0x000003b0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(17),
	},
	80: {
		Fupper:   uint32(0x000003c2),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	81: {
		Fupper:   uint32(0x000003cf),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(8),
	},
	82: {
		Fupper:   uint32(0x000003d0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(30)),
	},
	83: {
		Fupper:   uint32(0x000003d1),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(25)),
	},
	84: {
		Fupper:   uint32(0x000003d5),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(15)),
	},
	85: {
		Fupper:   uint32(0x000003d6),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(22)),
	},
	86: {
		Fupper:   uint32(0x000003d8),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0017)&0x3fff<<2,
		Foffset:  int16(1),
	},
	87: {
		Fupper:   uint32(0x000003f0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(54)),
	},
	88: {
		Fupper:   uint32(0x000003f1),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(48)),
	},
	89: {
		Fupper:   uint32(0x000003f4),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(60)),
	},
	90: {
		Fupper:   uint32(0x000003f5),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(64)),
	},
	91: {
		Fupper:   uint32(0x000003f7),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	92: {
		Fupper:   uint32(0x000003f9),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(7)),
	},
	93: {
		Fupper:   uint32(0x000003fa),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	94: {
		Fupper:   uint32(0x000003fd),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(-int32(130)),
	},
	95: {
		Fupper:   uint32(0x00000400),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0010)&0x3fff<<2,
		Foffset:  int16(80),
	},
	96: {
		Fupper:   uint32(0x00000410),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0020)&0x3fff<<2,
		Foffset:  int16(32),
	},
	97: {
		Fupper:   uint32(0x00000460),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0021)&0x3fff<<2,
		Foffset:  int16(1),
	},
	98: {
		Fupper:   uint32(0x0000048a),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0035)&0x3fff<<2,
		Foffset:  int16(1),
	},
	99: {
		Fupper:   uint32(0x000004c0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(15),
	},
	100: {
		Fupper:   uint32(0x000004c1),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x000d)&0x3fff<<2,
		Foffset:  int16(1),
	},
	101: {
		Fupper:   uint32(0x000004d0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x005f)&0x3fff<<2,
		Foffset:  int16(1),
	},
	102: {
		Fupper:   uint32(0x00000531),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0026)&0x3fff<<2,
		Foffset:  int16(48),
	},
	103: {
		Fupper:   uint32(0x00000587),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(23),
	},
	104: {
		Fupper:   uint32(0x000010a0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0026)&0x3fff<<2,
		Foffset:  int16(7264),
	},
	105: {
		Fupper:   uint32(0x000010c7),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(7264),
	},
	106: {
		Fupper:   uint32(0x000010cd),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(7264),
	},
	107: {
		Fupper:   uint32(0x000013f8),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(-int32(8)),
	},
	108: {
		Fupper:   uint32(0x00001c80),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(6222)),
	},
	109: {
		Fupper:   uint32(0x00001c81),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(6221)),
	},
	110: {
		Fupper:   uint32(0x00001c82),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(6212)),
	},
	111: {
		Fupper:   uint32(0x00001c83),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(-int32(6210)),
	},
	112: {
		Fupper:   uint32(0x00001c85),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(6211)),
	},
	113: {
		Fupper:   uint32(0x00001c86),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(6204)),
	},
	114: {
		Fupper:   uint32(0x00001c87),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(6180)),
	},
	115: {
		Fupper:   uint32(0x00001c88),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(30269)),
	},
	116: {
		Fupper:   uint32(0x00001c90),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x002b)&0x3fff<<2,
		Foffset:  int16(-int32(3008)),
	},
	117: {
		Fupper:   uint32(0x00001cbd),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(-int32(3008)),
	},
	118: {
		Fupper:   uint32(0x00001e00),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0095)&0x3fff<<2,
		Foffset:  int16(1),
	},
	119: {
		Fupper:   uint32(0x00001e96),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(27),
	},
	120: {
		Fupper:   uint32(0x00001e97),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(30),
	},
	121: {
		Fupper:   uint32(0x00001e98),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(33),
	},
	122: {
		Fupper:   uint32(0x00001e99),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(36),
	},
	123: {
		Fupper:   uint32(0x00001e9a),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(39),
	},
	124: {
		Fupper:   uint32(0x00001e9b),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(58)),
	},
	125: {
		Fupper:   uint32(0x00001e9e),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(42),
	},
	126: {
		Fupper:   uint32(0x00001ea0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x005f)&0x3fff<<2,
		Foffset:  int16(1),
	},
	127: {
		Fupper:   uint32(0x00001f08),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0008)&0x3fff<<2,
		Foffset:  int16(-int32(8)),
	},
	128: {
		Fupper:   uint32(0x00001f18),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(-int32(8)),
	},
	129: {
		Fupper:   uint32(0x00001f28),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0008)&0x3fff<<2,
		Foffset:  int16(-int32(8)),
	},
	130: {
		Fupper:   uint32(0x00001f38),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0008)&0x3fff<<2,
		Foffset:  int16(-int32(8)),
	},
	131: {
		Fupper:   uint32(0x00001f48),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(-int32(8)),
	},
	132: {
		Fupper:   uint32(0x00001f50),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(44),
	},
	133: {
		Fupper:   uint32(0x00001f52),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(48),
	},
	134: {
		Fupper:   uint32(0x00001f54),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(54),
	},
	135: {
		Fupper:   uint32(0x00001f56),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(60),
	},
	136: {
		Fupper:   uint32(0x00001f59),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(8)),
	},
	137: {
		Fupper:   uint32(0x00001f5b),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(8)),
	},
	138: {
		Fupper:   uint32(0x00001f5d),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(8)),
	},
	139: {
		Fupper:   uint32(0x00001f5f),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(8)),
	},
	140: {
		Fupper:   uint32(0x00001f68),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0008)&0x3fff<<2,
		Foffset:  int16(-int32(8)),
	},
	141: {
		Fupper:   uint32(0x00001f80),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(66),
	},
	142: {
		Fupper:   uint32(0x00001f81),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(71),
	},
	143: {
		Fupper:   uint32(0x00001f82),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(76),
	},
	144: {
		Fupper:   uint32(0x00001f83),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(81),
	},
	145: {
		Fupper:   uint32(0x00001f84),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(86),
	},
	146: {
		Fupper:   uint32(0x00001f85),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(91),
	},
	147: {
		Fupper:   uint32(0x00001f86),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(96),
	},
	148: {
		Fupper:   uint32(0x00001f87),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(101),
	},
	149: {
		Fupper:   uint32(0x00001f88),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(106),
	},
	150: {
		Fupper:   uint32(0x00001f89),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(111),
	},
	151: {
		Fupper:   uint32(0x00001f8a),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(116),
	},
	152: {
		Fupper:   uint32(0x00001f8b),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(121),
	},
	153: {
		Fupper:   uint32(0x00001f8c),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(126),
	},
	154: {
		Fupper:   uint32(0x00001f8d),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(131),
	},
	155: {
		Fupper:   uint32(0x00001f8e),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(136),
	},
	156: {
		Fupper:   uint32(0x00001f8f),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(141),
	},
	157: {
		Fupper:   uint32(0x00001f90),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(146),
	},
	158: {
		Fupper:   uint32(0x00001f91),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(151),
	},
	159: {
		Fupper:   uint32(0x00001f92),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(156),
	},
	160: {
		Fupper:   uint32(0x00001f93),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(161),
	},
	161: {
		Fupper:   uint32(0x00001f94),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(166),
	},
	162: {
		Fupper:   uint32(0x00001f95),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(171),
	},
	163: {
		Fupper:   uint32(0x00001f96),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(176),
	},
	164: {
		Fupper:   uint32(0x00001f97),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(181),
	},
	165: {
		Fupper:   uint32(0x00001f98),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(186),
	},
	166: {
		Fupper:   uint32(0x00001f99),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(191),
	},
	167: {
		Fupper:   uint32(0x00001f9a),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(196),
	},
	168: {
		Fupper:   uint32(0x00001f9b),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(201),
	},
	169: {
		Fupper:   uint32(0x00001f9c),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(206),
	},
	170: {
		Fupper:   uint32(0x00001f9d),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(211),
	},
	171: {
		Fupper:   uint32(0x00001f9e),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(216),
	},
	172: {
		Fupper:   uint32(0x00001f9f),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(221),
	},
	173: {
		Fupper:   uint32(0x00001fa0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(226),
	},
	174: {
		Fupper:   uint32(0x00001fa1),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(231),
	},
	175: {
		Fupper:   uint32(0x00001fa2),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(236),
	},
	176: {
		Fupper:   uint32(0x00001fa3),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(241),
	},
	177: {
		Fupper:   uint32(0x00001fa4),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(246),
	},
	178: {
		Fupper:   uint32(0x00001fa5),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(251),
	},
	179: {
		Fupper:   uint32(0x00001fa6),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(256),
	},
	180: {
		Fupper:   uint32(0x00001fa7),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(261),
	},
	181: {
		Fupper:   uint32(0x00001fa8),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(266),
	},
	182: {
		Fupper:   uint32(0x00001fa9),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(271),
	},
	183: {
		Fupper:   uint32(0x00001faa),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(276),
	},
	184: {
		Fupper:   uint32(0x00001fab),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(281),
	},
	185: {
		Fupper:   uint32(0x00001fac),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(286),
	},
	186: {
		Fupper:   uint32(0x00001fad),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(291),
	},
	187: {
		Fupper:   uint32(0x00001fae),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(296),
	},
	188: {
		Fupper:   uint32(0x00001faf),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(301),
	},
	189: {
		Fupper:   uint32(0x00001fb2),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(306),
	},
	190: {
		Fupper:   uint32(0x00001fb3),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(311),
	},
	191: {
		Fupper:   uint32(0x00001fb4),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(315),
	},
	192: {
		Fupper:   uint32(0x00001fb6),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(319),
	},
	193: {
		Fupper:   uint32(0x00001fb7),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(323),
	},
	194: {
		Fupper:   uint32(0x00001fb8),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(-int32(8)),
	},
	195: {
		Fupper:   uint32(0x00001fba),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(-int32(74)),
	},
	196: {
		Fupper:   uint32(0x00001fbc),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(329),
	},
	197: {
		Fupper:   uint32(0x00001fbe),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(7173)),
	},
	198: {
		Fupper:   uint32(0x00001fc2),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(333),
	},
	199: {
		Fupper:   uint32(0x00001fc3),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(338),
	},
	200: {
		Fupper:   uint32(0x00001fc4),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(342),
	},
	201: {
		Fupper:   uint32(0x00001fc6),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(346),
	},
	202: {
		Fupper:   uint32(0x00001fc7),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(350),
	},
	203: {
		Fupper:   uint32(0x00001fc8),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(-int32(86)),
	},
	204: {
		Fupper:   uint32(0x00001fcc),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(356),
	},
	205: {
		Fupper:   uint32(0x00001fd2),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(360),
	},
	206: {
		Fupper:   uint32(0x00001fd3),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(366),
	},
	207: {
		Fupper:   uint32(0x00001fd6),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(372),
	},
	208: {
		Fupper:   uint32(0x00001fd7),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(376),
	},
	209: {
		Fupper:   uint32(0x00001fd8),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(-int32(8)),
	},
	210: {
		Fupper:   uint32(0x00001fda),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(-int32(100)),
	},
	211: {
		Fupper:   uint32(0x00001fe2),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(382),
	},
	212: {
		Fupper:   uint32(0x00001fe3),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(388),
	},
	213: {
		Fupper:   uint32(0x00001fe4),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(394),
	},
	214: {
		Fupper:   uint32(0x00001fe6),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(398),
	},
	215: {
		Fupper:   uint32(0x00001fe7),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(402),
	},
	216: {
		Fupper:   uint32(0x00001fe8),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(-int32(8)),
	},
	217: {
		Fupper:   uint32(0x00001fea),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(-int32(112)),
	},
	218: {
		Fupper:   uint32(0x00001fec),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(7)),
	},
	219: {
		Fupper:   uint32(0x00001ff2),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(408),
	},
	220: {
		Fupper:   uint32(0x00001ff3),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(413),
	},
	221: {
		Fupper:   uint32(0x00001ff4),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(417),
	},
	222: {
		Fupper:   uint32(0x00001ff6),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(421),
	},
	223: {
		Fupper:   uint32(0x00001ff7),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0006)&0x3fff<<2,
		Foffset:  int16(425),
	},
	224: {
		Fupper:   uint32(0x00001ff8),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(-int32(128)),
	},
	225: {
		Fupper:   uint32(0x00001ffa),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(-int32(126)),
	},
	226: {
		Fupper:   uint32(0x00001ffc),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(431),
	},
	227: {
		Fupper:   uint32(0x00002126),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(7517)),
	},
	228: {
		Fupper:   uint32(0x0000212a),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(8383)),
	},
	229: {
		Fupper:   uint32(0x0000212b),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(8262)),
	},
	230: {
		Fupper:   uint32(0x00002132),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(28),
	},
	231: {
		Fupper:   uint32(0x00002160),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0010)&0x3fff<<2,
		Foffset:  int16(16),
	},
	232: {
		Fupper:   uint32(0x00002183),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	233: {
		Fupper:   uint32(0x000024b6),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x001a)&0x3fff<<2,
		Foffset:  int16(26),
	},
	234: {
		Fupper:   uint32(0x00002c00),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0030)&0x3fff<<2,
		Foffset:  int16(48),
	},
	235: {
		Fupper:   uint32(0x00002c60),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	236: {
		Fupper:   uint32(0x00002c62),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(10743)),
	},
	237: {
		Fupper:   uint32(0x00002c63),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(3814)),
	},
	238: {
		Fupper:   uint32(0x00002c64),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(10727)),
	},
	239: {
		Fupper:   uint32(0x00002c67),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0005)&0x3fff<<2,
		Foffset:  int16(1),
	},
	240: {
		Fupper:   uint32(0x00002c6d),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(10780)),
	},
	241: {
		Fupper:   uint32(0x00002c6e),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(10749)),
	},
	242: {
		Fupper:   uint32(0x00002c6f),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(10783)),
	},
	243: {
		Fupper:   uint32(0x00002c70),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(10782)),
	},
	244: {
		Fupper:   uint32(0x00002c72),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	245: {
		Fupper:   uint32(0x00002c75),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	246: {
		Fupper:   uint32(0x00002c7e),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(-int32(10815)),
	},
	247: {
		Fupper:   uint32(0x00002c80),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0063)&0x3fff<<2,
		Foffset:  int16(1),
	},
	248: {
		Fupper:   uint32(0x00002ceb),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(1),
	},
	249: {
		Fupper:   uint32(0x00002cf2),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	250: {
		Fupper:   uint32(0x0000a640),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x002d)&0x3fff<<2,
		Foffset:  int16(1),
	},
	251: {
		Fupper:   uint32(0x0000a680),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x001b)&0x3fff<<2,
		Foffset:  int16(1),
	},
	252: {
		Fupper:   uint32(0x0000a722),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x000d)&0x3fff<<2,
		Foffset:  int16(1),
	},
	253: {
		Fupper:   uint32(0x0000a732),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x003d)&0x3fff<<2,
		Foffset:  int16(1),
	},
	254: {
		Fupper:   uint32(0x0000a779),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(1),
	},
	255: {
		Fupper:   uint32(0x0000a77d),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(30204),
	},
	256: {
		Fupper:   uint32(0x0000a77e),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0009)&0x3fff<<2,
		Foffset:  int16(1),
	},
	257: {
		Fupper:   uint32(0x0000a78b),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	258: {
		Fupper:   uint32(0x0000a78d),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(23256),
	},
	259: {
		Fupper:   uint32(0x0000a790),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(1),
	},
	260: {
		Fupper:   uint32(0x0000a796),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0013)&0x3fff<<2,
		Foffset:  int16(1),
	},
	261: {
		Fupper:   uint32(0x0000a7aa),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(23228),
	},
	262: {
		Fupper:   uint32(0x0000a7ab),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(23217),
	},
	263: {
		Fupper:   uint32(0x0000a7ac),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(23221),
	},
	264: {
		Fupper:   uint32(0x0000a7ad),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(23231),
	},
	265: {
		Fupper:   uint32(0x0000a7ae),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(23228),
	},
	266: {
		Fupper:   uint32(0x0000a7b0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(23278),
	},
	267: {
		Fupper:   uint32(0x0000a7b1),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(23254),
	},
	268: {
		Fupper:   uint32(0x0000a7b2),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(23275),
	},
	269: {
		Fupper:   uint32(0x0000a7b3),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(928),
	},
	270: {
		Fupper:   uint32(0x0000a7b4),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x000f)&0x3fff<<2,
		Foffset:  int16(1),
	},
	271: {
		Fupper:   uint32(0x0000a7c4),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(-int32(48)),
	},
	272: {
		Fupper:   uint32(0x0000a7c5),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(23229),
	},
	273: {
		Fupper:   uint32(0x0000a7c6),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(30152),
	},
	274: {
		Fupper:   uint32(0x0000a7c7),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(1),
	},
	275: {
		Fupper:   uint32(0x0000a7d0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	276: {
		Fupper:   uint32(0x0000a7d6),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(1),
	},
	277: {
		Fupper:   uint32(0x0000a7f5),
		F__ccgo4: uint16(m_FC_CASE_FOLD_EVEN_ODD)&0x3<<0 | uint16(0x0001)&0x3fff<<2,
		Foffset:  int16(1),
	},
	278: {
		Fupper:   uint32(0x0000ab70),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0050)&0x3fff<<2,
		Foffset:  int16(26672),
	},
	279: {
		Fupper:   uint32(0x0000fb00),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(435),
	},
	280: {
		Fupper:   uint32(0x0000fb01),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(437),
	},
	281: {
		Fupper:   uint32(0x0000fb02),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(439),
	},
	282: {
		Fupper:   uint32(0x0000fb03),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(441),
	},
	283: {
		Fupper:   uint32(0x0000fb04),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0003)&0x3fff<<2,
		Foffset:  int16(444),
	},
	284: {
		Fupper:   uint32(0x0000fb05),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(447),
	},
	285: {
		Fupper:   uint32(0x0000fb06),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(449),
	},
	286: {
		Fupper:   uint32(0x0000fb13),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(451),
	},
	287: {
		Fupper:   uint32(0x0000fb14),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(455),
	},
	288: {
		Fupper:   uint32(0x0000fb15),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(459),
	},
	289: {
		Fupper:   uint32(0x0000fb16),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(463),
	},
	290: {
		Fupper:   uint32(0x0000fb17),
		F__ccgo4: uint16(m_FC_CASE_FOLD_FULL)&0x3<<0 | uint16(0x0004)&0x3fff<<2,
		Foffset:  int16(467),
	},
	291: {
		Fupper:   uint32(0x0000ff21),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x001a)&0x3fff<<2,
		Foffset:  int16(32),
	},
	292: {
		Fupper:   uint32(0x00010400),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0028)&0x3fff<<2,
		Foffset:  int16(40),
	},
	293: {
		Fupper:   uint32(0x000104b0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0024)&0x3fff<<2,
		Foffset:  int16(40),
	},
	294: {
		Fupper:   uint32(0x00010570),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x000b)&0x3fff<<2,
		Foffset:  int16(39),
	},
	295: {
		Fupper:   uint32(0x0001057c),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x000f)&0x3fff<<2,
		Foffset:  int16(39),
	},
	296: {
		Fupper:   uint32(0x0001058c),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0007)&0x3fff<<2,
		Foffset:  int16(39),
	},
	297: {
		Fupper:   uint32(0x00010594),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0002)&0x3fff<<2,
		Foffset:  int16(39),
	},
	298: {
		Fupper:   uint32(0x00010c80),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0033)&0x3fff<<2,
		Foffset:  int16(64),
	},
	299: {
		Fupper:   uint32(0x000118a0),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0020)&0x3fff<<2,
		Foffset:  int16(32),
	},
	300: {
		Fupper:   uint32(0x00016e40),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0020)&0x3fff<<2,
		Foffset:  int16(32),
	},
	301: {
		Fupper:   uint32(0x0001e900),
		F__ccgo4: uint16(m_FC_CASE_FOLD_RANGE)&0x3<<0 | uint16(0x0022)&0x3fff<<2,
		Foffset:  int16(34),
	},
}
var _fcCaseFoldChars = [471]TFcChar8{
	0:   uint8(0x73),
	1:   uint8(0x73),
	2:   uint8(0x69),
	3:   uint8(0xcc),
	4:   uint8(0x87),
	5:   uint8(0xca),
	6:   uint8(0xbc),
	7:   uint8(0x6e),
	8:   uint8(0x6a),
	9:   uint8(0xcc),
	10:  uint8(0x8c),
	11:  uint8(0xce),
	12:  uint8(0xb9),
	13:  uint8(0xcc),
	14:  uint8(0x88),
	15:  uint8(0xcc),
	16:  uint8(0x81),
	17:  uint8(0xcf),
	18:  uint8(0x85),
	19:  uint8(0xcc),
	20:  uint8(0x88),
	21:  uint8(0xcc),
	22:  uint8(0x81),
	23:  uint8(0xd5),
	24:  uint8(0xa5),
	25:  uint8(0xd6),
	26:  uint8(0x82),
	27:  uint8(0x68),
	28:  uint8(0xcc),
	29:  uint8(0xb1),
	30:  uint8(0x74),
	31:  uint8(0xcc),
	32:  uint8(0x88),
	33:  uint8(0x77),
	34:  uint8(0xcc),
	35:  uint8(0x8a),
	36:  uint8(0x79),
	37:  uint8(0xcc),
	38:  uint8(0x8a),
	39:  uint8(0x61),
	40:  uint8(0xca),
	41:  uint8(0xbe),
	42:  uint8(0x73),
	43:  uint8(0x73),
	44:  uint8(0xcf),
	45:  uint8(0x85),
	46:  uint8(0xcc),
	47:  uint8(0x93),
	48:  uint8(0xcf),
	49:  uint8(0x85),
	50:  uint8(0xcc),
	51:  uint8(0x93),
	52:  uint8(0xcc),
	53:  uint8(0x80),
	54:  uint8(0xcf),
	55:  uint8(0x85),
	56:  uint8(0xcc),
	57:  uint8(0x93),
	58:  uint8(0xcc),
	59:  uint8(0x81),
	60:  uint8(0xcf),
	61:  uint8(0x85),
	62:  uint8(0xcc),
	63:  uint8(0x93),
	64:  uint8(0xcd),
	65:  uint8(0x82),
	66:  uint8(0xe1),
	67:  uint8(0xbc),
	68:  uint8(0x80),
	69:  uint8(0xce),
	70:  uint8(0xb9),
	71:  uint8(0xe1),
	72:  uint8(0xbc),
	73:  uint8(0x81),
	74:  uint8(0xce),
	75:  uint8(0xb9),
	76:  uint8(0xe1),
	77:  uint8(0xbc),
	78:  uint8(0x82),
	79:  uint8(0xce),
	80:  uint8(0xb9),
	81:  uint8(0xe1),
	82:  uint8(0xbc),
	83:  uint8(0x83),
	84:  uint8(0xce),
	85:  uint8(0xb9),
	86:  uint8(0xe1),
	87:  uint8(0xbc),
	88:  uint8(0x84),
	89:  uint8(0xce),
	90:  uint8(0xb9),
	91:  uint8(0xe1),
	92:  uint8(0xbc),
	93:  uint8(0x85),
	94:  uint8(0xce),
	95:  uint8(0xb9),
	96:  uint8(0xe1),
	97:  uint8(0xbc),
	98:  uint8(0x86),
	99:  uint8(0xce),
	100: uint8(0xb9),
	101: uint8(0xe1),
	102: uint8(0xbc),
	103: uint8(0x87),
	104: uint8(0xce),
	105: uint8(0xb9),
	106: uint8(0xe1),
	107: uint8(0xbc),
	108: uint8(0x80),
	109: uint8(0xce),
	110: uint8(0xb9),
	111: uint8(0xe1),
	112: uint8(0xbc),
	113: uint8(0x81),
	114: uint8(0xce),
	115: uint8(0xb9),
	116: uint8(0xe1),
	117: uint8(0xbc),
	118: uint8(0x82),
	119: uint8(0xce),
	120: uint8(0xb9),
	121: uint8(0xe1),
	122: uint8(0xbc),
	123: uint8(0x83),
	124: uint8(0xce),
	125: uint8(0xb9),
	126: uint8(0xe1),
	127: uint8(0xbc),
	128: uint8(0x84),
	129: uint8(0xce),
	130: uint8(0xb9),
	131: uint8(0xe1),
	132: uint8(0xbc),
	133: uint8(0x85),
	134: uint8(0xce),
	135: uint8(0xb9),
	136: uint8(0xe1),
	137: uint8(0xbc),
	138: uint8(0x86),
	139: uint8(0xce),
	140: uint8(0xb9),
	141: uint8(0xe1),
	142: uint8(0xbc),
	143: uint8(0x87),
	144: uint8(0xce),
	145: uint8(0xb9),
	146: uint8(0xe1),
	147: uint8(0xbc),
	148: uint8(0xa0),
	149: uint8(0xce),
	150: uint8(0xb9),
	151: uint8(0xe1),
	152: uint8(0xbc),
	153: uint8(0xa1),
	154: uint8(0xce),
	155: uint8(0xb9),
	156: uint8(0xe1),
	157: uint8(0xbc),
	158: uint8(0xa2),
	159: uint8(0xce),
	160: uint8(0xb9),
	161: uint8(0xe1),
	162: uint8(0xbc),
	163: uint8(0xa3),
	164: uint8(0xce),
	165: uint8(0xb9),
	166: uint8(0xe1),
	167: uint8(0xbc),
	168: uint8(0xa4),
	169: uint8(0xce),
	170: uint8(0xb9),
	171: uint8(0xe1),
	172: uint8(0xbc),
	173: uint8(0xa5),
	174: uint8(0xce),
	175: uint8(0xb9),
	176: uint8(0xe1),
	177: uint8(0xbc),
	178: uint8(0xa6),
	179: uint8(0xce),
	180: uint8(0xb9),
	181: uint8(0xe1),
	182: uint8(0xbc),
	183: uint8(0xa7),
	184: uint8(0xce),
	185: uint8(0xb9),
	186: uint8(0xe1),
	187: uint8(0xbc),
	188: uint8(0xa0),
	189: uint8(0xce),
	190: uint8(0xb9),
	191: uint8(0xe1),
	192: uint8(0xbc),
	193: uint8(0xa1),
	194: uint8(0xce),
	195: uint8(0xb9),
	196: uint8(0xe1),
	197: uint8(0xbc),
	198: uint8(0xa2),
	199: uint8(0xce),
	200: uint8(0xb9),
	201: uint8(0xe1),
	202: uint8(0xbc),
	203: uint8(0xa3),
	204: uint8(0xce),
	205: uint8(0xb9),
	206: uint8(0xe1),
	207: uint8(0xbc),
	208: uint8(0xa4),
	209: uint8(0xce),
	210: uint8(0xb9),
	211: uint8(0xe1),
	212: uint8(0xbc),
	213: uint8(0xa5),
	214: uint8(0xce),
	215: uint8(0xb9),
	216: uint8(0xe1),
	217: uint8(0xbc),
	218: uint8(0xa6),
	219: uint8(0xce),
	220: uint8(0xb9),
	221: uint8(0xe1),
	222: uint8(0xbc),
	223: uint8(0xa7),
	224: uint8(0xce),
	225: uint8(0xb9),
	226: uint8(0xe1),
	227: uint8(0xbd),
	228: uint8(0xa0),
	229: uint8(0xce),
	230: uint8(0xb9),
	231: uint8(0xe1),
	232: uint8(0xbd),
	233: uint8(0xa1),
	234: uint8(0xce),
	235: uint8(0xb9),
	236: uint8(0xe1),
	237: uint8(0xbd),
	238: uint8(0xa2),
	239: uint8(0xce),
	240: uint8(0xb9),
	241: uint8(0xe1),
	242: uint8(0xbd),
	243: uint8(0xa3),
	244: uint8(0xce),
	245: uint8(0xb9),
	246: uint8(0xe1),
	247: uint8(0xbd),
	248: uint8(0xa4),
	249: uint8(0xce),
	250: uint8(0xb9),
	251: uint8(0xe1),
	252: uint8(0xbd),
	253: uint8(0xa5),
	254: uint8(0xce),
	255: uint8(0xb9),
	256: uint8(0xe1),
	257: uint8(0xbd),
	258: uint8(0xa6),
	259: uint8(0xce),
	260: uint8(0xb9),
	261: uint8(0xe1),
	262: uint8(0xbd),
	263: uint8(0xa7),
	264: uint8(0xce),
	265: uint8(0xb9),
	266: uint8(0xe1),
	267: uint8(0xbd),
	268: uint8(0xa0),
	269: uint8(0xce),
	270: uint8(0xb9),
	271: uint8(0xe1),
	272: uint8(0xbd),
	273: uint8(0xa1),
	274: uint8(0xce),
	275: uint8(0xb9),
	276: uint8(0xe1),
	277: uint8(0xbd),
	278: uint8(0xa2),
	279: uint8(0xce),
	280: uint8(0xb9),
	281: uint8(0xe1),
	282: uint8(0xbd),
	283: uint8(0xa3),
	284: uint8(0xce),
	285: uint8(0xb9),
	286: uint8(0xe1),
	287: uint8(0xbd),
	288: uint8(0xa4),
	289: uint8(0xce),
	290: uint8(0xb9),
	291: uint8(0xe1),
	292: uint8(0xbd),
	293: uint8(0xa5),
	294: uint8(0xce),
	295: uint8(0xb9),
	296: uint8(0xe1),
	297: uint8(0xbd),
	298: uint8(0xa6),
	299: uint8(0xce),
	300: uint8(0xb9),
	301: uint8(0xe1),
	302: uint8(0xbd),
	303: uint8(0xa7),
	304: uint8(0xce),
	305: uint8(0xb9),
	306: uint8(0xe1),
	307: uint8(0xbd),
	308: uint8(0xb0),
	309: uint8(0xce),
	310: uint8(0xb9),
	311: uint8(0xce),
	312: uint8(0xb1),
	313: uint8(0xce),
	314: uint8(0xb9),
	315: uint8(0xce),
	316: uint8(0xac),
	317: uint8(0xce),
	318: uint8(0xb9),
	319: uint8(0xce),
	320: uint8(0xb1),
	321: uint8(0xcd),
	322: uint8(0x82),
	323: uint8(0xce),
	324: uint8(0xb1),
	325: uint8(0xcd),
	326: uint8(0x82),
	327: uint8(0xce),
	328: uint8(0xb9),
	329: uint8(0xce),
	330: uint8(0xb1),
	331: uint8(0xce),
	332: uint8(0xb9),
	333: uint8(0xe1),
	334: uint8(0xbd),
	335: uint8(0xb4),
	336: uint8(0xce),
	337: uint8(0xb9),
	338: uint8(0xce),
	339: uint8(0xb7),
	340: uint8(0xce),
	341: uint8(0xb9),
	342: uint8(0xce),
	343: uint8(0xae),
	344: uint8(0xce),
	345: uint8(0xb9),
	346: uint8(0xce),
	347: uint8(0xb7),
	348: uint8(0xcd),
	349: uint8(0x82),
	350: uint8(0xce),
	351: uint8(0xb7),
	352: uint8(0xcd),
	353: uint8(0x82),
	354: uint8(0xce),
	355: uint8(0xb9),
	356: uint8(0xce),
	357: uint8(0xb7),
	358: uint8(0xce),
	359: uint8(0xb9),
	360: uint8(0xce),
	361: uint8(0xb9),
	362: uint8(0xcc),
	363: uint8(0x88),
	364: uint8(0xcc),
	365: uint8(0x80),
	366: uint8(0xce),
	367: uint8(0xb9),
	368: uint8(0xcc),
	369: uint8(0x88),
	370: uint8(0xcc),
	371: uint8(0x81),
	372: uint8(0xce),
	373: uint8(0xb9),
	374: uint8(0xcd),
	375: uint8(0x82),
	376: uint8(0xce),
	377: uint8(0xb9),
	378: uint8(0xcc),
	379: uint8(0x88),
	380: uint8(0xcd),
	381: uint8(0x82),
	382: uint8(0xcf),
	383: uint8(0x85),
	384: uint8(0xcc),
	385: uint8(0x88),
	386: uint8(0xcc),
	387: uint8(0x80),
	388: uint8(0xcf),
	389: uint8(0x85),
	390: uint8(0xcc),
	391: uint8(0x88),
	392: uint8(0xcc),
	393: uint8(0x81),
	394: uint8(0xcf),
	395: uint8(0x81),
	396: uint8(0xcc),
	397: uint8(0x93),
	398: uint8(0xcf),
	399: uint8(0x85),
	400: uint8(0xcd),
	401: uint8(0x82),
	402: uint8(0xcf),
	403: uint8(0x85),
	404: uint8(0xcc),
	405: uint8(0x88),
	406: uint8(0xcd),
	407: uint8(0x82),
	408: uint8(0xe1),
	409: uint8(0xbd),
	410: uint8(0xbc),
	411: uint8(0xce),
	412: uint8(0xb9),
	413: uint8(0xcf),
	414: uint8(0x89),
	415: uint8(0xce),
	416: uint8(0xb9),
	417: uint8(0xcf),
	418: uint8(0x8e),
	419: uint8(0xce),
	420: uint8(0xb9),
	421: uint8(0xcf),
	422: uint8(0x89),
	423: uint8(0xcd),
	424: uint8(0x82),
	425: uint8(0xcf),
	426: uint8(0x89),
	427: uint8(0xcd),
	428: uint8(0x82),
	429: uint8(0xce),
	430: uint8(0xb9),
	431: uint8(0xcf),
	432: uint8(0x89),
	433: uint8(0xce),
	434: uint8(0xb9),
	435: uint8(0x66),
	436: uint8(0x66),
	437: uint8(0x66),
	438: uint8(0x69),
	439: uint8(0x66),
	440: uint8(0x6c),
	441: uint8(0x66),
	442: uint8(0x66),
	443: uint8(0x69),
	444: uint8(0x66),
	445: uint8(0x66),
	446: uint8(0x6c),
	447: uint8(0x73),
	448: uint8(0x74),
	449: uint8(0x73),
	450: uint8(0x74),
	451: uint8(0xd5),
	452: uint8(0xb4),
	453: uint8(0xd5),
	454: uint8(0xb6),
	455: uint8(0xd5),
	456: uint8(0xb4),
	457: uint8(0xd5),
	458: uint8(0xa5),
	459: uint8(0xd5),
	460: uint8(0xb4),
	461: uint8(0xd5),
	462: uint8(0xab),
	463: uint8(0xd5),
	464: uint8(0xbe),
	465: uint8(0xd5),
	466: uint8(0xb6),
	467: uint8(0xd5),
	468: uint8(0xb4),
	469: uint8(0xd5),
	470: uint8(0xad),
}

type TFcCaseWalker = struct {
	Fread uintptr
	Fsrc  uintptr
	Futf8 [7]TFcChar8
}

type T_FcCaseWalker = TFcCaseWalker

func _FcStrCaseWalkerInit(tls *libc.TLS, src uintptr, w uintptr) {
	(*TFcCaseWalker)(unsafe.Pointer(w)).Fsrc = src
	(*TFcCaseWalker)(unsafe.Pointer(w)).Fread = uintptr(0)
}

func _FcStrCaseWalkerLong(tls *libc.TLS, w uintptr, r TFcChar8) (r1 TFcChar8) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var dlen, len1, max, mid, min, slen, v1 int32
	var fold, v2, v3 uintptr
	var high, low TFcChar32
	var _ /* ucs4 at bp+0 */ TFcChar32
	_, _, _, _, _, _, _, _, _, _, _, _ = dlen, fold, high, len1, low, max, mid, min, slen, v1, v2, v3
	len1 = libc.Int32FromUint64(libc.Xstrlen(tls, (*TFcCaseWalker)(unsafe.Pointer(w)).Fsrc))
	slen = XFcUtf8ToUcs4(tls, (*TFcCaseWalker)(unsafe.Pointer(w)).Fsrc-uintptr(1), bp, len1+int32(1))
	if slen <= 0 {
		return r
	}
	if uint32(m_FC_MIN_FOLD_CHAR) <= *(*TFcChar32)(unsafe.Pointer(bp)) && *(*TFcChar32)(unsafe.Pointer(bp)) <= uint32(m_FC_MAX_FOLD_CHAR) {
		min = 0
		max = int32(m_FC_NUM_CASE_FOLD)
		for min <= max {
			mid = (min + max) >> int32(1)
			low = _fcCaseFold[mid].Fupper
			if int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcCaseFold)) + uintptr(mid)*8 + 4))&0x3>>0) == int32(m_FC_CASE_FOLD_FULL) {
				v1 = int32(1)
			} else {
				v1 = int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fcCaseFold)) + uintptr(mid)*8 + 4)) & 0xfffc >> 2)
			}
			high = low + libc.Uint32FromInt32(v1)
			if high <= *(*TFcChar32)(unsafe.Pointer(bp)) {
				min = mid + int32(1)
			} else {
				if *(*TFcChar32)(unsafe.Pointer(bp)) < low {
					max = mid - int32(1)
				} else {
					fold = uintptr(unsafe.Pointer(&_fcCaseFold)) + uintptr(mid)*8
					switch int32(*(*uint16)(unsafe.Pointer(fold + 4)) & 0x3 >> 0) {
					case int32(m_FC_CASE_FOLD_EVEN_ODD):
						if *(*TFcChar32)(unsafe.Pointer(bp))&uint32(1) != (*TFcCaseFold)(unsafe.Pointer(fold)).Fupper&uint32(1) {
							return r
						}
						/* fall through ... */
						fallthrough
					default:
						dlen = XFcUcs4ToUtf8(tls, *(*TFcChar32)(unsafe.Pointer(bp))+libc.Uint32FromInt16((*TFcCaseFold)(unsafe.Pointer(fold)).Foffset), w+16)
					case int32(m_FC_CASE_FOLD_FULL):
						dlen = int32(*(*uint16)(unsafe.Pointer(fold + 4)) & 0xfffc >> 2)
						libc.X__builtin___memcpy_chk(tls, w+16, uintptr(unsafe.Pointer(&_fcCaseFoldChars))+uintptr((*TFcCaseFold)(unsafe.Pointer(fold)).Foffset), libc.Uint64FromInt32(dlen), ^t__predefined_size_t(0))
						break
					}
					/* consume rest of src utf-8 bytes */
					*(*uintptr)(unsafe.Pointer(w + 8)) += uintptr(slen - int32(1))
					/* read from temp buffer */
					*(*TFcChar8)(unsafe.Pointer(w + 16 + uintptr(dlen))) = uint8('\000')
					(*TFcCaseWalker)(unsafe.Pointer(w)).Fread = w + 16
					v3 = w
					v2 = *(*uintptr)(unsafe.Pointer(v3))
					*(*uintptr)(unsafe.Pointer(v3))++
					return *(*TFcChar8)(unsafe.Pointer(v2))
				}
			}
		}
	}
	return r
}

func _FcStrCaseWalkerNextNonDelim(tls *libc.TLS, w uintptr, delims uintptr) (r1 TFcChar8) {
	var r, v2 TFcChar8
	var v1, v7 int32
	var v3, v4, v5, v6 uintptr
	_, _, _, _, _, _, _, _ = r, v1, v2, v3, v4, v5, v6, v7
	if (*TFcCaseWalker)(unsafe.Pointer(w)).Fread != libc.UintptrFromInt32(0) {
		v1 = int32(1)
	} else {
		v1 = 0
	}
	if libc.X__builtin_expect(tls, int64(v1), 0) != 0 {
		v4 = w
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		v2 = *(*TFcChar8)(unsafe.Pointer(v3))
		r = v2
		if v2 != 0 {
			return r
		}
		(*TFcCaseWalker)(unsafe.Pointer(w)).Fread = uintptr(0)
	}
	for cond := true; cond; cond = libc.Int32FromUint8(r) != 0 && delims != 0 && libc.Xstrchr(tls, delims, libc.Int32FromUint8(r)) != 0 {
		v6 = w + 8
		v5 = *(*uintptr)(unsafe.Pointer(v6))
		*(*uintptr)(unsafe.Pointer(v6))++
		r = *(*TFcChar8)(unsafe.Pointer(v5))
	}
	if libc.Int32FromUint8(r)&int32(0xc0) == int32(0xc0) {
		v7 = int32(1)
	} else {
		v7 = 0
	}
	if libc.X__builtin_expect(tls, int64(v7), 0) != 0 {
		return _FcStrCaseWalkerLong(tls, w, r)
	}
	if int32('A') <= libc.Int32FromUint8(r) && libc.Int32FromUint8(r) <= int32('Z') {
		r = libc.Uint8FromInt32(libc.Int32FromUint8(r) - int32('A') + int32('a'))
	}
	return r
}

func _FcStrCaseWalkerNextNonBlank(tls *libc.TLS, w uintptr) (r1 TFcChar8) {
	var r, v2 TFcChar8
	var v1, v7 int32
	var v3, v4, v5, v6 uintptr
	_, _, _, _, _, _, _, _ = r, v1, v2, v3, v4, v5, v6, v7
	if (*TFcCaseWalker)(unsafe.Pointer(w)).Fread != libc.UintptrFromInt32(0) {
		v1 = int32(1)
	} else {
		v1 = 0
	}
	if libc.X__builtin_expect(tls, int64(v1), 0) != 0 {
		v4 = w
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		v2 = *(*TFcChar8)(unsafe.Pointer(v3))
		r = v2
		if v2 != 0 {
			return r
		}
		(*TFcCaseWalker)(unsafe.Pointer(w)).Fread = uintptr(0)
	}
	for cond := true; cond; cond = libc.Int32FromUint8(r) == int32(' ') {
		v6 = w + 8
		v5 = *(*uintptr)(unsafe.Pointer(v6))
		*(*uintptr)(unsafe.Pointer(v6))++
		r = *(*TFcChar8)(unsafe.Pointer(v5))
	}
	if libc.Int32FromUint8(r)&int32(0xc0) == int32(0xc0) {
		v7 = int32(1)
	} else {
		v7 = 0
	}
	if libc.X__builtin_expect(tls, int64(v7), 0) != 0 {
		return _FcStrCaseWalkerLong(tls, w, r)
	}
	if int32('A') <= libc.Int32FromUint8(r) && libc.Int32FromUint8(r) <= int32('Z') {
		r = libc.Uint8FromInt32(libc.Int32FromUint8(r) - int32('A') + int32('a'))
	}
	return r
}

func _FcStrCaseWalkerNext(tls *libc.TLS, w uintptr) (r1 TFcChar8) {
	var r, v2 TFcChar8
	var v1, v7 int32
	var v3, v4, v5, v6 uintptr
	_, _, _, _, _, _, _, _ = r, v1, v2, v3, v4, v5, v6, v7
	if (*TFcCaseWalker)(unsafe.Pointer(w)).Fread != libc.UintptrFromInt32(0) {
		v1 = int32(1)
	} else {
		v1 = 0
	}
	if libc.X__builtin_expect(tls, int64(v1), 0) != 0 {
		v4 = w
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		v2 = *(*TFcChar8)(unsafe.Pointer(v3))
		r = v2
		if v2 != 0 {
			return r
		}
		(*TFcCaseWalker)(unsafe.Pointer(w)).Fread = uintptr(0)
	}
	v6 = w + 8
	v5 = *(*uintptr)(unsafe.Pointer(v6))
	*(*uintptr)(unsafe.Pointer(v6))++
	r = *(*TFcChar8)(unsafe.Pointer(v5))
	if libc.Int32FromUint8(r)&int32(0xc0) == int32(0xc0) {
		v7 = int32(1)
	} else {
		v7 = 0
	}
	if libc.X__builtin_expect(tls, int64(v7), 0) != 0 {
		return _FcStrCaseWalkerLong(tls, w, r)
	}
	if int32('A') <= libc.Int32FromUint8(r) && libc.Int32FromUint8(r) <= int32('Z') {
		r = libc.Uint8FromInt32(libc.Int32FromUint8(r) - int32('A') + int32('a'))
	}
	return r
}

func XFcStrDowncase(tls *libc.TLS, s uintptr) (r uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var d, dst, v1, v3 uintptr
	var len1 int32
	var v2 TFcChar8
	var _ /* w at bp+0 */ TFcCaseWalker
	_, _, _, _, _, _ = d, dst, len1, v1, v2, v3
	len1 = 0
	_FcStrCaseWalkerInit(tls, s, bp)
	for _FcStrCaseWalkerNext(tls, bp) != 0 {
		len1++
	}
	v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(len1+int32(1)))
	dst = v1
	d = v1
	if !(d != 0) {
		return uintptr(0)
	}
	_FcStrCaseWalkerInit(tls, s, bp)
	for {
		v2 = _FcStrCaseWalkerNext(tls, bp)
		v3 = d
		d++
		*(*TFcChar8)(unsafe.Pointer(v3)) = v2
		if !(v2 != 0) {
			break
		}
	}
	return dst
}

func XFcStrCmpIgnoreCase(tls *libc.TLS, s1 uintptr, s2 uintptr) (r int32) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var c1, c2 TFcChar8
	var _ /* w1 at bp+0 */ TFcCaseWalker
	var _ /* w2 at bp+24 */ TFcCaseWalker
	_, _ = c1, c2
	if s1 == s2 {
		return 0
	}
	_FcStrCaseWalkerInit(tls, s1, bp)
	_FcStrCaseWalkerInit(tls, s2, bp+24)
	for {
		c1 = _FcStrCaseWalkerNext(tls, bp)
		c2 = _FcStrCaseWalkerNext(tls, bp+24)
		if !(c1 != 0) || libc.Int32FromUint8(c1) != libc.Int32FromUint8(c2) {
			break
		}
		goto _1
	_1:
	}
	return libc.Int32FromUint8(c1) - libc.Int32FromUint8(c2)
}

func XFcStrCmpIgnoreBlanksAndCase(tls *libc.TLS, s1 uintptr, s2 uintptr) (r int32) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var c1, c2 TFcChar8
	var _ /* w1 at bp+0 */ TFcCaseWalker
	var _ /* w2 at bp+24 */ TFcCaseWalker
	_, _ = c1, c2
	if s1 == s2 {
		return 0
	}
	_FcStrCaseWalkerInit(tls, s1, bp)
	_FcStrCaseWalkerInit(tls, s2, bp+24)
	for {
		c1 = _FcStrCaseWalkerNextNonBlank(tls, bp)
		c2 = _FcStrCaseWalkerNextNonBlank(tls, bp+24)
		if !(c1 != 0) || libc.Int32FromUint8(c1) != libc.Int32FromUint8(c2) {
			break
		}
		goto _1
	_1:
	}
	return libc.Int32FromUint8(c1) - libc.Int32FromUint8(c2)
}

func XFcStrCmp(tls *libc.TLS, s1 uintptr, s2 uintptr) (r int32) {
	var c1, c2 TFcChar8
	var v2, v3 uintptr
	_, _, _, _ = c1, c2, v2, v3
	if s1 == s2 {
		return 0
	}
	for {
		v2 = s1
		s1++
		c1 = *(*TFcChar8)(unsafe.Pointer(v2))
		v3 = s2
		s2++
		c2 = *(*TFcChar8)(unsafe.Pointer(v3))
		if !(c1 != 0) || libc.Int32FromUint8(c1) != libc.Int32FromUint8(c2) {
			break
		}
		goto _1
	_1:
	}
	return libc.Int32FromUint8(c1) - libc.Int32FromUint8(c2)
}

/*
 * Return a hash value for a string
 */

func XFcStrHashIgnoreCase(tls *libc.TLS, s uintptr) (r TFcChar32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var c, v1 TFcChar8
	var h TFcChar32
	var _ /* w at bp+0 */ TFcCaseWalker
	_, _, _ = c, h, v1
	h = uint32(0)
	_FcStrCaseWalkerInit(tls, s, bp)
	for {
		v1 = _FcStrCaseWalkerNext(tls, bp)
		c = v1
		if !(v1 != 0) {
			break
		}
		h = h<<libc.Int32FromInt32(3) ^ h>>libc.Int32FromInt32(3) ^ uint32(c)
	}
	return h
}

func XFcStrHashIgnoreBlanksAndCase(tls *libc.TLS, s uintptr) (r TFcChar32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var c, v1 TFcChar8
	var h TFcChar32
	var _ /* w at bp+0 */ TFcCaseWalker
	_, _, _ = c, h, v1
	h = uint32(0)
	_FcStrCaseWalkerInit(tls, s, bp)
	for {
		v1 = _FcStrCaseWalkerNextNonBlank(tls, bp)
		c = v1
		if !(v1 != 0) {
			break
		}
		h = h<<libc.Int32FromInt32(3) ^ h>>libc.Int32FromInt32(3) ^ uint32(c)
	}
	return h
}

/*
 * Is the head of s1 equal to s2?
 */

func _FcStrIsAtIgnoreBlanksAndCase(tls *libc.TLS, s1 uintptr, s2 uintptr) (r TFcBool) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var c1, c2 TFcChar8
	var _ /* w1 at bp+0 */ TFcCaseWalker
	var _ /* w2 at bp+24 */ TFcCaseWalker
	_, _ = c1, c2
	_FcStrCaseWalkerInit(tls, s1, bp)
	_FcStrCaseWalkerInit(tls, s2, bp+24)
	for {
		c1 = _FcStrCaseWalkerNextNonBlank(tls, bp)
		c2 = _FcStrCaseWalkerNextNonBlank(tls, bp+24)
		if !(c1 != 0) || libc.Int32FromUint8(c1) != libc.Int32FromUint8(c2) {
			break
		}
		goto _1
	_1:
	}
	return libc.BoolInt32(libc.Int32FromUint8(c1) == libc.Int32FromUint8(c2) || !(c2 != 0))
}

/*
 * Does s1 contain an instance of s2 (ignoring blanks and case)?
 */

func XFcStrContainsIgnoreBlanksAndCase(tls *libc.TLS, s1 uintptr, s2 uintptr) (r uintptr) {
	for *(*TFcChar8)(unsafe.Pointer(s1)) != 0 {
		if _FcStrIsAtIgnoreBlanksAndCase(tls, s1, s2) != 0 {
			return s1
		}
		s1++
	}
	return uintptr(0)
}

func _FcCharIsPunct1(tls *libc.TLS, c TFcChar8) (r TFcBool) {
	if libc.Int32FromUint8(c) < int32('0') {
		return int32(m_FcTrue)
	}
	if libc.Int32FromUint8(c) <= int32('9') {
		return m_FcFalse
	}
	if libc.Int32FromUint8(c) < int32('A') {
		return int32(m_FcTrue)
	}
	if libc.Int32FromUint8(c) <= int32('Z') {
		return m_FcFalse
	}
	if libc.Int32FromUint8(c) < int32('a') {
		return int32(m_FcTrue)
	}
	if libc.Int32FromUint8(c) <= int32('z') {
		return m_FcFalse
	}
	if libc.Int32FromUint8(c) <= int32('~') {
		return int32(m_FcTrue)
	}
	return m_FcFalse
}

/*
 * Is the head of s1 equal to s2?
 */

func _FcStrIsAtIgnoreCase(tls *libc.TLS, s1 uintptr, s2 uintptr) (r TFcBool) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var c1, c2 TFcChar8
	var _ /* w1 at bp+0 */ TFcCaseWalker
	var _ /* w2 at bp+24 */ TFcCaseWalker
	_, _ = c1, c2
	_FcStrCaseWalkerInit(tls, s1, bp)
	_FcStrCaseWalkerInit(tls, s2, bp+24)
	for {
		c1 = _FcStrCaseWalkerNext(tls, bp)
		c2 = _FcStrCaseWalkerNext(tls, bp+24)
		if !(c1 != 0) || libc.Int32FromUint8(c1) != libc.Int32FromUint8(c2) {
			break
		}
		goto _1
	_1:
	}
	return libc.BoolInt32(libc.Int32FromUint8(c1) == libc.Int32FromUint8(c2) || !(c2 != 0))
}

/*
 * Does s1 contain an instance of s2 (ignoring blanks and case)?
 */

func XFcStrContainsIgnoreCase(tls *libc.TLS, s1 uintptr, s2 uintptr) (r uintptr) {
	for *(*TFcChar8)(unsafe.Pointer(s1)) != 0 {
		if _FcStrIsAtIgnoreCase(tls, s1, s2) != 0 {
			return s1
		}
		s1++
	}
	return uintptr(0)
}

/*
 * Does s1 contain an instance of s2 on a word boundary (ignoring case)?
 */

func XFcStrContainsWord(tls *libc.TLS, s1 uintptr, s2 uintptr) (r uintptr) {
	var s1len, s2len int32
	var wordStart TFcBool
	_, _, _ = s1len, s2len, wordStart
	wordStart = int32(m_FcTrue)
	s1len = libc.Int32FromUint64(libc.Xstrlen(tls, s1))
	s2len = libc.Int32FromUint64(libc.Xstrlen(tls, s2))
	for s1len >= s2len {
		if wordStart != 0 && _FcStrIsAtIgnoreCase(tls, s1, s2) != 0 && (s1len == s2len || _FcCharIsPunct1(tls, *(*TFcChar8)(unsafe.Pointer(s1 + uintptr(s2len)))) != 0) {
			return s1
		}
		wordStart = m_FcFalse
		if _FcCharIsPunct1(tls, *(*TFcChar8)(unsafe.Pointer(s1))) != 0 {
			wordStart = int32(m_FcTrue)
		}
		s1++
		s1len--
	}
	return uintptr(0)
}

/*
 * returns the number of strings (ignoring delimiters and case) being matched
 */

func XFcStrMatchIgnoreCaseAndDelims(tls *libc.TLS, s1 uintptr, s2 uintptr, delims uintptr) (r int32) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var c1, c2 TFcChar8
	var _ /* w1 at bp+0 */ TFcCaseWalker
	var _ /* w2 at bp+24 */ TFcCaseWalker
	_, _ = c1, c2
	if s1 == s2 {
		return 0
	}
	_FcStrCaseWalkerInit(tls, s1, bp)
	_FcStrCaseWalkerInit(tls, s2, bp+24)
	for {
		c1 = _FcStrCaseWalkerNextNonDelim(tls, bp, delims)
		c2 = _FcStrCaseWalkerNextNonDelim(tls, bp+24, delims)
		if !(c1 != 0) || libc.Int32FromUint8(c1) != libc.Int32FromUint8(c2) {
			break
		}
		goto _1
	_1:
	}
	return int32(int64((*(*TFcCaseWalker)(unsafe.Pointer(bp))).Fsrc) - int64(s1) - int64(1))
}

func XFcStrGlobMatch(tls *libc.TLS, glob uintptr, string1 uintptr) (r TFcBool) {
	var c, v1 TFcChar8
	var l1, l2 Tsize_t
	var v2, v3, v4 uintptr
	_, _, _, _, _, _, _ = c, l1, l2, v1, v2, v3, v4
	for {
		v2 = glob
		glob++
		v1 = *(*TFcChar8)(unsafe.Pointer(v2))
		c = v1
		if !(v1 != 0) {
			break
		}
		switch libc.Int32FromUint8(c) {
		case int32('*'):
			/* short circuit common case */
			if !(*(*TFcChar8)(unsafe.Pointer(glob)) != 0) {
				return int32(m_FcTrue)
			}
			/* short circuit another common case */
			if libc.Xstrchr(tls, glob, int32('*')) == uintptr(0) {
				l1 = libc.Xstrlen(tls, string1)
				l2 = libc.Xstrlen(tls, glob)
				if l1 < l2 {
					return m_FcFalse
				}
				string1 += uintptr(l1 - l2)
			}
			for *(*TFcChar8)(unsafe.Pointer(string1)) != 0 {
				if XFcStrGlobMatch(tls, glob, string1) != 0 {
					return int32(m_FcTrue)
				}
				string1++
			}
			return m_FcFalse
		case int32('?'):
			v3 = string1
			string1++
			if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v3))) == int32('\000') {
				return m_FcFalse
			}
		default:
			v4 = string1
			string1++
			if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v4))) != libc.Int32FromUint8(c) {
				return m_FcFalse
			}
			break
		}
	}
	return libc.BoolInt32(libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(string1))) == int32('\000'))
}

func XFcStrStrIgnoreCase(tls *libc.TLS, s1 uintptr, s2 uintptr) (r uintptr) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var c1, c1t, c2, c2t TFcChar8
	var cur uintptr
	var _ /* w1 at bp+0 */ TFcCaseWalker
	var _ /* w1t at bp+48 */ TFcCaseWalker
	var _ /* w2 at bp+24 */ TFcCaseWalker
	var _ /* w2t at bp+72 */ TFcCaseWalker
	_, _, _, _, _ = c1, c1t, c2, c2t, cur
	if !(s1 != 0) || !(s2 != 0) {
		return uintptr(0)
	}
	if s1 == s2 {
		return s1
	}
	_FcStrCaseWalkerInit(tls, s1, bp)
	_FcStrCaseWalkerInit(tls, s2, bp+24)
	c2 = _FcStrCaseWalkerNext(tls, bp+24)
	for {
		cur = (*(*TFcCaseWalker)(unsafe.Pointer(bp))).Fsrc
		c1 = _FcStrCaseWalkerNext(tls, bp)
		if !(c1 != 0) {
			break
		}
		if libc.Int32FromUint8(c1) == libc.Int32FromUint8(c2) {
			*(*TFcCaseWalker)(unsafe.Pointer(bp + 48)) = *(*TFcCaseWalker)(unsafe.Pointer(bp))
			*(*TFcCaseWalker)(unsafe.Pointer(bp + 72)) = *(*TFcCaseWalker)(unsafe.Pointer(bp + 24))
			for {
				c1t = _FcStrCaseWalkerNext(tls, bp+48)
				c2t = _FcStrCaseWalkerNext(tls, bp+72)
				if !(c2t != 0) {
					return cur
				}
				if libc.Int32FromUint8(c2t) != libc.Int32FromUint8(c1t) {
					break
				}
				goto _2
			_2:
			}
		}
		goto _1
	_1:
	}
	return uintptr(0)
}

func XFcStrStr(tls *libc.TLS, s1 uintptr, s2 uintptr) (r uintptr) {
	var b, p, v1, v3 uintptr
	var c1, c2 TFcChar8
	_, _, _, _, _, _ = b, c1, c2, p, v1, v3
	p = s1
	b = s2
	if !(s1 != 0) || !(s2 != 0) {
		return uintptr(0)
	}
	if s1 == s2 {
		return s1
	}
	goto again
again:
	;
	v1 = s2
	s2++
	c2 = *(*TFcChar8)(unsafe.Pointer(v1))
	if !(c2 != 0) {
		return uintptr(0)
	}
	for {
		p = s1
		v3 = s1
		s1++
		c1 = *(*TFcChar8)(unsafe.Pointer(v3))
		if !(c1 != 0) || libc.Int32FromUint8(c1) == libc.Int32FromUint8(c2) {
			break
		}
		goto _2
	_2:
	}
	if libc.Int32FromUint8(c1) != libc.Int32FromUint8(c2) {
		return uintptr(0)
	}
	for {
		c1 = *(*TFcChar8)(unsafe.Pointer(s1))
		c2 = *(*TFcChar8)(unsafe.Pointer(s2))
		if c1 != 0 && c2 != 0 && libc.Int32FromUint8(c1) != libc.Int32FromUint8(c2) {
			s1 = p + uintptr(1)
			s2 = b
			goto again
		}
		if !(c2 != 0) {
			return p
		}
		if !(c1 != 0) {
			return uintptr(0)
		}
		s1++
		s2++
		goto _4
	_4:
	}
	/* never reached. */
	return r
}

func XFcUtf8ToUcs4(tls *libc.TLS, src_orig uintptr, dst uintptr, len1 int32) (r int32) {
	var extra, v2 int32
	var result TFcChar32
	var s TFcChar8
	var src, v1, v3 uintptr
	_, _, _, _, _, _, _ = extra, result, s, src, v1, v2, v3
	src = src_orig
	if len1 == 0 {
		return 0
	}
	v1 = src
	src++
	s = *(*TFcChar8)(unsafe.Pointer(v1))
	len1--
	if !(libc.Int32FromUint8(s)&libc.Int32FromInt32(0x80) != 0) {
		result = uint32(s)
		extra = 0
	} else {
		if !(libc.Int32FromUint8(s)&libc.Int32FromInt32(0x40) != 0) {
			return -int32(1)
		} else {
			if !(libc.Int32FromUint8(s)&libc.Int32FromInt32(0x20) != 0) {
				result = libc.Uint32FromInt32(libc.Int32FromUint8(s) & int32(0x1f))
				extra = int32(1)
			} else {
				if !(libc.Int32FromUint8(s)&libc.Int32FromInt32(0x10) != 0) {
					result = libc.Uint32FromInt32(libc.Int32FromUint8(s) & int32(0xf))
					extra = int32(2)
				} else {
					if !(libc.Int32FromUint8(s)&libc.Int32FromInt32(0x08) != 0) {
						result = libc.Uint32FromInt32(libc.Int32FromUint8(s) & int32(0x07))
						extra = int32(3)
					} else {
						if !(libc.Int32FromUint8(s)&libc.Int32FromInt32(0x04) != 0) {
							result = libc.Uint32FromInt32(libc.Int32FromUint8(s) & int32(0x03))
							extra = int32(4)
						} else {
							if !(libc.Int32FromUint8(s)&libc.Int32FromInt32(0x02) != 0) {
								result = libc.Uint32FromInt32(libc.Int32FromUint8(s) & int32(0x01))
								extra = int32(5)
							} else {
								return -int32(1)
							}
						}
					}
				}
			}
		}
	}
	if extra > len1 {
		return -int32(1)
	}
	for {
		v2 = extra
		extra--
		if !(v2 != 0) {
			break
		}
		result <<= uint32(6)
		v3 = src
		src++
		s = *(*TFcChar8)(unsafe.Pointer(v3))
		if libc.Int32FromUint8(s)&int32(0xc0) != int32(0x80) {
			return -int32(1)
		}
		result |= libc.Uint32FromInt32(libc.Int32FromUint8(s) & int32(0x3f))
	}
	*(*TFcChar32)(unsafe.Pointer(dst)) = result
	return int32(int64(src) - int64(src_orig))
}

func XFcUtf8Len(tls *libc.TLS, string1 uintptr, len1 int32, nchar uintptr, wchar uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var clen, n int32
	var max TFcChar32
	var _ /* c at bp+0 */ TFcChar32
	_, _, _ = clen, max, n
	n = 0
	max = uint32(0)
	for len1 != 0 {
		clen = XFcUtf8ToUcs4(tls, string1, bp, len1)
		if clen <= 0 { /* malformed UTF8 string */
			return m_FcFalse
		}
		if *(*TFcChar32)(unsafe.Pointer(bp)) > max {
			max = *(*TFcChar32)(unsafe.Pointer(bp))
		}
		string1 += uintptr(clen)
		len1 -= clen
		n++
	}
	*(*int32)(unsafe.Pointer(nchar)) = n
	if max >= uint32(0x10000) {
		*(*int32)(unsafe.Pointer(wchar)) = int32(4)
	} else {
		if max > uint32(0x100) {
			*(*int32)(unsafe.Pointer(wchar)) = int32(2)
		} else {
			*(*int32)(unsafe.Pointer(wchar)) = int32(1)
		}
	}
	return int32(m_FcTrue)
}

func XFcUcs4ToUtf8(tls *libc.TLS, ucs4 TFcChar32, dest uintptr) (r int32) {
	var bits int32
	var d, v1, v2, v3, v4, v5, v6, v8 uintptr
	_, _, _, _, _, _, _, _, _ = bits, d, v1, v2, v3, v4, v5, v6, v8
	d = dest
	if ucs4 < uint32(0x80) {
		v1 = d
		d++
		*(*TFcChar8)(unsafe.Pointer(v1)) = uint8(ucs4)
		bits = -int32(6)
	} else {
		if ucs4 < uint32(0x800) {
			v2 = d
			d++
			*(*TFcChar8)(unsafe.Pointer(v2)) = uint8(ucs4>>libc.Int32FromInt32(6)&uint32(0x1F) | uint32(0xC0))
			bits = 0
		} else {
			if ucs4 < uint32(0x10000) {
				v3 = d
				d++
				*(*TFcChar8)(unsafe.Pointer(v3)) = uint8(ucs4>>libc.Int32FromInt32(12)&uint32(0x0F) | uint32(0xE0))
				bits = int32(6)
			} else {
				if ucs4 < uint32(0x200000) {
					v4 = d
					d++
					*(*TFcChar8)(unsafe.Pointer(v4)) = uint8(ucs4>>libc.Int32FromInt32(18)&uint32(0x07) | uint32(0xF0))
					bits = int32(12)
				} else {
					if ucs4 < uint32(0x4000000) {
						v5 = d
						d++
						*(*TFcChar8)(unsafe.Pointer(v5)) = uint8(ucs4>>libc.Int32FromInt32(24)&uint32(0x03) | uint32(0xF8))
						bits = int32(18)
					} else {
						if ucs4 < uint32(0x80000000) {
							v6 = d
							d++
							*(*TFcChar8)(unsafe.Pointer(v6)) = uint8(ucs4>>libc.Int32FromInt32(30)&uint32(0x01) | uint32(0xFC))
							bits = int32(24)
						} else {
							return 0
						}
					}
				}
			}
		}
	}
	for {
		if !(bits >= 0) {
			break
		}
		v8 = d
		d++
		*(*TFcChar8)(unsafe.Pointer(v8)) = uint8(ucs4>>bits&uint32(0x3F) | uint32(0x80))
		goto _7
	_7:
		;
		bits -= int32(6)
	}
	return int32(int64(d) - int64(dest))
}

func XFcUtf16ToUcs4(tls *libc.TLS, src_orig uintptr, endian TFcEndian, dst uintptr, len1 int32) (r int32) {
	/* in bytes */
	var a, b TFcChar16
	var result TFcChar32
	var src uintptr
	var v1, v2, v3, v4 int32
	_, _, _, _, _, _, _, _ = a, b, result, src, v1, v2, v3, v4
	src = src_orig
	if len1 < int32(2) {
		return 0
	}
	if endian == int32(_FcEndianBig) {
		v1 = 0
	} else {
		v1 = int32(1)
	}
	if endian == int32(_FcEndianBig) {
		v2 = int32(1)
	} else {
		v2 = 0
	}
	a = libc.Uint16FromInt32(libc.Int32FromUint16(libc.Uint16FromInt32(libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(src + uintptr(v1))))<<libc.Int32FromInt32(8))) | libc.Int32FromUint16(uint16(*(*TFcChar8)(unsafe.Pointer(src + uintptr(v2))))))
	src += uintptr(2)
	len1 -= int32(2)
	/*
	 * Check for surrogate
	 */
	if libc.Int32FromUint16(a)&int32(0xfc00) == int32(0xd800) {
		if len1 < int32(2) {
			return 0
		}
		if endian == int32(_FcEndianBig) {
			v3 = 0
		} else {
			v3 = int32(1)
		}
		if endian == int32(_FcEndianBig) {
			v4 = int32(1)
		} else {
			v4 = 0
		}
		b = libc.Uint16FromInt32(libc.Int32FromUint16(libc.Uint16FromInt32(libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(src + uintptr(v3))))<<libc.Int32FromInt32(8))) | libc.Int32FromUint16(uint16(*(*TFcChar8)(unsafe.Pointer(src + uintptr(v4))))))
		src += uintptr(2)
		len1 -= int32(2)
		/*
		 * Check for invalid surrogate sequence
		 */
		if libc.Int32FromUint16(b)&int32(0xfc00) != int32(0xdc00) {
			return 0
		}
		result = uint32(a)&uint32(0x3ff)<<int32(10) | uint32(b)&uint32(0x3ff) + uint32(0x10000)
	} else {
		result = uint32(a)
	}
	*(*TFcChar32)(unsafe.Pointer(dst)) = result
	return int32(int64(src) - int64(src_orig))
}

func XFcUtf16Len(tls *libc.TLS, string1 uintptr, endian TFcEndian, len1 int32, nchar uintptr, wchar uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var clen, n int32
	var max TFcChar32
	var _ /* c at bp+0 */ TFcChar32
	_, _, _ = clen, max, n
	n = 0
	max = uint32(0)
	for len1 != 0 {
		clen = XFcUtf16ToUcs4(tls, string1, endian, bp, len1)
		if clen <= 0 { /* malformed UTF8 string */
			return m_FcFalse
		}
		if *(*TFcChar32)(unsafe.Pointer(bp)) > max {
			max = *(*TFcChar32)(unsafe.Pointer(bp))
		}
		string1 += uintptr(clen)
		len1 -= clen
		n++
	}
	*(*int32)(unsafe.Pointer(nchar)) = n
	if max >= uint32(0x10000) {
		*(*int32)(unsafe.Pointer(wchar)) = int32(4)
	} else {
		if max > uint32(0x100) {
			*(*int32)(unsafe.Pointer(wchar)) = int32(2)
		} else {
			*(*int32)(unsafe.Pointer(wchar)) = int32(1)
		}
	}
	return int32(m_FcTrue)
}

func XFcStrBufInit(tls *libc.TLS, buf uintptr, init1 uintptr, size int32) {
	if init1 != 0 {
		(*TFcStrBuf)(unsafe.Pointer(buf)).Fbuf = init1
		(*TFcStrBuf)(unsafe.Pointer(buf)).Fsize = size
	} else {
		(*TFcStrBuf)(unsafe.Pointer(buf)).Fbuf = buf + 24
		(*TFcStrBuf)(unsafe.Pointer(buf)).Fsize = int32(128)
	}
	(*TFcStrBuf)(unsafe.Pointer(buf)).Fallocated = m_FcFalse
	(*TFcStrBuf)(unsafe.Pointer(buf)).Ffailed = m_FcFalse
	(*TFcStrBuf)(unsafe.Pointer(buf)).Flen1 = 0
}

func XFcStrBufDestroy(tls *libc.TLS, buf uintptr) {
	if (*TFcStrBuf)(unsafe.Pointer(buf)).Fallocated != 0 {
		libc.Xfree(tls, (*TFcStrBuf)(unsafe.Pointer(buf)).Fbuf)
		XFcStrBufInit(tls, buf, uintptr(0), 0)
	}
}

func XFcStrBufDone(tls *libc.TLS, buf uintptr) (r uintptr) {
	var ret uintptr
	_ = ret
	if (*TFcStrBuf)(unsafe.Pointer(buf)).Ffailed != 0 {
		ret = libc.UintptrFromInt32(0)
	} else {
		ret = libc.Xmalloc(tls, libc.Uint64FromInt32((*TFcStrBuf)(unsafe.Pointer(buf)).Flen1+int32(1)))
	}
	if ret != 0 {
		libc.X__builtin___memcpy_chk(tls, ret, (*TFcStrBuf)(unsafe.Pointer(buf)).Fbuf, libc.Uint64FromInt32((*TFcStrBuf)(unsafe.Pointer(buf)).Flen1), ^t__predefined_size_t(0))
		*(*TFcChar8)(unsafe.Pointer(ret + uintptr((*TFcStrBuf)(unsafe.Pointer(buf)).Flen1))) = uint8('\000')
	}
	XFcStrBufDestroy(tls, buf)
	return ret
}

func XFcStrBufDoneStatic(tls *libc.TLS, buf uintptr) (r uintptr) {
	XFcStrBufChar(tls, buf, uint8('\000'))
	if (*TFcStrBuf)(unsafe.Pointer(buf)).Ffailed != 0 {
		return libc.UintptrFromInt32(0)
	}
	return (*TFcStrBuf)(unsafe.Pointer(buf)).Fbuf
}

func XFcStrBufChar(tls *libc.TLS, buf uintptr, c TFcChar8) (r TFcBool) {
	var new1, v2 uintptr
	var size, v1 int32
	_, _, _, _ = new1, size, v1, v2
	if (*TFcStrBuf)(unsafe.Pointer(buf)).Flen1 == (*TFcStrBuf)(unsafe.Pointer(buf)).Fsize {
		if (*TFcStrBuf)(unsafe.Pointer(buf)).Ffailed != 0 {
			return m_FcFalse
		}
		if (*TFcStrBuf)(unsafe.Pointer(buf)).Fallocated != 0 {
			size = (*TFcStrBuf)(unsafe.Pointer(buf)).Fsize * int32(2)
			new1 = libc.Xrealloc(tls, (*TFcStrBuf)(unsafe.Pointer(buf)).Fbuf, libc.Uint64FromInt32(size))
		} else {
			size = (*TFcStrBuf)(unsafe.Pointer(buf)).Fsize + int32(64)
			new1 = libc.Xmalloc(tls, libc.Uint64FromInt32(size))
			if new1 != 0 {
				(*TFcStrBuf)(unsafe.Pointer(buf)).Fallocated = int32(m_FcTrue)
				libc.X__builtin___memcpy_chk(tls, new1, (*TFcStrBuf)(unsafe.Pointer(buf)).Fbuf, libc.Uint64FromInt32((*TFcStrBuf)(unsafe.Pointer(buf)).Flen1), ^t__predefined_size_t(0))
			}
		}
		if !(new1 != 0) {
			(*TFcStrBuf)(unsafe.Pointer(buf)).Ffailed = int32(m_FcTrue)
			return m_FcFalse
		}
		(*TFcStrBuf)(unsafe.Pointer(buf)).Fsize = size
		(*TFcStrBuf)(unsafe.Pointer(buf)).Fbuf = new1
	}
	v2 = buf + 16
	v1 = *(*int32)(unsafe.Pointer(v2))
	*(*int32)(unsafe.Pointer(v2))++
	*(*TFcChar8)(unsafe.Pointer((*TFcStrBuf)(unsafe.Pointer(buf)).Fbuf + uintptr(v1))) = c
	return int32(m_FcTrue)
}

func XFcStrBufString(tls *libc.TLS, buf uintptr, s uintptr) (r TFcBool) {
	var c, v1 TFcChar8
	var v2 uintptr
	_, _, _ = c, v1, v2
	for {
		v2 = s
		s++
		v1 = *(*TFcChar8)(unsafe.Pointer(v2))
		c = v1
		if !(v1 != 0) {
			break
		}
		if !(XFcStrBufChar(tls, buf, c) != 0) {
			return m_FcFalse
		}
	}
	return int32(m_FcTrue)
}

func XFcStrBufData(tls *libc.TLS, buf uintptr, s uintptr, len1 int32) (r TFcBool) {
	var v1 int32
	var v2 uintptr
	_, _ = v1, v2
	for {
		v1 = len1
		len1--
		if !(v1 > 0) {
			break
		}
		v2 = s
		s++
		if !(XFcStrBufChar(tls, buf, *(*TFcChar8)(unsafe.Pointer(v2))) != 0) {
			return m_FcFalse
		}
	}
	return int32(m_FcTrue)
}

func XFcStrUsesHome(tls *libc.TLS, s uintptr) (r TFcBool) {
	return libc.BoolInt32(libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s))) == int32('~'))
}

func XFcStrIsAbsoluteFilename(tls *libc.TLS, s uintptr) (r TFcBool) {
	return libc.BoolInt32(libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s))) == int32('/'))
}

func XFcStrBuildFilename(tls *libc.TLS, path uintptr, va uintptr) (r uintptr) {
	var ap Tva_list
	var len1 Tsize_t
	var list, p, ret, s, sset, v1, v2 uintptr
	_, _, _, _, _, _, _, _, _ = ap, len1, list, p, ret, s, sset, v1, v2
	ret = libc.UintptrFromInt32(0)
	len1 = uint64(0)
	if !(path != 0) {
		return libc.UintptrFromInt32(0)
	}
	sset = XFcStrSetCreateEx(tls, libc.Uint32FromInt32(libc.Int32FromInt32(m_FCSS_ALLOW_DUPLICATES)|libc.Int32FromInt32(m_FCSS_GROW_BY_64)))
	if !(sset != 0) {
		return libc.UintptrFromInt32(0)
	}
	if !(XFcStrSetAdd(tls, sset, path) != 0) {
		goto bail0
	}
	ap = va
	for int32(1) != 0 {
		s = libc.VaUintptr(&ap)
		if !(s != 0) {
			break
		}
		if !(XFcStrSetAdd(tls, sset, s) != 0) {
			goto bail1
		}
	}
	list = XFcStrListCreate(tls, sset)
	for {
		v1 = XFcStrListNext(tls, list)
		s = v1
		if !(v1 != 0) {
			break
		}
		len1 += libc.Xstrlen(tls, s) + uint64(1)
	}
	(*TFcStrList)(unsafe.Pointer(list)).Fn = 0
	ret = libc.Xmalloc(tls, uint64(1)*(len1+uint64(1)))
	if !(ret != 0) {
		goto bail2
	}
	p = ret
	for {
		v2 = XFcStrListNext(tls, list)
		s = v2
		if !(v2 != 0) {
			break
		}
		if p != ret {
			*(*TFcChar8)(unsafe.Pointer(p)) = uint8('/')
			p++
		}
		len1 = libc.Xstrlen(tls, s)
		libc.X__builtin___memcpy_chk(tls, p, s, len1, ^t__predefined_size_t(0))
		p += uintptr(len1)
	}
	*(*TFcChar8)(unsafe.Pointer(p)) = uint8(0)
	goto bail2
bail2:
	;
	XFcStrListDone(tls, list)
	goto bail1
bail1:
	;
	_ = ap
	goto bail0
bail0:
	;
	XFcStrSetDestroy(tls, sset)
	return ret
}

func XFcStrCopyFilename(tls *libc.TLS, s uintptr) (r uintptr) {
	var full, home, new1 uintptr
	var size int32
	_, _, _, _ = full, home, new1, size
	if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s))) == int32('~') {
		home = XFcConfigHome(tls)
		if !(home != 0) {
			return libc.UintptrFromInt32(0)
		}
		size = libc.Int32FromUint64(libc.Xstrlen(tls, home) + libc.Xstrlen(tls, s))
		full = libc.Xmalloc(tls, libc.Uint64FromInt32(size+int32(1)))
		if !(full != 0) {
			return libc.UintptrFromInt32(0)
		}
		libc.X__builtin___strcpy_chk(tls, full, home, ^t__predefined_size_t(0))
		libc.X__builtin___strcat_chk(tls, full, s+uintptr(1), ^t__predefined_size_t(0))
		new1 = XFcStrCanonFilename(tls, full)
		libc.Xfree(tls, full)
	} else {
		new1 = XFcStrCanonFilename(tls, s)
	}
	return new1
}

func XFcStrLastSlash(tls *libc.TLS, path uintptr) (r uintptr) {
	var slash uintptr
	_ = slash
	slash = libc.Xstrrchr(tls, path, int32('/'))
	return slash
}

func XFcStrDirname(tls *libc.TLS, file uintptr) (r uintptr) {
	var dir, slash uintptr
	_, _ = dir, slash
	slash = XFcStrLastSlash(tls, file)
	if !(slash != 0) {
		return XFcStrCopy(tls, __ccgo_ts+6984)
	}
	dir = libc.Xmalloc(tls, libc.Uint64FromInt64(int64(slash)-int64(file)+int64(1)))
	if !(dir != 0) {
		return uintptr(0)
	}
	libc.X__builtin___strncpy_chk(tls, dir, file, libc.Uint64FromInt64(int64(slash)-int64(file)), ^t__predefined_size_t(0))
	*(*TFcChar8)(unsafe.Pointer(dir + uintptr(int64(slash)-int64(file)))) = uint8('\000')
	return dir
}

func XFcStrBasename(tls *libc.TLS, file uintptr) (r uintptr) {
	var slash uintptr
	_ = slash
	slash = XFcStrLastSlash(tls, file)
	if !(slash != 0) {
		return XFcStrCopy(tls, file)
	}
	return XFcStrCopy(tls, slash+uintptr(1))
}

func XFcStrRealPath(tls *libc.TLS, path uintptr) (r uintptr) {
	bp := tls.Alloc(1040)
	defer tls.Free(1040)
	var resolved_ret uintptr
	var _ /* resolved_name at bp+0 */ [1025]int8
	_ = resolved_ret
	if !(path != 0) {
		return libc.UintptrFromInt32(0)
	}
	resolved_ret = libc.Xrealpath(tls, path, bp)
	if resolved_ret != 0 {
		path = resolved_ret
	}
	return XFcStrCopyFilename(tls, path)
}

func _FcStrCanonAbsoluteFilename(tls *libc.TLS, s uintptr) (r uintptr) {
	var f, file, slash, v2, v4, v5 uintptr
	var size int32
	var v3 TFcChar8
	_, _, _, _, _, _, _, _ = f, file, size, slash, v2, v3, v4, v5
	size = libc.Int32FromUint64(libc.Xstrlen(tls, s) + uint64(1))
	file = libc.Xmalloc(tls, libc.Uint64FromInt32(size))
	if !(file != 0) {
		return libc.UintptrFromInt32(0)
	}
	slash = libc.UintptrFromInt32(0)
	f = file
	for {
		if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s))) == int32('/') || libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s))) == int32('\000') {
			if slash != 0 {
				switch int64(s) - int64(slash) {
				case int64(1):
					f -= uintptr(1) /* squash // and trim final / from file */
				case int64(2):
					if !(libc.Xstrncmp(tls, slash, __ccgo_ts+6986, uint64(2)) != 0) {
						f -= uintptr(2) /* trim /. from file */
					}
				case int64(3):
					if !(libc.Xstrncmp(tls, slash, __ccgo_ts+6989, uint64(3)) != 0) {
						f -= uintptr(3) /* trim /.. from file */
						for f > file {
							f--
							v2 = f
							if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(v2))) == int32('/') {
								break
							}
						}
					}
					break
				}
			}
			slash = s
		}
		v4 = s
		s++
		v3 = *(*TFcChar8)(unsafe.Pointer(v4))
		v5 = f
		f++
		*(*TFcChar8)(unsafe.Pointer(v5)) = v3
		if !(v3 != 0) {
			break
		}
		goto _1
	_1:
	}
	return file
}

func XFcStrCanonFilename(tls *libc.TLS, s uintptr) (r uintptr) {
	bp := tls.Alloc(4128)
	defer tls.Free(4128)
	var file, full uintptr
	var _ /* cwd at bp+0 */ [4098]TFcChar8
	_, _ = file, full
	if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(s))) == int32('/') {
		return _FcStrCanonAbsoluteFilename(tls, s)
	} else {
		if libc.Xgetcwd(tls, bp, uint64(m_FC_MAX_FILE_LEN)) == libc.UintptrFromInt32(0) {
			return libc.UintptrFromInt32(0)
		}
		full = XFcStrBuildFilename(tls, bp, libc.VaList(bp+4112, s, libc.UintptrFromInt32(0)))
		file = _FcStrCanonAbsoluteFilename(tls, full)
		XFcStrFree(tls, full)
		return file
	}
	return r
}

func XFcStrSetCreate(tls *libc.TLS) (r uintptr) {
	return XFcStrSetCreateEx(tls, uint32(m_FCSS_DEFAULT))
}

func XFcStrSetCreateEx(tls *libc.TLS, control uint32) (r uintptr) {
	var set uintptr
	_ = set
	set = libc.Xmalloc(tls, uint64(32))
	if !(set != 0) {
		return uintptr(0)
	}
	(*TFcRef)(unsafe.Pointer(set)).Fcount = int32(1)
	(*TFcStrSet)(unsafe.Pointer(set)).Fnum = 0
	(*TFcStrSet)(unsafe.Pointer(set)).Fsize = 0
	(*TFcStrSet)(unsafe.Pointer(set)).Fstrs = uintptr(0)
	(*TFcStrSet)(unsafe.Pointer(set)).Fcontrol = control
	return set
}

func __FcStrSetGrow(tls *libc.TLS, set uintptr, growElements int32) (r TFcBool) {
	var strs uintptr
	_ = strs
	/* accommodate an additional NULL entry at the end of the array */
	strs = libc.Xmalloc(tls, libc.Uint64FromInt32((*TFcStrSet)(unsafe.Pointer(set)).Fsize+growElements+libc.Int32FromInt32(1))*uint64(8))
	if !(strs != 0) {
		return m_FcFalse
	}
	if (*TFcStrSet)(unsafe.Pointer(set)).Fnum != 0 {
		libc.X__builtin___memcpy_chk(tls, strs, (*TFcStrSet)(unsafe.Pointer(set)).Fstrs, libc.Uint64FromInt32((*TFcStrSet)(unsafe.Pointer(set)).Fnum)*uint64(8), ^t__predefined_size_t(0))
	}
	if (*TFcStrSet)(unsafe.Pointer(set)).Fstrs != 0 {
		libc.Xfree(tls, (*TFcStrSet)(unsafe.Pointer(set)).Fstrs)
	}
	(*TFcStrSet)(unsafe.Pointer(set)).Fsize = (*TFcStrSet)(unsafe.Pointer(set)).Fsize + growElements
	(*TFcStrSet)(unsafe.Pointer(set)).Fstrs = strs
	return int32(m_FcTrue)
}

func __FcStrSetInsert(tls *libc.TLS, set uintptr, s uintptr, pos int32) (r TFcBool) {
	var growElements, i, v1, v2 int32
	var v3 uintptr
	_, _, _, _, _ = growElements, i, v1, v2, v3
	if !((*TFcStrSet)(unsafe.Pointer(set)).Fcontrol&libc.Uint32FromInt32(m_FCSS_ALLOW_DUPLICATES) != 0) {
		if XFcStrSetMember(tls, set, s) != 0 {
			XFcStrFree(tls, s)
			return int32(m_FcTrue)
		}
	}
	if (*TFcStrSet)(unsafe.Pointer(set)).Fnum == (*TFcStrSet)(unsafe.Pointer(set)).Fsize {
		if (*TFcStrSet)(unsafe.Pointer(set)).Fcontrol&uint32(m_FCSS_GROW_BY_64) != 0 {
			v1 = int32(64)
		} else {
			v1 = int32(1)
		}
		growElements = v1
		if !(__FcStrSetGrow(tls, set, growElements) != 0) {
			return m_FcFalse
		}
	}
	if pos >= (*TFcStrSet)(unsafe.Pointer(set)).Fnum {
		v3 = set + 4
		v2 = *(*int32)(unsafe.Pointer(v3))
		*(*int32)(unsafe.Pointer(v3))++
		*(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(set)).Fstrs + uintptr(v2)*8)) = s
		*(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(set)).Fstrs + uintptr((*TFcStrSet)(unsafe.Pointer(set)).Fnum)*8)) = uintptr(0)
	} else {
		(*TFcStrSet)(unsafe.Pointer(set)).Fnum++
		*(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(set)).Fstrs + uintptr((*TFcStrSet)(unsafe.Pointer(set)).Fnum)*8)) = uintptr(0)
		i = (*TFcStrSet)(unsafe.Pointer(set)).Fnum - int32(1)
		for {
			if !(i > pos) {
				break
			}
			*(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(set)).Fstrs + uintptr(i)*8)) = *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(set)).Fstrs + uintptr(i-int32(1))*8))
			goto _4
		_4:
			;
			i--
		}
		*(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(set)).Fstrs + uintptr(pos)*8)) = s
	}
	return int32(m_FcTrue)
}

func XFcStrSetMember(tls *libc.TLS, set uintptr, s uintptr) (r TFcBool) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < (*TFcStrSet)(unsafe.Pointer(set)).Fnum) {
			break
		}
		if !(XFcStrCmp(tls, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(set)).Fstrs + uintptr(i)*8)), s) != 0) {
			return int32(m_FcTrue)
		}
		goto _1
	_1:
		;
		i++
	}
	return m_FcFalse
}

func _fc_strcmp_r(tls *libc.TLS, s1 uintptr, s2 uintptr, ret uintptr) (r int32) {
	var c1, c2 TFcChar8
	var v2, v3 uintptr
	_, _, _, _ = c1, c2, v2, v3
	if s1 == s2 {
		if ret != 0 {
			*(*uintptr)(unsafe.Pointer(ret)) = libc.UintptrFromInt32(0)
		}
		return 0
	}
	for {
		if s1 != 0 {
			v2 = s1
			s1++
			c1 = *(*TFcChar8)(unsafe.Pointer(v2))
		} else {
			c1 = uint8(0)
		}
		if s2 != 0 {
			v3 = s2
			s2++
			c2 = *(*TFcChar8)(unsafe.Pointer(v3))
		} else {
			c2 = uint8(0)
		}
		if !(c1 != 0) || libc.Int32FromUint8(c1) != libc.Int32FromUint8(c2) {
			break
		}
		goto _1
	_1:
	}
	if ret != 0 {
		*(*uintptr)(unsafe.Pointer(ret)) = s1
	}
	return libc.Int32FromUint8(c1) - libc.Int32FromUint8(c2)
}

func XFcStrSetMemberAB(tls *libc.TLS, set uintptr, a uintptr, b uintptr, ret uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i int32
	var _ /* s at bp+0 */ uintptr
	_ = i
	*(*uintptr)(unsafe.Pointer(bp)) = libc.UintptrFromInt32(0)
	i = 0
	for {
		if !(i < (*TFcStrSet)(unsafe.Pointer(set)).Fnum) {
			break
		}
		if !(_fc_strcmp_r(tls, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(set)).Fstrs + uintptr(i)*8)), a, bp) != 0) && *(*uintptr)(unsafe.Pointer(bp)) != 0 {
			if !(_fc_strcmp_r(tls, *(*uintptr)(unsafe.Pointer(bp)), b, libc.UintptrFromInt32(0)) != 0) {
				if ret != 0 {
					*(*uintptr)(unsafe.Pointer(ret)) = *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(set)).Fstrs + uintptr(i)*8))
				}
				return int32(m_FcTrue)
			}
		}
		goto _1
	_1:
		;
		i++
	}
	if ret != 0 {
		*(*uintptr)(unsafe.Pointer(ret)) = libc.UintptrFromInt32(0)
	}
	return m_FcFalse
}

func XFcStrSetEqual(tls *libc.TLS, sa uintptr, sb uintptr) (r TFcBool) {
	var i int32
	_ = i
	if (*TFcStrSet)(unsafe.Pointer(sa)).Fnum != (*TFcStrSet)(unsafe.Pointer(sb)).Fnum {
		return m_FcFalse
	}
	i = 0
	for {
		if !(i < (*TFcStrSet)(unsafe.Pointer(sa)).Fnum) {
			break
		}
		if !(XFcStrSetMember(tls, sb, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(sa)).Fstrs + uintptr(i)*8))) != 0) {
			return m_FcFalse
		}
		goto _1
	_1:
		;
		i++
	}
	return int32(m_FcTrue)
}

func XFcStrSetAdd(tls *libc.TLS, set uintptr, s uintptr) (r TFcBool) {
	var new1 uintptr
	_ = new1
	new1 = XFcStrCopy(tls, s)
	if !(new1 != 0) {
		return m_FcFalse
	}
	if !(__FcStrSetInsert(tls, set, new1, (*TFcStrSet)(unsafe.Pointer(set)).Fnum) != 0) {
		XFcStrFree(tls, new1)
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

func XFcStrSetInsert(tls *libc.TLS, set uintptr, s uintptr, pos int32) (r TFcBool) {
	var new1 uintptr
	_ = new1
	new1 = XFcStrCopy(tls, s)
	if !(new1 != 0) {
		return m_FcFalse
	}
	if !(__FcStrSetInsert(tls, set, new1, pos) != 0) {
		XFcStrFree(tls, new1)
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

func XFcStrSetAddTriple(tls *libc.TLS, set uintptr, a uintptr, b uintptr, c uintptr) (r TFcBool) {
	var new1 uintptr
	_ = new1
	new1 = _FcStrMakeTriple(tls, a, b, c)
	if !(new1 != 0) {
		return m_FcFalse
	}
	if !(__FcStrSetInsert(tls, set, new1, (*TFcStrSet)(unsafe.Pointer(set)).Fnum) != 0) {
		XFcStrFree(tls, new1)
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

func XFcStrTripleSecond(tls *libc.TLS, str uintptr) (r uintptr) {
	var second uintptr
	_ = second
	second = str + uintptr(libc.Xstrlen(tls, str)) + uintptr(1)
	if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(second))) == int32('\000') {
		return uintptr(0)
	}
	return second
}

func XFcStrTripleThird(tls *libc.TLS, str uintptr) (r uintptr) {
	var second, third uintptr
	_, _ = second, third
	second = str + uintptr(libc.Xstrlen(tls, str)) + uintptr(1)
	third = second + uintptr(libc.Xstrlen(tls, second)) + uintptr(1)
	if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(third))) == int32('\000') {
		return uintptr(0)
	}
	return third
}

func XFcStrSetAddFilename(tls *libc.TLS, set uintptr, s uintptr) (r TFcBool) {
	var new1 uintptr
	_ = new1
	new1 = XFcStrCopyFilename(tls, s)
	if !(new1 != 0) {
		return m_FcFalse
	}
	if !(__FcStrSetInsert(tls, set, new1, (*TFcStrSet)(unsafe.Pointer(set)).Fnum) != 0) {
		XFcStrFree(tls, new1)
		return m_FcFalse
	}
	return int32(m_FcTrue)
}

func XFcStrSetAddFilenamePairWithSalt(tls *libc.TLS, set uintptr, a uintptr, b uintptr, salt uintptr) (r TFcBool) {
	var new_a, new_b uintptr
	var ret TFcBool
	_, _, _ = new_a, new_b, ret
	new_a = libc.UintptrFromInt32(0)
	new_b = libc.UintptrFromInt32(0)
	if a != 0 {
		new_a = XFcStrCopyFilename(tls, a)
		if !(new_a != 0) {
			return m_FcFalse
		}
	}
	if b != 0 {
		new_b = XFcStrCopyFilename(tls, b)
		if !(new_b != 0) {
			if new_a != 0 {
				XFcStrFree(tls, new_a)
			}
			return m_FcFalse
		}
	}
	/* Override maps with new one if exists */
	XFcStrSetDel(tls, set, new_a)
	ret = XFcStrSetAddTriple(tls, set, new_a, new_b, salt)
	if new_a != 0 {
		XFcStrFree(tls, new_a)
	}
	if new_b != 0 {
		XFcStrFree(tls, new_b)
	}
	return ret
}

func XFcStrSetAddLangs(tls *libc.TLS, strs uintptr, languages uintptr) (r TFcBool) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var len1 Tsize_t
	var next, normalized_lang, p, v1 uintptr
	var ret TFcBool
	var v2 uint64
	var _ /* lang at bp+0 */ [128]TFcChar8
	_, _, _, _, _, _, _ = len1, next, normalized_lang, p, ret, v1, v2
	p = languages
	*(*[128]TFcChar8)(unsafe.Pointer(bp)) = [128]TFcChar8{}
	ret = m_FcFalse
	if !(languages != 0) {
		return m_FcFalse
	}
	for {
		v1 = libc.Xstrchr(tls, p, int32(':'))
		next = v1
		if !(v1 != 0) {
			break
		}
		len1 = libc.Uint64FromInt64(int64(next) - int64(p))
		if len1 < libc.Uint64FromInt32(libc.Int32FromInt32(127)) {
			v2 = len1
		} else {
			v2 = libc.Uint64FromInt32(libc.Int32FromInt32(127))
		}
		len1 = v2
		libc.X__builtin___strncpy_chk(tls, bp, p, len1, ^t__predefined_size_t(0))
		(*(*[128]TFcChar8)(unsafe.Pointer(bp)))[len1] = uint8(0)
		/* ignore an empty item */
		if *(*TFcChar8)(unsafe.Pointer(bp)) != 0 {
			normalized_lang = XFcLangNormalize(tls, bp)
			if normalized_lang != 0 {
				XFcStrSetAdd(tls, strs, normalized_lang)
				XFcStrFree(tls, normalized_lang)
				ret = int32(m_FcTrue)
			}
		}
		p = next + uintptr(1)
	}
	if *(*int8)(unsafe.Pointer(p)) != 0 {
		normalized_lang = XFcLangNormalize(tls, p)
		if normalized_lang != 0 {
			XFcStrSetAdd(tls, strs, normalized_lang)
			XFcStrFree(tls, normalized_lang)
			ret = int32(m_FcTrue)
		}
	}
	return ret
}

func XFcStrSetDel(tls *libc.TLS, set uintptr, s uintptr) (r TFcBool) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < (*TFcStrSet)(unsafe.Pointer(set)).Fnum) {
			break
		}
		if !(XFcStrCmp(tls, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(set)).Fstrs + uintptr(i)*8)), s) != 0) {
			XFcStrFree(tls, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(set)).Fstrs + uintptr(i)*8)))
			/*
			 * copy remaining string pointers and trailing
			 * NULL
			 */
			libc.X__builtin___memmove_chk(tls, (*TFcStrSet)(unsafe.Pointer(set)).Fstrs+uintptr(i)*8, (*TFcStrSet)(unsafe.Pointer(set)).Fstrs+uintptr(i+int32(1))*8, libc.Uint64FromInt32((*TFcStrSet)(unsafe.Pointer(set)).Fnum-i)*uint64(8), ^t__predefined_size_t(0))
			(*TFcStrSet)(unsafe.Pointer(set)).Fnum--
			return int32(m_FcTrue)
		}
		goto _1
	_1:
		;
		i++
	}
	return m_FcFalse
}

func XFcStrSetDeleteAll(tls *libc.TLS, set uintptr) (r TFcBool) {
	var i int32
	var v1 TFcBool
	_, _ = i, v1
	v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(set)).Fcount == -libc.Int32FromInt32(1))
	goto _2
_2:
	if v1 != 0 {
		return m_FcFalse
	}
	i = (*TFcStrSet)(unsafe.Pointer(set)).Fnum
	for {
		if !(i > 0) {
			break
		}
		XFcStrFree(tls, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(set)).Fstrs + uintptr(i-int32(1))*8)))
		(*TFcStrSet)(unsafe.Pointer(set)).Fnum--
		goto _3
	_3:
		;
		i--
	}
	return int32(m_FcTrue)
}

// C documentation
//
//	/* TODO Make public */
func _FcStrSetReference(tls *libc.TLS, set uintptr) (r uintptr) {
	var v1 TFcBool
	var p4 uintptr
	_, _ = v1, p4
	v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(set)).Fcount == -libc.Int32FromInt32(1))
	goto _2
_2:
	if v1 != 0 {
		return set
	}
	p4 = set
	*(*Tfc_atomic_int_t)(unsafe.Pointer(p4)) += +libc.Int32FromInt32(1)
	_ = *(*Tfc_atomic_int_t)(unsafe.Pointer(p4)) - +libc.Int32FromInt32(1)
	goto _3
_3:
	;
	return set
}

func XFcStrSetDestroy(tls *libc.TLS, set uintptr) {
	var i, v3 int32
	var v1 TFcBool
	var p5 uintptr
	_, _, _, _ = i, v1, v3, p5
	/* We rely on this in FcGetDefaultLangs for caching. */
	v1 = libc.BoolInt32((*TFcRef)(unsafe.Pointer(set)).Fcount == -libc.Int32FromInt32(1))
	goto _2
_2:
	if v1 != 0 {
		return
	}
	p5 = set
	*(*Tfc_atomic_int_t)(unsafe.Pointer(p5)) += -int32(1)
	v3 = *(*Tfc_atomic_int_t)(unsafe.Pointer(p5)) - -int32(1)
	goto _4
_4:
	if v3 != int32(1) {
		return
	}
	i = 0
	for {
		if !(i < (*TFcStrSet)(unsafe.Pointer(set)).Fnum) {
			break
		}
		XFcStrFree(tls, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(set)).Fstrs + uintptr(i)*8)))
		goto _6
	_6:
		;
		i++
	}
	if (*TFcStrSet)(unsafe.Pointer(set)).Fstrs != 0 {
		libc.Xfree(tls, (*TFcStrSet)(unsafe.Pointer(set)).Fstrs)
	}
	libc.Xfree(tls, set)
}

func XFcStrListCreate(tls *libc.TLS, set uintptr) (r uintptr) {
	var list uintptr
	_ = list
	list = libc.Xmalloc(tls, uint64(16))
	if !(list != 0) {
		return uintptr(0)
	}
	(*TFcStrList)(unsafe.Pointer(list)).Fset = set
	_FcStrSetReference(tls, set)
	(*TFcStrList)(unsafe.Pointer(list)).Fn = 0
	return list
}

func XFcStrListFirst(tls *libc.TLS, list uintptr) {
	(*TFcStrList)(unsafe.Pointer(list)).Fn = 0
}

func XFcStrListNext(tls *libc.TLS, list uintptr) (r uintptr) {
	var v1 int32
	var v2 uintptr
	_, _ = v1, v2
	if (*TFcStrList)(unsafe.Pointer(list)).Fn >= (*TFcStrSet)(unsafe.Pointer((*TFcStrList)(unsafe.Pointer(list)).Fset)).Fnum {
		return uintptr(0)
	}
	v2 = list + 8
	v1 = *(*int32)(unsafe.Pointer(v2))
	*(*int32)(unsafe.Pointer(v2))++
	return *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer((*TFcStrList)(unsafe.Pointer(list)).Fset)).Fstrs + uintptr(v1)*8))
}

func XFcStrListDone(tls *libc.TLS, list uintptr) {
	XFcStrSetDestroy(tls, (*TFcStrList)(unsafe.Pointer(list)).Fset)
	libc.Xfree(tls, list)
}

const m_FC_DIR_SEPARATOR4 = '/'

var _map = [13]struct {
	Fot int32
	Ffc int32
}{
	0: {},
	1: {
		Fot: int32(100),
	},
	2: {
		Fot: int32(200),
		Ffc: int32(m_FC_WEIGHT_EXTRALIGHT),
	},
	3: {
		Fot: int32(300),
		Ffc: int32(m_FC_WEIGHT_LIGHT),
	},
	4: {
		Fot: int32(350),
		Ffc: int32(m_FC_WEIGHT_DEMILIGHT),
	},
	5: {
		Fot: int32(380),
		Ffc: int32(m_FC_WEIGHT_BOOK),
	},
	6: {
		Fot: int32(400),
		Ffc: int32(m_FC_WEIGHT_REGULAR),
	},
	7: {
		Fot: int32(500),
		Ffc: int32(m_FC_WEIGHT_MEDIUM),
	},
	8: {
		Fot: int32(600),
		Ffc: int32(m_FC_WEIGHT_DEMIBOLD),
	},
	9: {
		Fot: int32(700),
		Ffc: int32(m_FC_WEIGHT_BOLD),
	},
	10: {
		Fot: int32(800),
		Ffc: int32(m_FC_WEIGHT_EXTRABOLD),
	},
	11: {
		Fot: int32(900),
		Ffc: int32(m_FC_WEIGHT_BLACK),
	},
	12: {
		Fot: int32(1000),
		Ffc: int32(m_FC_WEIGHT_EXTRABLACK),
	},
}

func _lerp(tls *libc.TLS, x float64, x1 int32, x2 int32, y1 int32, y2 int32) (r float64) {
	var dx, dy int32
	_, _ = dx, dy
	dx = x2 - x1
	dy = y2 - y1
	return float64(y1) + float64((x-float64(x1))*float64(dy))/float64(dx)
}

func XFcWeightFromOpenTypeDouble(tls *libc.TLS, ot_weight float64) (r float64) {
	var i int32
	var v1 float64
	_, _ = i, v1
	if ot_weight < libc.Float64FromInt32(0) {
		return float64(-libc.Int32FromInt32(1))
	}
	if ot_weight < float64(_map[libc.Uint64FromInt64(104)/libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1)].Fot) {
		v1 = ot_weight
	} else {
		v1 = float64(_map[libc.Uint64FromInt64(104)/libc.Uint64FromInt64(8)-libc.Uint64FromInt32(1)].Fot)
	}
	ot_weight = v1
	i = int32(1)
	for {
		if !(ot_weight > float64(_map[i].Fot)) {
			break
		}
		goto _2
	_2:
		;
		i++
	}
	if ot_weight == float64(_map[i].Fot) {
		return float64(_map[i].Ffc)
	}
	/* Interpolate between two items. */
	return _lerp(tls, ot_weight, _map[i-int32(1)].Fot, _map[i].Fot, _map[i-int32(1)].Ffc, _map[i].Ffc)
}

func XFcWeightToOpenTypeDouble(tls *libc.TLS, fc_weight float64) (r float64) {
	var i int32
	_ = i
	if fc_weight < libc.Float64FromInt32(0) || fc_weight > libc.Float64FromInt32(m_FC_WEIGHT_EXTRABLACK) {
		return float64(-libc.Int32FromInt32(1))
	}
	i = int32(1)
	for {
		if !(fc_weight > float64(_map[i].Ffc)) {
			break
		}
		goto _1
	_1:
		;
		i++
	}
	if fc_weight == float64(_map[i].Ffc) {
		return float64(_map[i].Fot)
	}
	/* Interpolate between two items. */
	return _lerp(tls, fc_weight, _map[i-int32(1)].Ffc, _map[i].Ffc, _map[i-int32(1)].Fot, _map[i].Fot)
}

func XFcWeightFromOpenType(tls *libc.TLS, ot_weight int32) (r int32) {
	return int32(XFcWeightFromOpenTypeDouble(tls, float64(ot_weight)) + float64(0.5))
}

func XFcWeightToOpenType(tls *libc.TLS, fc_weight int32) (r int32) {
	return int32(XFcWeightToOpenTypeDouble(tls, float64(fc_weight)) + float64(0.5))
}

const m_API_TO_BE_DEPRECATED = 100000
const m_API_TO_BE_DEPRECATED_DRIVERKIT = 100000
const m_API_TO_BE_DEPRECATED_IOS = 100000
const m_API_TO_BE_DEPRECATED_MACOS = 100000
const m_API_TO_BE_DEPRECATED_TVOS = 100000
const m_API_TO_BE_DEPRECATED_VISIONOS = 100000
const m_API_TO_BE_DEPRECATED_WATCHOS = 100000
const m_Expat_External_INCLUDED = 1
const m_Expat_INCLUDED = 1
const m_FC_DIR_SEPARATOR5 = 47
const m_HAVE_XMLPARSE_H = 0
const m_LC_ALL = 0
const m_LC_COLLATE = 1
const m_LC_CTYPE = 2
const m_LC_MESSAGES = 6
const m_LC_MONETARY = 3
const m_LC_NUMERIC = 4
const m_LC_TIME = 5
const m_TAIL = ".conf"
const m_TAIL_LEN = 5
const m_XML_ENABLE_VISIBILITY = 0
const m_XML_GetErrorByteIndex = "XML_GetCurrentByteIndex"
const m_XML_GetErrorColumnNumber = "XML_GetCurrentColumnNumber"
const m_XML_GetErrorLineNumber = "XML_GetCurrentLineNumber"
const m_XML_MAJOR_VERSION = 2
const m_XML_MICRO_VERSION = 1
const m_XML_MINOR_VERSION = 7
const m__LC_LAST = 7
const m__LC_NUM_MASK = 6

type TXML_Char = int8

type TXML_LChar = int8

type TXML_Index = int64

type TXML_Size = uint64

type TXML_Parser = uintptr

type TXML_Bool = uint8

type _XML_Status = int32

const _XML_STATUS_ERROR = 0
const _XML_STATUS_OK = 1
const _XML_STATUS_SUSPENDED = 2

type _XML_Error = int32

const _XML_ERROR_NONE = 0
const _XML_ERROR_NO_MEMORY = 1
const _XML_ERROR_SYNTAX = 2
const _XML_ERROR_NO_ELEMENTS = 3
const _XML_ERROR_INVALID_TOKEN = 4
const _XML_ERROR_UNCLOSED_TOKEN = 5
const _XML_ERROR_PARTIAL_CHAR = 6
const _XML_ERROR_TAG_MISMATCH = 7
const _XML_ERROR_DUPLICATE_ATTRIBUTE = 8
const _XML_ERROR_JUNK_AFTER_DOC_ELEMENT = 9
const _XML_ERROR_PARAM_ENTITY_REF = 10
const _XML_ERROR_UNDEFINED_ENTITY = 11
const _XML_ERROR_RECURSIVE_ENTITY_REF = 12
const _XML_ERROR_ASYNC_ENTITY = 13
const _XML_ERROR_BAD_CHAR_REF = 14
const _XML_ERROR_BINARY_ENTITY_REF = 15
const _XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF = 16
const _XML_ERROR_MISPLACED_XML_PI = 17
const _XML_ERROR_UNKNOWN_ENCODING = 18
const _XML_ERROR_INCORRECT_ENCODING = 19
const _XML_ERROR_UNCLOSED_CDATA_SECTION = 20
const _XML_ERROR_EXTERNAL_ENTITY_HANDLING = 21
const _XML_ERROR_NOT_STANDALONE = 22
const _XML_ERROR_UNEXPECTED_STATE = 23
const _XML_ERROR_ENTITY_DECLARED_IN_PE = 24
const _XML_ERROR_FEATURE_REQUIRES_XML_DTD = 25
const _XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING = 26
const _XML_ERROR_UNBOUND_PREFIX = 27
const _XML_ERROR_UNDECLARING_PREFIX = 28
const _XML_ERROR_INCOMPLETE_PE = 29
const _XML_ERROR_XML_DECL = 30
const _XML_ERROR_TEXT_DECL = 31
const _XML_ERROR_PUBLICID = 32
const _XML_ERROR_SUSPENDED = 33
const _XML_ERROR_NOT_SUSPENDED = 34
const _XML_ERROR_ABORTED = 35
const _XML_ERROR_FINISHED = 36
const _XML_ERROR_SUSPEND_PE = 37
const _XML_ERROR_RESERVED_PREFIX_XML = 38
const _XML_ERROR_RESERVED_PREFIX_XMLNS = 39
const _XML_ERROR_RESERVED_NAMESPACE_URI = 40
const _XML_ERROR_INVALID_ARGUMENT = 41
const _XML_ERROR_NO_BUFFER = 42
const _XML_ERROR_AMPLIFICATION_LIMIT_BREACH = 43
const _XML_ERROR_NOT_STARTED = 44

type _XML_Content_Type = int32

const _XML_CTYPE_EMPTY = 1
const _XML_CTYPE_ANY = 2
const _XML_CTYPE_MIXED = 3
const _XML_CTYPE_NAME = 4
const _XML_CTYPE_CHOICE = 5
const _XML_CTYPE_SEQ = 6

type _XML_Content_Quant = int32

const _XML_CQUANT_NONE = 0
const _XML_CQUANT_OPT = 1
const _XML_CQUANT_REP = 2
const _XML_CQUANT_PLUS = 3

type TXML_Content = struct {
	Ftype1       _XML_Content_Type
	Fquant       _XML_Content_Quant
	Fname        uintptr
	Fnumchildren uint32
	Fchildren    uintptr
}

type TXML_cp = TXML_Content

type TXML_ElementDeclHandler = uintptr

type TXML_AttlistDeclHandler = uintptr

type TXML_XmlDeclHandler = uintptr

type TXML_Memory_Handling_Suite = struct {
	Fmalloc_fcn  uintptr
	Frealloc_fcn uintptr
	Ffree_fcn    uintptr
}

type TXML_StartElementHandler = uintptr

type TXML_EndElementHandler = uintptr

type TXML_CharacterDataHandler = uintptr

type TXML_ProcessingInstructionHandler = uintptr

type TXML_CommentHandler = uintptr

type TXML_StartCdataSectionHandler = uintptr

type TXML_EndCdataSectionHandler = uintptr

type TXML_DefaultHandler = uintptr

type TXML_StartDoctypeDeclHandler = uintptr

type TXML_EndDoctypeDeclHandler = uintptr

type TXML_EntityDeclHandler = uintptr

type TXML_UnparsedEntityDeclHandler = uintptr

type TXML_NotationDeclHandler = uintptr

type TXML_StartNamespaceDeclHandler = uintptr

type TXML_EndNamespaceDeclHandler = uintptr

type TXML_NotStandaloneHandler = uintptr

type TXML_ExternalEntityRefHandler = uintptr

type TXML_SkippedEntityHandler = uintptr

type TXML_Encoding = struct {
	Fmap1    [256]int32
	Fdata    uintptr
	Fconvert uintptr
	Frelease uintptr
}

type TXML_UnknownEncodingHandler = uintptr

type _XML_Parsing = int32

const _XML_INITIALIZED = 0
const _XML_PARSING = 1
const _XML_FINISHED = 2
const _XML_SUSPENDED = 3

type TXML_ParsingStatus = struct {
	Fparsing     _XML_Parsing
	FfinalBuffer TXML_Bool
}

type _XML_ParamEntityParsing = int32

const _XML_PARAM_ENTITY_PARSING_NEVER = 0
const _XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE = 1
const _XML_PARAM_ENTITY_PARSING_ALWAYS = 2

type TXML_Expat_Version = struct {
	Fmajor int32
	Fminor int32
	Fmicro int32
}

type _XML_FeatureEnum = int32

const _XML_FEATURE_END = 0
const _XML_FEATURE_UNICODE = 1
const _XML_FEATURE_UNICODE_WCHAR_T = 2
const _XML_FEATURE_DTD = 3
const _XML_FEATURE_CONTEXT_BYTES = 4
const _XML_FEATURE_MIN_SIZE = 5
const _XML_FEATURE_SIZEOF_XML_CHAR = 6
const _XML_FEATURE_SIZEOF_XML_LCHAR = 7
const _XML_FEATURE_NS = 8
const _XML_FEATURE_LARGE_SIZE = 9
const _XML_FEATURE_ATTR_INFO = 10
const _XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT = 11
const _XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT = 12
const _XML_FEATURE_GE = 13

type TXML_Feature = struct {
	Ffeature _XML_FeatureEnum
	Fname    uintptr
	Fvalue   int64
}

/* Expat follows the semantic versioning convention.
   See https://semver.org
*/

var ___fc_userdir = libc.UintptrFromInt32(0)
var ___fc_userconf = libc.UintptrFromInt32(0)

func XFcTestDestroy(tls *libc.TLS, test uintptr) {
	_FcExprDestroy(tls, (*TFcTest)(unsafe.Pointer(test)).Fexpr)
	libc.Xfree(tls, test)
}

func XFcRuleDestroy(tls *libc.TLS, rule uintptr) {
	var n uintptr
	_ = n
	n = (*TFcRule)(unsafe.Pointer(rule)).Fnext
	switch (*TFcRule)(unsafe.Pointer(rule)).Ftype1 {
	case int32(_FcRuleTest):
		XFcTestDestroy(tls, *(*uintptr)(unsafe.Pointer(rule + 16)))
	case int32(_FcRuleEdit):
		XFcEditDestroy(tls, *(*uintptr)(unsafe.Pointer(rule + 16)))
	case int32(_FcRuleUnknown):
		fallthrough
	default:
		break
	}
	libc.Xfree(tls, rule)
	if n != 0 {
		XFcRuleDestroy(tls, n)
	}
}

func _FcExprCreateInteger(tls *libc.TLS, config uintptr, i int32) (r uintptr) {
	var e uintptr
	_ = e
	e = XFcConfigAllocExpr(tls, config)
	if e != 0 {
		(*TFcExpr)(unsafe.Pointer(e)).Fop = int32(_FcOpInteger)
		(*TFcExpr)(unsafe.Pointer(e)).Fu.Fival = i
	}
	return e
}

func _FcExprCreateDouble(tls *libc.TLS, config uintptr, d float64) (r uintptr) {
	var e uintptr
	_ = e
	e = XFcConfigAllocExpr(tls, config)
	if e != 0 {
		(*TFcExpr)(unsafe.Pointer(e)).Fop = int32(_FcOpDouble)
		*(*float64)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)) = d
	}
	return e
}

func _FcExprCreateString(tls *libc.TLS, config uintptr, s uintptr) (r uintptr) {
	var e uintptr
	_ = e
	e = XFcConfigAllocExpr(tls, config)
	if e != 0 {
		(*TFcExpr)(unsafe.Pointer(e)).Fop = int32(_FcOpString)
		*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)) = libc.Xstrdup(tls, s)
	}
	return e
}

func _FcExprMatrixCopyShallow(tls *libc.TLS, matrix uintptr) (r uintptr) {
	var m uintptr
	_ = m
	m = libc.Xmalloc(tls, uint64(32))
	if m != 0 {
		*(*TFcExprMatrix)(unsafe.Pointer(m)) = *(*TFcExprMatrix)(unsafe.Pointer(matrix))
	}
	return m
}

func _FcExprMatrixFreeShallow(tls *libc.TLS, m uintptr) {
	if !(m != 0) {
		return
	}
	libc.Xfree(tls, m)
}

func _FcExprMatrixFree(tls *libc.TLS, m uintptr) {
	if !(m != 0) {
		return
	}
	_FcExprDestroy(tls, (*TFcExprMatrix)(unsafe.Pointer(m)).Fxx)
	_FcExprDestroy(tls, (*TFcExprMatrix)(unsafe.Pointer(m)).Fxy)
	_FcExprDestroy(tls, (*TFcExprMatrix)(unsafe.Pointer(m)).Fyx)
	_FcExprDestroy(tls, (*TFcExprMatrix)(unsafe.Pointer(m)).Fyy)
	libc.Xfree(tls, m)
}

func _FcExprCreateMatrix(tls *libc.TLS, config uintptr, matrix uintptr) (r uintptr) {
	var e uintptr
	_ = e
	e = XFcConfigAllocExpr(tls, config)
	if e != 0 {
		(*TFcExpr)(unsafe.Pointer(e)).Fop = int32(_FcOpMatrix)
		*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)) = _FcExprMatrixCopyShallow(tls, matrix)
	}
	return e
}

func _FcExprCreateRange(tls *libc.TLS, config uintptr, range1 uintptr) (r uintptr) {
	var e uintptr
	_ = e
	e = XFcConfigAllocExpr(tls, config)
	if e != 0 {
		(*TFcExpr)(unsafe.Pointer(e)).Fop = int32(_FcOpRange)
		*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)) = XFcRangeCopy(tls, range1)
	}
	return e
}

func _FcExprCreateBool(tls *libc.TLS, config uintptr, b TFcBool) (r uintptr) {
	var e uintptr
	_ = e
	e = XFcConfigAllocExpr(tls, config)
	if e != 0 {
		(*TFcExpr)(unsafe.Pointer(e)).Fop = int32(_FcOpBool)
		*(*TFcBool)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)) = b
	}
	return e
}

func _FcExprCreateCharSet(tls *libc.TLS, config uintptr, charset uintptr) (r uintptr) {
	var e uintptr
	_ = e
	e = XFcConfigAllocExpr(tls, config)
	if e != 0 {
		(*TFcExpr)(unsafe.Pointer(e)).Fop = int32(_FcOpCharSet)
		*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)) = XFcCharSetCopy(tls, charset)
	}
	return e
}

func _FcExprCreateLangSet(tls *libc.TLS, config uintptr, langset uintptr) (r uintptr) {
	var e uintptr
	_ = e
	e = XFcConfigAllocExpr(tls, config)
	if e != 0 {
		(*TFcExpr)(unsafe.Pointer(e)).Fop = int32(_FcOpLangSet)
		*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)) = XFcLangSetCopy(tls, langset)
	}
	return e
}

func _FcExprCreateName(tls *libc.TLS, config uintptr, name TFcExprName) (r uintptr) {
	var e uintptr
	_ = e
	e = XFcConfigAllocExpr(tls, config)
	if e != 0 {
		(*TFcExpr)(unsafe.Pointer(e)).Fop = int32(_FcOpField)
		*(*TFcExprName)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)) = name
	}
	return e
}

func _FcExprCreateConst(tls *libc.TLS, config uintptr, constant uintptr) (r uintptr) {
	var e uintptr
	_ = e
	e = XFcConfigAllocExpr(tls, config)
	if e != 0 {
		(*TFcExpr)(unsafe.Pointer(e)).Fop = int32(_FcOpConst)
		*(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)) = libc.Xstrdup(tls, constant)
	}
	return e
}

func _FcExprCreateOp(tls *libc.TLS, config uintptr, left uintptr, op TFcOp, right uintptr) (r uintptr) {
	var e uintptr
	_ = e
	e = XFcConfigAllocExpr(tls, config)
	if e != 0 {
		(*TFcExpr)(unsafe.Pointer(e)).Fop = op
		(*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fleft = left
		(*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fright = right
	}
	return e
}

func _FcExprDestroy(tls *libc.TLS, e uintptr) {
	if !(e != 0) {
		return
	}
	switch (*TFcExpr)(unsafe.Pointer(e)).Fop & libc.Int32FromInt32(0xffff) {
	case int32(_FcOpInteger):
	case int32(_FcOpDouble):
	case int32(_FcOpString):
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)))
	case int32(_FcOpMatrix):
		_FcExprMatrixFree(tls, *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)))
	case int32(_FcOpRange):
		XFcRangeDestroy(tls, *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)))
	case int32(_FcOpCharSet):
		XFcCharSetDestroy(tls, *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)))
	case int32(_FcOpLangSet):
		XFcLangSetDestroy(tls, *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)))
	case int32(_FcOpBool):
	case int32(_FcOpField):
	case int32(_FcOpConst):
		libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(e)).Fu)))
	case int32(_FcOpAssign):
		fallthrough
	case int32(_FcOpAssignReplace):
		fallthrough
	case int32(_FcOpPrepend):
		fallthrough
	case int32(_FcOpPrependFirst):
		fallthrough
	case int32(_FcOpAppend):
		fallthrough
	case int32(_FcOpAppendLast):
		fallthrough
	case int32(_FcOpDelete):
		fallthrough
	case int32(_FcOpDeleteAll):
	case int32(_FcOpOr):
		fallthrough
	case int32(_FcOpAnd):
		fallthrough
	case int32(_FcOpEqual):
		fallthrough
	case int32(_FcOpNotEqual):
		fallthrough
	case int32(_FcOpLess):
		fallthrough
	case int32(_FcOpLessEqual):
		fallthrough
	case int32(_FcOpMore):
		fallthrough
	case int32(_FcOpMoreEqual):
		fallthrough
	case int32(_FcOpContains):
		fallthrough
	case int32(_FcOpListing):
		fallthrough
	case int32(_FcOpNotContains):
		fallthrough
	case int32(_FcOpPlus):
		fallthrough
	case int32(_FcOpMinus):
		fallthrough
	case int32(_FcOpTimes):
		fallthrough
	case int32(_FcOpDivide):
		fallthrough
	case int32(_FcOpQuest):
		fallthrough
	case int32(_FcOpComma):
		_FcExprDestroy(tls, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fright)
		/* fall through */
		fallthrough
	case int32(_FcOpNot):
		fallthrough
	case int32(_FcOpFloor):
		fallthrough
	case int32(_FcOpCeil):
		fallthrough
	case int32(_FcOpRound):
		fallthrough
	case int32(_FcOpTrunc):
		_FcExprDestroy(tls, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(e + 8))).Fleft)
	case int32(_FcOpNil):
		fallthrough
	case int32(_FcOpInvalid):
		break
	}
	(*TFcExpr)(unsafe.Pointer(e)).Fop = int32(_FcOpNil)
}

func XFcEditDestroy(tls *libc.TLS, e uintptr) {
	if (*TFcEdit)(unsafe.Pointer(e)).Fexpr != 0 {
		_FcExprDestroy(tls, (*TFcEdit)(unsafe.Pointer(e)).Fexpr)
	}
	libc.Xfree(tls, e)
}

type TFcElement = int32

type __FcElement = int32

const _FcElementNone = 0
const _FcElementFontconfig = 1
const _FcElementDir = 2
const _FcElementCacheDir = 3
const _FcElementCache = 4
const _FcElementInclude = 5
const _FcElementConfig = 6
const _FcElementMatch = 7
const _FcElementAlias = 8
const _FcElementDescription = 9
const _FcElementRemapDir = 10
const _FcElementResetDirs = 11
const _FcElementRescan = 12
const _FcElementPrefer = 13
const _FcElementAccept = 14
const _FcElementDefault = 15
const _FcElementFamily = 16
const _FcElementSelectfont = 17
const _FcElementAcceptfont = 18
const _FcElementRejectfont = 19
const _FcElementGlob = 20
const _FcElementPattern = 21
const _FcElementPatelt = 22
const _FcElementTest = 23
const _FcElementEdit = 24
const _FcElementInt = 25
const _FcElementDouble = 26
const _FcElementString = 27
const _FcElementMatrix = 28
const _FcElementRange = 29
const _FcElementBool = 30
const _FcElementCharSet = 31
const _FcElementLangSet = 32
const _FcElementName = 33
const _FcElementConst = 34
const _FcElementOr = 35
const _FcElementAnd = 36
const _FcElementEq = 37
const _FcElementNotEq = 38
const _FcElementLess = 39
const _FcElementLessEq = 40
const _FcElementMore = 41
const _FcElementMoreEq = 42
const _FcElementContains = 43
const _FcElementNotContains = 44
const _FcElementPlus = 45
const _FcElementMinus = 46
const _FcElementTimes = 47
const _FcElementDivide = 48
const _FcElementNot = 49
const _FcElementIf = 50
const _FcElementFloor = 51
const _FcElementCeil = 52
const _FcElementRound = 53
const _FcElementTrunc = 54
const _FcElementUnknown = 55

var _fcElementMap = [54]struct {
	Fname    [16]int8
	Felement TFcElement
}{
	0: {
		Fname:    [16]int8{'f', 'o', 'n', 't', 'c', 'o', 'n', 'f', 'i', 'g'},
		Felement: int32(_FcElementFontconfig),
	},
	1: {
		Fname:    [16]int8{'d', 'i', 'r'},
		Felement: int32(_FcElementDir),
	},
	2: {
		Fname:    [16]int8{'c', 'a', 'c', 'h', 'e', 'd', 'i', 'r'},
		Felement: int32(_FcElementCacheDir),
	},
	3: {
		Fname:    [16]int8{'c', 'a', 'c', 'h', 'e'},
		Felement: int32(_FcElementCache),
	},
	4: {
		Fname:    [16]int8{'i', 'n', 'c', 'l', 'u', 'd', 'e'},
		Felement: int32(_FcElementInclude),
	},
	5: {
		Fname:    [16]int8{'c', 'o', 'n', 'f', 'i', 'g'},
		Felement: int32(_FcElementConfig),
	},
	6: {
		Fname:    [16]int8{'m', 'a', 't', 'c', 'h'},
		Felement: int32(_FcElementMatch),
	},
	7: {
		Fname:    [16]int8{'a', 'l', 'i', 'a', 's'},
		Felement: int32(_FcElementAlias),
	},
	8: {
		Fname:    [16]int8{'d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'},
		Felement: int32(_FcElementDescription),
	},
	9: {
		Fname:    [16]int8{'r', 'e', 'm', 'a', 'p', '-', 'd', 'i', 'r'},
		Felement: int32(_FcElementRemapDir),
	},
	10: {
		Fname:    [16]int8{'r', 'e', 's', 'e', 't', '-', 'd', 'i', 'r', 's'},
		Felement: int32(_FcElementResetDirs),
	},
	11: {
		Fname:    [16]int8{'r', 'e', 's', 'c', 'a', 'n'},
		Felement: int32(_FcElementRescan),
	},
	12: {
		Fname:    [16]int8{'p', 'r', 'e', 'f', 'e', 'r'},
		Felement: int32(_FcElementPrefer),
	},
	13: {
		Fname:    [16]int8{'a', 'c', 'c', 'e', 'p', 't'},
		Felement: int32(_FcElementAccept),
	},
	14: {
		Fname:    [16]int8{'d', 'e', 'f', 'a', 'u', 'l', 't'},
		Felement: int32(_FcElementDefault),
	},
	15: {
		Fname:    [16]int8{'f', 'a', 'm', 'i', 'l', 'y'},
		Felement: int32(_FcElementFamily),
	},
	16: {
		Fname:    [16]int8{'s', 'e', 'l', 'e', 'c', 't', 'f', 'o', 'n', 't'},
		Felement: int32(_FcElementSelectfont),
	},
	17: {
		Fname:    [16]int8{'a', 'c', 'c', 'e', 'p', 't', 'f', 'o', 'n', 't'},
		Felement: int32(_FcElementAcceptfont),
	},
	18: {
		Fname:    [16]int8{'r', 'e', 'j', 'e', 'c', 't', 'f', 'o', 'n', 't'},
		Felement: int32(_FcElementRejectfont),
	},
	19: {
		Fname:    [16]int8{'g', 'l', 'o', 'b'},
		Felement: int32(_FcElementGlob),
	},
	20: {
		Fname:    [16]int8{'p', 'a', 't', 't', 'e', 'r', 'n'},
		Felement: int32(_FcElementPattern),
	},
	21: {
		Fname:    [16]int8{'p', 'a', 't', 'e', 'l', 't'},
		Felement: int32(_FcElementPatelt),
	},
	22: {
		Fname:    [16]int8{'t', 'e', 's', 't'},
		Felement: int32(_FcElementTest),
	},
	23: {
		Fname:    [16]int8{'e', 'd', 'i', 't'},
		Felement: int32(_FcElementEdit),
	},
	24: {
		Fname:    [16]int8{'i', 'n', 't'},
		Felement: int32(_FcElementInt),
	},
	25: {
		Fname:    [16]int8{'d', 'o', 'u', 'b', 'l', 'e'},
		Felement: int32(_FcElementDouble),
	},
	26: {
		Fname:    [16]int8{'s', 't', 'r', 'i', 'n', 'g'},
		Felement: int32(_FcElementString),
	},
	27: {
		Fname:    [16]int8{'m', 'a', 't', 'r', 'i', 'x'},
		Felement: int32(_FcElementMatrix),
	},
	28: {
		Fname:    [16]int8{'r', 'a', 'n', 'g', 'e'},
		Felement: int32(_FcElementRange),
	},
	29: {
		Fname:    [16]int8{'b', 'o', 'o', 'l'},
		Felement: int32(_FcElementBool),
	},
	30: {
		Fname:    [16]int8{'c', 'h', 'a', 'r', 's', 'e', 't'},
		Felement: int32(_FcElementCharSet),
	},
	31: {
		Fname:    [16]int8{'l', 'a', 'n', 'g', 's', 'e', 't'},
		Felement: int32(_FcElementLangSet),
	},
	32: {
		Fname:    [16]int8{'n', 'a', 'm', 'e'},
		Felement: int32(_FcElementName),
	},
	33: {
		Fname:    [16]int8{'c', 'o', 'n', 's', 't'},
		Felement: int32(_FcElementConst),
	},
	34: {
		Fname:    [16]int8{'o', 'r'},
		Felement: int32(_FcElementOr),
	},
	35: {
		Fname:    [16]int8{'a', 'n', 'd'},
		Felement: int32(_FcElementAnd),
	},
	36: {
		Fname:    [16]int8{'e', 'q'},
		Felement: int32(_FcElementEq),
	},
	37: {
		Fname:    [16]int8{'n', 'o', 't', '_', 'e', 'q'},
		Felement: int32(_FcElementNotEq),
	},
	38: {
		Fname:    [16]int8{'l', 'e', 's', 's'},
		Felement: int32(_FcElementLess),
	},
	39: {
		Fname:    [16]int8{'l', 'e', 's', 's', '_', 'e', 'q'},
		Felement: int32(_FcElementLessEq),
	},
	40: {
		Fname:    [16]int8{'m', 'o', 'r', 'e'},
		Felement: int32(_FcElementMore),
	},
	41: {
		Fname:    [16]int8{'m', 'o', 'r', 'e', '_', 'e', 'q'},
		Felement: int32(_FcElementMoreEq),
	},
	42: {
		Fname:    [16]int8{'c', 'o', 'n', 't', 'a', 'i', 'n', 's'},
		Felement: int32(_FcElementContains),
	},
	43: {
		Fname:    [16]int8{'n', 'o', 't', '_', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's'},
		Felement: int32(_FcElementNotContains),
	},
	44: {
		Fname:    [16]int8{'p', 'l', 'u', 's'},
		Felement: int32(_FcElementPlus),
	},
	45: {
		Fname:    [16]int8{'m', 'i', 'n', 'u', 's'},
		Felement: int32(_FcElementMinus),
	},
	46: {
		Fname:    [16]int8{'t', 'i', 'm', 'e', 's'},
		Felement: int32(_FcElementTimes),
	},
	47: {
		Fname:    [16]int8{'d', 'i', 'v', 'i', 'd', 'e'},
		Felement: int32(_FcElementDivide),
	},
	48: {
		Fname:    [16]int8{'n', 'o', 't'},
		Felement: int32(_FcElementNot),
	},
	49: {
		Fname:    [16]int8{'i', 'f'},
		Felement: int32(_FcElementIf),
	},
	50: {
		Fname:    [16]int8{'f', 'l', 'o', 'o', 'r'},
		Felement: int32(_FcElementFloor),
	},
	51: {
		Fname:    [16]int8{'c', 'e', 'i', 'l'},
		Felement: int32(_FcElementCeil),
	},
	52: {
		Fname:    [16]int8{'r', 'o', 'u', 'n', 'd'},
		Felement: int32(_FcElementRound),
	},
	53: {
		Fname:    [16]int8{'t', 'r', 'u', 'n', 'c'},
		Felement: int32(_FcElementTrunc),
	},
}

var _fcElementIgnoreName = [16]uintptr{
	0: __ccgo_ts + 6993,
	1: libc.UintptrFromInt32(0),
}

func _FcElementMap(tls *libc.TLS, name uintptr) (r TFcElement) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < libc.Int32FromUint64(libc.Uint64FromInt64(1080)/libc.Uint64FromInt64(20))) {
			break
		}
		if !(libc.Xstrcmp(tls, name, uintptr(unsafe.Pointer(&_fcElementMap))+uintptr(i)*20) != 0) {
			return _fcElementMap[i].Felement
		}
		goto _1
	_1:
		;
		i++
	}
	i = 0
	for {
		if !(_fcElementIgnoreName[i] != libc.UintptrFromInt32(0)) {
			break
		}
		if !(libc.Xstrncmp(tls, name, _fcElementIgnoreName[i], libc.Xstrlen(tls, _fcElementIgnoreName[i])) != 0) {
			return int32(_FcElementNone)
		}
		goto _2
	_2:
		;
		i++
	}
	return int32(_FcElementUnknown)
}

func _FcElementReverseMap(tls *libc.TLS, e TFcElement) (r uintptr) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < libc.Int32FromUint64(libc.Uint64FromInt64(1080)/libc.Uint64FromInt64(20))) {
			break
		}
		if _fcElementMap[i].Felement == e {
			return uintptr(unsafe.Pointer(&_fcElementMap)) + uintptr(i)*20
		}
		goto _1
	_1:
		;
		i++
	}
	return libc.UintptrFromInt32(0)
}

type TFcPStack = struct {
	Fprev            uintptr
	Felement         TFcElement
	Fattr            uintptr
	Fstr             TFcStrBuf
	Fattr_buf_static [16]uintptr
}

type T_FcPStack = TFcPStack

type TFcVStackTag = int32

type __FcVStackTag = int32

const _FcVStackNone = 0
const _FcVStackString = 1
const _FcVStackFamily = 2
const _FcVStackConstant = 3
const _FcVStackGlob = 4
const _FcVStackName = 5
const _FcVStackPattern = 6
const _FcVStackPrefer = 7
const _FcVStackAccept = 8
const _FcVStackDefault = 9
const _FcVStackInteger = 10
const _FcVStackDouble = 11
const _FcVStackMatrix = 12
const _FcVStackRange = 13
const _FcVStackBool = 14
const _FcVStackCharSet = 15
const _FcVStackLangSet = 16
const _FcVStackTest = 17
const _FcVStackExpr = 18
const _FcVStackEdit = 19

type TFcVStack = struct {
	Fprev   uintptr
	Fpstack uintptr
	Ftag    TFcVStackTag
	Fu      struct {
		Finteger [0]int32
		F_double [0]float64
		Fmatrix  [0]uintptr
		Frange1  [0]uintptr
		Fbool_   [0]TFcBool
		Fcharset [0]uintptr
		Flangset [0]uintptr
		Fname    [0]TFcExprName
		Ftest    [0]uintptr
		Fqual    [0]TFcQual
		Fop      [0]TFcOp
		Fexpr    [0]uintptr
		Fedit    [0]uintptr
		Fpattern [0]uintptr
		Fstring1 uintptr
	}
}

type T_FcVStack = TFcVStack

type TFcConfigParse = struct {
	Fpstack             uintptr
	Fvstack             uintptr
	Ferror1             TFcBool
	Fname               uintptr
	Fconfig             uintptr
	Fruleset            uintptr
	Fparser             TXML_Parser
	Fpstack_static_used uint32
	Fpstack_static      [8]TFcPStack
	Fvstack_static_used uint32
	Fvstack_static      [64]TFcVStack
	FscanOnly           TFcBool
}

type T_FcConfigParse = TFcConfigParse

type TFcConfigSeverity = int32

type __FcConfigSeverity = int32

const _FcSevereInfo = 0
const _FcSevereWarning = 1
const _FcSevereError = 2

func _FcConfigMessage(tls *libc.TLS, parse uintptr, severe TFcConfigSeverity, fmt uintptr, va uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var args Tva_list
	var s uintptr
	_, _ = args, s
	s = __ccgo_ts + 4707
	args = va
	switch severe {
	case int32(_FcSevereInfo):
		s = __ccgo_ts + 6998
	case int32(_FcSevereWarning):
		s = __ccgo_ts + 7003
	case int32(_FcSevereError):
		s = __ccgo_ts + 7011
		break
	}
	if parse != 0 {
		if (*TFcConfigParse)(unsafe.Pointer(parse)).Fname != 0 {
			libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+7017, libc.VaList(bp+8, s, (*TFcConfigParse)(unsafe.Pointer(parse)).Fname, libc.Int32FromUint64(libexpat.XXML_GetCurrentLineNumber(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fparser))))
		} else {
			libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+7048, libc.VaList(bp+8, s, libc.Int32FromUint64(libexpat.XXML_GetCurrentLineNumber(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fparser))))
		}
		if severe >= int32(_FcSevereError) {
			(*TFcConfigParse)(unsafe.Pointer(parse)).Ferror1 = int32(m_FcTrue)
		}
	} else {
		libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+7073, libc.VaList(bp+8, s))
	}
	libc.Xvfprintf(tls, libc.X__stderrp, fmt, args)
	libc.Xfprintf(tls, libc.X__stderrp, __ccgo_ts+1266, 0)
	_ = args
}

func _FcTypeName(tls *libc.TLS, type1 TFcType) (r uintptr) {
	switch type1 {
	case int32(_FcTypeVoid):
		return __ccgo_ts + 7089
	case int32(_FcTypeInteger):
		fallthrough
	case int32(_FcTypeDouble):
		return __ccgo_ts + 7094
	case int32(_FcTypeString):
		return __ccgo_ts + 7101
	case int32(_FcTypeBool):
		return __ccgo_ts + 7108
	case int32(_FcTypeMatrix):
		return __ccgo_ts + 6400
	case int32(_FcTypeCharSet):
		return __ccgo_ts + 6125
	case int32(_FcTypeFTFace):
		return __ccgo_ts + 7113
	case int32(_FcTypeLangSet):
		return __ccgo_ts + 7121
	case int32(_FcTypeRange):
		return __ccgo_ts + 7129
	case int32(_FcTypeUnknown):
		fallthrough
	default:
		return __ccgo_ts + 4707
	}
	return r
}

func _FcTypecheckValue(tls *libc.TLS, parse uintptr, value TFcType, type1 TFcType) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	if value == int32(_FcTypeInteger) {
		value = int32(_FcTypeDouble)
	}
	if type1 == int32(_FcTypeInteger) {
		type1 = int32(_FcTypeDouble)
	}
	if value != type1 {
		if value == int32(_FcTypeLangSet) && type1 == int32(_FcTypeString) || value == int32(_FcTypeString) && type1 == int32(_FcTypeLangSet) || value == int32(_FcTypeDouble) && type1 == int32(_FcTypeRange) {
			return
		}
		if type1 == int32(_FcTypeUnknown) {
			return
		}
		/* It's perfectly fine to use user-define elements in expressions,
		 * so don't warn in that case. */
		if value == int32(_FcTypeUnknown) {
			return
		}
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7135, libc.VaList(bp+8, _FcTypeName(tls, value), _FcTypeName(tls, type1)))
	}
}

func _FcTypecheckExpr(tls *libc.TLS, parse uintptr, expr uintptr, type1 TFcType) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, o uintptr
	_, _ = c, o
	/* If parsing the expression failed, some nodes may be NULL */
	if !(expr != 0) {
		return
	}
	switch (*TFcExpr)(unsafe.Pointer(expr)).Fop & libc.Int32FromInt32(0xffff) {
	case int32(_FcOpInteger):
		fallthrough
	case int32(_FcOpDouble):
		_FcTypecheckValue(tls, parse, int32(_FcTypeDouble), type1)
	case int32(_FcOpString):
		_FcTypecheckValue(tls, parse, int32(_FcTypeString), type1)
	case int32(_FcOpMatrix):
		_FcTypecheckValue(tls, parse, int32(_FcTypeMatrix), type1)
	case int32(_FcOpBool):
		_FcTypecheckValue(tls, parse, int32(_FcTypeBool), type1)
	case int32(_FcOpCharSet):
		_FcTypecheckValue(tls, parse, int32(_FcTypeCharSet), type1)
	case int32(_FcOpLangSet):
		_FcTypecheckValue(tls, parse, int32(_FcTypeLangSet), type1)
	case int32(_FcOpRange):
		_FcTypecheckValue(tls, parse, int32(_FcTypeRange), type1)
	case int32(_FcOpNil):
	case int32(_FcOpField):
		o = XFcNameGetObjectType(tls, XFcObjectName(tls, (*(*TFcExprName)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu))).Fobject))
		if o != 0 {
			_FcTypecheckValue(tls, parse, (*TFcObjectType)(unsafe.Pointer(o)).Ftype1, type1)
		}
	case int32(_FcOpConst):
		c = XFcNameGetConstant(tls, *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu)))
		if c != 0 {
			o = XFcNameGetObjectType(tls, (*TFcConstant)(unsafe.Pointer(c)).Fobject)
			if o != 0 {
				_FcTypecheckValue(tls, parse, (*TFcObjectType)(unsafe.Pointer(o)).Ftype1, type1)
			}
		} else {
			_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7155, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(&(*TFcExpr)(unsafe.Pointer(expr)).Fu))))
		}
	case int32(_FcOpQuest):
		_FcTypecheckExpr(tls, parse, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(expr + 8))).Fleft, int32(_FcTypeBool))
		_FcTypecheckExpr(tls, parse, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer((*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(expr + 8))).Fright + 8))).Fleft, type1)
		_FcTypecheckExpr(tls, parse, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer((*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(expr + 8))).Fright + 8))).Fright, type1)
	case int32(_FcOpAssign):
		fallthrough
	case int32(_FcOpAssignReplace):
	case int32(_FcOpEqual):
		fallthrough
	case int32(_FcOpNotEqual):
		fallthrough
	case int32(_FcOpLess):
		fallthrough
	case int32(_FcOpLessEqual):
		fallthrough
	case int32(_FcOpMore):
		fallthrough
	case int32(_FcOpMoreEqual):
		fallthrough
	case int32(_FcOpContains):
		fallthrough
	case int32(_FcOpNotContains):
		fallthrough
	case int32(_FcOpListing):
		_FcTypecheckValue(tls, parse, int32(_FcTypeBool), type1)
	case int32(_FcOpComma):
		fallthrough
	case int32(_FcOpOr):
		fallthrough
	case int32(_FcOpAnd):
		fallthrough
	case int32(_FcOpPlus):
		fallthrough
	case int32(_FcOpMinus):
		fallthrough
	case int32(_FcOpTimes):
		fallthrough
	case int32(_FcOpDivide):
		_FcTypecheckExpr(tls, parse, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(expr + 8))).Fleft, type1)
		_FcTypecheckExpr(tls, parse, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(expr + 8))).Fright, type1)
	case int32(_FcOpNot):
		_FcTypecheckValue(tls, parse, int32(_FcTypeBool), type1)
		_FcTypecheckExpr(tls, parse, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(expr + 8))).Fleft, int32(_FcTypeBool))
	case int32(_FcOpFloor):
		fallthrough
	case int32(_FcOpCeil):
		fallthrough
	case int32(_FcOpRound):
		fallthrough
	case int32(_FcOpTrunc):
		_FcTypecheckValue(tls, parse, int32(_FcTypeDouble), type1)
		_FcTypecheckExpr(tls, parse, (*(*struct {
			Fleft  uintptr
			Fright uintptr
		})(unsafe.Pointer(expr + 8))).Fleft, int32(_FcTypeDouble))
	default:
		break
	}
}

func _FcTestCreate(tls *libc.TLS, parse uintptr, kind TFcMatchKind, qual TFcQual, field uintptr, compare uint32, expr uintptr) (r uintptr) {
	var o, test uintptr
	_, _ = o, test
	test = libc.Xmalloc(tls, uint64(24))
	if test != 0 {
		(*TFcTest)(unsafe.Pointer(test)).Fkind = kind
		(*TFcTest)(unsafe.Pointer(test)).Fqual = qual
		(*TFcTest)(unsafe.Pointer(test)).Fobject = XFcObjectFromName(tls, field)
		(*TFcTest)(unsafe.Pointer(test)).Fop = libc.Int32FromUint32(compare)
		(*TFcTest)(unsafe.Pointer(test)).Fexpr = expr
		o = XFcNameGetObjectType(tls, XFcObjectName(tls, (*TFcTest)(unsafe.Pointer(test)).Fobject))
		if o != 0 {
			_FcTypecheckExpr(tls, parse, expr, (*TFcObjectType)(unsafe.Pointer(o)).Ftype1)
		}
	}
	return test
}

func _FcEditCreate(tls *libc.TLS, parse uintptr, object TFcObject, op TFcOp, expr uintptr, binding TFcValueBinding) (r uintptr) {
	var e, o uintptr
	_, _ = e, o
	e = libc.Xmalloc(tls, uint64(24))
	if e != 0 {
		(*TFcEdit)(unsafe.Pointer(e)).Fobject = object
		(*TFcEdit)(unsafe.Pointer(e)).Fop = op
		(*TFcEdit)(unsafe.Pointer(e)).Fexpr = expr
		(*TFcEdit)(unsafe.Pointer(e)).Fbinding = binding
		o = XFcNameGetObjectType(tls, XFcObjectName(tls, (*TFcEdit)(unsafe.Pointer(e)).Fobject))
		if o != 0 {
			_FcTypecheckExpr(tls, parse, expr, (*TFcObjectType)(unsafe.Pointer(o)).Ftype1)
		}
	}
	return e
}

func _FcRuleCreate(tls *libc.TLS, type1 TFcRuleType, p uintptr) (r1 uintptr) {
	var r uintptr
	_ = r
	r = libc.Xmalloc(tls, uint64(24))
	if !(r != 0) {
		return libc.UintptrFromInt32(0)
	}
	(*TFcRule)(unsafe.Pointer(r)).Fnext = libc.UintptrFromInt32(0)
	(*TFcRule)(unsafe.Pointer(r)).Ftype1 = type1
	switch type1 {
	case int32(_FcRuleTest):
		*(*uintptr)(unsafe.Pointer(r + 16)) = p
	case int32(_FcRuleEdit):
		*(*uintptr)(unsafe.Pointer(r + 16)) = p
	case int32(_FcRuleUnknown):
		fallthrough
	default:
		libc.Xfree(tls, r)
		r = libc.UintptrFromInt32(0)
		break
	}
	return r
}

func _FcVStackCreateAndPush(tls *libc.TLS, parse uintptr) (r uintptr) {
	var new1, v2, v3 uintptr
	var v1 uint32
	_, _, _, _ = new1, v1, v2, v3
	if uint64((*TFcConfigParse)(unsafe.Pointer(parse)).Fvstack_static_used) < libc.Uint64FromInt64(2048)/libc.Uint64FromInt64(32) {
		v2 = parse + 2496
		v1 = *(*uint32)(unsafe.Pointer(v2))
		*(*uint32)(unsafe.Pointer(v2))++
		new1 = parse + 2504 + uintptr(v1)*32
	} else {
		new1 = libc.Xmalloc(tls, uint64(32))
		if !(new1 != 0) {
			return uintptr(0)
		}
	}
	(*TFcVStack)(unsafe.Pointer(new1)).Ftag = int32(_FcVStackNone)
	(*TFcVStack)(unsafe.Pointer(new1)).Fprev = uintptr(0)
	(*TFcVStack)(unsafe.Pointer(new1)).Fprev = (*TFcConfigParse)(unsafe.Pointer(parse)).Fvstack
	if (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack != 0 {
		v3 = (*TFcPStack)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack)).Fprev
	} else {
		v3 = uintptr(0)
	}
	(*TFcVStack)(unsafe.Pointer(new1)).Fpstack = v3
	(*TFcConfigParse)(unsafe.Pointer(parse)).Fvstack = new1
	return new1
}

func _FcVStackPushString(tls *libc.TLS, parse uintptr, tag TFcVStackTag, string1 uintptr) (r TFcBool) {
	var vstack uintptr
	_ = vstack
	vstack = _FcVStackCreateAndPush(tls, parse)
	if !(vstack != 0) {
		return m_FcFalse
	}
	*(*uintptr)(unsafe.Pointer(vstack + 24)) = string1
	(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = tag
	return int32(m_FcTrue)
}

func _FcVStackPushInteger(tls *libc.TLS, parse uintptr, integer int32) (r TFcBool) {
	var vstack uintptr
	_ = vstack
	vstack = _FcVStackCreateAndPush(tls, parse)
	if !(vstack != 0) {
		return m_FcFalse
	}
	*(*int32)(unsafe.Pointer(&(*TFcVStack)(unsafe.Pointer(vstack)).Fu)) = integer
	(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackInteger)
	return int32(m_FcTrue)
}

func _FcVStackPushDouble(tls *libc.TLS, parse uintptr, _double float64) (r TFcBool) {
	var vstack uintptr
	_ = vstack
	vstack = _FcVStackCreateAndPush(tls, parse)
	if !(vstack != 0) {
		return m_FcFalse
	}
	*(*float64)(unsafe.Pointer(vstack + 24)) = _double
	(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackDouble)
	return int32(m_FcTrue)
}

func _FcVStackPushMatrix(tls *libc.TLS, parse uintptr, matrix uintptr) (r TFcBool) {
	var vstack uintptr
	_ = vstack
	vstack = _FcVStackCreateAndPush(tls, parse)
	if !(vstack != 0) {
		return m_FcFalse
	}
	*(*uintptr)(unsafe.Pointer(vstack + 24)) = _FcExprMatrixCopyShallow(tls, matrix)
	(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackMatrix)
	return int32(m_FcTrue)
}

func _FcVStackPushRange(tls *libc.TLS, parse uintptr, range1 uintptr) (r TFcBool) {
	var vstack uintptr
	_ = vstack
	vstack = _FcVStackCreateAndPush(tls, parse)
	if !(vstack != 0) {
		return m_FcFalse
	}
	*(*uintptr)(unsafe.Pointer(vstack + 24)) = range1
	(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackRange)
	return int32(m_FcTrue)
}

func _FcVStackPushBool(tls *libc.TLS, parse uintptr, bool_ TFcBool) (r TFcBool) {
	var vstack uintptr
	_ = vstack
	vstack = _FcVStackCreateAndPush(tls, parse)
	if !(vstack != 0) {
		return m_FcFalse
	}
	*(*TFcBool)(unsafe.Pointer(&(*TFcVStack)(unsafe.Pointer(vstack)).Fu)) = bool_
	(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackBool)
	return int32(m_FcTrue)
}

func _FcVStackPushCharSet(tls *libc.TLS, parse uintptr, charset uintptr) (r TFcBool) {
	var vstack uintptr
	_ = vstack
	if !(charset != 0) {
		return m_FcFalse
	}
	vstack = _FcVStackCreateAndPush(tls, parse)
	if !(vstack != 0) {
		return m_FcFalse
	}
	*(*uintptr)(unsafe.Pointer(vstack + 24)) = charset
	(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackCharSet)
	return int32(m_FcTrue)
}

func _FcVStackPushLangSet(tls *libc.TLS, parse uintptr, langset uintptr) (r TFcBool) {
	var vstack uintptr
	_ = vstack
	if !(langset != 0) {
		return m_FcFalse
	}
	vstack = _FcVStackCreateAndPush(tls, parse)
	if !(vstack != 0) {
		return m_FcFalse
	}
	*(*uintptr)(unsafe.Pointer(vstack + 24)) = langset
	(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackLangSet)
	return int32(m_FcTrue)
}

func _FcVStackPushName(tls *libc.TLS, parse uintptr, kind TFcMatchKind, object TFcObject) (r TFcBool) {
	var vstack uintptr
	_ = vstack
	vstack = _FcVStackCreateAndPush(tls, parse)
	if !(vstack != 0) {
		return m_FcFalse
	}
	(*(*TFcExprName)(unsafe.Pointer(vstack + 24))).Fobject = object
	(*(*TFcExprName)(unsafe.Pointer(vstack + 24))).Fkind = kind
	(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackName)
	return int32(m_FcTrue)
}

func _FcVStackPushTest(tls *libc.TLS, parse uintptr, test uintptr) (r TFcBool) {
	var vstack uintptr
	_ = vstack
	vstack = _FcVStackCreateAndPush(tls, parse)
	if !(vstack != 0) {
		return m_FcFalse
	}
	*(*uintptr)(unsafe.Pointer(vstack + 24)) = test
	(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackTest)
	return int32(m_FcTrue)
}

func _FcVStackPushExpr(tls *libc.TLS, parse uintptr, tag TFcVStackTag, expr uintptr) (r TFcBool) {
	var vstack uintptr
	_ = vstack
	vstack = _FcVStackCreateAndPush(tls, parse)
	if !(vstack != 0) {
		return m_FcFalse
	}
	*(*uintptr)(unsafe.Pointer(vstack + 24)) = expr
	(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = tag
	return int32(m_FcTrue)
}

func _FcVStackPushEdit(tls *libc.TLS, parse uintptr, edit uintptr) (r TFcBool) {
	var vstack uintptr
	_ = vstack
	vstack = _FcVStackCreateAndPush(tls, parse)
	if !(vstack != 0) {
		return m_FcFalse
	}
	*(*uintptr)(unsafe.Pointer(vstack + 24)) = edit
	(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackEdit)
	return int32(m_FcTrue)
}

func _FcVStackPushPattern(tls *libc.TLS, parse uintptr, pattern uintptr) (r TFcBool) {
	var vstack uintptr
	_ = vstack
	vstack = _FcVStackCreateAndPush(tls, parse)
	if !(vstack != 0) {
		return m_FcFalse
	}
	*(*uintptr)(unsafe.Pointer(vstack + 24)) = pattern
	(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackPattern)
	return int32(m_FcTrue)
}

func _FcVStackFetch(tls *libc.TLS, parse uintptr, off int32) (r uintptr) {
	var vstack uintptr
	var v2 int32
	var v3 bool
	_, _, _ = vstack, v2, v3
	vstack = (*TFcConfigParse)(unsafe.Pointer(parse)).Fvstack
	for {
		if v3 = vstack != 0; v3 {
			v2 = off
			off--
		}
		if !(v3 && v2 > 0) {
			break
		}
		goto _1
	_1:
		;
		vstack = (*TFcVStack)(unsafe.Pointer(vstack)).Fprev
	}
	return vstack
}

func _FcVStackPeek(tls *libc.TLS, parse uintptr) (r uintptr) {
	var vstack, v1 uintptr
	_, _ = vstack, v1
	vstack = (*TFcConfigParse)(unsafe.Pointer(parse)).Fvstack
	if vstack != 0 && (*TFcVStack)(unsafe.Pointer(vstack)).Fpstack == (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack {
		v1 = vstack
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func _FcVStackPopAndDestroy(tls *libc.TLS, parse uintptr) {
	var vstack uintptr
	_ = vstack
	vstack = (*TFcConfigParse)(unsafe.Pointer(parse)).Fvstack
	if !(vstack != 0) || (*TFcVStack)(unsafe.Pointer(vstack)).Fpstack != (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack {
		return
	}
	(*TFcConfigParse)(unsafe.Pointer(parse)).Fvstack = (*TFcVStack)(unsafe.Pointer(vstack)).Fprev
	switch (*TFcVStack)(unsafe.Pointer(vstack)).Ftag {
	case int32(_FcVStackNone):
	case int32(_FcVStackName):
	case int32(_FcVStackFamily):
	case int32(_FcVStackString):
		fallthrough
	case int32(_FcVStackConstant):
		fallthrough
	case int32(_FcVStackGlob):
		XFcStrFree(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackPattern):
		XFcPatternDestroy(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackInteger):
		fallthrough
	case int32(_FcVStackDouble):
	case int32(_FcVStackMatrix):
		_FcExprMatrixFreeShallow(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackBool):
	case int32(_FcVStackRange):
		XFcRangeDestroy(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackCharSet):
		XFcCharSetDestroy(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackLangSet):
		XFcLangSetDestroy(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackTest):
		XFcTestDestroy(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackExpr):
		fallthrough
	case int32(_FcVStackPrefer):
		fallthrough
	case int32(_FcVStackAccept):
		fallthrough
	case int32(_FcVStackDefault):
		_FcExprDestroy(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackEdit):
		XFcEditDestroy(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
		break
	}
	if vstack == parse+2504+uintptr((*TFcConfigParse)(unsafe.Pointer(parse)).Fvstack_static_used-uint32(1))*32 {
		(*TFcConfigParse)(unsafe.Pointer(parse)).Fvstack_static_used--
	} else {
		libc.Xfree(tls, vstack)
	}
}

func _FcVStackClear(tls *libc.TLS, parse uintptr) {
	for _FcVStackPeek(tls, parse) != 0 {
		_FcVStackPopAndDestroy(tls, parse)
	}
}

func _FcVStackElements(tls *libc.TLS, parse uintptr) (r int32) {
	var h int32
	var vstack uintptr
	_, _ = h, vstack
	h = 0
	vstack = (*TFcConfigParse)(unsafe.Pointer(parse)).Fvstack
	for vstack != 0 && (*TFcVStack)(unsafe.Pointer(vstack)).Fpstack == (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack {
		h++
		vstack = (*TFcVStack)(unsafe.Pointer(vstack)).Fprev
	}
	return h
}

func _FcConfigSaveAttr(tls *libc.TLS, attr uintptr, buf uintptr, size_bytes int32) (r uintptr) {
	var i, slen int32
	var new1, s uintptr
	_, _, _, _ = i, new1, s, slen
	if !(attr != 0) {
		return uintptr(0)
	}
	slen = 0
	i = 0
	for {
		if !(*(*uintptr)(unsafe.Pointer(attr + uintptr(i)*8)) != 0) {
			break
		}
		slen = int32(uint64(slen) + (libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(attr + uintptr(i)*8))) + libc.Uint64FromInt32(1)))
		goto _1
	_1:
		;
		i++
	}
	if i == 0 {
		return uintptr(0)
	}
	slen = int32(uint64(slen) + libc.Uint64FromInt32(i+libc.Int32FromInt32(1))*libc.Uint64FromInt64(8))
	if slen <= size_bytes {
		new1 = buf
	} else {
		new1 = libc.Xmalloc(tls, libc.Uint64FromInt32(slen))
		if !(new1 != 0) {
			_FcConfigMessage(tls, uintptr(0), int32(_FcSevereError), __ccgo_ts+7182, 0)
			return uintptr(0)
		}
	}
	s = new1 + uintptr(i+libc.Int32FromInt32(1))*8
	i = 0
	for {
		if !(*(*uintptr)(unsafe.Pointer(attr + uintptr(i)*8)) != 0) {
			break
		}
		*(*uintptr)(unsafe.Pointer(new1 + uintptr(i)*8)) = s
		libc.X__builtin___strcpy_chk(tls, s, *(*uintptr)(unsafe.Pointer(attr + uintptr(i)*8)), ^t__predefined_size_t(0))
		s += uintptr(libc.Xstrlen(tls, s) + uint64(1))
		goto _2
	_2:
		;
		i++
	}
	*(*uintptr)(unsafe.Pointer(new1 + uintptr(i)*8)) = uintptr(0)
	return new1
}

func _FcPStackPush(tls *libc.TLS, parse uintptr, element TFcElement, attr uintptr) (r TFcBool) {
	var new1, v2 uintptr
	var v1 uint32
	_, _, _ = new1, v1, v2
	if uint64((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack_static_used) < libc.Uint64FromInt64(2432)/libc.Uint64FromInt64(304) {
		v2 = parse + 56
		v1 = *(*uint32)(unsafe.Pointer(v2))
		*(*uint32)(unsafe.Pointer(v2))++
		new1 = parse + 64 + uintptr(v1)*304
	} else {
		new1 = libc.Xmalloc(tls, uint64(304))
		if !(new1 != 0) {
			return m_FcFalse
		}
	}
	(*TFcPStack)(unsafe.Pointer(new1)).Fprev = (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack
	(*TFcPStack)(unsafe.Pointer(new1)).Felement = element
	(*TFcPStack)(unsafe.Pointer(new1)).Fattr = _FcConfigSaveAttr(tls, attr, new1+176, int32(128))
	XFcStrBufInit(tls, new1+24, uintptr(0), 0)
	(*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack = new1
	return int32(m_FcTrue)
}

func _FcPStackPop(tls *libc.TLS, parse uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var attrs, old uintptr
	_, _ = attrs, old
	if !((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7196, 0)
		return m_FcFalse
	}
	/* Don't check the attributes for FcElementNone */
	if (*TFcPStack)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack)).Felement != int32(_FcElementNone) && (*TFcPStack)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack)).Fattr != 0 {
		/* Warn about unused attrs. */
		attrs = (*TFcPStack)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack)).Fattr
		for *(*uintptr)(unsafe.Pointer(attrs)) != 0 {
			if *(*TFcChar8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(attrs)))) != 0 {
				_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7216, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(attrs))))
			}
			attrs += uintptr(2) * 8
		}
	}
	_FcVStackClear(tls, parse)
	old = (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack
	(*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack = (*TFcPStack)(unsafe.Pointer(old)).Fprev
	XFcStrBufDestroy(tls, old+24)
	if (*TFcPStack)(unsafe.Pointer(old)).Fattr != 0 && (*TFcPStack)(unsafe.Pointer(old)).Fattr != old+176 {
		libc.Xfree(tls, (*TFcPStack)(unsafe.Pointer(old)).Fattr)
	}
	if old == parse+64+uintptr((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack_static_used-uint32(1))*304 {
		(*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack_static_used--
	} else {
		libc.Xfree(tls, old)
	}
	return int32(m_FcTrue)
}

func _FcConfigParseInit(tls *libc.TLS, parse uintptr, name uintptr, config uintptr, parser TXML_Parser, enabled TFcBool) (r TFcBool) {
	(*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack = uintptr(0)
	(*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack_static_used = uint32(0)
	(*TFcConfigParse)(unsafe.Pointer(parse)).Fvstack = uintptr(0)
	(*TFcConfigParse)(unsafe.Pointer(parse)).Fvstack_static_used = uint32(0)
	(*TFcConfigParse)(unsafe.Pointer(parse)).Ferror1 = m_FcFalse
	(*TFcConfigParse)(unsafe.Pointer(parse)).Fname = name
	(*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig = config
	(*TFcConfigParse)(unsafe.Pointer(parse)).Fruleset = XFcRuleSetCreate(tls, name)
	(*TFcConfigParse)(unsafe.Pointer(parse)).Fparser = parser
	(*TFcConfigParse)(unsafe.Pointer(parse)).FscanOnly = libc.BoolInt32(!(enabled != 0))
	XFcRuleSetEnable(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fruleset, enabled)
	return int32(m_FcTrue)
}

func _FcConfigCleanup(tls *libc.TLS, parse uintptr) {
	for (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack != 0 {
		_FcPStackPop(tls, parse)
	}
	XFcRuleSetDestroy(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fruleset)
	(*TFcConfigParse)(unsafe.Pointer(parse)).Fruleset = libc.UintptrFromInt32(0)
}

func _FcConfigGetAttribute(tls *libc.TLS, parse uintptr, attr uintptr) (r uintptr) {
	var attrs uintptr
	_ = attrs
	if !((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack != 0) {
		return uintptr(0)
	}
	attrs = (*TFcPStack)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack)).Fattr
	if !(attrs != 0) {
		return uintptr(0)
	}
	for *(*uintptr)(unsafe.Pointer(attrs)) != 0 {
		if !(libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(attrs)), attr) != 0) {
			*(*TFcChar8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(attrs)))) = uint8('\000') /* Mark as used. */
			return *(*uintptr)(unsafe.Pointer(attrs + 1*8))
		}
		attrs += uintptr(2) * 8
	}
	return uintptr(0)
}

func __get_real_paths_from_prefix(tls *libc.TLS, parse uintptr, path uintptr, prefix uintptr) (r uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var e, p, parent, retval, s uintptr
	var i int32
	_, _, _, _, _, _ = e, i, p, parent, retval, s
	parent = libc.UintptrFromInt32(0)
	retval = libc.UintptrFromInt32(0)
	e = libc.UintptrFromInt32(0)
	if prefix != 0 {
		if XFcStrCmp(tls, prefix, __ccgo_ts+7239) == 0 {
			parent = XFcConfigXdgDataHome(tls)
			if !(parent != 0) {
				/* Home directory might be disabled */
				return libc.UintptrFromInt32(0)
			}
			e = XFcConfigXdgDataDirs(tls)
			if !(e != 0) {
				XFcStrFree(tls, parent)
				return libc.UintptrFromInt32(0)
			}
		} else {
			if XFcStrCmp(tls, prefix, __ccgo_ts+7243) == 0 || XFcStrCmp(tls, prefix, __ccgo_ts+7251) == 0 {
				/* Nothing to do */
			} else {
				if XFcStrCmp(tls, prefix, __ccgo_ts+7255) == 0 {
					p = XFcStrRealPath(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fname)
					if !(p != 0) {
						return libc.UintptrFromInt32(0)
					}
					parent = XFcStrDirname(tls, p)
					if !(parent != 0) {
						libc.Xfree(tls, p)
						return libc.UintptrFromInt32(0)
					}
				}
			}
		}
	} else {
		if !(XFcStrIsAbsoluteFilename(tls, path) != 0) && libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(path))) != int32('~') {
			_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7264, libc.VaList(bp+8, _FcElementReverseMap(tls, (*TFcPStack)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack)).Felement)))
		}
	}
	if parent != 0 {
		retval = XFcStrBuildFilename(tls, parent, libc.VaList(bp+8, path, libc.UintptrFromInt32(0)))
		XFcStrFree(tls, parent)
	} else {
		retval = libc.Xstrdup(tls, path)
	}
	if !(e != 0) {
		e = XFcStrSetCreate(tls)
	} else {
		i = 0
		for {
			if !(i < (*TFcStrSet)(unsafe.Pointer(e)).Fnum) {
				break
			}
			s = XFcStrBuildFilename(tls, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(e)).Fstrs + uintptr(i)*8)), libc.VaList(bp+8, path, libc.UintptrFromInt32(0)))
			XFcStrFree(tls, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(e)).Fstrs + uintptr(i)*8)))
			*(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(e)).Fstrs + uintptr(i)*8)) = s
			goto _1
		_1:
			;
			i++
		}
	}
	if !(XFcStrSetInsert(tls, e, retval, 0) != 0) {
		XFcStrSetDestroy(tls, e)
		e = libc.UintptrFromInt32(0)
	}
	XFcStrFree(tls, retval)
	return e
}

func _FcStartElement(tls *libc.TLS, userData uintptr, name uintptr, attr uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var element TFcElement
	var parse uintptr
	_, _ = element, parse
	parse = userData
	element = _FcElementMap(tls, name)
	if element == int32(_FcElementUnknown) {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7359, libc.VaList(bp+8, name))
	}
	if !(_FcPStackPush(tls, parse, element, attr) != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		return
	}
	return
}

func _FcParseRescan(tls *libc.TLS, parse uintptr) {
	var n, v1 int32
	var v uintptr
	_, _, _ = n, v, v1
	n = _FcVStackElements(tls, parse)
	for {
		v1 = n
		n--
		if !(v1 > 0) {
			break
		}
		v = _FcVStackFetch(tls, parse, n)
		if (*TFcVStack)(unsafe.Pointer(v)).Ftag != int32(_FcVStackInteger) {
			_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7380, 0)
		} else {
			(*TFcConfig)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig)).FrescanInterval = *(*int32)(unsafe.Pointer(&(*TFcVStack)(unsafe.Pointer(v)).Fu))
		}
	}
}

func _FcParseInt(tls *libc.TLS, parse uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var l int32
	var s uintptr
	var _ /* end at bp+0 */ uintptr
	_, _ = l, s
	if !((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack != 0) {
		return
	}
	s = XFcStrBufDoneStatic(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	if !(s != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		return
	}
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	l = int32(libc.Xstrtol(tls, s, bp, 0))
	if *(*uintptr)(unsafe.Pointer(bp)) != s+uintptr(libc.Xstrlen(tls, s)) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7399, libc.VaList(bp+16, s))
	} else {
		_FcVStackPushInteger(tls, parse, l)
	}
	XFcStrBufDestroy(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
}

type Tlconv = struct {
	Fdecimal_point      uintptr
	Fthousands_sep      uintptr
	Fgrouping           uintptr
	Fint_curr_symbol    uintptr
	Fcurrency_symbol    uintptr
	Fmon_decimal_point  uintptr
	Fmon_thousands_sep  uintptr
	Fmon_grouping       uintptr
	Fpositive_sign      uintptr
	Fnegative_sign      uintptr
	Fint_frac_digits    int8
	Ffrac_digits        int8
	Fp_cs_precedes      int8
	Fp_sep_by_space     int8
	Fn_cs_precedes      int8
	Fn_sep_by_space     int8
	Fp_sign_posn        int8
	Fn_sign_posn        int8
	Fint_p_cs_precedes  int8
	Fint_n_cs_precedes  int8
	Fint_p_sep_by_space int8
	Fint_n_sep_by_space int8
	Fint_p_sign_posn    int8
	Fint_n_sign_posn    int8
}

type Tlocale_t = uintptr

func _FcStrtod(tls *libc.TLS, s uintptr, end uintptr) (r float64) {
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var decimal_point, dot, locale_data, v1 uintptr
	var dlen, slen int32
	var v float64
	var _ /* buf at bp+0 */ [128]int8
	var _ /* buf_end at bp+128 */ uintptr
	_, _, _, _, _, _, _ = decimal_point, dlen, dot, locale_data, slen, v, v1
	/*
	 * Have to swap the decimal point to match the current locale
	 * if that locale doesn't use 0x2e
	 */
	locale_data = libc.Xlocaleconv(tls)
	decimal_point = (*Tlconv)(unsafe.Pointer(locale_data)).Fdecimal_point
	dlen = libc.Int32FromUint64(libc.Xstrlen(tls, decimal_point))
	v1 = libc.Xstrchr(tls, s, int32(0x2e))
	dot = v1
	if v1 != 0 && (int32(*(*int8)(unsafe.Pointer(decimal_point))) != int32(0x2e) || int32(*(*int8)(unsafe.Pointer(decimal_point + 1))) != 0) {
		slen = libc.Int32FromUint64(libc.Xstrlen(tls, s))
		if slen+dlen > libc.Int32FromInt64(128) {
			if end != 0 {
				*(*uintptr)(unsafe.Pointer(end)) = s
			}
			v = libc.Float64FromInt32(0)
		} else {
			/* mantissa */
			libc.X__builtin___strncpy_chk(tls, bp, s, libc.Uint64FromInt64(int64(dot)-int64(s)), ^t__predefined_size_t(0))
			/* decimal point */
			libc.X__builtin___strcpy_chk(tls, bp+uintptr(int64(dot)-int64(s)), decimal_point, ^t__predefined_size_t(0))
			/* rest of number */
			libc.X__builtin___strcpy_chk(tls, bp+uintptr(int64(dot)-int64(s))+uintptr(dlen), dot+uintptr(1), ^t__predefined_size_t(0))
			*(*uintptr)(unsafe.Pointer(bp + 128)) = uintptr(0)
			v = libc.Xstrtod(tls, bp, bp+128)
			if *(*uintptr)(unsafe.Pointer(bp + 128)) != 0 {
				*(*uintptr)(unsafe.Pointer(bp + 128)) = s + uintptr(int64(*(*uintptr)(unsafe.Pointer(bp + 128)))-t__predefined_ptrdiff_t(bp))
				if *(*uintptr)(unsafe.Pointer(bp + 128)) > dot {
					*(*uintptr)(unsafe.Pointer(bp + 128)) -= uintptr(dlen - int32(1))
				}
			}
			if end != 0 {
				*(*uintptr)(unsafe.Pointer(end)) = *(*uintptr)(unsafe.Pointer(bp + 128))
			}
		}
	} else {
		v = libc.Xstrtod(tls, s, end)
	}
	return v
}

func _FcParseDouble(tls *libc.TLS, parse uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var d float64
	var s uintptr
	var _ /* end at bp+0 */ uintptr
	_, _ = d, s
	if !((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack != 0) {
		return
	}
	s = XFcStrBufDoneStatic(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	if !(s != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		return
	}
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	d = _FcStrtod(tls, s, bp)
	if *(*uintptr)(unsafe.Pointer(bp)) != s+uintptr(libc.Xstrlen(tls, s)) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7425, libc.VaList(bp+16, s))
	} else {
		_FcVStackPushDouble(tls, parse, d)
	}
	XFcStrBufDestroy(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
}

func _FcParseString(tls *libc.TLS, parse uintptr, tag TFcVStackTag) {
	var s uintptr
	_ = s
	if !((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack != 0) {
		return
	}
	s = XFcStrBufDone(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	if !(s != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		return
	}
	if !(_FcVStackPushString(tls, parse, tag, s) != 0) {
		XFcStrFree(tls, s)
	}
}

func _FcParseName(tls *libc.TLS, parse uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var kind TFcMatchKind
	var kind_string, s uintptr
	var object TFcObject
	_, _, _, _ = kind, kind_string, object, s
	kind_string = _FcConfigGetAttribute(tls, parse, __ccgo_ts+7450)
	if !(kind_string != 0) {
		kind = -libc.Int32FromInt32(1)
	} else {
		if !(libc.Xstrcmp(tls, kind_string, __ccgo_ts+7457) != 0) {
			kind = int32(_FcMatchPattern)
		} else {
			if !(libc.Xstrcmp(tls, kind_string, __ccgo_ts+7465) != 0) {
				kind = int32(_FcMatchFont)
			} else {
				if !(libc.Xstrcmp(tls, kind_string, __ccgo_ts+7243) != 0) {
					kind = -libc.Int32FromInt32(1)
				} else {
					_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7470, libc.VaList(bp+8, kind_string))
					return
				}
			}
		}
	}
	if !((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack != 0) {
		return
	}
	s = XFcStrBufDone(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	if !(s != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		return
	}
	object = XFcObjectFromName(tls, s)
	_FcVStackPushName(tls, parse, kind, object)
	XFcStrFree(tls, s)
}

func _FcParseMatrix(tls *libc.TLS, parse uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* m at bp+0 */ TFcExprMatrix
	(*(*TFcExprMatrix)(unsafe.Pointer(bp))).Fyy = _FcPopExpr(tls, parse)
	(*(*TFcExprMatrix)(unsafe.Pointer(bp))).Fyx = _FcPopExpr(tls, parse)
	(*(*TFcExprMatrix)(unsafe.Pointer(bp))).Fxy = _FcPopExpr(tls, parse)
	(*(*TFcExprMatrix)(unsafe.Pointer(bp))).Fxx = _FcPopExpr(tls, parse)
	if !((*(*TFcExprMatrix)(unsafe.Pointer(bp))).Fyy != 0) || !((*(*TFcExprMatrix)(unsafe.Pointer(bp))).Fyx != 0) || !((*(*TFcExprMatrix)(unsafe.Pointer(bp))).Fxy != 0) || !((*(*TFcExprMatrix)(unsafe.Pointer(bp))).Fxx != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7495, 0)
		return
	}
	if _FcPopExpr(tls, parse) != 0 {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7528, 0)
	} else {
		_FcVStackPushMatrix(tls, parse, bp)
	}
}

func _FcParseRange(tls *libc.TLS, parse uintptr) {
	var count int32
	var d [2]float64
	var dflag TFcBool
	var n [2]TFcChar32
	var r, vstack, v1 uintptr
	_, _, _, _, _, _, _ = count, d, dflag, n, r, vstack, v1
	n = [2]TFcChar32{}
	count = int32(1)
	d = [2]float64{}
	dflag = m_FcFalse
	for {
		v1 = _FcVStackPeek(tls, parse)
		vstack = v1
		if !(v1 != 0) {
			break
		}
		if count < 0 {
			_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7560, 0)
			return
		}
		switch (*TFcVStack)(unsafe.Pointer(vstack)).Ftag {
		case int32(_FcVStackInteger):
			if dflag != 0 {
				d[count] = float64(*(*int32)(unsafe.Pointer(&(*TFcVStack)(unsafe.Pointer(vstack)).Fu)))
			} else {
				n[count] = libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(&(*TFcVStack)(unsafe.Pointer(vstack)).Fu)))
			}
		case int32(_FcVStackDouble):
			if count == 0 && !(dflag != 0) {
				d[int32(1)] = float64(n[int32(1)])
			}
			d[count] = *(*float64)(unsafe.Pointer(vstack + 24))
			dflag = int32(m_FcTrue)
		default:
			_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7587, 0)
			if dflag != 0 {
				d[count] = libc.Float64FromFloat64(0)
			} else {
				n[count] = uint32(0)
			}
			break
		}
		count--
		_FcVStackPopAndDestroy(tls, parse)
	}
	if count >= 0 {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7612, 0)
		return
	}
	if dflag != 0 {
		if d[0] > d[int32(1)] {
			_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7612, 0)
			return
		}
		r = XFcRangeCreateDouble(tls, d[0], d[int32(1)])
	} else {
		if n[0] > n[int32(1)] {
			_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7612, 0)
			return
		}
		r = XFcRangeCreateInteger(tls, n[0], n[int32(1)])
	}
	_FcVStackPushRange(tls, parse, r)
}

func _FcConfigLexBool(tls *libc.TLS, parse uintptr, bool_ uintptr) (r TFcBool) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* result at bp+0 */ TFcBool
	*(*TFcBool)(unsafe.Pointer(bp)) = m_FcFalse
	if !(XFcNameBool(tls, bool_, bp) != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7626, libc.VaList(bp+16, bool_))
	}
	return *(*TFcBool)(unsafe.Pointer(bp))
}

func _FcParseBool(tls *libc.TLS, parse uintptr) {
	var s uintptr
	_ = s
	if !((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack != 0) {
		return
	}
	s = XFcStrBufDoneStatic(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	if !(s != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		return
	}
	_FcVStackPushBool(tls, parse, _FcConfigLexBool(tls, parse, s))
	XFcStrBufDestroy(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
}

func _FcParseCharSet(tls *libc.TLS, parse uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var begin, end, i TFcChar32
	var charset, vstack, v1 uintptr
	var n int32
	_, _, _, _, _, _, _ = begin, charset, end, i, n, vstack, v1
	charset = XFcCharSetCreate(tls)
	n = 0
	for {
		v1 = _FcVStackPeek(tls, parse)
		vstack = v1
		if !(v1 != 0) {
			break
		}
		switch (*TFcVStack)(unsafe.Pointer(vstack)).Ftag {
		case int32(_FcVStackInteger):
			if !(XFcCharSetAddChar(tls, charset, libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(&(*TFcVStack)(unsafe.Pointer(vstack)).Fu)))) != 0) {
				_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7652, libc.VaList(bp+8, *(*int32)(unsafe.Pointer(&(*TFcVStack)(unsafe.Pointer(vstack)).Fu))))
			} else {
				n++
			}
		case int32(_FcVStackRange):
			begin = uint32((*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(vstack + 24)))).Fbegin)
			end = uint32((*TFcRange)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(vstack + 24)))).Fend)
			if begin <= end {
				i = begin
				for {
					if !(i <= end) {
						break
					}
					if !(XFcCharSetAddChar(tls, charset, i) != 0) {
						_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7652, libc.VaList(bp+8, i))
					} else {
						n++
					}
					goto _2
				_2:
					;
					i++
				}
			}
		default:
			_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7678, 0)
			break
		}
		_FcVStackPopAndDestroy(tls, parse)
	}
	if n > 0 {
		_FcVStackPushCharSet(tls, parse, charset)
	} else {
		XFcCharSetDestroy(tls, charset)
	}
}

func _FcParseLangSet(tls *libc.TLS, parse uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var langset, vstack, v1 uintptr
	var n int32
	_, _, _, _ = langset, n, vstack, v1
	langset = XFcLangSetCreate(tls)
	n = 0
	for {
		v1 = _FcVStackPeek(tls, parse)
		vstack = v1
		if !(v1 != 0) {
			break
		}
		switch (*TFcVStack)(unsafe.Pointer(vstack)).Ftag {
		case int32(_FcVStackString):
			if !(XFcLangSetAdd(tls, langset, *(*uintptr)(unsafe.Pointer(vstack + 24))) != 0) {
				_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7705, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(vstack + 24))))
			} else {
				n++
			}
		default:
			_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7725, 0)
			break
		}
		_FcVStackPopAndDestroy(tls, parse)
	}
	if n > 0 {
		_FcVStackPushLangSet(tls, parse, langset)
	} else {
		XFcLangSetDestroy(tls, langset)
	}
}

func _FcConfigLexBinding(tls *libc.TLS, parse uintptr, binding_string uintptr, binding_ret uintptr) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var binding TFcValueBinding
	_ = binding
	if !(binding_string != 0) {
		binding = int32(_FcValueBindingWeak)
	} else {
		if !(libc.Xstrcmp(tls, binding_string, __ccgo_ts+7752) != 0) {
			binding = int32(_FcValueBindingWeak)
		} else {
			if !(libc.Xstrcmp(tls, binding_string, __ccgo_ts+7757) != 0) {
				binding = int32(_FcValueBindingStrong)
			} else {
				if !(libc.Xstrcmp(tls, binding_string, __ccgo_ts+7764) != 0) {
					binding = int32(_FcValueBindingSame)
				} else {
					_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7769, libc.VaList(bp+8, binding_string))
					return m_FcFalse
				}
			}
		}
	}
	*(*TFcValueBinding)(unsafe.Pointer(binding_ret)) = binding
	return int32(m_FcTrue)
}

func _FcParseFamilies(tls *libc.TLS, parse uintptr, tag TFcVStackTag) {
	var expr, left, new1, vstack, v1 uintptr
	_, _, _, _, _ = expr, left, new1, vstack, v1
	expr = uintptr(0)
	for {
		v1 = _FcVStackPeek(tls, parse)
		vstack = v1
		if !(v1 != 0) {
			break
		}
		if (*TFcVStack)(unsafe.Pointer(vstack)).Ftag != int32(_FcVStackFamily) {
			_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7790, 0)
			_FcVStackPopAndDestroy(tls, parse)
			continue
		}
		left = *(*uintptr)(unsafe.Pointer(vstack + 24))
		(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackNone)
		_FcVStackPopAndDestroy(tls, parse)
		if expr != 0 {
			new1 = _FcExprCreateOp(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, left, int32(_FcOpComma), expr)
			if !(new1 != 0) {
				_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
				_FcExprDestroy(tls, left)
				_FcExprDestroy(tls, expr)
				break
			}
			expr = new1
		} else {
			expr = left
		}
	}
	if expr != 0 {
		if !(_FcVStackPushExpr(tls, parse, tag, expr) != 0) {
			_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
			_FcExprDestroy(tls, expr)
		}
	}
}

func _FcParseFamily(tls *libc.TLS, parse uintptr) {
	var expr, s uintptr
	_, _ = expr, s
	if !((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack != 0) {
		return
	}
	s = XFcStrBufDoneStatic(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	if !(s != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		return
	}
	expr = _FcExprCreateString(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, s)
	XFcStrBufDestroy(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	if expr != 0 {
		_FcVStackPushExpr(tls, parse, int32(_FcVStackFamily), expr)
	}
}

func _FcParseAlias(tls *libc.TLS, parse uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var accept, def, edit, family, new1, prefer, r, rule, t, vstack, v1, v3 uintptr
	var n, v4 int32
	var _ /* binding at bp+0 */ TFcValueBinding
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = accept, def, edit, family, n, new1, prefer, r, rule, t, vstack, v1, v3, v4
	family = uintptr(0)
	accept = uintptr(0)
	prefer = uintptr(0)
	def = uintptr(0)
	new1 = uintptr(0)
	edit = uintptr(0)
	rule = libc.UintptrFromInt32(0)
	if !(_FcConfigLexBinding(tls, parse, _FcConfigGetAttribute(tls, parse, __ccgo_ts+7801), bp) != 0) {
		return
	}
	for {
		v1 = _FcVStackPeek(tls, parse)
		vstack = v1
		if !(v1 != 0) {
			break
		}
		switch (*TFcVStack)(unsafe.Pointer(vstack)).Ftag {
		case int32(_FcVStackFamily):
			if family != 0 {
				_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7809, 0)
				new1 = _FcExprCreateOp(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, *(*uintptr)(unsafe.Pointer(vstack + 24)), int32(_FcOpComma), family)
				if !(new1 != 0) {
					_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
				} else {
					family = new1
				}
			} else {
				new1 = *(*uintptr)(unsafe.Pointer(vstack + 24))
			}
			if new1 != 0 {
				family = new1
				(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackNone)
			}
		case int32(_FcVStackPrefer):
			if prefer != 0 {
				_FcExprDestroy(tls, prefer)
			}
			prefer = *(*uintptr)(unsafe.Pointer(vstack + 24))
			(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackNone)
		case int32(_FcVStackAccept):
			if accept != 0 {
				_FcExprDestroy(tls, accept)
			}
			accept = *(*uintptr)(unsafe.Pointer(vstack + 24))
			(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackNone)
		case int32(_FcVStackDefault):
			if def != 0 {
				_FcExprDestroy(tls, def)
			}
			def = *(*uintptr)(unsafe.Pointer(vstack + 24))
			(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackNone)
		case int32(_FcVStackTest):
			if rule != 0 {
				r = _FcRuleCreate(tls, int32(_FcRuleTest), *(*uintptr)(unsafe.Pointer(vstack + 24)))
				(*TFcRule)(unsafe.Pointer(r)).Fnext = rule
				rule = r
			} else {
				rule = _FcRuleCreate(tls, int32(_FcRuleTest), *(*uintptr)(unsafe.Pointer(vstack + 24)))
			}
			(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackNone)
		default:
			_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7890, 0)
			break
		}
		_FcVStackPopAndDestroy(tls, parse)
	}
	if !(family != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7900, 0)
		if prefer != 0 {
			_FcExprDestroy(tls, prefer)
		}
		if accept != 0 {
			_FcExprDestroy(tls, accept)
		}
		if def != 0 {
			_FcExprDestroy(tls, def)
		}
		if rule != 0 {
			XFcRuleDestroy(tls, rule)
		}
		return
	}
	if !(prefer != 0) && !(accept != 0) && !(def != 0) {
		_FcExprDestroy(tls, family)
		if rule != 0 {
			XFcRuleDestroy(tls, rule)
		}
		return
	} else {
		t = _FcTestCreate(tls, parse, int32(_FcMatchPattern), int32(_FcQualAny), __ccgo_ts+5977, libc.Uint32FromInt32(int32(_FcOpEqual)&libc.Int32FromInt32(0xffff)|int32(_FcOpFlagIgnoreBlanks)<<libc.Int32FromInt32(16)), family)
		if rule != 0 {
			r = rule
			for {
				if !((*TFcRule)(unsafe.Pointer(r)).Fnext != 0) {
					break
				}
				goto _2
			_2:
				;
				r = (*TFcRule)(unsafe.Pointer(r)).Fnext
			}
			(*TFcRule)(unsafe.Pointer(r)).Fnext = _FcRuleCreate(tls, int32(_FcRuleTest), t)
			r = (*TFcRule)(unsafe.Pointer(r)).Fnext
		} else {
			v3 = _FcRuleCreate(tls, int32(_FcRuleTest), t)
			rule = v3
			r = v3
		}
	}
	if prefer != 0 {
		edit = _FcEditCreate(tls, parse, int32(_FC_FAMILY_OBJECT), int32(_FcOpPrepend), prefer, *(*TFcValueBinding)(unsafe.Pointer(bp)))
		if !(edit != 0) {
			_FcExprDestroy(tls, prefer)
		} else {
			(*TFcRule)(unsafe.Pointer(r)).Fnext = _FcRuleCreate(tls, int32(_FcRuleEdit), edit)
			r = (*TFcRule)(unsafe.Pointer(r)).Fnext
		}
	}
	if accept != 0 {
		edit = _FcEditCreate(tls, parse, int32(_FC_FAMILY_OBJECT), int32(_FcOpAppend), accept, *(*TFcValueBinding)(unsafe.Pointer(bp)))
		if !(edit != 0) {
			_FcExprDestroy(tls, accept)
		} else {
			(*TFcRule)(unsafe.Pointer(r)).Fnext = _FcRuleCreate(tls, int32(_FcRuleEdit), edit)
			r = (*TFcRule)(unsafe.Pointer(r)).Fnext
		}
	}
	if def != 0 {
		edit = _FcEditCreate(tls, parse, int32(_FC_FAMILY_OBJECT), int32(_FcOpAppendLast), def, *(*TFcValueBinding)(unsafe.Pointer(bp)))
		if !(edit != 0) {
			_FcExprDestroy(tls, def)
		} else {
			(*TFcRule)(unsafe.Pointer(r)).Fnext = _FcRuleCreate(tls, int32(_FcRuleEdit), edit)
			r = (*TFcRule)(unsafe.Pointer(r)).Fnext
		}
	}
	v4 = XFcRuleSetAdd(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fruleset, rule, int32(_FcMatchPattern))
	n = v4
	if v4 == -int32(1) {
		XFcRuleDestroy(tls, rule)
	} else {
		if (*TFcConfig)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig)).FmaxObjects < n {
			(*TFcConfig)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig)).FmaxObjects = n
		}
	}
}

func _FcParseDescription(tls *libc.TLS, parse uintptr) {
	var desc, domain uintptr
	_, _ = desc, domain
	domain = _FcConfigGetAttribute(tls, parse, __ccgo_ts+7924)
	desc = XFcStrBufDone(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	if !(desc != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		return
	}
	XFcRuleSetAddDescription(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fruleset, domain, desc)
	XFcStrFree(tls, desc)
}

func _FcParseRemapDir(tls *libc.TLS, parse uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var attr, data, l, path, prefix, prefix_dirs, salt, v1 uintptr
	_, _, _, _, _, _, _, _ = attr, data, l, path, prefix, prefix_dirs, salt, v1
	prefix_dirs = libc.UintptrFromInt32(0)
	data = XFcStrBufDoneStatic(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	if !(data != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		return
	}
	if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(data))) == 0 {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7931, 0)
		return
	}
	path = _FcConfigGetAttribute(tls, parse, __ccgo_ts+7975)
	if !(path != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+7983, 0)
		return
	}
	attr = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8012)
	salt = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8019)
	prefix_dirs = __get_real_paths_from_prefix(tls, parse, data, attr)
	if prefix_dirs != 0 {
		l = XFcStrListCreate(tls, prefix_dirs)
		XFcStrSetDestroy(tls, prefix_dirs)
		for {
			v1 = XFcStrListNext(tls, l)
			prefix = v1
			if !(v1 != 0) {
				break
			}
			if !(prefix != 0) || libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(prefix))) == 0 {
				/* nop */
			} else {
				if !((*TFcConfigParse)(unsafe.Pointer(parse)).FscanOnly != 0) && (!(XFcStrUsesHome(tls, prefix) != 0) || XFcConfigHome(tls) != 0) {
					if !(XFcConfigAddFontDir(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, prefix, path, salt) != 0) {
						_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+8024, libc.VaList(bp+8, prefix, path))
					}
				}
			}
			XFcStrBufDestroy(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
		}
		XFcStrListDone(tls, l)
	}
}

func _FcParseResetDirs(tls *libc.TLS, parse uintptr) {
	if !((*TFcConfigParse)(unsafe.Pointer(parse)).FscanOnly != 0) {
		if !(XFcConfigResetFontDirs(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig) != 0) {
			_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+8077, 0)
		}
	}
}

func _FcPopExpr(tls *libc.TLS, parse uintptr) (r uintptr) {
	var expr, vstack uintptr
	_, _ = expr, vstack
	vstack = _FcVStackPeek(tls, parse)
	expr = uintptr(0)
	if !(vstack != 0) {
		return uintptr(0)
	}
	switch (*TFcVStack)(unsafe.Pointer(vstack)).Ftag {
	case int32(_FcVStackNone):
	case int32(_FcVStackString):
		fallthrough
	case int32(_FcVStackFamily):
		expr = _FcExprCreateString(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, *(*uintptr)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackName):
		expr = _FcExprCreateName(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, *(*TFcExprName)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackConstant):
		expr = _FcExprCreateConst(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, *(*uintptr)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackGlob):
		/* XXX: What's the correct action here? (CDW) */
	case int32(_FcVStackPrefer):
		fallthrough
	case int32(_FcVStackAccept):
		fallthrough
	case int32(_FcVStackDefault):
		expr = *(*uintptr)(unsafe.Pointer(vstack + 24))
		(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackNone)
	case int32(_FcVStackInteger):
		expr = _FcExprCreateInteger(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, *(*int32)(unsafe.Pointer(&(*TFcVStack)(unsafe.Pointer(vstack)).Fu)))
	case int32(_FcVStackDouble):
		expr = _FcExprCreateDouble(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, *(*float64)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackMatrix):
		expr = _FcExprCreateMatrix(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, *(*uintptr)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackRange):
		expr = _FcExprCreateRange(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, *(*uintptr)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackBool):
		expr = _FcExprCreateBool(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, *(*TFcBool)(unsafe.Pointer(&(*TFcVStack)(unsafe.Pointer(vstack)).Fu)))
	case int32(_FcVStackCharSet):
		expr = _FcExprCreateCharSet(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, *(*uintptr)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackLangSet):
		expr = _FcExprCreateLangSet(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, *(*uintptr)(unsafe.Pointer(vstack + 24)))
	case int32(_FcVStackTest):
	case int32(_FcVStackExpr):
		expr = *(*uintptr)(unsafe.Pointer(vstack + 24))
		(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackNone)
	case int32(_FcVStackEdit):
	default:
		break
	}
	_FcVStackPopAndDestroy(tls, parse)
	return expr
}

// C documentation
//
//	/*
//	 * This builds a tree of binary operations.  Note
//	 * that every operator is defined so that if only
//	 * a single operand is contained, the value of the
//	 * whole expression is the value of the operand.
//	 *
//	 * This code reduces in that case to returning that
//	 * operand.
//	 */
func _FcPopBinary(tls *libc.TLS, parse uintptr, op TFcOp) (r uintptr) {
	var expr, left, new1, v1 uintptr
	_, _, _, _ = expr, left, new1, v1
	expr = uintptr(0)
	for {
		v1 = _FcPopExpr(tls, parse)
		left = v1
		if !(v1 != 0) {
			break
		}
		if expr != 0 {
			new1 = _FcExprCreateOp(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, left, op, expr)
			if !(new1 != 0) {
				_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
				_FcExprDestroy(tls, left)
				_FcExprDestroy(tls, expr)
				return uintptr(0)
			}
			expr = new1
		} else {
			expr = left
		}
	}
	return expr
}

func _FcParseBinary(tls *libc.TLS, parse uintptr, op TFcOp) {
	var expr uintptr
	_ = expr
	expr = _FcPopBinary(tls, parse, op)
	if expr != 0 {
		_FcVStackPushExpr(tls, parse, int32(_FcVStackExpr), expr)
	}
}

/*
 * This builds a a unary operator, it consumes only
 * a single operand
 */

func _FcPopUnary(tls *libc.TLS, parse uintptr, op TFcOp) (r uintptr) {
	var new1, operand, v1 uintptr
	_, _, _ = new1, operand, v1
	new1 = uintptr(0)
	v1 = _FcPopExpr(tls, parse)
	operand = v1
	if v1 != 0 {
		new1 = _FcExprCreateOp(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, operand, op, uintptr(0))
		if !(new1 != 0) {
			_FcExprDestroy(tls, operand)
			_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		}
	}
	return new1
}

func _FcParseUnary(tls *libc.TLS, parse uintptr, op TFcOp) {
	var expr uintptr
	_ = expr
	expr = _FcPopUnary(tls, parse, op)
	if expr != 0 {
		_FcVStackPushExpr(tls, parse, int32(_FcVStackExpr), expr)
	}
}

func _FcParseDir(tls *libc.TLS, parse uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var attr, data, l, prefix, prefix_dirs, salt, v1 uintptr
	_, _, _, _, _, _, _ = attr, data, l, prefix, prefix_dirs, salt, v1
	prefix_dirs = libc.UintptrFromInt32(0)
	data = XFcStrBufDoneStatic(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	if !(data != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		return
	}
	if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(data))) == 0 {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8104, 0)
		return
	}
	attr = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8012)
	salt = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8019)
	prefix_dirs = __get_real_paths_from_prefix(tls, parse, data, attr)
	if prefix_dirs != 0 {
		l = XFcStrListCreate(tls, prefix_dirs)
		XFcStrSetDestroy(tls, prefix_dirs)
		for {
			v1 = XFcStrListNext(tls, l)
			prefix = v1
			if !(v1 != 0) {
				break
			}
			if !(prefix != 0) || libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(prefix))) == 0 {
				/* nop */
			} else {
				if !((*TFcConfigParse)(unsafe.Pointer(parse)).FscanOnly != 0) && (!(XFcStrUsesHome(tls, prefix) != 0) || XFcConfigHome(tls) != 0) {
					if !(XFcConfigAddFontDir(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, prefix, libc.UintptrFromInt32(0), salt) != 0) {
						_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+8138, libc.VaList(bp+8, prefix))
					}
				}
			}
			XFcStrBufDestroy(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
		}
		XFcStrListDone(tls, l)
	}
}

func _FcParseCacheDir(tls *libc.TLS, parse uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var attr, data, p, prefix uintptr
	var dlen, plen Tsize_t
	_, _, _, _, _, _ = attr, data, dlen, p, plen, prefix
	prefix = libc.UintptrFromInt32(0)
	data = libc.UintptrFromInt32(0)
	attr = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8012)
	if attr != 0 && XFcStrCmp(tls, attr, __ccgo_ts+7239) == 0 {
		prefix = XFcConfigXdgCacheHome(tls)
		/* home directory might be disabled.
		 * simply ignore this element.
		 */
		if !(prefix != 0) {
			goto bail
		}
	}
	data = XFcStrBufDone(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	if !(data != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		data = prefix
		goto bail
	}
	if libc.Int32FromUint8(*(*TFcChar8)(unsafe.Pointer(data))) == 0 {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8177, 0)
		XFcStrFree(tls, data)
		data = prefix
		goto bail
	}
	if prefix != 0 {
		plen = libc.Xstrlen(tls, prefix)
		dlen = libc.Xstrlen(tls, data)
		p = libc.Xrealloc(tls, prefix, plen+uint64(1)+dlen+uint64(1))
		if !(p != 0) {
			_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
			XFcStrFree(tls, prefix)
			goto bail
		}
		prefix = p
		*(*TFcChar8)(unsafe.Pointer(prefix + uintptr(plen))) = uint8('/')
		libc.X__builtin___memcpy_chk(tls, prefix+uintptr(plen+uint64(1)), data, dlen, ^t__predefined_size_t(0))
		*(*TFcChar8)(unsafe.Pointer(prefix + uintptr(plen+uint64(1)+dlen))) = uint8(0)
		XFcStrFree(tls, data)
		data = prefix
	}
	if libc.Xstrlen(tls, data) == uint64(0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8177, 0)
	} else {
		if !((*TFcConfigParse)(unsafe.Pointer(parse)).FscanOnly != 0) && (!(XFcStrUsesHome(tls, data) != 0) || XFcConfigHome(tls) != 0) {
			if !(XFcConfigAddCacheDir(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, data) != 0) {
				_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+8212, libc.VaList(bp+8, data))
			}
		}
	}
	XFcStrBufDestroy(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	goto bail
bail:
	;
	if data != 0 {
		XFcStrFree(tls, data)
	}
}

func XFcConfigPathFini(tls *libc.TLS) {
	var s uintptr
	var v1, v2 int32
	_, _, _ = s, v1, v2
	goto retry_dir
retry_dir:
	;
	s = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&___fc_userdir))))
	if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&___fc_userdir)))) == s {
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&___fc_userdir)))) = libc.UintptrFromInt32(0)
		v1 = libc.Int32FromInt32(m_FcTrue)
	} else {
		v1 = m_FcFalse
	}
	if !(v1 != 0) {
		goto retry_dir
	}
	libc.Xfree(tls, s)
	goto retry_conf
retry_conf:
	;
	s = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&___fc_userconf))))
	if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&___fc_userconf)))) == s {
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&___fc_userconf)))) = libc.UintptrFromInt32(0)
		v2 = libc.Int32FromInt32(m_FcTrue)
	} else {
		v2 = m_FcFalse
	}
	if !(v2 != 0) {
		goto retry_conf
	}
	libc.Xfree(tls, s)
}

func _FcParseInclude(tls *libc.TLS, parse uintptr) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var attr, filename, p, parent, parent1, prefix, ruleset, s, u, userconf, userdir uintptr
	var deprecated, ignore_missing TFcBool
	var dlen, plen Tsize_t
	var k TFcMatchKind
	var v3, v6 int32
	var _ /* iter at bp+0 */ TFcPtrListIter
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = attr, deprecated, dlen, filename, ignore_missing, k, p, parent, parent1, plen, prefix, ruleset, s, u, userconf, userdir, v3, v6
	ignore_missing = m_FcFalse
	deprecated = m_FcFalse
	prefix = libc.UintptrFromInt32(0)
	userdir = libc.UintptrFromInt32(0)
	userconf = libc.UintptrFromInt32(0)
	s = XFcStrBufDoneStatic(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	if !(s != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		goto bail
	}
	attr = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8257)
	if attr != 0 && _FcConfigLexBool(tls, parse, attr) == int32(m_FcTrue) {
		ignore_missing = int32(m_FcTrue)
	}
	attr = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8272)
	if attr != 0 && _FcConfigLexBool(tls, parse, attr) == int32(m_FcTrue) {
		deprecated = int32(m_FcTrue)
	}
	attr = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8012)
	if attr != 0 && XFcStrCmp(tls, attr, __ccgo_ts+7239) == 0 {
		prefix = XFcConfigXdgConfigHome(tls)
		/* home directory might be disabled.
		 * simply ignore this element.
		 */
		if !(prefix != 0) {
			goto bail
		}
	}
	if prefix != 0 {
		plen = libc.Xstrlen(tls, prefix)
		dlen = libc.Xstrlen(tls, s)
		p = libc.Xrealloc(tls, prefix, plen+uint64(1)+dlen+uint64(1))
		if !(p != 0) {
			_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
			goto bail
		}
		prefix = p
		*(*TFcChar8)(unsafe.Pointer(prefix + uintptr(plen))) = uint8('/')
		libc.X__builtin___memcpy_chk(tls, prefix+uintptr(plen+uint64(1)), s, dlen, ^t__predefined_size_t(0))
		*(*TFcChar8)(unsafe.Pointer(prefix + uintptr(plen+uint64(1)+dlen))) = uint8(0)
		s = prefix
		if !(XFcFileIsDir(tls, s) != 0) {
			goto _1
		}
		goto userdir
	userdir:
		;
		userdir = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&___fc_userdir))))
		if !(userdir != 0) {
			u = libc.Xstrdup(tls, s)
			if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&___fc_userdir)))) == userdir {
				*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&___fc_userdir)))) = u
				v3 = libc.Int32FromInt32(m_FcTrue)
			} else {
				v3 = m_FcFalse
			}
			if !(v3 != 0) {
				libc.Xfree(tls, u)
				goto userdir
			}
			userdir = u
		}
		goto _2
	_1:
		;
		if !(XFcFileIsFile(tls, s) != 0) {
			goto _4
		}
		goto userconf
	userconf:
		;
		userconf = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&___fc_userconf))))
		if !(userconf != 0) {
			u = libc.Xstrdup(tls, s)
			if *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&___fc_userconf)))) == userconf {
				*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&___fc_userconf)))) = u
				v6 = libc.Int32FromInt32(m_FcTrue)
			} else {
				v6 = m_FcFalse
			}
			if !(v6 != 0) {
				libc.Xfree(tls, u)
				goto userconf
			}
			userconf = u
		}
		goto _5
	_4:
		;
		/* No config dir nor file on the XDG directory spec compliant place
		 * so need to guess what it is supposed to be.
		 */
		if XFcStrStr(tls, s, __ccgo_ts+8283) != libc.UintptrFromInt32(0) {
			goto userdir
		} else {
			goto userconf
		}
	_5:
		;
	_2:
	}
	/* flush the ruleset into the queue */
	ruleset = (*TFcConfigParse)(unsafe.Pointer(parse)).Fruleset
	(*TFcConfigParse)(unsafe.Pointer(parse)).Fruleset = XFcRuleSetCreate(tls, (*TFcRuleSet)(unsafe.Pointer(ruleset)).Fname)
	XFcRuleSetEnable(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fruleset, (*TFcRuleSet)(unsafe.Pointer(ruleset)).Fenabled)
	XFcRuleSetAddDescription(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fruleset, (*TFcRuleSet)(unsafe.Pointer(ruleset)).Fdomain, (*TFcRuleSet)(unsafe.Pointer(ruleset)).Fdescription)
	k = int32(_FcMatchKindBegin)
	for {
		if !(k < int32(_FcMatchKindEnd)) {
			break
		}
		XFcPtrListIterInit(tls, *(*uintptr)(unsafe.Pointer(ruleset + 40 + uintptr(k)*8)), bp)
		if XFcPtrListIterIsValid(tls, *(*uintptr)(unsafe.Pointer(ruleset + 40 + uintptr(k)*8)), bp) != 0 {
			XFcPtrListIterInitAtLast(tls, *(*uintptr)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig + 40 + uintptr(k)*8)), bp)
			XFcRuleSetReference(tls, ruleset)
			XFcPtrListIterAdd(tls, *(*uintptr)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig + 40 + uintptr(k)*8)), bp, ruleset)
		}
		goto _7
	_7:
		;
		k++
	}
	XFcRuleSetDestroy(tls, ruleset)
	if !(__FcConfigParse(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, s, libc.BoolInt32(!(ignore_missing != 0)), libc.BoolInt32(!((*TFcConfigParse)(unsafe.Pointer(parse)).FscanOnly != 0))) != 0) {
		(*TFcConfigParse)(unsafe.Pointer(parse)).Ferror1 = int32(m_FcTrue)
	} else {
		filename = XFcConfigGetFilename(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, s)
		if deprecated == int32(m_FcTrue) && filename != libc.UintptrFromInt32(0) && userdir != libc.UintptrFromInt32(0) && !(XFcFileIsLink(tls, filename) != 0) {
			if XFcFileIsDir(tls, filename) != 0 {
				parent = XFcStrDirname(tls, userdir)
				if !(XFcFileIsDir(tls, parent) != 0) {
					XFcMakeDirectory(tls, parent)
				}
				XFcStrFree(tls, parent)
				if XFcFileIsDir(tls, userdir) != 0 || libc.Xrename(tls, filename, userdir) != 0 || libc.Xsymlink(tls, userdir, filename) != 0 {
					if !(_warn_confd != 0) {
						_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8290, libc.VaList(bp+32, s, userdir))
						_warn_confd = int32(m_FcTrue)
					}
				}
			} else {
				parent1 = XFcStrDirname(tls, userconf)
				if !(XFcFileIsDir(tls, parent1) != 0) {
					XFcMakeDirectory(tls, parent1)
				}
				XFcStrFree(tls, parent1)
				if XFcFileIsFile(tls, userconf) != 0 || libc.Xrename(tls, filename, userconf) != 0 || libc.Xsymlink(tls, userconf, filename) != 0 {
					if !(_warn_conf != 0) {
						_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8290, libc.VaList(bp+32, s, userconf))
						_warn_conf = int32(m_FcTrue)
					}
				}
			}
		}
		if filename != 0 {
			XFcStrFree(tls, filename)
		}
	}
	XFcStrBufDestroy(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	goto bail
bail:
	;
	if prefix != 0 {
		XFcStrFree(tls, prefix)
	}
}

var _warn_conf TFcBool

var _warn_confd TFcBool

type TFcOpMap = struct {
	Fname [16]int8
	Fop   TFcOp
}

type T_FcOpMap = TFcOpMap

func _FcConfigLexOp(tls *libc.TLS, op uintptr, map1 uintptr, nmap int32) (r TFcOp) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < nmap) {
			break
		}
		if !(libc.Xstrcmp(tls, op, map1+uintptr(i)*20) != 0) {
			return (*(*TFcOpMap)(unsafe.Pointer(map1 + uintptr(i)*20))).Fop
		}
		goto _1
	_1:
		;
		i++
	}
	return int32(_FcOpInvalid)
}

var _fcCompareOps = [8]TFcOpMap{
	0: {
		Fname: [16]int8{'e', 'q'},
		Fop:   int32(_FcOpEqual),
	},
	1: {
		Fname: [16]int8{'n', 'o', 't', '_', 'e', 'q'},
		Fop:   int32(_FcOpNotEqual),
	},
	2: {
		Fname: [16]int8{'l', 'e', 's', 's'},
		Fop:   int32(_FcOpLess),
	},
	3: {
		Fname: [16]int8{'l', 'e', 's', 's', '_', 'e', 'q'},
		Fop:   int32(_FcOpLessEqual),
	},
	4: {
		Fname: [16]int8{'m', 'o', 'r', 'e'},
		Fop:   int32(_FcOpMore),
	},
	5: {
		Fname: [16]int8{'m', 'o', 'r', 'e', '_', 'e', 'q'},
		Fop:   int32(_FcOpMoreEqual),
	},
	6: {
		Fname: [16]int8{'c', 'o', 'n', 't', 'a', 'i', 'n', 's'},
		Fop:   int32(_FcOpContains),
	},
	7: {
		Fname: [16]int8{'n', 'o', 't', '_', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's'},
		Fop:   int32(_FcOpNotContains),
	},
}

func _FcConfigLexCompare(tls *libc.TLS, compare uintptr) (r TFcOp) {
	return _FcConfigLexOp(tls, compare, uintptr(unsafe.Pointer(&_fcCompareOps)), libc.Int32FromUint64(libc.Uint64FromInt64(160)/libc.Uint64FromInt64(20)))
}

func _FcParseTest(tls *libc.TLS, parse uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var compare TFcOp
	var compare_string, expr, iblanks_string, kind_string, name, qual_string, test uintptr
	var flags int32
	var kind TFcMatchKind
	var qual TFcQual
	var _ /* f at bp+0 */ TFcBool
	_, _, _, _, _, _, _, _, _, _, _ = compare, compare_string, expr, flags, iblanks_string, kind, kind_string, name, qual, qual_string, test
	flags = 0
	kind_string = _FcConfigGetAttribute(tls, parse, __ccgo_ts+7450)
	if !(kind_string != 0) {
		kind = -libc.Int32FromInt32(1)
	} else {
		if !(libc.Xstrcmp(tls, kind_string, __ccgo_ts+7457) != 0) {
			kind = int32(_FcMatchPattern)
		} else {
			if !(libc.Xstrcmp(tls, kind_string, __ccgo_ts+7465) != 0) {
				kind = int32(_FcMatchFont)
			} else {
				if !(libc.Xstrcmp(tls, kind_string, __ccgo_ts+8366) != 0) {
					kind = int32(_FcMatchScan)
				} else {
					if !(libc.Xstrcmp(tls, kind_string, __ccgo_ts+7243) != 0) {
						kind = -libc.Int32FromInt32(1)
					} else {
						_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8371, libc.VaList(bp+16, kind_string))
						return
					}
				}
			}
		}
	}
	qual_string = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8396)
	if !(qual_string != 0) {
		qual = int32(_FcQualAny)
	} else {
		if !(libc.Xstrcmp(tls, qual_string, __ccgo_ts+8401) != 0) {
			qual = int32(_FcQualAny)
		} else {
			if !(libc.Xstrcmp(tls, qual_string, __ccgo_ts+8405) != 0) {
				qual = int32(_FcQualAll)
			} else {
				if !(libc.Xstrcmp(tls, qual_string, __ccgo_ts+8409) != 0) {
					qual = int32(_FcQualFirst)
				} else {
					if !(libc.Xstrcmp(tls, qual_string, __ccgo_ts+8415) != 0) {
						qual = int32(_FcQualNotFirst)
					} else {
						_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8425, libc.VaList(bp+16, qual_string))
						return
					}
				}
			}
		}
	}
	name = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8448)
	if !(name != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8453, 0)
		return
	}
	compare_string = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8471)
	if !(compare_string != 0) {
		compare = int32(_FcOpEqual)
	} else {
		compare = _FcConfigLexCompare(tls, compare_string)
		if compare == int32(_FcOpInvalid) {
			_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8479, libc.VaList(bp+16, compare_string))
			return
		}
	}
	iblanks_string = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8505)
	if iblanks_string != 0 {
		*(*TFcBool)(unsafe.Pointer(bp)) = m_FcFalse
		if !(XFcNameBool(tls, iblanks_string, bp) != 0) {
			_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8519, libc.VaList(bp+16, iblanks_string))
		}
		if *(*TFcBool)(unsafe.Pointer(bp)) != 0 {
			flags |= int32(_FcOpFlagIgnoreBlanks)
		}
	}
	expr = _FcPopBinary(tls, parse, int32(_FcOpComma))
	if !(expr != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8551, 0)
		return
	}
	if (*TFcExpr)(unsafe.Pointer(expr)).Fop == int32(_FcOpComma) {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8575, 0)
	}
	test = _FcTestCreate(tls, parse, kind, qual, name, libc.Uint32FromInt32(compare&libc.Int32FromInt32(0xffff)|flags<<libc.Int32FromInt32(16)), expr)
	if !(test != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		return
	}
	_FcVStackPushTest(tls, parse, test)
}

var _fcModeOps = [8]TFcOpMap{
	0: {
		Fname: [16]int8{'a', 's', 's', 'i', 'g', 'n'},
		Fop:   int32(_FcOpAssign),
	},
	1: {
		Fname: [16]int8{'a', 's', 's', 'i', 'g', 'n', '_', 'r', 'e', 'p', 'l', 'a', 'c', 'e'},
		Fop:   int32(_FcOpAssignReplace),
	},
	2: {
		Fname: [16]int8{'p', 'r', 'e', 'p', 'e', 'n', 'd'},
		Fop:   int32(_FcOpPrepend),
	},
	3: {
		Fname: [16]int8{'p', 'r', 'e', 'p', 'e', 'n', 'd', '_', 'f', 'i', 'r', 's', 't'},
		Fop:   int32(_FcOpPrependFirst),
	},
	4: {
		Fname: [16]int8{'a', 'p', 'p', 'e', 'n', 'd'},
		Fop:   int32(_FcOpAppend),
	},
	5: {
		Fname: [16]int8{'a', 'p', 'p', 'e', 'n', 'd', '_', 'l', 'a', 's', 't'},
		Fop:   int32(_FcOpAppendLast),
	},
	6: {
		Fname: [16]int8{'d', 'e', 'l', 'e', 't', 'e'},
		Fop:   int32(_FcOpDelete),
	},
	7: {
		Fname: [16]int8{'d', 'e', 'l', 'e', 't', 'e', '_', 'a', 'l', 'l'},
		Fop:   int32(_FcOpDeleteAll),
	},
}

func _FcConfigLexMode(tls *libc.TLS, mode uintptr) (r TFcOp) {
	return _FcConfigLexOp(tls, mode, uintptr(unsafe.Pointer(&_fcModeOps)), libc.Int32FromUint64(libc.Uint64FromInt64(160)/libc.Uint64FromInt64(20)))
}

func _FcParseEdit(tls *libc.TLS, parse uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var edit, expr, mode_string, name uintptr
	var mode TFcOp
	var _ /* binding at bp+0 */ TFcValueBinding
	_, _, _, _, _ = edit, expr, mode, mode_string, name
	name = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8448)
	if !(name != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8653, 0)
		return
	}
	mode_string = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8671)
	if !(mode_string != 0) {
		mode = int32(_FcOpAssign)
	} else {
		mode = _FcConfigLexMode(tls, mode_string)
		if mode == int32(_FcOpInvalid) {
			_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8676, libc.VaList(bp+16, mode_string))
			return
		}
	}
	if !(_FcConfigLexBinding(tls, parse, _FcConfigGetAttribute(tls, parse, __ccgo_ts+7801), bp) != 0) {
		return
	}
	expr = _FcPopBinary(tls, parse, int32(_FcOpComma))
	if (mode == int32(_FcOpDelete) || mode == int32(_FcOpDeleteAll)) && expr != libc.UintptrFromInt32(0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8699, 0)
		_FcExprDestroy(tls, expr)
		expr = libc.UintptrFromInt32(0)
	}
	edit = _FcEditCreate(tls, parse, XFcObjectFromName(tls, name), mode, expr, *(*TFcValueBinding)(unsafe.Pointer(bp)))
	if !(edit != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		_FcExprDestroy(tls, expr)
		return
	}
	if !(_FcVStackPushEdit(tls, parse, edit) != 0) {
		XFcEditDestroy(tls, edit)
	}
}

func _FcParseMatch(tls *libc.TLS, parse uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var kind TFcMatchKind
	var kind_name, r, rule, vstack, v1 uintptr
	var n, v2 int32
	_, _, _, _, _, _, _, _ = kind, kind_name, n, r, rule, vstack, v1, v2
	rule = libc.UintptrFromInt32(0)
	kind_name = _FcConfigGetAttribute(tls, parse, __ccgo_ts+7450)
	if !(kind_name != 0) {
		kind = int32(_FcMatchPattern)
	} else {
		if !(libc.Xstrcmp(tls, kind_name, __ccgo_ts+7457) != 0) {
			kind = int32(_FcMatchPattern)
		} else {
			if !(libc.Xstrcmp(tls, kind_name, __ccgo_ts+7465) != 0) {
				kind = int32(_FcMatchFont)
			} else {
				if !(libc.Xstrcmp(tls, kind_name, __ccgo_ts+8366) != 0) {
					kind = int32(_FcMatchScan)
				} else {
					_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8761, libc.VaList(bp+8, kind_name))
					return
				}
			}
		}
	}
	for {
		v1 = _FcVStackPeek(tls, parse)
		vstack = v1
		if !(v1 != 0) {
			break
		}
		switch (*TFcVStack)(unsafe.Pointer(vstack)).Ftag {
		case int32(_FcVStackTest):
			r = _FcRuleCreate(tls, int32(_FcRuleTest), *(*uintptr)(unsafe.Pointer(vstack + 24)))
			if rule != 0 {
				(*TFcRule)(unsafe.Pointer(r)).Fnext = rule
			}
			rule = r
			(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackNone)
		case int32(_FcVStackEdit):
			if kind == int32(_FcMatchScan) && (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(vstack + 24)))).Fobject > int32(_FC_ONE_AFTER_MAX_BASE_OBJECT)-libc.Int32FromInt32(1) {
				_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+8787, libc.VaList(bp+8, XFcObjectName(tls, (*TFcEdit)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(vstack + 24)))).Fobject)))
				if rule != 0 {
					XFcRuleDestroy(tls, rule)
				}
				return
			}
			r = _FcRuleCreate(tls, int32(_FcRuleEdit), *(*uintptr)(unsafe.Pointer(vstack + 24)))
			if rule != 0 {
				(*TFcRule)(unsafe.Pointer(r)).Fnext = rule
			}
			rule = r
			(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackNone)
		default:
			_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8846, 0)
			break
		}
		_FcVStackPopAndDestroy(tls, parse)
	}
	if !(rule != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8868, 0)
		return
	}
	v2 = XFcRuleSetAdd(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fruleset, rule, kind)
	n = v2
	if v2 == -int32(1) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		XFcRuleDestroy(tls, rule)
	} else {
		if (*TFcConfig)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig)).FmaxObjects < n {
			(*TFcConfig)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig)).FmaxObjects = n
		}
	}
}

func _FcParseAcceptRejectFont(tls *libc.TLS, parse uintptr, element TFcElement) {
	var vstack, v1 uintptr
	_, _ = vstack, v1
	for {
		v1 = _FcVStackPeek(tls, parse)
		vstack = v1
		if !(v1 != 0) {
			break
		}
		switch (*TFcVStack)(unsafe.Pointer(vstack)).Ftag {
		case int32(_FcVStackGlob):
			if !((*TFcConfigParse)(unsafe.Pointer(parse)).FscanOnly != 0) && !(XFcConfigGlobAdd(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, *(*uintptr)(unsafe.Pointer(vstack + 24)), libc.BoolInt32(element == int32(_FcElementAcceptfont))) != 0) {
				_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
			} else {
				if (*TFcConfigParse)(unsafe.Pointer(parse)).FscanOnly != 0 && *(*uintptr)(unsafe.Pointer(vstack + 24)) != 0 {
					XFcStrFree(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
					(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackNone)
				}
			}
		case int32(_FcVStackPattern):
			if !((*TFcConfigParse)(unsafe.Pointer(parse)).FscanOnly != 0) && !(XFcConfigPatternsAdd(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fconfig, *(*uintptr)(unsafe.Pointer(vstack + 24)), libc.BoolInt32(element == int32(_FcElementAcceptfont))) != 0) {
				_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
			} else {
				if (*TFcConfigParse)(unsafe.Pointer(parse)).FscanOnly != 0 && *(*uintptr)(unsafe.Pointer(vstack + 24)) != 0 {
					XFcPatternDestroy(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
				}
				(*TFcVStack)(unsafe.Pointer(vstack)).Ftag = int32(_FcVStackNone)
			}
		default:
			_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8909, 0)
			break
		}
		_FcVStackPopAndDestroy(tls, parse)
	}
}

func _FcPopValue(tls *libc.TLS, parse uintptr) (r TFcValue) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var vstack uintptr
	var _ /* value at bp+0 */ TFcValue
	_ = vstack
	vstack = _FcVStackPeek(tls, parse)
	(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeVoid)
	if !(vstack != 0) {
		return *(*TFcValue)(unsafe.Pointer(bp))
	}
	switch (*TFcVStack)(unsafe.Pointer(vstack)).Ftag {
	case int32(_FcVStackString):
		*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.Xstrdup(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
		if *(*uintptr)(unsafe.Pointer(bp + 8)) != 0 {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeString)
		}
	case int32(_FcVStackConstant):
		if XFcNameConstant(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)), bp+8) != 0 {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeInteger)
		}
	case int32(_FcVStackInteger):
		*(*int32)(unsafe.Pointer(bp + 8)) = *(*int32)(unsafe.Pointer(&(*TFcVStack)(unsafe.Pointer(vstack)).Fu))
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeInteger)
	case int32(_FcVStackDouble):
		*(*float64)(unsafe.Pointer(bp + 8)) = *(*float64)(unsafe.Pointer(vstack + 24))
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeDouble)
	case int32(_FcVStackBool):
		*(*TFcBool)(unsafe.Pointer(bp + 8)) = *(*TFcBool)(unsafe.Pointer(&(*TFcVStack)(unsafe.Pointer(vstack)).Fu))
		(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeBool)
	case int32(_FcVStackCharSet):
		*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcCharSetCopy(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
		if *(*uintptr)(unsafe.Pointer(bp + 8)) != 0 {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeCharSet)
		}
	case int32(_FcVStackLangSet):
		*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcLangSetCopy(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
		if *(*uintptr)(unsafe.Pointer(bp + 8)) != 0 {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeLangSet)
		}
	case int32(_FcVStackRange):
		*(*uintptr)(unsafe.Pointer(bp + 8)) = XFcRangeCopy(tls, *(*uintptr)(unsafe.Pointer(vstack + 24)))
		if *(*uintptr)(unsafe.Pointer(bp + 8)) != 0 {
			(*(*TFcValue)(unsafe.Pointer(bp))).Ftype1 = int32(_FcTypeRange)
		}
	default:
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8927, libc.VaList(bp+24, (*TFcVStack)(unsafe.Pointer(vstack)).Ftag))
		break
	}
	_FcVStackPopAndDestroy(tls, parse)
	return *(*TFcValue)(unsafe.Pointer(bp))
}

func _FcParsePatelt(tls *libc.TLS, parse uintptr) {
	var name, pattern uintptr
	var value TFcValue
	_, _, _ = name, pattern, value
	pattern = XFcPatternCreate(tls)
	if !(pattern != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		return
	}
	name = _FcConfigGetAttribute(tls, parse, __ccgo_ts+8448)
	if !(name != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8954, 0)
		XFcPatternDestroy(tls, pattern)
		return
	}
	for {
		value = _FcPopValue(tls, parse)
		if value.Ftype1 == int32(_FcTypeVoid) {
			break
		}
		if !(XFcPatternAdd(tls, pattern, name, value, int32(m_FcTrue)) != 0) {
			_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
			XFcValueDestroy(tls, value)
			break
		}
		XFcValueDestroy(tls, value)
		goto _1
	_1:
	}
	_FcVStackPushPattern(tls, parse, pattern)
}

func _FcParsePattern(tls *libc.TLS, parse uintptr) {
	var pattern, vstack, v1 uintptr
	_, _, _ = pattern, vstack, v1
	pattern = XFcPatternCreate(tls)
	if !(pattern != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
		return
	}
	for {
		v1 = _FcVStackPeek(tls, parse)
		vstack = v1
		if !(v1 != 0) {
			break
		}
		switch (*TFcVStack)(unsafe.Pointer(vstack)).Ftag {
		case int32(_FcVStackPattern):
			if !(XFcPatternAppend(tls, pattern, *(*uintptr)(unsafe.Pointer(vstack + 24))) != 0) {
				_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
				XFcPatternDestroy(tls, pattern)
				return
			}
		default:
			_FcConfigMessage(tls, parse, int32(_FcSevereWarning), __ccgo_ts+8983, 0)
			break
		}
		_FcVStackPopAndDestroy(tls, parse)
	}
	_FcVStackPushPattern(tls, parse, pattern)
}

func _FcEndElement(tls *libc.TLS, userData uintptr, name uintptr) {
	var data, parse uintptr
	_, _ = data, parse
	parse = userData
	if !((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack != 0) {
		return
	}
	switch (*TFcPStack)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack)).Felement {
	case int32(_FcElementNone):
	case int32(_FcElementFontconfig):
	case int32(_FcElementDir):
		_FcParseDir(tls, parse)
	case int32(_FcElementCacheDir):
		_FcParseCacheDir(tls, parse)
	case int32(_FcElementCache):
		data = XFcStrBufDoneStatic(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
		if !(data != 0) {
			_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
			break
		}
		/* discard this data; no longer used */
		XFcStrBufDestroy(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24)
	case int32(_FcElementInclude):
		_FcParseInclude(tls, parse)
	case int32(_FcElementConfig):
	case int32(_FcElementMatch):
		_FcParseMatch(tls, parse)
	case int32(_FcElementAlias):
		_FcParseAlias(tls, parse)
	case int32(_FcElementDescription):
		_FcParseDescription(tls, parse)
	case int32(_FcElementRemapDir):
		_FcParseRemapDir(tls, parse)
	case int32(_FcElementResetDirs):
		_FcParseResetDirs(tls, parse)
	case int32(_FcElementRescan):
		_FcParseRescan(tls, parse)
	case int32(_FcElementPrefer):
		_FcParseFamilies(tls, parse, int32(_FcVStackPrefer))
	case int32(_FcElementAccept):
		_FcParseFamilies(tls, parse, int32(_FcVStackAccept))
	case int32(_FcElementDefault):
		_FcParseFamilies(tls, parse, int32(_FcVStackDefault))
	case int32(_FcElementFamily):
		_FcParseFamily(tls, parse)
	case int32(_FcElementTest):
		_FcParseTest(tls, parse)
	case int32(_FcElementEdit):
		_FcParseEdit(tls, parse)
	case int32(_FcElementInt):
		_FcParseInt(tls, parse)
	case int32(_FcElementDouble):
		_FcParseDouble(tls, parse)
	case int32(_FcElementString):
		_FcParseString(tls, parse, int32(_FcVStackString))
	case int32(_FcElementMatrix):
		_FcParseMatrix(tls, parse)
	case int32(_FcElementRange):
		_FcParseRange(tls, parse)
	case int32(_FcElementBool):
		_FcParseBool(tls, parse)
	case int32(_FcElementCharSet):
		_FcParseCharSet(tls, parse)
	case int32(_FcElementLangSet):
		_FcParseLangSet(tls, parse)
	case int32(_FcElementSelectfont):
	case int32(_FcElementAcceptfont):
		fallthrough
	case int32(_FcElementRejectfont):
		_FcParseAcceptRejectFont(tls, parse, (*TFcPStack)(unsafe.Pointer((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack)).Felement)
	case int32(_FcElementGlob):
		_FcParseString(tls, parse, int32(_FcVStackGlob))
	case int32(_FcElementPattern):
		_FcParsePattern(tls, parse)
	case int32(_FcElementPatelt):
		_FcParsePatelt(tls, parse)
	case int32(_FcElementName):
		_FcParseName(tls, parse)
	case int32(_FcElementConst):
		_FcParseString(tls, parse, int32(_FcVStackConstant))
	case int32(_FcElementOr):
		_FcParseBinary(tls, parse, int32(_FcOpOr))
	case int32(_FcElementAnd):
		_FcParseBinary(tls, parse, int32(_FcOpAnd))
	case int32(_FcElementEq):
		_FcParseBinary(tls, parse, int32(_FcOpEqual))
	case int32(_FcElementNotEq):
		_FcParseBinary(tls, parse, int32(_FcOpNotEqual))
	case int32(_FcElementLess):
		_FcParseBinary(tls, parse, int32(_FcOpLess))
	case int32(_FcElementLessEq):
		_FcParseBinary(tls, parse, int32(_FcOpLessEqual))
	case int32(_FcElementMore):
		_FcParseBinary(tls, parse, int32(_FcOpMore))
	case int32(_FcElementMoreEq):
		_FcParseBinary(tls, parse, int32(_FcOpMoreEqual))
	case int32(_FcElementContains):
		_FcParseBinary(tls, parse, int32(_FcOpContains))
	case int32(_FcElementNotContains):
		_FcParseBinary(tls, parse, int32(_FcOpNotContains))
	case int32(_FcElementPlus):
		_FcParseBinary(tls, parse, int32(_FcOpPlus))
	case int32(_FcElementMinus):
		_FcParseBinary(tls, parse, int32(_FcOpMinus))
	case int32(_FcElementTimes):
		_FcParseBinary(tls, parse, int32(_FcOpTimes))
	case int32(_FcElementDivide):
		_FcParseBinary(tls, parse, int32(_FcOpDivide))
	case int32(_FcElementNot):
		_FcParseUnary(tls, parse, int32(_FcOpNot))
	case int32(_FcElementIf):
		_FcParseBinary(tls, parse, int32(_FcOpQuest))
	case int32(_FcElementFloor):
		_FcParseUnary(tls, parse, int32(_FcOpFloor))
	case int32(_FcElementCeil):
		_FcParseUnary(tls, parse, int32(_FcOpCeil))
	case int32(_FcElementRound):
		_FcParseUnary(tls, parse, int32(_FcOpRound))
	case int32(_FcElementTrunc):
		_FcParseUnary(tls, parse, int32(_FcOpTrunc))
	case int32(_FcElementUnknown):
		break
	}
	_FcPStackPop(tls, parse)
}

func _FcCharacterData(tls *libc.TLS, userData uintptr, s uintptr, len1 int32) {
	var parse uintptr
	_ = parse
	parse = userData
	if !((*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack != 0) {
		return
	}
	if !(XFcStrBufData(tls, (*TFcConfigParse)(unsafe.Pointer(parse)).Fpstack+24, s, len1) != 0) {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+7182, 0)
	}
}

func _FcStartDoctypeDecl(tls *libc.TLS, userData uintptr, doctypeName uintptr, sysid uintptr, pubid uintptr, has_internal_subset int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var parse uintptr
	_ = parse
	parse = userData
	if libc.Xstrcmp(tls, doctypeName, __ccgo_ts+9007) != 0 {
		_FcConfigMessage(tls, parse, int32(_FcSevereError), __ccgo_ts+9018, libc.VaList(bp+8, doctypeName))
	}
}

func _FcEndDoctypeDecl(tls *libc.TLS, userData uintptr) {
}

func _FcSortCmpStr(tls *libc.TLS, a uintptr, b uintptr) (r int32) {
	var as, bs uintptr
	_, _ = as, bs
	as = *(*uintptr)(unsafe.Pointer(a))
	bs = *(*uintptr)(unsafe.Pointer(b))
	return XFcStrCmp(tls, as, bs)
}

func _FcConfigParseAndLoadDir(tls *libc.TLS, config uintptr, name uintptr, dir uintptr, complain TFcBool, load TFcBool) (r TFcBool) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var base, d, e, file, files, v1 uintptr
	var d_len, i int32
	var ret TFcBool
	var v2 bool
	_, _, _, _, _, _, _, _, _, _ = base, d, d_len, e, file, files, i, ret, v1, v2
	ret = int32(m_FcTrue)
	d = libc.Xopendir(tls, dir)
	if !(d != 0) {
		if complain != 0 {
			_FcConfigMessage(tls, uintptr(0), int32(_FcSevereError), __ccgo_ts+9039, libc.VaList(bp+8, name))
		}
		ret = m_FcFalse
		goto bail0
	}
	/* freed below */
	file = libc.Xmalloc(tls, libc.Xstrlen(tls, dir)+uint64(1)+uint64(m_FC_MAX_FILE_LEN)+uint64(1))
	if !(file != 0) {
		ret = m_FcFalse
		goto bail1
	}
	libc.X__builtin___strcpy_chk(tls, file, dir, ^t__predefined_size_t(0))
	libc.X__builtin___strcat_chk(tls, file, __ccgo_ts+1485, ^t__predefined_size_t(0))
	base = file + uintptr(libc.Xstrlen(tls, file))
	files = XFcStrSetCreateEx(tls, uint32(m_FCSS_GROW_BY_64))
	if !(files != 0) {
		ret = m_FcFalse
		goto bail2
	}
	if XFcDebugVal&int32(m_FC_DBG_CONFIG) != 0 {
		libc.Xprintf(tls, __ccgo_ts+9067, libc.VaList(bp+8, dir))
	}
	if load != 0 {
		XFcConfigAddConfigDir(tls, config, dir)
	}
	for {
		if v2 = ret != 0; v2 {
			v1 = libc.Xreaddir(tls, d)
			e = v1
		}
		if !(v2 && v1 != 0) {
			break
		}
		/*
		 * Add all files of the form [0-9]*.conf
		 */
		d_len = libc.Int32FromUint64(libc.Xstrlen(tls, e+21))
		if int32('0') <= int32(*(*int8)(unsafe.Pointer(e + 21))) && int32(*(*int8)(unsafe.Pointer(e + 21))) <= int32('9') && d_len > int32(m_TAIL_LEN) && libc.Xstrcmp(tls, e+21+uintptr(d_len)-uintptr(m_TAIL_LEN), __ccgo_ts+9092) == 0 {
			libc.X__builtin___strcpy_chk(tls, base, e+21, ^t__predefined_size_t(0))
			if !(XFcStrSetAdd(tls, files, file) != 0) {
				ret = m_FcFalse
				goto bail3
			}
		}
	}
	if ret != 0 {
		libc.Xqsort(tls, (*TFcStrSet)(unsafe.Pointer(files)).Fstrs, libc.Uint64FromInt32((*TFcStrSet)(unsafe.Pointer(files)).Fnum), uint64(8), __ccgo_fp(_FcSortCmpStr))
		i = 0
		for {
			if !(ret != 0 && i < (*TFcStrSet)(unsafe.Pointer(files)).Fnum) {
				break
			}
			ret = __FcConfigParse(tls, config, *(*uintptr)(unsafe.Pointer((*TFcStrSet)(unsafe.Pointer(files)).Fstrs + uintptr(i)*8)), complain, load)
			goto _3
		_3:
			;
			i++
		}
	}
	goto bail3
bail3:
	;
	XFcStrSetDestroy(tls, files)
	goto bail2
bail2:
	;
	libc.Xfree(tls, file)
	goto bail1
bail1:
	;
	libc.Xclosedir(tls, d)
	goto bail0
bail0:
	;
	return libc.BoolInt32(ret != 0 || !(complain != 0))
	return r
}

func _FcConfigParseAndLoadFromMemoryInternal(tls *libc.TLS, config uintptr, filename uintptr, buffer uintptr, complain TFcBool, load TFcBool) (r TFcBool) {
	bp := tls.Alloc(4640)
	defer tls.Free(4640)
	var buf, s, v1, v3, v4 uintptr
	var buflen, len1 Tsize_t
	var error1 TFcBool
	var k TFcMatchKind
	var p TXML_Parser
	var _ /* iter at bp+4584 */ TFcPtrListIter
	var _ /* liter at bp+4560 */ TFcPtrListIter
	var _ /* parse at bp+0 */ TFcConfigParse
	_, _, _, _, _, _, _, _, _, _ = buf, buflen, error1, k, len1, p, s, v1, v3, v4
	error1 = int32(m_FcTrue)
	if !(buffer != 0) {
		return m_FcFalse
	}
	len1 = libc.Xstrlen(tls, buffer)
	if XFcDebugVal&int32(m_FC_DBG_CONFIG) != 0 {
		if load != 0 {
			v1 = __ccgo_ts + 9098
		} else {
			v1 = __ccgo_ts + 9106
		}
		libc.Xprintf(tls, __ccgo_ts+9115, libc.VaList(bp+4616, v1, filename))
	}
	p = libexpat.XXML_ParserCreate(tls, __ccgo_ts+9140)
	if !(p != 0) {
		goto bail1
	}
	if !(_FcConfigParseInit(tls, bp, filename, config, p, load) != 0) {
		goto bail2
	}
	libexpat.XXML_SetUserData(tls, p, bp)
	libexpat.XXML_SetDoctypeDeclHandler(tls, p, __ccgo_fp(_FcStartDoctypeDecl), __ccgo_fp(_FcEndDoctypeDecl))
	libexpat.XXML_SetElementHandler(tls, p, __ccgo_fp(_FcStartElement), __ccgo_fp(_FcEndElement))
	libexpat.XXML_SetCharacterDataHandler(tls, p, __ccgo_fp(_FcCharacterData))
	s = buffer
	for cond := true; cond; cond = buflen != uint64(0) {
		buf = libexpat.XXML_GetBuffer(tls, p, int32(m_BUFSIZ))
		if !(buf != 0) {
			_FcConfigMessage(tls, bp, int32(_FcSevereError), __ccgo_ts+9146, 0)
			goto bail3
		}
		if len1 > uint64(m_BUFSIZ) {
			buflen = uint64(m_BUFSIZ)
			len1 -= uint64(m_BUFSIZ)
		} else {
			buflen = len1
			len1 = uint64(0)
		}
		libc.X__builtin___memcpy_chk(tls, buf, s, buflen, ^t__predefined_size_t(0))
		s = s + uintptr(buflen)
		if !(libexpat.XXML_ParseBuffer(tls, p, libc.Int32FromUint64(buflen), libc.BoolInt32(buflen == uint64(0))) != 0) {
			_FcConfigMessage(tls, bp, int32(_FcSevereError), __ccgo_ts+1991, libc.VaList(bp+4616, libexpat.XXML_ErrorString(tls, libexpat.XXML_GetErrorCode(tls, p))))
			goto bail3
		}
	}
	error1 = (*(*TFcConfigParse)(unsafe.Pointer(bp))).Ferror1
	if load != 0 {
		k = int32(_FcMatchKindBegin)
		for {
			if !(k < int32(_FcMatchKindEnd)) {
				break
			}
			XFcPtrListIterInit(tls, *(*uintptr)(unsafe.Pointer((*(*TFcConfigParse)(unsafe.Pointer(bp))).Fruleset + 40 + uintptr(k)*8)), bp+4584)
			if XFcPtrListIterIsValid(tls, *(*uintptr)(unsafe.Pointer((*(*TFcConfigParse)(unsafe.Pointer(bp))).Fruleset + 40 + uintptr(k)*8)), bp+4584) != 0 {
				XFcPtrListIterInitAtLast(tls, *(*uintptr)(unsafe.Pointer((*(*TFcConfigParse)(unsafe.Pointer(bp))).Fconfig + 40 + uintptr(k)*8)), bp+4584)
				XFcRuleSetReference(tls, (*(*TFcConfigParse)(unsafe.Pointer(bp))).Fruleset)
				XFcPtrListIterAdd(tls, *(*uintptr)(unsafe.Pointer((*(*TFcConfigParse)(unsafe.Pointer(bp))).Fconfig + 40 + uintptr(k)*8)), bp+4584, (*(*TFcConfigParse)(unsafe.Pointer(bp))).Fruleset)
			}
			goto _2
		_2:
			;
			k++
		}
	}
	XFcPtrListIterInitAtLast(tls, (*TFcConfig)(unsafe.Pointer((*(*TFcConfigParse)(unsafe.Pointer(bp))).Fconfig)).FrulesetList, bp+4560)
	XFcRuleSetReference(tls, (*(*TFcConfigParse)(unsafe.Pointer(bp))).Fruleset)
	XFcPtrListIterAdd(tls, (*TFcConfig)(unsafe.Pointer((*(*TFcConfigParse)(unsafe.Pointer(bp))).Fconfig)).FrulesetList, bp+4560, (*(*TFcConfigParse)(unsafe.Pointer(bp))).Fruleset)
	goto bail3
bail3:
	;
	_FcConfigCleanup(tls, bp)
	goto bail2
bail2:
	;
	libexpat.XXML_ParserFree(tls, p)
	goto bail1
bail1:
	;
	if error1 != 0 && complain != 0 {
		if load != 0 {
			v3 = __ccgo_ts + 9170
		} else {
			v3 = __ccgo_ts + 8366
		}
		_FcConfigMessage(tls, uintptr(0), int32(_FcSevereError), __ccgo_ts+9175, libc.VaList(bp+4616, v3, filename))
		return m_FcFalse
	}
	if XFcDebugVal&int32(m_FC_DBG_CONFIG) != 0 {
		if load != 0 {
			v4 = __ccgo_ts + 9098
		} else {
			v4 = __ccgo_ts + 9106
		}
		libc.Xprintf(tls, __ccgo_ts+9205, libc.VaList(bp+4616, v4, filename))
	}
	return int32(m_FcTrue)
}

func __FcConfigParse(tls *libc.TLS, config uintptr, name uintptr, complain TFcBool, load TFcBool) (r TFcBool) {
	bp := tls.Alloc(2400)
	defer tls.Free(2400)
	var complain_again, ret TFcBool
	var errno_, fd, len1 int32
	var filename, realfilename, v1, v2, v3, v4 uintptr
	var _ /* buf at bp+152 */ [1024]int8
	var _ /* ebuf at bp+1328 */ [1025]int8
	var _ /* reason at bp+1176 */ TFcStrBuf
	var _ /* sbuf at bp+0 */ TFcStrBuf
	_, _, _, _, _, _, _, _, _, _, _ = complain_again, errno_, fd, filename, len1, realfilename, ret, v1, v2, v3, v4
	filename = libc.UintptrFromInt32(0)
	realfilename = libc.UintptrFromInt32(0)
	ret = m_FcFalse
	complain_again = complain
	XFcStrBufInit(tls, bp+1176, libc.UintptrFromInt32(0), 0)
	filename = XFcConfigGetFilename(tls, config, name)
	if !(filename != 0) {
		XFcStrBufString(tls, bp+1176, __ccgo_ts+9235)
		if name != 0 {
			v1 = name
		} else {
			v1 = __ccgo_ts + 4341
		}
		XFcStrBufString(tls, bp+1176, v1)
		goto bail0
	}
	realfilename = XFcConfigRealFilename(tls, config, name)
	if !(realfilename != 0) {
		XFcStrBufString(tls, bp+1176, __ccgo_ts+9250)
		if name != 0 {
			v2 = name
		} else {
			v2 = __ccgo_ts + 4341
		}
		XFcStrBufString(tls, bp+1176, v2)
		goto bail0
	}
	if XFcStrSetMember(tls, (*TFcConfig)(unsafe.Pointer(config)).FavailConfigFiles, realfilename) != 0 {
		XFcStrFree(tls, filename)
		XFcStrFree(tls, realfilename)
		return int32(m_FcTrue)
	}
	if load != 0 {
		if !(XFcStrSetAdd(tls, (*TFcConfig)(unsafe.Pointer(config)).FconfigFiles, filename) != 0) {
			goto bail0
		}
	}
	if !(XFcStrSetAdd(tls, (*TFcConfig)(unsafe.Pointer(config)).FavailConfigFiles, realfilename) != 0) {
		goto bail0
	}
	if XFcFileIsDir(tls, realfilename) != 0 {
		ret = _FcConfigParseAndLoadDir(tls, config, name, realfilename, complain, load)
		XFcStrFree(tls, filename)
		XFcStrFree(tls, realfilename)
		return ret
	}
	XFcStrBufInit(tls, bp, libc.UintptrFromInt32(0), 0)
	fd = XFcOpen(tls, realfilename, m_O_RDONLY2, 0)
	if fd == -int32(1) {
		XFcStrBufString(tls, bp+1176, __ccgo_ts+9269)
		XFcStrBufString(tls, bp+1176, realfilename)
		goto bail1
	}
	for cond := true; cond; cond = len1 != 0 {
		len1 = int32(libc.Xread(tls, fd, bp+152, uint64(m_BUFSIZ)))
		if len1 < 0 {
			errno_ = *(*int32)(unsafe.Pointer(libc.X__error(tls)))
			libc.Xstrerror_r(tls, errno_, bp+1328, uint64(m_BUFSIZ))
			_FcConfigMessage(tls, uintptr(0), int32(_FcSevereError), __ccgo_ts+9285, libc.VaList(bp+2368, realfilename, bp+1328, errno_))
			libc.Xclose(tls, fd)
			goto bail1
		}
		XFcStrBufData(tls, bp, bp+152, len1)
	}
	libc.Xclose(tls, fd)
	ret = _FcConfigParseAndLoadFromMemoryInternal(tls, config, filename, XFcStrBufDoneStatic(tls, bp), complain, load)
	complain_again = m_FcFalse /* no need to reclaim here */
	goto bail1
bail1:
	;
	XFcStrBufDestroy(tls, bp)
	goto bail0
bail0:
	;
	if filename != 0 {
		XFcStrFree(tls, filename)
	}
	if realfilename != 0 {
		XFcStrFree(tls, realfilename)
	}
	if !(complain != 0) {
		return int32(m_FcTrue)
	}
	if !(ret != 0) && complain_again != 0 {
		if name != 0 {
			if load != 0 {
				v3 = __ccgo_ts + 9170
			} else {
				v3 = __ccgo_ts + 8366
			}
			_FcConfigMessage(tls, uintptr(0), int32(_FcSevereError), __ccgo_ts+9331, libc.VaList(bp+2368, v3, name, XFcStrBufDoneStatic(tls, bp+1176)))
		} else {
			if load != 0 {
				v4 = __ccgo_ts + 9170
			} else {
				v4 = __ccgo_ts + 8366
			}
			_FcConfigMessage(tls, uintptr(0), int32(_FcSevereError), __ccgo_ts+9362, libc.VaList(bp+2368, v4, XFcStrBufDoneStatic(tls, bp+1176)))
		}
		XFcStrBufDestroy(tls, bp+1176)
		return m_FcFalse
	}
	XFcStrBufDestroy(tls, bp+1176)
	return ret
}

func XFcConfigParseOnly(tls *libc.TLS, config uintptr, name uintptr, complain TFcBool) (r TFcBool) {
	return __FcConfigParse(tls, config, name, complain, m_FcFalse)
}

func XFcConfigParseAndLoad(tls *libc.TLS, config uintptr, name uintptr, complain TFcBool) (r TFcBool) {
	return __FcConfigParse(tls, config, name, complain, int32(m_FcTrue))
}

func XFcConfigParseAndLoadFromMemory(tls *libc.TLS, config uintptr, buffer uintptr, complain TFcBool) (r TFcBool) {
	return _FcConfigParseAndLoadFromMemoryInternal(tls, config, __ccgo_ts+9396, buffer, complain, int32(m_FcTrue))
}

const m_FC_DIR_SEPARATOR6 = '/'

// C documentation
//
//	/* only used internally */
func _ftglue_qalloc(tls *libc.TLS, memory TFT_Memory, size TFT_ULong, perror uintptr) (r TFT_Pointer) {
	var block TFT_Pointer
	var error1 TFT_Error
	_, _ = block, error1
	error1 = 0
	block = libc.UintptrFromInt32(0)
	if size > uint64(0) {
		block = (*(*func(*libc.TLS, TFT_Memory, int64) uintptr)(unsafe.Pointer(&struct{ uintptr }{(*TFT_MemoryRec_)(unsafe.Pointer(memory)).Falloc})))(tls, memory, libc.Int64FromUint64(size))
		if !(block != 0) {
			error1 = int32(_FT_Err_Out_Of_Memory)
		}
	}
	*(*TFT_Error)(unsafe.Pointer(perror)) = error1
	return block
}

func _ftglue_free(tls *libc.TLS, memory TFT_Memory, block TFT_Pointer) {
	if block != 0 {
		(*(*func(*libc.TLS, TFT_Memory, uintptr))(unsafe.Pointer(&struct{ uintptr }{(*TFT_MemoryRec_)(unsafe.Pointer(memory)).Ffree})))(tls, memory, block)
	}
}

func Xftglue_stream_pos(tls *libc.TLS, stream TFT_Stream) (r TFT_Long) {
	return libc.Int64FromUint64((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fpos)
}

func Xftglue_stream_seek(tls *libc.TLS, stream TFT_Stream, pos TFT_Long) (r TFT_Error) {
	var error1 TFT_Error
	_ = error1
	error1 = 0
	if (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fread != 0 {
		if (*(*func(*libc.TLS, TFT_Stream, uint64, uintptr, uint64) uint64)(unsafe.Pointer(&struct{ uintptr }{(*TFT_StreamRec_)(unsafe.Pointer(stream)).Fread})))(tls, stream, libc.Uint64FromInt64(pos), uintptr(0), uint64(0)) != 0 {
			error1 = int32(_FT_Err_Invalid_Stream_Operation)
		}
	} else {
		if pos < 0 || libc.Uint64FromInt64(pos) > (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fsize {
			error1 = int32(_FT_Err_Invalid_Stream_Operation)
		}
	}
	if !(error1 != 0) {
		(*TFT_StreamRec_)(unsafe.Pointer(stream)).Fpos = libc.Uint64FromInt64(pos)
	}
	return error1
}

func Xftglue_stream_frame_enter(tls *libc.TLS, stream TFT_Stream, count TFT_ULong) (r TFT_Error) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var memory TFT_Memory
	var read_bytes TFT_ULong
	var _ /* error at bp+0 */ TFT_Error
	_, _ = memory, read_bytes
	*(*TFT_Error)(unsafe.Pointer(bp)) = int32(_FT_Err_Ok)
	if (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fread != 0 {
		/* allocate the frame in memory */
		memory = (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fmemory
		(*TFT_StreamRec_)(unsafe.Pointer(stream)).Fbase = _ftglue_qalloc(tls, memory, count, bp)
		if *(*TFT_Error)(unsafe.Pointer(bp)) != libc.Int32FromInt32(0) {
			goto Exit
		}
		/* read it */
		read_bytes = (*(*func(*libc.TLS, TFT_Stream, uint64, uintptr, uint64) uint64)(unsafe.Pointer(&struct{ uintptr }{(*TFT_StreamRec_)(unsafe.Pointer(stream)).Fread})))(tls, stream, (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fpos, (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fbase, count)
		if read_bytes < count {
			if (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fbase != 0 {
				_ftglue_free(tls, memory, (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fbase)
				(*TFT_StreamRec_)(unsafe.Pointer(stream)).Fbase = libc.UintptrFromInt32(0)
			}
			*(*TFT_Error)(unsafe.Pointer(bp)) = int32(_FT_Err_Invalid_Stream_Operation)
		}
		(*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor = (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fbase
		(*TFT_StreamRec_)(unsafe.Pointer(stream)).Flimit = (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor + uintptr(count)
		*(*uint64)(unsafe.Pointer(stream + 16)) += read_bytes
	} else {
		/* check current and new position */
		if (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fpos >= (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fsize || (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fpos+count > (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fsize {
			*(*TFT_Error)(unsafe.Pointer(bp)) = int32(_FT_Err_Invalid_Stream_Operation)
			goto Exit
		}
		/* set cursor */
		(*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor = (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fbase + uintptr((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fpos)
		(*TFT_StreamRec_)(unsafe.Pointer(stream)).Flimit = (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor + uintptr(count)
		*(*uint64)(unsafe.Pointer(stream + 16)) += count
	}
	goto Exit
Exit:
	;
	return *(*TFT_Error)(unsafe.Pointer(bp))
}

func Xftglue_stream_frame_exit(tls *libc.TLS, stream TFT_Stream) {
	var memory TFT_Memory
	_ = memory
	if (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fread != 0 {
		memory = (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fmemory
		if (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fbase != 0 {
			_ftglue_free(tls, memory, (*TFT_StreamRec_)(unsafe.Pointer(stream)).Fbase)
			(*TFT_StreamRec_)(unsafe.Pointer(stream)).Fbase = libc.UintptrFromInt32(0)
		}
	}
	(*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor = uintptr(0)
	(*TFT_StreamRec_)(unsafe.Pointer(stream)).Flimit = uintptr(0)
}

func Xftglue_face_goto_table(tls *libc.TLS, face TFT_Face, the_tag TFT_ULong, stream TFT_Stream) (r TFT_Error) {
	var checksum, offset, sig, size, start, tag TFT_ULong
	var count, nn TFT_UInt
	var error1, v1, v10, v11, v2, v4, v5, v7, v8 TFT_Error
	var v12, v3, v6, v9 bool
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = checksum, count, error1, nn, offset, sig, size, start, tag, v1, v10, v11, v12, v2, v3, v4, v5, v6, v7, v8, v9
	if !!!((*TFT_FaceRec_)(unsafe.Pointer(face)).Fface_flags&(libc.Int64FromInt64(1)<<libc.Int32FromInt32(3)) != 0) {
		error1 = int32(_FT_Err_Invalid_Face_Handle)
	} else {
		/* parse the directory table directly, without using
		 * FreeType's built-in data structures
		 */
		offset = uint64(0)
		v1 = Xftglue_stream_seek(tls, stream, 0)
		error1 = v1
		if v3 = v1 != 0; !v3 {
			v2 = Xftglue_stream_frame_enter(tls, stream, uint64(4))
			error1 = v2
		}
		if v3 || v2 != 0 {
			goto Exit
		}
		*(*uintptr)(unsafe.Pointer(stream + 64)) += uintptr(4)
		sig = libc.Uint64FromInt64(libc.Int64FromUint64(uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(4))))<<libc.Int32FromInt32(24) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(3))))<<libc.Int32FromInt32(16) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(2))))<<libc.Int32FromInt32(8) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(1))))))
		Xftglue_stream_frame_exit(tls, stream)
		if sig == uint64(uint32(libc.Uint64FromUint8('t')<<libc.Int32FromInt32(24)|libc.Uint64FromUint8('t')<<libc.Int32FromInt32(16)|libc.Uint64FromUint8('c')<<libc.Int32FromInt32(8)|libc.Uint64FromUint8('f'))) {
			/* deal with TrueType collections */
			v4 = Xftglue_stream_seek(tls, stream, int64(12)+(*TFT_FaceRec_)(unsafe.Pointer(face)).Fface_index*int64(4))
			error1 = v4
			if v6 = v4 != 0; !v6 {
				v5 = Xftglue_stream_frame_enter(tls, stream, uint64(4))
				error1 = v5
			}
			if v6 || v5 != 0 {
				goto Exit
			}
			*(*uintptr)(unsafe.Pointer(stream + 64)) += uintptr(4)
			offset = libc.Uint64FromInt64(libc.Int64FromUint64(uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(4))))<<libc.Int32FromInt32(24) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(3))))<<libc.Int32FromInt32(16) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(2))))<<libc.Int32FromInt32(8) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(1))))))
			Xftglue_stream_frame_exit(tls, stream)
		}
		v7 = Xftglue_stream_seek(tls, stream, libc.Int64FromUint64(offset+uint64(4)))
		error1 = v7
		if v9 = v7 != 0; !v9 {
			v8 = Xftglue_stream_frame_enter(tls, stream, uint64(2))
			error1 = v8
		}
		if v9 || v8 != 0 {
			goto Exit
		}
		*(*uintptr)(unsafe.Pointer(stream + 64)) += uintptr(2)
		count = uint32(libc.Uint16FromInt16(libc.Int16FromUint64(uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(2))))<<libc.Int32FromInt32(8) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(1)))))))
		Xftglue_stream_frame_exit(tls, stream)
		v10 = Xftglue_stream_seek(tls, stream, libc.Int64FromUint64(offset+uint64(12)))
		error1 = v10
		if v12 = v10 != 0; !v12 {
			v11 = Xftglue_stream_frame_enter(tls, stream, uint64(count*uint32(16)))
			error1 = v11
		}
		if v12 || v11 != 0 {
			goto Exit
		}
		nn = uint32(0)
		for {
			if !(nn < count) {
				break
			}
			*(*uintptr)(unsafe.Pointer(stream + 64)) += uintptr(4)
			tag = libc.Uint64FromInt64(libc.Int64FromUint64(uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(4))))<<libc.Int32FromInt32(24) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(3))))<<libc.Int32FromInt32(16) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(2))))<<libc.Int32FromInt32(8) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(1))))))
			*(*uintptr)(unsafe.Pointer(stream + 64)) += uintptr(4)
			checksum = libc.Uint64FromInt64(libc.Int64FromUint64(uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(4))))<<libc.Int32FromInt32(24) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(3))))<<libc.Int32FromInt32(16) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(2))))<<libc.Int32FromInt32(8) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(1))))))
			*(*uintptr)(unsafe.Pointer(stream + 64)) += uintptr(4)
			start = libc.Uint64FromInt64(libc.Int64FromUint64(uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(4))))<<libc.Int32FromInt32(24) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(3))))<<libc.Int32FromInt32(16) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(2))))<<libc.Int32FromInt32(8) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(1))))))
			*(*uintptr)(unsafe.Pointer(stream + 64)) += uintptr(4)
			size = libc.Uint64FromInt64(libc.Int64FromUint64(uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(4))))<<libc.Int32FromInt32(24) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(3))))<<libc.Int32FromInt32(16) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(2))))<<libc.Int32FromInt32(8) | uint64(*(*TFT_Byte)(unsafe.Pointer((*TFT_StreamRec_)(unsafe.Pointer(stream)).Fcursor - libc.UintptrFromInt32(1))))))
			if tag == the_tag {
				error1 = Xftglue_stream_seek(tls, stream, libc.Int64FromUint64(start))
				goto FoundIt
			}
			goto _13
		_13:
			;
			nn++
		}
		error1 = int32(_FT_Err_Table_Missing)
		goto FoundIt
	FoundIt:
		;
		Xftglue_stream_frame_exit(tls, stream)
	}
	goto Exit
Exit:
	;
	return error1
}

func __ccgo_fp(f interface{}) uintptr {
	type iface [2]uintptr
	return (*iface)(unsafe.Pointer(&f))[1]
}

var XFcDebugVal int32

/*
 * Copyright (c) 2002-2017 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * Copyright (c) 2000, 2002 - 2008, 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2023 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

/*
 * Copyright (c) 2000, 2005, 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * This code is derived from software contributed to Berkeley by
 * Paul Borman at Krystal Technologies.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ctype.h	8.4 (Berkeley) 1/21/94
 */

/*
 * Copyright (c) 2000, 2005, 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * This code is derived from software contributed to Berkeley by
 * Paul Borman at Krystal Technologies.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ctype.h	8.4 (Berkeley) 1/21/94
 */

var XFcIdentityMatrix = TFcMatrix{
	Fxx: libc.Float64FromInt32(1),
	Fyy: libc.Float64FromInt32(1),
}

var Xdefault_langs uintptr

var Xother_types uintptr

var __ccgo_ts = (*reflect.StringHeader)(unsafe.Pointer(&__ccgo_ts1)).Data

var __ccgo_ts1 = ".NEW\x00.LCK\x00.TMP-XXXXXX\x00w\x00%ld\n\x00.uuid\x00Unable to revert mtime: %s\n\x00FONTCONFIG_USE_MMAP\x00-le64.cache-8\x00 (mapped to \x00\x00)\x00, salt: \x00cache: %s (dir: %s%s%s%s%s%s)\n\x00cache fallbacks to: %s (dir: %s)\n\x00Fontconfig error: not freed %p (dir: %s, refcount %d)\n\x00FcCacheTimeValid dir \"%s\" cache checksum %d dir checksum %d\n\x00SOURCE_DATE_EPOCH\x00Fontconfig: SOURCE_DATE_EPOCH invalid\n\x00Fontconfig: SOURCE_DATE_EPOCH: strtoull: %s: %llu\n\x00Fontconfig: SOURCE_DATE_EPOCH has trailing garbage\n\x00Fontconfig: SOURCE_DATE_EPOCH must be <= %lu but saw: %llu\n\x00Fontconfig error: No writable cache directories\n\x00FcDirCacheWriteDir dir \"%s\" file \"%s\"\n\x00write cache\x00Fontconfig error: %s: out of memory\n\x00unwritable\x00non-existent\x00%s: not cleaning %s cache directory\n\x00%s: cleaning cache directory\n\x00Fontconfig error: %s: allocation failure\n\x00%s: invalid cache file: %s\n\x00%s: %s: missing directory: %s \n\x00CACHEDIR.TAG\x00wb\x00Created CACHEDIR.TAG at %s\n\x00Unable to create CACHEDIR.TAG at %s\n\x00FONTCONFIG_SYSROOT\x00Fontconfig warning: Directory/file mtime in the future. New fonts may not be detected.\n\x00adding fonts from %s\n\x00 (salt: \x00%s -> %s%s%s%s\n\x00%s%s%s%s\n\x00Reset font directories!\n\x00Fontconfig warning: <name> tag has target=\"font\" in a <match target=\"pattern\">.\n\x00Fontconfig warning: FcPattern object %s does not accept value\x00\n\x00Not adding\n\x00position not on list\n\x00Append\x00Prepend\x00%s list before \x00%s list after \x00und\x00FcConfigSubstitute \x00\nRule Set: %s\n\x00FcConfigSubstitute test \x00No match\n\x00Substitute \x00\n\n\x00FcConfigSubstitute edit\x00FcConfigSubstitute done\x00/\x00FONTCONFIG_PATH\x00/etc/fonts\x00HOME\x00XDG_CACHE_HOME\x00/.cache\x00XDG_CONFIG_HOME\x00/.config\x00XDG_DATA_HOME\x00/.local/share\x00XDG_DATA_DIRS\x00/usr/local/share\x00/usr/share\x00FONTCONFIG_FILE\x00fonts.conf\x00Fontconfig warning: Unable to initialize config and retry limit exceeded. sysroot functionality may not work as expected.\n\x00Add Rule(kind:%d, name: %s) \x00No description\x00%x\x00\ncharsets %d -> %d leaves %d -> %d\n\x00<unknown>\x00<void>\x00%d(i)\x00%g(f)\x00\"%s\"\x00True\x00False\x00DontCare\x00[%g %g; %g %g]\x00face\x00[%g %g]\x00 \x00 [marker] \x00(w)\x00(s)\x00(=)\x00(?)\x00 [marker]\x00%s\x00langset (alloc error)\x00\t\x00%04x:\x00 %08x\x00Null pattern\n\x00Pattern has %d elts (size %d)\n\x00\t%s:\x00Pattern has %d elts (size %d), %d elts (size %d)\n\x00\t%s: (None) -> \x00 -> (None)\n\x00 -> \x00Integer\x00Double\x00String\x00Matrix\x00Range\x00Bool\x00CharSet\x00LangSet\x00Field\x00Const\x00Assign\x00AssignReplace\x00PrependFirst\x00AppendLast\x00Delete\x00DeleteAll\x00Quest\x00Or\x00And\x00Equal\x00(ignore blanks)\x00NotEqual\x00Less\x00LessEqual\x00More\x00MoreEqual\x00Contains\x00NotContains\x00Plus\x00Minus\x00Times\x00Divide\x00Not\x00Nil\x00Comma\x00Floor\x00Ceil\x00Round\x00Trunc\x00Listing\x00Invalid\x00none\x00%d\x00%g\x00[\x00; \x00]\x00(%g, %g)\x00true\x00false\x00charset\n\x00langset:\x00nil\n\x00%s \x00(pattern) \x00(font) \x00 quest \x00 colon \x00Not \x00Floor \x00Ceil \x00Round \x00Trunc \x00pattern \x00font \x00scan \x00any \x00all \x00first \x00not_first \x00Edit %s \x00[test]\n\x00[edit]\n\x00;\n\x00FontSet %d of %d\n\x00Font %d \x00FC_DEBUG\x00FC_DEBUG=%s\n\x00FC_LANG\x00LC_ALL\x00LC_CTYPE\x00LANG\x00en\x00en-us\x00\tScanning file %s...\x00done\n\x00Final font pattern:\n\x00\tScanning dir %s\n\x00cache scan dir %s\n\x00Fontconfig: Pattern format error: \x00.\n\x00format ended while expecting '%c'\x00expected '%c' at %d\x00expected identifier at %d\x00expected character data at %d\x00unparse\x00fccat\x00\"%{file|basename|cescape}\" %{index} \"%{-file{%{=unparse|cescape}}}\"\x00fcmatch\x00%{file:-<unknown filename>|basename}: \"%{family[0]:-<unknown family>}\" \"%{style[0]:-<unknown style>}\"\x00fclist\x00%{?file{%{file}: }}%{-file{%{=unparse}}}\x00pkgkit\x00%{[]family{font(%{family|downcase|delete( )})\n}}%{[]lang{font(:lang=%{lang|downcase|translate(_,-)})\n}}\x00unknown builtin \"%s\"\x00expected non-negative number at %d\x00'\\''\x00&amp;\x00&lt;\x00&gt;\x00downcase\x00basename\x00dirname\x00cescape\x00shescape\x00xmlescape\x00delete\x00escape\x00translate\x00unknown converter \"%s\"\x00Adobe\x00adobe\x00Bigelow\x00b&h\x00Bitstream\x00bitstream\x00Gnat\x00culmus\x00Iorsh\x00HanYang System\x00hanyang\x00Font21\x00hwan\x00IBM\x00ibm\x00International Typeface Corporation\x00itc\x00Linotype\x00linotype\x00LINOTYPE-HELL\x00Microsoft\x00microsoft\x00Monotype\x00monotype\x00Omega\x00omega\x00Tiro Typeworks\x00tiro\x00URW\x00urw\x00XFree86\x00xfree86\x00Xorg\x00xorg\x00MACINTOSH\x00SJIS\x00UCS-2BE\x00UTF-16BE\x00ASCII\x00ISO-8859-1\x00thin\x00extralight\x00ultralight\x00demilight\x00semilight\x00light\x00book\x00regular\x00normal\x00medium\x00demibold\x00demi\x00semibold\x00extrabold\x00superbold\x00ultrabold\x00bold\x00ultrablack\x00superblack\x00extrablack\x00<ultra\x00black\x00heavy\x00ultracondensed\x00extracondensed\x00semicondensed\x00condensed\x00semiexpanded\x00extraexpanded\x00ultraexpanded\x00expanded\x00extended\x00italic\x00kursiv\x00oblique\x00shadow\x00caps\x00antiqua\x00romansc\x00embosed\x00dunhill\x00found family (n %2d p %d e %d l 0x%04x)\x00found full   (n %2d p %d e %d l 0x%04x)\x00found style  (n %2d p %d e %d l 0x%04x) \x00(null)\x00%s\n\x00using FreeType family \"%s\"\n\x00Regular\x00using FreeType style \"%s\"\n\x00applying default style Regular\n\x00using filename for family %s\n\x00\tos2 weight class %d multiplier %g maps to weight %g\n\x00\tos2 width class %d multiplier %g maps to width %g\n\x00style\x00\tStyle %s maps to weight %g\n\x00\tStyle %s maps to width %g\n\x00\tStyle %s maps to slant %d\n\x00\tStyle %s maps to decorative %d\n\x00unknown\x00otlayout:\x00ttable:Silf \x00complex_ features in this font: %s\n\x00<fontconfig><dir>/System/Library/Fonts</dir> <dir>/Library/Fonts</dir> <dir>~/Library/Fonts</dir> <dir>/System/Library/Assets/com_apple_MobileAsset_Font3</dir> <dir>/System/Library/Assets/com_apple_MobileAsset_Font4</dir>  <dir prefix=\"xdg\">fonts</dir>  <cachedir>/usr/var/cache/fontconfig</cachedir>  <cachedir prefix=\"xdg\">fontconfig</cachedir>  <include ignore_missing=\"yes\">/etc/fonts/conf.d</include>  <include ignore_missing=\"yes\" prefix=\"xdg\">fontconfig/conf.d</include>  <include ignore_missing=\"yes\" prefix=\"xdg\">fontconfig/fonts.conf</include></fontconfig>\x00/usr/share/fontconfig/conf.avail\x00Fontconfig warning: no <cachedir> elements found. Check configuration.\n\x00Fontconfig warning: adding <cachedir>%s</cachedir>\n\x00/usr/var/cache/fontconfig\x00/fontconfig\x00Fontconfig warning: adding <cachedir prefix=\"xdg\">fontconfig</cachedir>\n\x00Fontconfig error: out of memory\x00font charset\x00%s charset\x00\n%s(%u) \x00{\x00 %04x\x00 }\n\t\x00%s(%u) \x00C\x00C.UTF-8\x00C.utf8\x00POSIX\x00Fontconfig warning: ignoring %s: not a valid language tag\n\x00Fontconfig warning: ignoring %s: not a valid region tag\n\x00Checking the existence of %s.orth\n\x00normalized: %s -> %s\n\x00Unable to normalize %s\n\x00FcLangSet \x00 contains \x00\tMissing bitmap %s\n\x00\tMissing string %s\n\x00family\x00familylang\x00fullname\x00fullnamelang\x00stylelang\x00 -\x00 %s: %g \x00, \x00%s: %g \x00    \x00wght\x00wdth\x00opsz\x00%4s=%g\x00Match \x00Score\x00 %g\x00Best score\x00FC_DBG_MATCH_FILTER\x00charset\x00Add \x00Sort \x00lang\x00Font %s:%s matches language %d\n\x00First font \x00slant\x00weight\x00width\x00size\x00aspect\x00pixelsize\x00spacing\x00foundry\x00antialias\x00hintstyle\x00hinting\x00verticallayout\x00autohint\x00globaladvance\x00file\x00index\x00rasterizer\x00outline\x00scalable\x00dpi\x00rgba\x00scale\x00minspace\x00charwidth\x00charheight\x00matrix\x00fontversion\x00capability\x00fontformat\x00embolden\x00embeddedbitmap\x00decorative\x00lcdfilter\x00namelang\x00fontfeatures\x00prgname\x00hash\x00postscriptname\x00color\x00symbol\x00fontvariations\x00variable\x00fonthashint\x00order\x00roman\x00proportional\x00dual\x00mono\x00charcell\x00rgb\x00bgr\x00vrgb\x00vbgr\x00hintnone\x00hintslight\x00hintmedium\x00hintfull\x00lcdnone\x00lcddefault\x00lcdlight\x00lcdlegacy\x00Fontconfig error: Unexpected constant name `%s' used for object `%s': should be `%s'\n\x00%lg %lg %lg %lg\x00[%lg %lg]\x00[%s %[^]]]\x00-,:\x00=_:\x00:,\x00%g %g %g %g\x00,\x00\\-:,\x00-\x00:\x00\\=_:,\x00=\x00Fontconfig error: No object ID to assign\n\x00Raw pattern:\n\x00Serialized pattern:\n\x00nfs\x00msdosfs\x00pcfs\x00.\x00/.\x00/..\x00its:\x00info\x00warning\x00error\x00Fontconfig %s: \"%s\", line %d: \x00Fontconfig %s: line %d: \x00Fontconfig %s: \x00void\x00number\x00string\x00bool\x00FT_Face\x00langset\x00range\x00saw %s, expected %s\x00invalid constant used : %s\x00out of memory\x00mismatching element\x00invalid attribute '%s'\x00xdg\x00default\x00cwd\x00relative\x00Use of ambiguous path in <%s> element. please add prefix=\"cwd\" if current behavior is desired.\x00unknown element \"%s\"\x00non-integer rescan\x00\"%s\": not a valid integer\x00\"%s\": not a valid double\x00target\x00pattern\x00font\x00invalid name target \"%s\"\x00Missing values in matrix element\x00wrong number of matrix elements\x00too many elements in range\x00invalid element in range\x00invalid range\x00\"%s\" is not known boolean\x00invalid character: 0x%04x\x00invalid element in charset\x00invalid langset: %s\x00invalid element in langset\x00weak\x00strong\x00same\x00invalid binding \"%s\"\x00non-family\x00binding\x00Having multiple <family> in <alias> isn't supported and may not work as expected\x00bad alias\x00missing family in alias\x00domain\x00empty font directory name for remap ignored\x00as-path\x00Missing as-path in remap-dir\x00prefix\x00salt\x00out of memory; cannot create remap data for %s as %s\x00Unable to reset fonts dirs\x00empty font directory name ignored\x00out of memory; cannot add directory %s\x00empty cache directory name ignored\x00out of memory; cannot add cache directory %s\x00ignore_missing\x00deprecated\x00conf.d\x00reading configurations from %s is deprecated. please move it to %s manually\x00scan\x00invalid test target \"%s\"\x00qual\x00any\x00all\x00first\x00not_first\x00invalid test qual \"%s\"\x00name\x00missing test name\x00compare\x00invalid test compare \"%s\"\x00ignore-blanks\x00invalid test ignore-blanks \"%s\"\x00missing test expression\x00Having multiple values in <test> isn't supported and may not work as expected\x00missing edit name\x00mode\x00invalid edit mode \"%s\"\x00Expression doesn't take any effects for delete and delete_all\x00invalid match target \"%s\"\x00<match target=\"scan\"> cannot edit user-defined object \"%s\"\x00invalid match element\x00No <test> nor <edit> elements in <match>\x00bad font selector\x00unknown pattern element %d\x00missing pattern element name\x00unknown pattern element\x00fontconfig\x00invalid doctype \"%s\"\x00Cannot open config dir \"%s\"\x00\tScanning config dir %s\n\x00.conf\x00Loading\x00Scanning\x00\t%s config file from %s\n\x00UTF-8\x00cannot get parse buffer\x00load\x00Cannot %s config file from %s\x00\t%s config file from %s done\n\x00No such file: \x00No such realfile: \x00Unable to open \x00failed reading config file: %s: %s (errno %d)\x00Cannot %s config file \"%s\": %s\x00Cannot %s default config file: %s\x00memory\x00"
